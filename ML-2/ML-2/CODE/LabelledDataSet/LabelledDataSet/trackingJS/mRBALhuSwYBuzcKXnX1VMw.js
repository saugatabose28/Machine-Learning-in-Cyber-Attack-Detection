require = (function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a)
                    return a(o, !0);
                if (i)
                    return i(o, !0);
                throw new Error("Cannot find module '" + o + "'")
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e)
            }, f, f.exports, e, t, n, r)
        }
        return n[o].exports
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++)
        s(r[o]);
    return s
})({
    1: [function(require, module, exports) {
        var $, Application, Backbone, Chaplin, ContactsC, ErrorsController, FollowersC, FollowingC, ListItemsC, ListsC, ModesC, NotificationM, PanelController, ProgressBarController, StumblesC, UserM, cookieDomain, hostname, root, routes, storage, utils, _,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        require('../bower_components/poly/all');

        $ = window.jQuery = require('jquery');

        require('../bower_components/jquery.cookie/jquery.cookie');

        require('../bower_components/select2/select2');

        require('ajaxRetry');

        require('../vendor/scripts/jquery.smartbanner.js');

        if (window.location.protocol === 'https:') {
            window.location.replace('http://' + window.location.host + window.location.pathname + document.location.search);
        }

        hostname = window.location.hostname;

        if (hostname.match('stumbleupon.com')) {
            cookieDomain = '.stumbleupon.com';
        } else if (hostname.match('stumble.net')) {
            cookieDomain = hostname.split('www').pop();
        }

        $.ajaxSetup({
            timeout: 45000
        });

        $.cookie.defaults = {
            path: '/',
            domain: cookieDomain
        };

        _ = require('lodash');

        _.str = require('underscore.string');

        _.mixin(_.str.exports());

        _.str.include('Underscore.string', 'string');

        Backbone = require('backbone');

        Backbone.$ = $;

        Chaplin = require('chaplin');

        window.Chaplin = Chaplin;

        window.SUdebug = require('./su-debug');

        routes = require('./routes');

        PanelController = require('./controllers/panel-controller');

        ProgressBarController = require('./controllers/progress-bar-controller');

        ErrorsController = require('./controllers/errors-controller');

        UserM = require('./models/user-model');

        ModesC = require('./models/modes-collection');

        ContactsC = require('./models/contacts-collection');

        StumblesC = require('./models/stumbles-collection');

        NotificationM = require('./models/notification-model');

        FollowersC = require('./models/followers-collection');

        FollowingC = require('./models/following-collection');

        ListItemsC = require('./models/list-items-collection');

        ListsC = require('./models/lists-collection');

        storage = require('simple-storage');

        utils = require('./lib/utils');

        root = require('./lib/root');

        setTimeout((function(_this) {
            return function() {
                return root().location.reload(true);
            };
        })(this), utils.toMs('12h'));

        module.exports = Application = (function(_super) {
            __extends(Application, _super);

            function Application() {
                return Application.__super__.constructor.apply(this, arguments);
            }

            Application.prototype.initialize = function(options) {
                if (utils.isSUBrowserAddonEnabled()) {
                    utils.disableSpa();
                } else if ((window.location === window.top.location) || window.top.location.hostname.match('optimizely')) {
                    Application.__super__.initialize.apply(this, arguments);
                    this.initControllers();
                } else {
                    utils.gotoNoToolbarUrl();
                }
                return $(window).on('suScriptReadyExtconnectWP', function() {
                    return utils.disableSpa();
                });
            };

            Application.prototype.initControllers = function() {
                this.panelController = new PanelController;
                this.progressBarController = new ProgressBarController;
                return this.errorsController = new ErrorsController;
            };

            Application.prototype.initMediator = function() {
                var webfont;
                Chaplin.mediator.userM = new UserM({}, {
                    parse: false,
                    auth: true
                });
                Chaplin.mediator.modesC = new ModesC;
                Chaplin.mediator.contactsC = new ContactsC;
                Chaplin.mediator.stumblesC = new StumblesC;
                Chaplin.mediator.listItemsC = new ListItemsC;
                Chaplin.mediator.listsC = new ListsC;
                Chaplin.mediator.notificationM = new NotificationM;
                Chaplin.mediator.followersC = new FollowersC;
                Chaplin.mediator.followingC = new FollowingC;
                Chaplin.mediator.loadTimes = [];
                Chaplin.mediator.update = false;
                Chaplin.mediator.sessionStumbleViews = 0;
                Chaplin.mediator.triedDeepLinking = false;
                Chaplin.mediator.seal();
                webfont = require('./lib/webfont');
                return webfont.loadAll();
            };

            return Application;

        })(Chaplin.Application);


    }, {
        "../bower_components/jquery.cookie/jquery.cookie": 251,
        "../bower_components/poly/all": 252,
        "../bower_components/select2/select2": 265,
        "../vendor/scripts/jquery.smartbanner.js": 277,
        "./controllers/errors-controller": "E2iFan",
        "./controllers/panel-controller": "3YYIHK",
        "./controllers/progress-bar-controller": "yZg3j8",
        "./lib/root": 47,
        "./lib/utils": 69,
        "./lib/webfont": 71,
        "./models/contacts-collection": 78,
        "./models/followers-collection": 79,
        "./models/following-collection": 80,
        "./models/list-items-collection": 81,
        "./models/lists-collection": 83,
        "./models/modes-collection": 88,
        "./models/notification-model": 91,
        "./models/stumbles-collection": 94,
        "./models/user-model": 98,
        "./routes": 99,
        "./su-debug": 101,
        "ajaxRetry": 266,
        "backbone": 267,
        "chaplin": 268,
        "jquery": 269,
        "lodash": 271,
        "simple-storage": 274,
        "underscore.string": 275
    }
    ],
    2: [function(require, module, exports) {
        module.exports = Object.freeze({
            localDev: {
                host: 'www.kmcbriarty.v5.stumble.net',
                protocol: 'http:'
            },
            host: 'www.stumbleupon.com',
            protocol: 'https:',
            prefix: '/api/v2_0',
            headers: {
                'X-Su-ConsumerKey': '35774027dc2f2f64a280e63eafb018505c045655',
                'X-Su-Version': 'spa 3.0'
            },
            logLevel: 5
        });


    }, {}
    ],
    "r1JNni": [function(require, module, exports) {
        var $, AnnounceEvents, AppView, Chaplin, Controller, LegacyClickTracking, Mixin, StopTimers, TimersC, analytics, config, mediator, root, utils, _,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        _ = require('lodash');

        Mixin = require('mixen');

        Chaplin = require('chaplin');

        StopTimers = require('../../lib/mixins/stop-timers');

        AnnounceEvents = require('../../lib/mixins/announce-events');

        utils = require('../../lib/utils');

        root = require('../../lib/root');

        mediator = require('chaplin').mediator;

        AppView = require('../../views/app-view');

        $ = require('jquery');

        analytics = require('../../lib/analytics');

        utils = require('../../lib/utils');

        config = require('../../config');

        TimersC = require('../../models/timers-collection');

        LegacyClickTracking = require('../../lib/legacy-click-tracking');

        module.exports = Controller = (function(_super) {
            __extends(Controller, _super);

            function Controller() {
                return Controller.__super__.constructor.apply(this, arguments);
            }

            Controller.prototype.beforeAction = function() {
                return this.sessionRefresh().then(this.whenAccessTokenKey).then(this.login).then((function(_this) {
                    return function() {
                        _this.reuse('app', AppView);
                        _this.reuse('timers', TimersC);
                        return _this.populateModels();
                    };
                })(this), (function(_this) {
                    return function() {
                        return _this.appStartFailed();
                    };
                })(this));
            };

            Controller.prototype.refresh = function() {
                return root().location.reload(true);
            };

            Controller.prototype.login = function() {
                var dfd;
                if (utils.isLoggedIn() || !utils.isVisitor()) {
                    mediator.userM.fetch();
                    dfd = new $.Deferred;
                    dfd.resolve();
                    return dfd.promise();
                }
            };

            Controller.prototype.whenAccessTokenKey = function() {
                var dfd;
                if (utils.getAccessTokenKey()) {
                    dfd = new $.Deferred;
                    dfd.resolve();
                    return dfd.promise();
                } else {
                    return $.get('/p');
                }
            };

            Controller.prototype.sessionRefresh = _.once(function() {
                return $.get('/p');
            });

            Controller.prototype.populateModels = _.once(function() {
                return setTimeout(function() {
                    if (!utils.isVisitor()) {
                        mediator.modesC.fetch();
                        mediator.contactsC.fetch();
                        mediator.listsC.fetch();
                        mediator.notificationM.fetch();
                        mediator.followersC.fetch();
                        return mediator.followingC.fetch();
                    }
                }, 1000);
            });

            Controller.prototype.appStartFailed = function() {
                var legacyClickTracking, _ref;
                console.error("Unable to start app");
                if (utils.isDev()) {
                    console.error("If you're on dev you MUST login from https://" + config.localDev.host + "/login See the comments above in this file!");
                }
                debugger;
                analytics.trackEvent('authFailure', 'sessionStumbleViews', mediator.sessionStumbleViews);
                if ((_ref = window.heap) != null) {
                    _ref.track('authFailure', {
                        stumbles: mediator.sessionStumbleViews
                    });
                }
                legacyClickTracking = new LegacyClickTracking;
                legacyClickTracking.clearCookies();
                return utils.disableSpa();
            };

            return Controller;

        })(Mixin(AnnounceEvents, StopTimers, Chaplin.Controller));


    }, {
        "../../config": 2,
        "../../lib/analytics": 39,
        "../../lib/legacy-click-tracking": 43,
        "../../lib/mixins/announce-events": 44,
        "../../lib/mixins/stop-timers": 45,
        "../../lib/root": 47,
        "../../lib/utils": 69,
        "../../models/timers-collection": 97,
        "../../views/app-view": 212,
        "chaplin": 268,
        "jquery": 269,
        "lodash": 271,
        "mixen": 272
    }
    ],
    "controllers/base/controller": [function(require, module, exports) {
        module.exports = require('r1JNni');
    }, {}
    ],
    "controllers/errors-controller": [function(require, module, exports) {
        module.exports = require('E2iFan');
    }, {}
    ],
    "E2iFan": [function(require, module, exports) {
        var $, Controller, ErrorsController, GeneralErrorV, NotFoundV,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Controller = require('./base/controller');

        NotFoundV = require('../views/not-found-view');

        GeneralErrorV = require('../views/general-error-view');

        $ = require('jquery');

        module.exports = ErrorsController = (function(_super) {
            __extends(ErrorsController, _super);

            function ErrorsController() {
                return ErrorsController.__super__.constructor.apply(this, arguments);
            }

            ErrorsController.prototype.initialize = function() {
                return this.subscribeEvent('error:general', this.general);
            };

            ErrorsController.prototype.general = function() {
                return this.view = new GeneralErrorV();
            };

            ErrorsController.prototype.notFound = function() {
                $('.stumble').remove();
                return this.view = new NotFoundV();
            };

            return ErrorsController;

        })(Controller);


    }, {
        "../views/general-error-view": 221,
        "../views/not-found-view": 232,
        "./base/controller": "r1JNni",
        "jquery": 269
    }
    ],
    "controllers/login-controller": [function(require, module, exports) {
        module.exports = require('ro7h2H');
    }, {}
    ],
    "ro7h2H": [function(require, module, exports) {
        var $, Controller, LoginController, mediator, root, storage, utils,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Controller = require('./base/controller');

        storage = require('simple-storage');

        mediator = require('chaplin').mediator;

        utils = require('../lib/utils');

        root = require('../lib/root');

        $ = require('jquery');

        module.exports = LoginController = (function(_super) {
            __extends(LoginController, _super);

            function LoginController() {
                return LoginController.__super__.constructor.apply(this, arguments);
            }

            LoginController.prototype.logout = function() {
                this.publishEvent('auth:loggedout');
                this.resetStorage();
                ['su_accesstoken', 'ssid', 'SU_REMEMBER', 'seulepage', 'ozspa'].forEach(function(name) {
                    $.removeCookie(name);
                    return $.removeCookie(name, {
                        domain: 'www.stumbleupon.com'
                    });
                });
                if (storage.get('return_count', 'session')) {
                    storage.set('return_count', storage.get('return_count', 'session') + 1, 'session');
                } else {
                    storage.set('return_count', 1, 'session');
                }
                if (storage.get('return_count', 'session') < 3) {
                    return root().location.href = '/logged-out';
                }
            };

            LoginController.prototype.resetStorage = function() {
                mediator.userM.clear({
                    silent: true
                });
                storage.remove('key');
                storage.remove('user');
                storage.remove('activeMode');
                storage.remove('modeInfo');
                storage.clear('session');
                if (storage.get('stumbles')) {
                    return storage.clear();
                }
            };

            return LoginController;

        })(Controller);


    }, {
        "../lib/root": 47,
        "../lib/utils": 69,
        "./base/controller": "r1JNni",
        "chaplin": 268,
        "jquery": 269,
        "simple-storage": 274
    }
    ],
    "controllers/panel-controller": [function(require, module, exports) {
        module.exports = require('3YYIHK');
    }, {}
    ],
    "3YYIHK": [function(require, module, exports) {
        var $, Controller, PanelController, analytics, defaultDelay, jwerty, utils, _,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        $ = require('jquery');

        _ = require('lodash');

        Controller = require('./base/controller');

        utils = require('../lib/utils');

        jwerty = require('jwerty').jwerty;

        analytics = require('../lib/analytics');

        defaultDelay = 300;

        module.exports = PanelController = (function(_super) {
            __extends(PanelController, _super);

            function PanelController() {
                return PanelController.__super__.constructor.apply(this, arguments);
            }

            PanelController.prototype.currentPanel = null;

            PanelController.prototype.initialize = function() {
                this.subscribeEvent('panel:open', this.open);
                this.subscribeEvent('panel:close', this.close);
                this.subscribeEvent('panel:toggle', this.toggle);
                this.subscribeEvent('user:loggedout', this.close);
                this.subscribeEvent('window:keydown', this.onKeydown);
                return this.subscribeEvent('router:match', function() {
                    return this.publishEvent('panel:close');
                });
            };

            PanelController.prototype.open = function(options) {
                if (options == null) {
                    options = {};
                }
                this.closePanel();
                return _.defer((function(_this) {
                    return function() {
                        _this.stopScroll = _this.setInterval(utils.scrollToTop, 1);
                        if (options.left) {
                            _this.safari5HackAdd(options.left);
                        }
                        _this.currentPanel = options.name;
                        _this.Controller = require("controllers/panels/" + options.name + "-controller");
                        _this.controller = new _this.Controller({
                            panel: options
                        });
                        return _.defer(function() {
                            var _ref;
                            if ((_ref = _this.controller.view) != null) {
                                _ref.trigger('open');
                            }
                            _this.publishEvent('panel:opened');
                            return analytics.trackEvent(options.name + '-panelopen');
                        });
                    };
                })(this));
            };

            PanelController.prototype.close = _.debounce(function() {
                return this.closePanel();
            }, defaultDelay);

            PanelController.prototype.closePanel = function() {
                var _ref;
                clearInterval(this.stopScroll);
                this.safari5HackRemove();
                this.currentPanel = null;
                ((_ref = this.controller) != null ? _ref.dispose : void 0) != null;
                $('#panel-container').empty();
                return this.publishEvent('panel:closed');
            };

            PanelController.prototype.toggle = function(options) {
                if (options == null) {
                    options = {};
                }
                if (this.currentPanel === options.name) {
                    return this.publishEvent('panel:close');
                } else {
                    return this.publishEvent('panel:open', options);
                }
            };

            PanelController.prototype.safari5HackAdd = function(leftPos) {
                if (utils.isOldSafari()) {
                    return $('#panel-container').css('left', leftPos);
                }
            };

            PanelController.prototype.safari5HackRemove = function() {
                if (utils.isOldSafari()) {
                    return $('#panel-container').removeAttr('style');
                }
            };

            PanelController.prototype.onKeydown = function(e) {
                if (jwerty.is('esc', e)) {
                    return this.publishEvent('panel:close');
                }
            };

            return PanelController;

        })(Controller);


    }, {
        "../lib/analytics": 39,
        "../lib/utils": 69,
        "./base/controller": "r1JNni",
        "jquery": 269,
        "jwerty": 270,
        "lodash": 271
    }
    ],
    "cES0qR": [function(require, module, exports) {
        var AlertController, AlertM, AlertV, Controller,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Controller = require('../base/controller');

        AlertV = require('../../views/alert-view');

        AlertM = require('../../models/alert-model');

        module.exports = AlertController = (function(_super) {
            __extends(AlertController, _super);

            function AlertController() {
                return AlertController.__super__.constructor.apply(this, arguments);
            }

            AlertController.prototype.initialize = function(options) {
                var _ref, _ref1;
                AlertController.__super__.initialize.apply(this, arguments);
                this.model = new AlertM({
                    text: options != null ? (_ref = options.panel) != null ? _ref.text : void 0 : void 0,
                    type: options != null ? (_ref1 = options.panel) != null ? _ref1.type : void 0 : void 0
                });
                return this.view = new AlertV({
                    region: 'panel',
                    model: this.model
                });
            };

            return AlertController;

        })(Controller);


    }, {
        "../../models/alert-model": 72,
        "../../views/alert-view": 210,
        "../base/controller": "r1JNni"
    }
    ],
    "controllers/panels/alert-controller": [function(require, module, exports) {
        module.exports = require('cES0qR');
    }, {}
    ],
    "controllers/panels/comment-controller": [function(require, module, exports) {
        module.exports = require('+ZdH5R');
    }, {}
    ],
    "+ZdH5R": [function(require, module, exports) {
        var AddCommentV, CommentController, CommentV, CommentsC, CommentsV, Controller, ShareExternalV, ShareM, stumble,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Controller = require('../base/controller');

        CommentsV = require('../../views/comments-view');

        AddCommentV = require('../../views/add-comment-view');

        CommentsC = require('../../models/comments-collection');

        CommentV = require('../../views/comment-view');

        ShareExternalV = require('../../views/share-external-view');

        ShareM = require('../../models/share-model');

        stumble = require('../../lib/stumble');

        module.exports = CommentController = (function(_super) {
            __extends(CommentController, _super);

            function CommentController() {
                return CommentController.__super__.constructor.apply(this, arguments);
            }

            CommentController.prototype.initialize = function() {
                var active;
                CommentController.__super__.initialize.apply(this, arguments);
                active = stumble.getCollection().getActive();
                this.commentsC = new CommentsC();
                this.shareM = new ShareM();
                this.view = new AddCommentV({
                    autoRender: true,
                    region: 'panel',
                    className: 'addcomment-container container',
                    collection: this.commentsC
                });
                this.commentsView = new CommentsV({
                    collection: this.commentsC,
                    container: '.comments-container',
                    className: 'comments-user',
                    itemView: CommentV,
                    containerMethod: 'html'
                });
                this.shareExternalView = new ShareExternalV({
                    autoRender: true,
                    model: this.shareM,
                    container: '.comments-share-external'
                });
                if (active.get('_legacy')) {
                    return this.publishEvent('comment:loading:legacy');
                } else {
                    return this.commentsC.fetch({
                        data: {
                            urlid: active.get('urlid')
                        }
                    }).then((function(_this) {
                        return function(data) {
                            return _this.publishEvent('comment:loading:end', data);
                        };
                    })(this));
                }
            };

            return CommentController;

        })(Controller);


    }, {
        "../../lib/stumble": 48,
        "../../models/comments-collection": 76,
        "../../models/share-model": 92,
        "../../views/add-comment-view": 208,
        "../../views/comment-view": 215,
        "../../views/comments-view": 216,
        "../../views/share-external-view": 245,
        "../base/controller": "r1JNni"
    }
    ],
    "jofflq": [function(require, module, exports) {
        var Controller, FacebookController, FacebookV, ShareM,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Controller = require('../base/controller');

        FacebookV = require('../../views/facebook-view');

        ShareM = require('../../models/share-model');

        module.exports = FacebookController = (function(_super) {
            __extends(FacebookController, _super);

            function FacebookController() {
                return FacebookController.__super__.constructor.apply(this, arguments);
            }

            FacebookController.prototype.initialize = function() {
                FacebookController.__super__.initialize.apply(this, arguments);
                this.shareM = new ShareM({
                    type: 'external',
                    services: ['facebook']
                });
                return this.view = new FacebookV({
                    region: 'panel',
                    model: this.shareM
                });
            };

            return FacebookController;

        })(Controller);


    }, {
        "../../models/share-model": 92,
        "../../views/facebook-view": 220,
        "../base/controller": "r1JNni"
    }
    ],
    "controllers/panels/facebook-controller": [function(require, module, exports) {
        module.exports = require('jofflq');
    }, {}
    ],
    "4JdDAV": [function(require, module, exports) {
        var AddToListView, Controller, CreateListView, ListController, ListM, mediator,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Controller = require('../base/controller');

        AddToListView = require('../../views/add-to-list-view');

        CreateListView = require('../../views/create-list-view');

        ListM = require('../../models/list-model');

        mediator = require('chaplin').mediator;

        module.exports = ListController = (function(_super) {
            __extends(ListController, _super);

            function ListController() {
                return ListController.__super__.constructor.apply(this, arguments);
            }

            ListController.prototype.initialize = function() {
                ListController.__super__.initialize.apply(this, arguments);
                this.subscribeEvent('list:displaycreate', this.displayCreateList);
                this.subscribeEvent('list:added', this.addCurrentStumbleTo);
                this.subscribeEvent('list:itemadd', this.addCurrentStumbleTo);
                this.subscribeEvent('list:displayadd', this.displayAddToList);
                this.subscribeEvent('list:itemadded', this.closePanel);
                this.subscribeEvent('list:itemadded:error', this.closePanel);
                this.displayAddToList();
                return mediator.listsC.fetch();
            };

            ListController.prototype.displayAddToList = function() {
                var _ref;
                if ((_ref = this.createlistview) != null) {
                    _ref.dispose();
                }
                return this.addtolistview = new AddToListView({
                    collection: mediator.listsC
                });
            };

            ListController.prototype.displayCreateList = function(name) {
                var listM, _ref;
                listM = new ListM({
                    name: name
                });
                if ((_ref = this.addtolistview) != null) {
                    _ref.dispose();
                }
                return this.createlistview = new CreateListView({
                    model: listM
                });
            };

            ListController.prototype.addCurrentStumbleTo = function(listM) {
                return listM.get('listItemsC').addCurrentStumble();
            };

            ListController.prototype.closePanel = function() {
                return this.setTimeout((function(_this) {
                    return function() {
                        return _this.publishEvent('panel:close', {
                            name: 'list'
                        });
                    };
                })(this), '2s');
            };

            return ListController;

        })(Controller);


    }, {
        "../../models/list-model": 82,
        "../../views/add-to-list-view": 209,
        "../../views/create-list-view": 219,
        "../base/controller": "r1JNni",
        "chaplin": 268
    }
    ],
    "controllers/panels/list-controller": [function(require, module, exports) {
        module.exports = require('4JdDAV');
    }, {}
    ],
    "+urNMo": [function(require, module, exports) {
        var Controller, MenuController, MenuView,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Controller = require('../base/controller');

        MenuView = require('../../views/menu-view');

        module.exports = MenuController = (function(_super) {
            __extends(MenuController, _super);

            function MenuController() {
                return MenuController.__super__.constructor.apply(this, arguments);
            }

            MenuController.prototype.initialize = function() {
                MenuController.__super__.initialize.apply(this, arguments);
                return this.view = new MenuView({
                    region: 'panel'
                });
            };

            return MenuController;

        })(Controller);


    }, {
        "../../views/menu-view": 227,
        "../base/controller": "r1JNni"
    }
    ],
    "controllers/panels/menu-controller": [function(require, module, exports) {
        module.exports = require('+urNMo');
    }, {}
    ],
    "kDd6n3": [function(require, module, exports) {
        var Controller, ModesController, ModesView, View, mediator,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Controller = require('../base/controller');

        ModesView = require('../../views/modes-view');

        View = require('../../views/base/view');

        mediator = require('chaplin').mediator;

        module.exports = ModesController = (function(_super) {
            __extends(ModesController, _super);

            function ModesController() {
                return ModesController.__super__.constructor.apply(this, arguments);
            }

            ModesController.prototype.initialize = function() {
                ModesController.__super__.initialize.apply(this, arguments);
                return this.view = new ModesView({
                    autoRender: true,
                    region: 'panel',
                    className: 'modes-container container',
                    collection: mediator.modesC,
                    filterer: function(model) {
                        return model.get('_hide') === !true;
                    }
                });
            };

            return ModesController;

        })(Controller);


    }, {
        "../../views/base/view": 214,
        "../../views/modes-view": 230,
        "../base/controller": "r1JNni",
        "chaplin": 268
    }
    ],
    "controllers/panels/modes-controller": [function(require, module, exports) {
        module.exports = require('kDd6n3');
    }, {}
    ],
    "controllers/panels/notification-controller": [function(require, module, exports) {
        module.exports = require('lBiuMh');
    }, {}
    ],
    "lBiuMh": [function(require, module, exports) {
        var Controller, NotificationController, NotificationItemsC, NotificationItemsV, NotificationV, mediator,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Controller = require('../base/controller');

        NotificationItemsC = require('../../models/notification-items-collection');

        mediator = require('chaplin').mediator;

        NotificationV = require('../../views/notification-view');

        NotificationItemsV = require('../../views/notification-items-view');

        module.exports = NotificationController = (function(_super) {
            __extends(NotificationController, _super);

            function NotificationController() {
                return NotificationController.__super__.constructor.apply(this, arguments);
            }

            NotificationController.prototype.initialize = function() {
                var notificationItemsC, notificationM;
                NotificationController.__super__.initialize.apply(this, arguments);
                notificationM = mediator.notificationM;
                notificationItemsC = new NotificationItemsC(notificationM.get('recentNotifications'));
                this.view = new NotificationV({
                    model: notificationM,
                    autoRender: true,
                    className: 'notification-container container',
                    region: 'panel'
                });
                this.NotificationItemsV = new NotificationItemsV({
                    collection: notificationItemsC
                });
                return this.view.subview('notificationItems', this.NotificationItemsV);
            };

            return NotificationController;

        })(Controller);


    }, {
        "../../models/notification-items-collection": 90,
        "../../views/notification-items-view": 236,
        "../../views/notification-view": 237,
        "../base/controller": "r1JNni",
        "chaplin": 268
    }
    ],
    "WwFx8w": [function(require, module, exports) {
        var Controller, ReplyController, ReplyView,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Controller = require('../base/controller');

        ReplyView = require('../../views/reply-view');

        module.exports = ReplyController = (function(_super) {
            __extends(ReplyController, _super);

            function ReplyController() {
                return ReplyController.__super__.constructor.apply(this, arguments);
            }

            ReplyController.prototype.initialize = function(options) {
                var _ref;
                if (options == null) {
                    options = {};
                }
                ReplyController.__super__.initialize.apply(this, arguments);
                return this.view = new ReplyView({
                    region: 'panel',
                    model: options != null ? (_ref = options.panel) != null ? _ref.model : void 0 : void 0
                });
            };

            return ReplyController;

        })(Controller);


    }, {
        "../../views/reply-view": 243,
        "../base/controller": "r1JNni"
    }
    ],
    "controllers/panels/reply-controller": [function(require, module, exports) {
        module.exports = require('WwFx8w');
    }, {}
    ],
    "controllers/panels/share-controller": [function(require, module, exports) {
        module.exports = require('qBJ77m');
    }, {}
    ],
    "qBJ77m": [function(require, module, exports) {
        var ContactView, ContactsView, Controller, ShareController, ShareExternalV, ShareM, ShareView, mediator,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Controller = require('../base/controller');

        ShareView = require('../../views/share-view');

        ShareM = require('../../models/share-model');

        ContactsView = require('../../views/contacts-view');

        ContactView = require('../../views/contact-view');

        ShareExternalV = require('../../views/share-external-view');

        mediator = require('chaplin').mediator;

        module.exports = ShareController = (function(_super) {
            __extends(ShareController, _super);

            function ShareController() {
                return ShareController.__super__.constructor.apply(this, arguments);
            }

            ShareController.prototype.initialize = function() {
                ShareController.__super__.initialize.apply(this, arguments);
                this.shareM = new ShareM();
                this.view = new ShareView({
                    autoRender: true,
                    region: 'panel',
                    className: 'share-container container',
                    model: this.shareM
                });
                this.allContanctsV = new ContactsView({
                    collection: mediator.contactsC,
                    className: 'faux-input',
                    container: '#webtb-share-contacts',
                    itemView: ContactView
                });
                this.mostSharedContactsV = new ContactsView({
                    collection: mediator.contactsC.getMostShared(),
                    className: 'faux-input',
                    container: '#webtb-most-shared',
                    itemView: ContactView,
                    filterer: function(item) {
                        return item.get('type') === 'most' || item;
                    }
                });
                this.view.subview('allContanctsV', this.allContanctsV);
                this.view.subview('mostSharedContactsV', this.mostSharedContactsV);
                return this.shareExternalView = new ShareExternalV({
                    autoRender: true,
                    model: this.shareM,
                    container: '.share-share-external'
                });
            };

            return ShareController;

        })(Controller);


    }, {
        "../../models/share-model": 92,
        "../../views/contact-view": 217,
        "../../views/contacts-view": 218,
        "../../views/share-external-view": 245,
        "../../views/share-view": 246,
        "../base/controller": "r1JNni",
        "chaplin": 268
    }
    ],
    "controllers/panels/thumbdown-controller": [function(require, module, exports) {
        module.exports = require('YnK63m');
    }, {}
    ],
    "YnK63m": [function(require, module, exports) {
        var Controller, ThumbDownController, ThumbDownView,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Controller = require('../base/controller');

        ThumbDownView = require('../../views/thumbdown-view');

        module.exports = ThumbDownController = (function(_super) {
            __extends(ThumbDownController, _super);

            function ThumbDownController() {
                return ThumbDownController.__super__.constructor.apply(this, arguments);
            }

            ThumbDownController.prototype.initialize = function() {
                ThumbDownController.__super__.initialize.apply(this, arguments);
                return this.view = new ThumbDownView({
                    region: 'panel'
                });
            };

            return ThumbDownController;

        })(Controller);


    }, {
        "../../views/thumbdown-view": 248,
        "../base/controller": "r1JNni"
    }
    ],
    "controllers/progress-bar-controller": [function(require, module, exports) {
        module.exports = require('yZg3j8');
    }, {}
    ],
    "yZg3j8": [function(require, module, exports) {
        var Collection, Controller, Model, ProgressBarController, ProgressBarView, mediator, storage, utils,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Controller = require('./base/controller');

        mediator = require('chaplin').mediator;

        Model = require('../models/base/model');

        Collection = require('../models/base/collection');

        utils = require('../lib/utils');

        ProgressBarView = require('../views/progress-bar/bar-view');

        storage = require('simple-storage');

        module.exports = ProgressBarController = (function(_super) {
            __extends(ProgressBarController, _super);

            function ProgressBarController() {
                return ProgressBarController.__super__.constructor.apply(this, arguments);
            }

            ProgressBarController.prototype.messages = ["Every time you click Stumble we'll surprise you with a new page based on your interests.", "Click thumbs up or down to help us learn more about your tastes.", "Share your discoveries with friends on Facebook and Twitter using the Share button.", "Tap the + button to organize content you find into personal collections called Lists.", "Thank you for the hard work. Stumbling will be custom-tailored for you from here on out!"];

            ProgressBarController.prototype.initialize = function() {
                ProgressBarController.__super__.initialize.apply(this, arguments);
                this.maxStops = this.messages.length - 1;
                this.subscribeEvent('progress-bar:close', this.close);
                this.subscribeEvent('progress-bar:open', this.launchProgressBar);
                return this.subscribeEvent('progress-bar:reset', this.resetProgressBar);
            };

            ProgressBarController.prototype.canLaunchProgressBar = function() {
                var canLaunch;
                if (window.location.href.match('progressbartest=true')) {
                    this.resetProgressBar();
                    canLaunch = true;
                } else if (utils.isMobile() && !utils.isIpad()) {
                    canLaunch = false;
                } else if (storage.get('progressBarClosed')) {
                    canLaunch = false;
                } else if (storage.get('progressBar')) {
                    canLaunch = true;
                } else {
                    canLaunch = mediator.userM.get('stumbles_count') <= this.messages.length;
                }
                return canLaunch;
            };

            ProgressBarController.prototype.launchProgressBar = function() {
                var count, percentLeft, stops, storageCount;
                if (!this.canLaunchProgressBar() || this.view) {
                    return null;
                }
                count = 0;
                if ((storageCount = storage.get("progressBarCount"))) {
                    count = storageCount;
                }
                stops = [];
                if ((stops = storage.get("progressBar"))) {
                    if (count < this.maxStops) {
                        stops[count].active = true;
                    }
                } else {
                    stops = this.genereateStops(this.maxStops);
                }
                percentLeft = 0;
                if (count < this.maxStops) {
                    percentLeft = 100 - this.calcPerc(count);
                }
                this.model = new Model({
                    count: count,
                    percent: percentLeft.toString(),
                    messages: this.messages,
                    message: this.messages[count]
                });
                this.collection = new Collection(stops);
                this.view = new ProgressBarView({
                    region: 'progress-bar',
                    model: this.model,
                    collection: this.collection
                });
                this.model.on('change:count', this.publishProgressCount, this);
                return this.publishProgressCount();
            };

            ProgressBarController.prototype.publishProgressCount = function(model) {
                return mediator.publish('progress-bar:count', this.model.get('count'));
            };

            ProgressBarController.prototype.calcPerc = function(itemCount) {
                return itemCount * (100 / (this.messages.length - 1));
            };

            ProgressBarController.prototype.genereateStops = function(total) {
                var currentPos, data, stops;
                stops = [];
                currentPos = 0;
                while (currentPos < total) {
                    data = {
                        active: false,
                        count: currentPos + 1,
                        passed: false,
                        percent: this.calcPerc(currentPos),
                        showCount: true
                    };
                    if (currentPos === 0) {
                        data.active = true;
                    }
                    if ((currentPos + 1) === total) {
                        data.final = true;
                    }
                    stops.push(new Model(data));
                    currentPos++;
                }
                return stops;
            };

            ProgressBarController.prototype.resetProgressBar = function() {
                return ['progressBarClosed', 'progressBar', 'progressBarCount'].forEach(function(key) {
                    return storage.remove(key);
                });
            };

            ProgressBarController.prototype.setToStop = function(stop) {
                var stops;
                stops = this.genereateStops(this.maxStops);
                storage.set('progressBar', stops);
                storage.set('progressBarCount', stop);
                return storage.remove('progressBarClosed');
            };

            ProgressBarController.prototype.close = function() {
                storage.set('progressBarClosed', true);
                storage.remove('progressBar');
                return this.dispose();
            };

            return ProgressBarController;

        })(Controller);


    }, {
        "../lib/utils": 69,
        "../models/base/collection": 73,
        "../models/base/model": 74,
        "../views/progress-bar/bar-view": 239,
        "./base/controller": "r1JNni",
        "chaplin": 268,
        "simple-storage": 274
    }
    ],
    "8zD71I": [function(require, module, exports) {
        var $, Chaplin, Controller, ToolbarController, ToolbarV, analytics, mediator, root, stumble, utils, _,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        _ = require('lodash');

        Chaplin = require('chaplin');

        Controller = require('./base/controller');

        mediator = require('chaplin').mediator;

        ToolbarV = require('../views/toolbar-view');

        utils = require('../lib/utils');

        root = require('../lib/root');

        stumble = require('../lib/stumble');

        analytics = require('../lib/analytics');

        $ = require('jquery');

        module.exports = ToolbarController = (function(_super) {
            __extends(ToolbarController, _super);

            function ToolbarController() {
                return ToolbarController.__super__.constructor.apply(this, arguments);
            }

            ToolbarController.prototype.initialize = function() {
                this.subscribeEvent('stumble:next', this.stumbleNext);
                this.subscribeEvent('api:outofstumbles', this.onOutOfStumbles);
                this.subscribeEvent('api:userhasnotopics', this.onUserHasNoTopics);
                this.subscribeEvent('toolbar:disabled', utils.gotoUrl);
                this.subscribeEvent('dd:pageloaded', function(ddwindow) {
                    this.publishEvent('panel:close');
                    if (ddwindow.location.pathname.indexOf('su/overlay') === - 1) {
                        return Chaplin.utils.redirectTo({
                            url: ddwindow.location.pathname
                        }, {
                            path: ddwindow.location.pathname
                        });
                    }
                });
                return this.View = ToolbarV;
            };

            ToolbarController.prototype.legacyHandler = function(data, params) {
                if (data.route === 'submit' && utils.getCurrentQueryParamValue('url')) {
                    return window.location.href = '/badge?' + params.query;
                } else {
                    this.publishEvent('panel:close');
                    stumble.getCollection().addLegacy(data.route, params.query);
                    return this.stumble({
                        urlid: data.route
                    });
                }
            };

            ToolbarController.prototype.stumbleNext = function() {
                return stumble.getNext().then((function(_this) {
                    return function(model) {
                        var route;
                        route = (model != null ? typeof model.get === "function" ? model.get('_route') : void 0 : void 0) || '/';
                        if (mediator.update) {
                            return utils.gotoUrl(utils.appendParams('/' + route, {
                                update: utils.unix()
                            }));
                        } else {
                            return Chaplin.utils.redirectTo({
                                url: route
                            });
                        }
                    };
                })(this), (function(_this) {
                    return function(data) {
                        var code, eventName, _ref, _ref1;
                        if (data != null ? data.visitor : void 0) {
                            return utils.getNoSpaUrl();
                        } else {
                            code = (data != null ? (_ref = data.responseJSON) != null ? _ref._code : void 0 : void 0) || 0;
                            eventName = "stumbleNextError-" + code;
                            console.error(eventName, data);
                            analytics.trackEvent(eventName);
                            return (_ref1 = window.heap) != null ? _ref1.track(eventName) : void 0;
                        }
                    };
                })(this));
            };

            ToolbarController.prototype.displayStumbleModel = function(model) {
                model.setActive();
                this.view = new this.View({
                    model: model
                });
                this.adjustTitle(model != null ? model.get('_title') : void 0);
                this.reportDDseenMethod();
                this.reportEmailClick(model != null ? model.get('urlid') : void 0);
                utils.replaceState(model.get('_route'));
                return analytics.trackComscore();
            };

            ToolbarController.prototype.onStumbleError = function(model, xhr, options) {
                var location, _ref;
                if ((xhr != null ? (_ref = xhr.responseJSON) != null ? _ref._code : void 0 : void 0) === 2000) {
                    return location = '/home';
                } else {
                    return location = '/500.html';
                }
            };

            ToolbarController.prototype.stumble = function(data, params, options) {
                var urlid;
                urlid = data.urlid;
                if (urlid === 'redir') {
                    urlid = window.location.href.split('pid=').pop().split('&').shift().split('%').shift();
                }
                if (utils.isVisitor() && params) {
                    data = {
                        route: params.path
                    };
                    return this.legacyHandler(data, params);
                } else {
                    return stumble.getCollection().getById(urlid).then((function(_this) {
                        return function(model) {
                            return _this.displayStumbleModel(model);
                        };
                    })(this), (function(_this) {
                        return function(model, xhr, options) {
                            return _this.onStumbleError(model, xhr, options);
                        };
                    })(this));
                }
            };

            ToolbarController.prototype.stumbleThru = function() {
                var domainMode;
                domainMode = mediator.modesC.setDomainMode();
                if (domainMode != null ? domainMode.urlid : void 0) {
                    return this.stumble(domainMode);
                } else {
                    return this.stumbleNext();
                }
            };

            ToolbarController.prototype.stumbleTopic = function(opts) {
                mediator.modesC.setActive(opts.topic);
                return this.stumbleNext();
            };

            ToolbarController.prototype.share = function(data) {
                stumble.getCollection().getByShareId(data.urlid).then((function(_this) {
                    return function(model) {
                        _this.displayStumbleModel(model);
                        return _this.publishEvent('share:loaded');
                    };
                })(this), (function(_this) {
                    return function(model, xhr, options) {
                        return _this.onStumbleError(model, xhr, options);
                    };
                })(this));
                return this.reportShareClick(data.urlid);
            };

            ToolbarController.prototype.onOutOfStumbles = function() {
                var currentMode, listId;
                currentMode = mediator.modesC.getActive();
                if (currentMode != null ? currentMode.get('listId') : void 0) {
                    listId = currentMode.get('listId');
                    return Chaplin.utils.redirectTo({
                        url: "lists/" + listId + "/runout"
                    });
                } else {
                    return mediator.modesC.setActive('All Interests');
                }
            };

            ToolbarController.prototype.onUserHasNoTopics = function() {
                return root().location.href = '/signup/choose-interests';
            };

            ToolbarController.prototype.reportDDseenMethod = function() {
                var href, reportUrl;
                href = root().location.href;
                if (href.match('from=')) {
                    reportUrl = decodeURIComponent(href.split('from=').pop());
                    if (!reportUrl.match('http')) {
                        return $.get(reportUrl);
                    }
                }
            };

            ToolbarController.prototype.reportShareClick = _.memoize(function(shareid) {
                return $.get("/su/share/" + shareid + "?_nospa=true");
            });

            ToolbarController.prototype.reportEmailClick = _.once(function(urlid) {
                return $.get("/su/" + urlid + "?_nospa=true");
            });

            return ToolbarController;

        })(Controller);


    }, {
        "../lib/analytics": 39,
        "../lib/root": 47,
        "../lib/stumble": 48,
        "../lib/utils": 69,
        "../views/toolbar-view": 250,
        "./base/controller": "r1JNni",
        "chaplin": 268,
        "jquery": 269,
        "lodash": 271
    }
    ],
    "controllers/toolbar-controller": [function(require, module, exports) {
        module.exports = require('8zD71I');
    }, {}
    ],
    "controllers/update-controller": [function(require, module, exports) {
        module.exports = require('dHCCyL');
    }, {}
    ],
    "dHCCyL": [function(require, module, exports) {
        var $, Chaplin, Controller, UpdateController, root, storage, utils, _,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        _ = require('lodash');

        $ = require('jquery');

        Chaplin = require('chaplin');

        Controller = require('./base/controller');

        root = require('../lib/root');

        storage = require('simple-storage');

        utils = require('../lib/utils');

        module.exports = UpdateController = (function(_super) {
            __extends(UpdateController, _super);

            function UpdateController() {
                return UpdateController.__super__.constructor.apply(this, arguments);
            }

            UpdateController.prototype.announceEvents = 'update';

            UpdateController.prototype.checkInterval = '2m';

            UpdateController.prototype.maxWait = '20m';

            UpdateController.prototype.initialize = function() {
                UpdateController.__super__.initialize.apply(this, arguments);
                if (!utils.isLocalDev()) {
                    this.on('outofdate', (function(_this) {
                        return function() {
                            storage.remove('version');
                            return _this.scheduleRefresh();
                        };
                    })(this));
                    return this.getCurrentVersion().then((function(_this) {
                        return function() {
                            return _this.monitor();
                        };
                    })(this));
                }
            };

            UpdateController.prototype.refresh = function() {
                return root().location.reload(true);
            };

            UpdateController.prototype.scheduleRefresh = function() {
                Chaplin.mediator.update = true;
                return this.setTimeout((function(_this) {
                    return function() {
                        return _this.refresh();
                    };
                })(this), this.maxWait);
            };

            UpdateController.prototype.monitor = function() {
                return this.setInterval((function(_this) {
                    return function() {
                        return _this.check();
                    };
                })(this), this.checkInterval);
            };

            UpdateController.prototype.check = function() {
                return $.when(this.getCurrentVersion(), this.getLatest()).then((function(_this) {
                    return function(current, latest) {
                        var updatemsg;
                        updatemsg = current === latest ? 'noupdates' : 'outofdate';
                        return _this.trigger("" + updatemsg, current, latest);
                    };
                })(this));
            };

            UpdateController.prototype.getCurrentVersion = function() {
                var dfd;
                if (storage.get('version')) {
                    dfd = new $.Deferred;
                    dfd.promise();
                    return dfd.resolve(storage.get('version'));
                } else {
                    return this.getLatest().then(function(latest) {
                        storage.set('version', latest);
                        return latest;
                    });
                }
            };

            UpdateController.prototype.getLatest = function() {
                var uid;
                uid = '/su/updatecheck.' + _.now() + _.random(1, 10000) + '.html';
                return $.get(uid).then(function(latest) {
                    return latest;
                }, (function(_this) {
                    return function() {
                        return _this.trigger('checkfailed', arguments);
                    };
                })(this));
            };

            return UpdateController;

        })(Controller);


    }, {
        "../lib/root": 47,
        "../lib/utils": 69,
        "./base/controller": "r1JNni",
        "chaplin": 268,
        "jquery": 269,
        "lodash": 271,
        "simple-storage": 274
    }
    ],
    37: [function(require, module, exports) {
        var $, Application, routes, _;

        _ = require('lodash');

        $ = require('jquery');

        Application = require('./application');

        routes = require('./routes');

        $(function() {
            return new Application({
                controllerSuffix: '-controller',
                title: 'StumbleUpon',
                titleTemplate: _.template('<%= subtitle %> - <%= title %>'),
                scrollTo: false,
                routes: routes
            });
        });


    }, {
        "./application": 1,
        "./routes": 99,
        "jquery": 269,
        "lodash": 271
    }
    ],
    38: [function(require, module, exports) {
        var $, storage;

        storage = require('simple-storage');

        $ = require('jquery');

        module.exports = {
            STUMBLE_BUCKETS: [1, 2, 3, 4, 5, 10, 15, 20, 30, 40, 50, 75, 100, 150, 200, 300],
            track: function(action) {
                var experimentId, sCountObj, stumbleCount;
                experimentId = typeof optimizely !== "undefined" && optimizely !== null ? optimizely.activeExperiments[0] : void 0;
                if (action === 'stumble') {
                    sCountObj = storage.get('sCount') || {};
                    stumbleCount = sCountObj[experimentId] + 1 || 1;
                    sCountObj[experimentId] = stumbleCount;
                    storage.set('sCount', sCountObj);
                    if (this.STUMBLE_BUCKETS.indexOf(stumbleCount) !== - 1) {
                        window['optimizely'].push(["trackEvent", "stumble-" + stumbleCount]);
                    }
                } else {
                    window['optimizely'].push(["trackEvent", action]);
                }
                if (action === 'thumbup') {
                    return mixpanel.track('Thumbup Clicked');
                }
            },
            trackAppInit: function(hours) {
                var date;
                if ((typeof optimizely !== "undefined" && optimizely !== null ? optimizely.activeExperiments.length : void 0) > 0) {
                    if (!$.cookie('nextinit')) {
                        date = new Date();
                        hours = hours || 24;
                        date.setTime(date.setHours(date.getHours() + hours));
                        $.cookie('nextinit', true, {
                            expires: date
                        });
                        return mixpanel.track('App Initialized');
                    }
                } else {
                    return $.removeCookie('nextinit');
                }
            }
        };


    }, {
        "jquery": 269,
        "simple-storage": 274
    }
    ],
    39: [function(require, module, exports) {
        var $, SUdebug, abTracking, config, storage, suMixpanel, _, _ref;

        _ = require('lodash');

        config = require('../config');

        SUdebug = require('../su-debug');

        abTracking = require('./ab-tracking');

        suMixpanel = require('./su-mixpanel');

        $ = require('jquery');

        storage = require('simple-storage');

        module.exports = {
            category: "SPA-" + (SUdebug != null ? SUdebug.branch : void 0) + "-" + (SUdebug != null ? (_ref = SUdebug.hash) != null ? _ref.slice(0, 7) : void 0 : void 0),
            trackPageview: function(path) {
                if (path[0] !== '/') {
                    path = '/' + path;
                }
                return typeof _gaq !== "undefined" && _gaq !== null ? _gaq.push(['_trackPageview', path]) : void 0;
            },
            trackComscore: function() {
                return typeof COMSCORE !== "undefined" && COMSCORE !== null ? COMSCORE.beacon({
                    c1: "2",
                    c2: "7677660"
                }) : void 0;
            },
            trackEvent: function(action, opt_label, opt_value, opt_noninteraction) {
                var gaEvent;
                if (action == null) {
                    throw new Error('Must specify an action');
                }
                if (action.match(' ')) {
                    throw new Error('Action must not have spaces');
                }
                gaEvent = ['_trackEvent', this.category].concat(_.toArray(arguments));
                if (_.random(10) === 1) {
                    if (typeof _gaq !== "undefined" && _gaq !== null) {
                        _gaq.push(gaEvent);
                    }
                }
                suMixpanel.track(action);
                if ((typeof optimizely !== "undefined" && optimizely !== null ? optimizely.activeExperiments.length : void 0) > 0) {
                    abTracking.track(action);
                } else {
                    storage.remove('sCount');
                }
                console.log('spa action', action);
                $.get('/p');
                return true;
            },
            trackUser: function(userid) {
                if ((typeof optimizely !== "undefined" && optimizely !== null ? optimizely.activeExperiments.length : void 0) > 0 && userid) {
                    console.debug('trackUser', userid);
                    return typeof optimizely !== "undefined" && optimizely !== null ? optimizely.push(['setDimensionValue', 1824091439, userid]) : void 0;
                }
            }
        };


    }, {
        "../config": 2,
        "../su-debug": 101,
        "./ab-tracking": 38,
        "./su-mixpanel": 65,
        "jquery": 269,
        "lodash": 271,
        "simple-storage": 274
    }
    ],
    40: [function(require, module, exports) {
        var $, ClickTracking, LegacyClickTracking, analytics, root, _;

        root = require('./root');

        LegacyClickTracking = require('./legacy-click-tracking');

        analytics = require('./analytics');

        _ = require('lodash');

        $ = require('jquery');

        module.exports = ClickTracking = (function() {
            function ClickTracking() {
                this.legacyClickTracking = new LegacyClickTracking;
                this.$body = $('body');
                this.$body.on('click', (function(_this) {
                    return function(e) {
                        return _this.onClick(e);
                    };
                })(this));
            }

            ClickTracking.prototype.getAnalyticsId = _.memoize(function(el) {
                var _ref, _ref1;
                return (_ref = $(el)) != null ? (_ref1 = _ref.closest('[data-id]')) != null ? _ref1.attr('data-id') : void 0 : void 0;
            }, function(el) {
                return el != null ? el.outerHTML : void 0;
            });

            ClickTracking.prototype.onClick = function(e) {
                return _.defer((function(_this) {
                    return function() {
                        var id;
                        id = _this.getAnalyticsId(e.target);
                        if (id != null) {
                            return analytics.trackEvent(id);
                        }
                    };
                })(this));
            };

            return ClickTracking;

        })();


    }, {
        "./analytics": 39,
        "./legacy-click-tracking": 43,
        "./root": 47,
        "jquery": 269,
        "lodash": 271
    }
    ],
    41: [function(require, module, exports) {
        var generateGuid, localStorageKey, s4, storage, _;

        _ = require('lodash');

        storage = require('simple-storage');

        localStorageKey = 'guid';

        s4 = function() {
            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        };

        generateGuid = _.once(function() {
            return s4() + s4() + "-" + s4() + "-" + s4() + "-" + s4() + "-" + s4() + s4() + s4();
        });

        module.exports = {
            get: function() {
                var existingGuid, generatedGuid;
                existingGuid = storage.get(localStorageKey);
                if (existingGuid) {
                    return existingGuid;
                } else {
                    generatedGuid = generateGuid();
                    storage.set(localStorageKey, generatedGuid);
                    return generatedGuid;
                }
            }
        };


    }, {
        "lodash": 271,
        "simple-storage": 274
    }
    ],
    42: [function(require, module, exports) {
        var stringsDefault;

        stringsDefault = require("../strings/en-US");

        module.exports = function(phrase) {
            return stringsDefault[phrase] || phrase;
        };


    }, {
        "../strings/en-US": 100
    }
    ],
    43: [function(require, module, exports) {
        var $, ClickTracking, S4, events, root, utils, _;

        $ = require('jquery');

        _ = require('lodash');

        utils = require('./utils');

        root = require('./root');


        /**
         * Queue of events that are captured waiting to be sent to server
         * @private
         * @type {Array}
         */

        events = [];


        /**
         * Generate random number
         * @private
         * @return {number} long random number
         */

        S4 = function() {
            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        };

        module.exports = ClickTracking = (function() {
            ClickTracking.prototype.cookiePrefix = 'ct_';

            ClickTracking.prototype.batch = {
                max: 50,
                size: 4
            };


            /**
               * Start capturing click events on body
               * @return {object}
               */

            function ClickTracking() {
                this.$body = $('body');
                this.$body.on('click', (function(_this) {
                    return function(e) {
                        return _this.onClick(e);
                    };
                })(this));
                this.scheduledSendBatch = setInterval((function(_this) {
                    return function() {
                        return _this.sendBatch(true);
                    };
                })(this), utils.toMs('15s'));
            }


            /**
               * Get the index of the given element relative to its parent
               * @param  {object}        el element
               * @return {number|string}    index of element relative to its parent
               */

            ClickTracking.prototype.getIndex = function(el) {
                var $el;
                $el = $(el);
                if ($el.index() !== - 1) {
                    return $el.index();
                } else {
                    return '';
                }
            };


            /**
               * Get a string of various attribute of the target element
               * @param  {object} e event
               * @return {string}   colon delimited string with various attributes of target element
               */

            ClickTracking.prototype.getE = function(e) {
                return [e.target.tagName, e.target.type, !e.target.id ? e.target.name : void 0, e.target.id, $(e.target.id).data('type'), e.target.className].join(':');
            };


            /**
               * Get a string of various attributes of the closest element
               * with either an id or a data-id depending on type
               * @param  {object} e    event
               * @param  {string} type id or data-id
               * @return {string}      colon delimited string with various attributes of closest target element
               */

            ClickTracking.prototype.getEventId = function(e, type) {
                var $el;
                $el = $(e.target).closest("[" + type + "]");
                return [$el.attr(type), $el.data('type'), this.getIndex(e.target), $el.attr('class')].join(':');
            };


            /**
               * Get the href of a tag unless it's #
               * @param  {object} e event
               * @return {string|undefined}   href if found and not #
               */

            ClickTracking.prototype.getTu = function(e) {
                var href;
                href = $(e.target).attr('href');
                if (href !== '#') {
                    return href;
                }
            };


            /**
               * Get guid in the format described at https://wiki.stumble.net/index.php/Click_Tracking#Data_definition
               * @param  {object} eventInfo Even info as described at https://wiki.stumble.net/index.php/Click_Tracking#Data_definition
               * @return {string}           cookieprefix_unixtimestamp_random
               */

            ClickTracking.prototype.getGuid = function(eventInfo) {
                return this.cookiePrefix + eventInfo.t + '_' + S4();
            };


            /**
               * Get the data of the item that was clicked on in the format of described at https://wiki.stumble.net/index.php/Click_Tracking#Data_definition
               * @param  {object} e event
               * @return {object}   promise
               */

            ClickTracking.prototype.getElementData = function(e) {
                var dfd;
                dfd = $.Deferred();
                _.defer((function(_this) {
                    return function() {
                        return dfd.resolve({
                            cx: e.clientX,
                            cy: e.clientY,
                            st: _this.$body.scrollTop(),
                            sl: _this.$body.scrollLeft(),
                            ms: 0,
                            e: _this.getE(e),
                            edid: _this.getEventId(e, 'data-id'),
                            eid: _this.getEventId(e, 'id'),
                            ou: root().location.href,
                            tu: _this.getTu(e),
                            t: Date.now()
                        });
                    };
                })(this));
                return dfd.promise();
            };


            /**
               * Get the total number of click tracking cookies currently set
               * @return {number} number of click tracking cookies
               */

            ClickTracking.prototype.clickCookiesCount = function() {
                return Object.keys($.cookie()).filter((function(_this) {
                    return function(item) {
                        return item.slice(0, 3 === _this.cookiePrefix);
                    };
                })(this)).length;
            };


            /**
               * Append the total batch with the event info
               * @param  {object} eventInfo Even info as described at https://wiki.stumble.net/index.php/Click_Tracking#Data_definition
               * @return {number}           Number of items in the total batch array
               */

            ClickTracking.prototype.appendBatch = function(eventInfo) {
                var guid;
                guid = this.getGuid(eventInfo);
                $.cookie(guid, $.param(eventInfo));
                return events.push({
                    guid: this.getGuid(eventInfo),
                    eventInfo: eventInfo
                });
            };


            /**
               * Send batch of events to server if need be
               * @return {object|undefined}
               */

            ClickTracking.prototype.sendBatch = function(force) {
                var currentBatch;
                if (force == null) {
                    force = false;
                }
                currentBatch = _(events).first(this.batch.size).value();
                if ((force && currentBatch.length) || (currentBatch.length === this.batch.size && this.clickCookiesCount() <= this.batch.max)) {
                    events = _(events).difference(currentBatch).value();
                    return $.get('/p').always((function(_this) {
                        return function() {
                            return _this.clearCookies();
                        };
                    })(this));
                }
            };


            /**
               * Clear cookies that have been stored for click tracking
               * @return {undefined}
               */

            ClickTracking.prototype.clearCookies = function() {
                return Object.keys($.cookie()).forEach(function(key) {
                    if (key.slice(0, 3) === 'ct_') {
                        return $.removeCookie(key);
                    }
                });
            };


            /**
               * Handle click events
               * @param  {object} e event
               * @return {object}   promise
               */

            ClickTracking.prototype.onClick = function(e) {
                return this.getElementData(e).then((function(_this) {
                    return function(data) {
                        return _this.appendBatch(data);
                    };
                })(this)).then((function(_this) {
                    return function() {
                        return _this.sendBatch();
                    };
                })(this));
            };

            return ClickTracking;

        })();


    }, {
        "./root": 47,
        "./utils": 69,
        "jquery": 269,
        "lodash": 271
    }
    ],
    44: [function(require, module, exports) {
        var AnnounceEvents, mediator, _;

        _ = require('lodash');

        mediator = require('chaplin').mediator;

        module.exports = AnnounceEvents = (function() {
            function AnnounceEvents() {}

            AnnounceEvents.prototype.announceEvents = null;

            AnnounceEvents.prototype.initialize = function() {
                if (typeof this.announceEvents === 'string') {
                    this.on('all', function(name) {
                        var args;
                        args = _.toArray(arguments);
                        args.shift();
                        args.unshift(this.announceEvents + ':' + name);
                        return mediator.publish.apply(mediator, args);
                    });
                }
                return AnnounceEvents.__super__.initialize.apply(this, arguments);
            };

            return AnnounceEvents;

        })();


    }, {
        "chaplin": 268,
        "lodash": 271
    }
    ],
    45: [function(require, module, exports) {
        var StopTimers, start, utils;

        utils = require('../utils');

        start = function(type, args) {
            var method, timer;
            if (!this.disposed) {
                method = window["set" + type];
                timer = method.apply(window, args);
                this.timers[type].push(timer);
                return timer;
            }
        };

        module.exports = StopTimers = (function() {
            function StopTimers() {
                this.resetTimers();
                StopTimers.__super__.constructor.apply(this, arguments);
            }

            StopTimers.prototype.resetTimers = function() {
                return this.timers = {
                    Interval: [],
                    Timeout: []
                };
            };

            StopTimers.prototype.setInterval = function() {
                if (arguments[1]) {
                    arguments[1] = utils.toMs(arguments[1]);
                }
                return start.call(this, 'Interval', arguments);
            };

            StopTimers.prototype.setTimeout = function() {
                if (arguments[1]) {
                    arguments[1] = utils.toMs(arguments[1]);
                }
                return start.call(this, 'Timeout', arguments);
            };

            StopTimers.prototype.dispose = function() {
                var clearMethod, key, val, _ref;
                _ref = this.timers;
                for (key in _ref) {
                    val = _ref[key];
                    clearMethod = window["clear" + key];
                    val.forEach(clearMethod);
                }
                this.resetTimers();
                return StopTimers.__super__.dispose.apply(this, arguments);
            };

            return StopTimers;

        })();


    }, {
        "../utils": 69
    }
    ],
    46: [function(require, module, exports) {
        var $, Chaplin, SU, analytics, announce, apiFail, handleError, rejectedPromise, root, utils;

        Chaplin = require('chaplin');

        SU = require('./su');

        root = require('./root');

        utils = require('./utils');

        $ = require('jquery');

        analytics = require('./analytics');

        apiFail = {
            threshold: 20,
            count: 0,
            errorPage: '/error-code-500?_nospa=true'
        };

        announce = function(name, data) {
            var code, eventName, _ref;
            Chaplin.mediator.publish('api:' + name, data);
            code = (data != null ? data._code : void 0) || 0;
            eventName = "api-" + name + "-" + code;
            console.error(eventName, data);
            analytics.trackEvent(eventName, code);
            return (_ref = window.heap) != null ? _ref.track(eventName) : void 0;
        };

        handleError = function(res) {
            var code, data;
            data = (res != null ? res.responseJSON : void 0) || null;
            code = (data != null ? data._code : void 0) || null;
            switch (code) {
            case 1230:
            case 1070:
            case 5090:
                return (function() {
                    return announce('badauth', data);
                })();
            case 5020:
            case 5030:
                return (function() {
                    return announce('outofstumbles', data);
                })();
            case 5060:
                return (function() {
                    return announce('userhasnotopics', data);
                })();
            case 1010:
                return (function() {
                    return announce('invalidtoken', data);
                })();
            case 19230:
                return (function() {
                    return announce('urlalreadyinlist', data);
                })();
            case 2000:
                return (function() {
                    return announce('urldoesnotexist', data);
                })();
            default:
                return (function() {
                    return announce('unknownerror', data);
                })();
            }
        };

        rejectedPromise = function() {
            var dfd;
            dfd = new $.Deferred;
            dfd.reject();
            return dfd.promise();
        };

        module.exports = function(apimethod, args) {
            var method, model, options, _ref;
            method = args[0];
            model = args[1];
            options = args[2] || {};
            if (apiFail.count >= apiFail.threshold) {
                try {
                    analytics.trackEvent('maxApiErrors', apiFail.count);
                    console.error('maxApiErrors', apiFail.count);
                    if ((_ref = window.heap) != null) {
                        _ref.track('maxApiErrors', {
                            apiFailCount: apiFail.count
                        });
                    }
                    debugger;
                } catch (_error) {}
                if (apiFail.errorPage.indexOf(root().location.pathname) === - 1) {
                    root().location.href = apiFail.errorPage;
                }
                return rejectedPromise();
            } else {
                return apimethod(options.data, function(res) {
                    if ((res != null ? res._success : void 0) && (!utils.isOutOfStumbles(res, options.data) || !utils.isLoggedIn())) {
                        apiFail.count = 0;
                        return typeof options.success === "function" ? options.success(res) : void 0;
                    } else {
                        handleError(res);
                        apiFail.count += 1;
                        return typeof options.error === "function" ? options.error(res) : void 0;
                    }
                }, handleError);
            }
        };


    }, {
        "./analytics": 39,
        "./root": 47,
        "./su": 66,
        "./utils": 69,
        "chaplin": 268,
        "jquery": 269
    }
    ],
    47: [function(require, module, exports) {
        var global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
        var internal;

        internal = {};

        module.exports = function() {
            if (typeof window !== "undefined" && window !== null) {
                return window;
            } else if (typeof global !== "undefined" && global !== null) {
                return global;
            } else {
                return internal;
            }
        };


    }, {}
    ],
    48: [function(require, module, exports) {
        var mediator;

        mediator = require('chaplin').mediator;

        module.exports = {
            getCollection: function() {
                var currentMode;
                currentMode = mediator.modesC.getActive();
                if ((currentMode != null ? currentMode.get('listId') : void 0) != null) {
                    return mediator.listItemsC;
                } else {
                    return mediator.stumblesC;
                }
            },
            getNext: function() {
                return this.getCollection().getNext(arguments);
            },
            whereUnseen: function() {
                return this.getCollection().whereUnseen(arguments);
            }
        };


    }, {
        "chaplin": 268
    }
    ],
    49: [function(require, module, exports) {
        var SUJS, StumbleUpon;

        SUJS = StumbleUpon = (function() {
            StumbleUpon.prototype.Comment = require('./stumbleupon/comment');

            StumbleUpon.prototype.Contact = require('./stumbleupon/contact');

            StumbleUpon.prototype.config = require('./stumbleupon/config');

            StumbleUpon.prototype.debug = true;

            StumbleUpon.prototype.History = require('./stumbleupon/history');

            StumbleUpon.prototype.Lists = require('./stumbleupon/lists');

            StumbleUpon.prototype.Notifications = require('./stumbleupon/notifications');

            StumbleUpon.prototype.Report = require('./stumbleupon/report');

            StumbleUpon.prototype.Share = require('./stumbleupon/share');

            StumbleUpon.prototype.Stumble = require('./stumbleupon/stumble');

            StumbleUpon.prototype.Url = require('./stumbleupon/url');

            StumbleUpon.prototype.User = require('./stumbleupon/user');

            function StumbleUpon(options) {}

            return StumbleUpon;

        })();

        if (module) {
            module.exports = SUJS;
        }

        if (window) {
            window.SUJS = SUJS;
        }


    }, {
        "./stumbleupon/comment": 51,
        "./stumbleupon/config": 52,
        "./stumbleupon/contact": 53,
        "./stumbleupon/history": 54,
        "./stumbleupon/lists": 57,
        "./stumbleupon/notifications": 59,
        "./stumbleupon/report": 60,
        "./stumbleupon/share": 61,
        "./stumbleupon/stumble": 62,
        "./stumbleupon/url": 63,
        "./stumbleupon/user": 64
    }
    ],
    50: [function(require, module, exports) {
        var $, analytics, config, generateHeaders, globalConfig, guid, noretry, storage, utils, _,
        __hasProp = {}.hasOwnProperty;

        _ = require('lodash');

        $ = require('jquery');

        globalConfig = require('../../config');

        config = require('./config');

        utils = require('../utils');

        analytics = require('../analytics');

        storage = require('simple-storage');

        guid = require('../guid');

        generateHeaders = _.once(function() {
            return _(globalConfig.headers).defaults({
                'X-Su-ClientId': guid.get(),
                'X-Su-AccessTokenKey': utils.getAccessTokenKey()
            }).omit(function(value) {
                return _.isEmpty(value);
            }).value();
        });

        noretry = [5060, 5020, 5030, 19230, 2000];

        module.exports = function(options, callback) {
            var hasUndefined, key, sendData, xhr;
            options.url = (options.path || config.api.path) + options.url;
            hasUndefined = false;
            if (options != null ? options.data : void 0) {
                sendData = options.data;
                for (key in sendData) {
                    if (!__hasProp.call(sendData, key)) 
                        continue;
                    if (typeof sendData[key] === 'undefined') {
                        hasUndefined = true;
                        break;
                    }
                }
            }
            xhr = $.ajax(_.defaults(options, {
                data: {},
                dataType: 'json',
                error: function() {
                    if (typeof callback === 'function') {
                        return callback.apply(this, arguments);
                    }
                },
                success: function() {
                    if (typeof callback === 'function') {
                        return callback.apply(this, arguments);
                    }
                },
                type: 'GET',
                xhrFields: {
                    withCredentials: true
                },
                headers: generateHeaders(),
                shouldRetry: function(res, retryCount, requestMethod) {
                    var code, delay, dfd, retry, _ref, _ref1;
                    dfd = new $.Deferred;
                    if (utils.isSUBrowserAddonEnabled()) {
                        utils.disableSpa();
                    }
                    code = (res != null ? (_ref = res.responseJSON) != null ? _ref._code : void 0 : void 0) || null;
                    retry = hasUndefined !== true && retryCount <= 5 && !_(noretry).contains(code) && options.noretry !== true;
                    delay = utils.toMs(retryCount * 2 + 's');
                    if (retryCount >= 2 && code === 1010) {
                        utils.disableSpa();
                    }
                    if (retry) {
                        console.warn('api request failed, retrying', arguments);
                    } else {
                        console.error('api requests failed, but NOT retrying', arguments);
                    }
                    setTimeout((function(_this) {
                        return function() {
                            var r;
                            r = new XMLHttpRequest();
                            r.open('GET', '/p', true);
                            r.send();
                            return dfd.resolve(retry);
                        };
                    })(this), delay);
                    try {
                        analytics.trackEvent('apiRetry', retryCount);
                        if ((_ref1 = window.heap) != null) {
                            _ref1.identify('apiRetry', {
                                retryCount: retryCount
                            });
                        }
                    } catch (_error) {}
                    return dfd.promise();
                }
            }));
            return xhr;
        };


    }, {
        "../../config": 2,
        "../analytics": 39,
        "../guid": 41,
        "../utils": 69,
        "./config": 52,
        "jquery": 269,
        "lodash": 271,
        "simple-storage": 274
    }
    ],
    51: [function(require, module, exports) {
        var Comment, api;

        api = require('./api');

        module.exports = Comment = (function() {
            function Comment() {}

            Comment.add = function(data, callback) {
                var options;
                options = {
                    data: data || {},
                    type: 'POST',
                    url: '/comment'
                };
                return api(options, callback);
            };

            Comment["delete"] = function(data, callback) {
                var options;
                options = {
                    data: data || {},
                    type: 'DELETE',
                    url: '/comment/url'
                };
                return api(options, callback);
            };

            Comment.get = function(data, callback) {
                var options;
                options = {
                    data: data || {},
                    type: 'GET',
                    url: '/comment/url'
                };
                return api(options, callback);
            };

            return Comment;

        })();


    }, {
        "./api": 50
    }
    ],
    52: [function(require, module, exports) {
        var config, host, prefix, protocol, utils;

        config = require('../../config');

        utils = require('../utils');

        if (utils.isLocalDev()) {
            host = config.localDev.host;
            protocol = config.localDev.protocol;
        } else if (utils.isProd()) {
            host = config.host;
            protocol = config.protocol;
        } else if (utils.isRemoteDev()) {
            host = window.location.hostname;
            protocol = 'http:';
        } else {
            host = window.location.hostname;
            protocol = 'https:';
        }

        prefix = config.prefix;

        module.exports = {
            api: {
                path: protocol + '//' + host + config.prefix
            }
        };


    }, {
        "../../config": 2,
        "../utils": 69
    }
    ],
    53: [function(require, module, exports) {
        var Contact, api;

        api = require('./api');

        module.exports = Contact = (function() {
            function Contact() {}

            Contact.findByEmail = function(data, callback) {
                var options;
                options = {
                    data: data,
                    type: 'GET',
                    url: '/contact/find/email'
                };
                return api(options, callback);
            };

            Contact.get = function(data, callback) {
                var options;
                options = {
                    type: 'GET',
                    url: '/contact'
                };
                return api(options, callback);
            };

            Contact.invite = function(data, callback) {
                var options;
                options = {
                    data: data,
                    type: 'POST',
                    url: '/contact/invite'
                };
                return api(options, callback);
            };

            return Contact;

        })();


    }, {
        "./api": 50
    }
    ],
    54: [function(require, module, exports) {
        var Lists, api;

        api = require('./api');

        module.exports = Lists = (function() {
            function Lists() {}

            Lists.getGroupLikes = function(data, callback) {
                var options;
                options = {
                    data: data,
                    type: 'GET',
                    url: "/history/" + data.userid + "/likes/groups"
                };
                return api(options, callback);
            };

            Lists.getLikes = function(data, callback) {
                var options;
                options = {
                    data: data,
                    type: 'GET',
                    url: "/history/" + data.userid + "/likes"
                };
                return api(options, callback);
            };

            Lists.getRecentLikes = function(data, callback) {
                var options;
                options = {
                    data: data,
                    type: 'GET',
                    url: "/history/" + data.userid + "/likes/recent"
                };
                return api(options, callback);
            };

            Lists.getStumbles = function(data, callback) {
                var options;
                options = {
                    data: data,
                    type: 'GET',
                    url: "/history/" + data.userid + "/stumbles"
                };
                return api(options, callback);
            };

            return Lists;

        })();


    }, {
        "./api": 50
    }
    ],
    55: [function(require, module, exports) {
        var Image;

        module.exports = Image = {
            getBase64DataFromImage: function(img, callback) {
                var canvas, ctx, dataURL;
                canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                dataURL = canvas.toDataURL('image/png');
                return callback(dataURL);
            },
            getBase64DataFromImageUrl: function(url, callback) {
                var img;
                img = document.createElement('img');
                img.onload = function() {
                    return Image.getBase64DataFromImage(img, function(dataUrl) {
                        return callback(dataUrl);
                    });
                };
                return img.src = url;
            }
        };


    }, {}
    ],
    56: [function(require, module, exports) {
        var Misc;

        module.exports = Misc = {

            /*
              Returns a random integer between min and max
              Using Math.round() will give you a non-uniform distribution!
               */
            generateRandomInt: function(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            },
            generateRandomUserData: function() {
                var randStr, userData;
                randStr = Math.round(new Date().getTime() / 1000) + Misc.generateRandomInt(1, 100000);
                userData = {
                    username: 'user' + randStr,
                    password: 'fastman888',
                    email: "user" + randStr + "@testytest.com",
                    bmonth: Misc.generateRandomInt(1, 12).toString(),
                    bday: Misc.generateRandomInt(1, 28).toString(),
                    byear: Misc.generateRandomInt(1938, 1978).toString(),
                    gender: Misc.generateRandomInt(1, 2).toString(),
                    findfriends: Misc.generateRandomInt(0, 1).toString()
                };
                return userData;
            }
        };


    }, {}
    ],
    57: [function(require, module, exports) {
        var Lists, api;

        api = require('./api');

        module.exports = Lists = (function() {
            function Lists() {}

            Lists.addItem = function(data, callback) {
                var options;
                options = {
                    data: data,
                    type: 'POST',
                    url: "/list/" + data.listId + "/items"
                };
                return api(options, callback);
            };

            Lists.create = function(data, callback) {
                var options;
                options = {
                    data: data,
                    type: 'POST',
                    url: "/user/" + data.userid + "/lists"
                };
                return api(options, callback);
            };

            Lists["delete"] = function(data, callback) {
                var options;
                options = {
                    data: data,
                    type: 'DELETE',
                    url: "/list/" + data.id
                };
                return api(options, callback);
            };

            Lists.deleteItem = function(data, callback) {
                var options;
                options = {
                    data: data,
                    type: 'DELETE',
                    url: "/list/" + data.listId + "/items"
                };
                return api(options, callback);
            };

            Lists.get = function(data, callback) {
                var options;
                options = {
                    data: data,
                    type: 'GET',
                    url: "/user/" + data.id + "/lists"
                };
                return api(options, callback);
            };

            Lists.getItems = function(data, callback) {
                var options;
                options = {
                    data: data,
                    type: 'GET',
                    url: "/list/" + data.listId + "/items"
                };
                return api(options, callback);
            };

            Lists.update = function(data, callback) {
                var options;
                options = {
                    data: data,
                    type: 'PUT',
                    url: "/list/" + data.id
                };
                return api(options, callback);
            };

            return Lists;

        })();


    }, {
        "./api": 50
    }
    ],
    58: [function(require, module, exports) {
        var Mediator,
        __slice = [].slice;

        module.exports = Mediator = (function() {
            function Mediator() {
                this.channels = {};
            }

            Mediator.subscribe = function(name, callback) {
                if (this.channels[name] == null) {
                    this.channels[name] = [];
                }
                this.channels[name].push({
                    context: this,
                    callback: callback
                });
                return this;
            };

            Mediator.unsubscribe = function(name, callback) {
                var i, sub, _i, _len, _ref, _results;
                _ref = this.channels[name];
                _results = [];
                for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
                    sub = _ref[i];
                    if (sub.callback === callback) {
                        _results.push(this.channels[name].splice(i, 1));
                    } else {
                        _results.push(void 0);
                    }
                }
                return _results;
            };

            Mediator.publish = function() {
                var data, name, sub, _i, _len, _ref, _results;
                name = arguments[0], data = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
                _ref = this.channels[name];
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    sub = _ref[_i];
                    _results.push(sub.callback.apply(sub.context, data));
                }
                return _results;
            };

            return Mediator;

        })();


    }, {}
    ],
    59: [function(require, module, exports) {
        var Notifications, api;

        api = require('./api');

        module.exports = Notifications = (function() {
            function Notifications() {}

            Notifications.get = function(data, callback) {
                var options;
                options = {
                    data: data,
                    type: 'GET',
                    url: "/user/" + data.userid + "/notifications"
                };
                return api(options, callback);
            };

            return Notifications;

        })();


    }, {
        "./api": 50
    }
    ],
    60: [function(require, module, exports) {
        var Report, api;

        api = require('./api');

        module.exports = Report = (function() {
            function Report() {}

            Report.event = function(data, callback) {
                var options;
                options = {
                    data: data || {},
                    type: 'POST',
                    url: '/report/event'
                };
                return api(options, callback);
            };

            Report.timers = function(data, callback) {
                var options;
                options = {
                    data: data,
                    type: 'POST',
                    url: "/report/timers"
                };
                return api(options, callback);
            };

            Report.seen = function(data, callback) {
                var options;
                options = {
                    data: data,
                    type: 'POST',
                    url: "/report/seenurls"
                };
                return api(options, callback);
            };

            return Report;

        })();


    }, {
        "./api": 50
    }
    ],
    61: [function(require, module, exports) {
        var Share, api;

        api = require('./api');

        module.exports = Share = (function() {
            function Share() {}

            Share.url = function(data, callback) {
                var options;
                options = {
                    data: data || {},
                    type: 'POST',
                    url: '/message/send'
                };
                if ((data != null ? data.no_email : void 0) === true) {
                    options.no_email = true;
                }
                return api(options, callback);
            };

            Share.seen = function(data, callback) {
                var options;
                options = {
                    contentType: 'application/json',
                    data: '{"isRead":true}',
                    type: 'PUT',
                    url: "/shares/" + data.id
                };
                return api(options, callback);
            };

            Share.get = function(data, callback) {
                var options;
                options = {
                    data: data || {},
                    type: 'GET',
                    url: "/shares/" + data.id
                };
                return api(options, callback);
            };

            return Share;

        })();


    }, {
        "./api": 50
    }
    ],
    62: [function(require, module, exports) {
        var Stumble, api;

        api = require('./api');

        module.exports = Stumble = (function() {
            function Stumble() {}

            Stumble.activity = function(data, callback) {
                var options;
                options = {
                    data: data || {},
                    type: 'POST',
                    url: '/stumble/activity'
                };
                return api(options, callback);
            };

            Stumble.all = function(data, callback) {
                var options;
                options = {
                    data: data || {},
                    type: 'POST',
                    url: '/stumble/all'
                };
                return api(options, callback);
            };

            Stumble.app = function(data, callback) {
                var options;
                options = {
                    data: data || {},
                    type: 'POST',
                    url: '/stumble/app'
                };
                return api(options, callback);
            };

            Stumble.blockDomain = function(data, callback) {
                var options;
                options = {
                    type: 'POST',
                    url: "/domain/" + data.urlid + "/block"
                };
                return api(options, callback);
            };

            Stumble.domain = function(data, callback) {
                var options;
                options = {
                    data: data || {},
                    type: 'POST',
                    url: '/stumble/domain'
                };
                return api(options, callback);
            };

            Stumble.following = function(data, callback) {
                var options;
                options = {
                    data: data || {},
                    type: 'POST',
                    url: '/stumble/following'
                };
                return api(options, callback);
            };

            Stumble.interest = function(data, callback) {
                var options;
                options = {
                    data: data || {},
                    type: 'POST',
                    url: '/stumble/interest'
                };
                return api(options, callback);
            };

            Stumble.keyword = function(data, callback) {
                var options;
                options = {
                    data: data || {},
                    type: 'POST',
                    url: '/stumble/keyword'
                };
                return api(options, callback);
            };

            Stumble.list = function(data, callback) {
                var options;
                options = {
                    data: data || {},
                    type: 'POST',
                    url: '/stumble/list'
                };
                return api(options, callback);
            };

            Stumble.news = function(data, callback) {
                var options;
                options = {
                    data: data || {},
                    type: 'POST',
                    url: '/stumble/news'
                };
                return api(options, callback);
            };

            Stumble.photo = function(data, callback) {
                var options;
                data.interests = ["302"];
                options = {
                    data: data || {},
                    type: 'POST',
                    url: '/stumble/interest'
                };
                return api(options, callback);
            };

            Stumble.related = function(data, callback) {
                var options;
                options = {
                    data: data || {},
                    type: 'POST',
                    url: '/stumble/related_url'
                };
                return api(options, callback);
            };

            Stumble.setRating = function(data, callback) {
                var options;
                if (data.type === 0) {
                    return Stumble.unrate.apply(Stumble, arguments);
                } else {
                    options = {
                        type: 'POST',
                        url: "/discovery/rating",
                        data: data || {}
                    };
                    return api(options, callback);
                }
            };

            Stumble.trending = function(data, callback) {
                var options;
                options = {
                    data: data || {},
                    type: 'POST',
                    url: '/stumble/trending'
                };
                return api(options, callback);
            };

            Stumble.unblockDomain = function(data, callback) {
                var options;
                options = {
                    type: 'POST',
                    url: "/domain/" + data.urlid + "/unblock"
                };
                return api(options, callback);
            };

            Stumble.unrate = function(data, callback) {
                var options;
                options = {
                    type: 'DELETE',
                    url: "/discovery/" + data.urlid + "/rating"
                };
                return api(options, callback);
            };

            Stumble.urlid = function(data, callback) {
                var options;
                if (data == null) {
                    data = {};
                }
                options = {
                    data: data,
                    type: 'GET',
                    url: '/url'
                };
                return api(options, callback);
            };

            Stumble.user = function(data, callback) {
                var options;
                options = {
                    data: data || {},
                    type: 'POST',
                    url: '/stumble/user'
                };
                return api(options, callback);
            };

            Stumble.video = function(data, callback) {
                var options;
                options = {
                    data: data || {},
                    type: 'POST',
                    url: '/stumble/video'
                };
                return api(options, callback);
            };

            return Stumble;

        })();


    }, {
        "./api": 50
    }
    ],
    63: [function(require, module, exports) {
        var Url, api;

        api = require('./api');

        module.exports = Url = (function() {
            function Url() {}

            Url.getInfo = function(data, callback) {
                var options;
                options = {
                    data: data || {},
                    type: 'GET',
                    url: '/url'
                };
                return api(options, callback);
            };

            Url.getLikers = function(data, callback) {
                var options;
                options = {
                    data: data,
                    type: 'GET',
                    url: "/url/" + data.urlid + "/likers"
                };
                return api(options, callback);
            };

            Url.getThumb = function(data, callback) {
                var options;
                options = {
                    data: data,
                    type: 'GET',
                    url: "/url/thumb"
                };
                return api(options, callback);
            };

            Url.addThumb = function(data, callback) {
                var options;
                options = {
                    data: data,
                    type: 'POST',
                    url: "/url/thumb"
                };
                return api(options, callback);
            };

            Url.setInterests = function(data, callback) {
                var options;
                options = {
                    data: data || {},
                    type: 'POST',
                    url: '/url/interest'
                };
                return api(options, callback);
            };

            return Url;

        })();


    }, {
        "./api": 50
    }
    ],
    64: [function(require, module, exports) {
        var User, api, storage;

        api = require('./api');

        storage = require('simple-storage');

        module.exports = User = (function() {
            function User() {}

            User.prototype.create = function(data, callback) {
                var options;
                delete api.headers['X-Su-AccessTokenKey'];
                options = {
                    data: data || {},
                    type: 'POST',
                    url: '/signup'
                };
                return api(options, function(res) {
                    api.headers['X-Su-AccessTokenKey'] = res.credentials.key;
                    return callback(res);
                });
            };

            User.prototype.follow = function(userid, callback) {
                var options;
                options = {
                    type: 'POST',
                    url: "/connection/follow/" + userid
                };
                return api(options, callback);
            };

            User.prototype.followList = function(data, callback) {
                var options;
                options = {
                    data: data,
                    type: 'POST',
                    url: "/user/" + data.userid + "/lists/following"
                };
                return api(options, callback);
            };

            User.prototype.followers = function(data, callback) {
                var options;
                options = {
                    data: data || {},
                    type: 'GET',
                    url: "/connection/" + data.userid + "/followers"
                };
                return api(options, callback);
            };

            User.prototype.following = function(data, callback) {
                var options;
                options = {
                    data: data || {},
                    type: 'GET',
                    url: "/connection/" + data.userid + "/following"
                };
                return api(options, callback);
            };

            User.prototype.get = function(userid, callback) {
                var options;
                if (userid == null) {
                    userid = '';
                }
                options = {
                    type: 'GET',
                    url: "/user/" + userid
                };
                return api(options, callback);
            };

            User.prototype.getLists = function(data, callback) {
                var options;
                options = {
                    data: data,
                    type: 'GET',
                    url: "/user/" + data.userid + "/lists"
                };
                return api(options, callback);
            };

            User.prototype.getListsCreated = function(data, callback) {
                var options;
                options = {
                    data: data,
                    type: 'GET',
                    url: "/user/" + data.userid + "/lists/created"
                };
                return api(options, callback);
            };

            User.prototype.getListsFollowing = function(data, callback) {
                var options;
                options = {
                    data: data,
                    type: 'GET',
                    url: "/user/" + data.userid + "/lists/following"
                };
                return api(options, callback);
            };

            User.prototype.getInterests = function(data, callback) {
                var options;
                options = {
                    data: data || {},
                    type: 'GET',
                    url: "/user/" + data.userid + "/interests"
                };
                return api(options, callback);
            };

            User.prototype.login = function(data, callback) {
                var options;
                storage.set('key', null);
                options = {
                    data: data || {},
                    type: 'POST',
                    url: '/auth/login'
                };
                return api(options, function(res) {
                    var _ref;
                    if ((res != null ? (_ref = res.credentials) != null ? _ref.key : void 0 : void 0) != null) {
                        storage.set('key', res.credentials.key);
                    }
                    return callback(res);
                });
            };

            User.prototype.passwordResetRequest = function(data, callback) {
                var options;
                options = {
                    data: data || {},
                    type: 'POST',
                    url: '/auth/resetpassword'
                };
                return api(options, callback);
            };

            User.prototype.searchLists = function(data, callback) {
                var options;
                options = {
                    data: data,
                    type: 'GET',
                    url: "/user/" + data.userid + "/lists/search"
                };
                return api(options, callback);
            };

            User.prototype.setInterest = function(data, callback) {
                var options;
                options = {
                    data: data || {},
                    type: 'POST',
                    url: "/user/" + data.userid + "/interests"
                };
                return api(options, callback);
            };

            User.prototype.setPhoto = function(data, callback) {
                var options;
                options = {
                    data: data || {},
                    type: 'POST',
                    url: "/user/" + data.userid + "/photo"
                };
                return api(options, callback);
            };

            User.prototype.suggestUsername = function(data, callback) {
                var options;
                options = {
                    data: data || {},
                    type: 'POST',
                    url: '/signup/suggestusername'
                };
                return api(options, callback);
            };

            User.prototype.unfollow = function(userid, callback) {
                var options;
                options = {
                    type: 'POST',
                    url: "/connection/unfollow/" + userid
                };
                return api(options, callback);
            };

            User.prototype.unfollowList = function(data, callback) {
                var options;
                options = {
                    data: data,
                    type: 'DELETE',
                    url: "/user/" + data.userid + "/lists/following/" + data.listId
                };
                return api(options, callback);
            };

            User.prototype.validateEmail = function(data, callback) {
                var options;
                options = {
                    data: data || {},
                    type: 'POST',
                    url: '/signup/validateemail'
                };
                return api(options, callback);
            };

            User.prototype.validateUsername = function(data, callback) {
                var options;
                options = {
                    data: data || {},
                    type: 'POST',
                    url: '/signup/validateusername'
                };
                return api(options, callback);
            };

            return User;

        })();


    }, {
        "./api": 50,
        "simple-storage": 274
    }
    ],
    65: [function(require, module, exports) {
        module.exports = {
            track: function(action) {
                var mixEvent;
                mixEvent = {
                    'list-panelopen': 'Add to List Opened',
                    'list-addedtolist': 'List - Added to List',
                    'list-create': 'List - Created List',
                    'comment-panelopen': 'Comment Opened',
                    'facebook-panelopen': 'Facebook Opened',
                    'share-panelopen': 'Share Opened',
                    'share-send': 'Share Sent',
                    'share-cancel': 'Share Cancelled',
                    'modes-panelopen': 'Mode Selector Opened',
                    'modes-editinterests': 'Modes Panel - Edit Interests',
                    'thumbdown': 'Thumbdown Clicked',
                    'thumbdown-panelopen': 'Thumbdown Options Opened',
                    'maxApiErrors': 'Max Api Errors hit',
                    'notification-panelopen': 'Notification Opened',
                    'menu-panelopen': 'Menu Opened',
                    'menu-mylikes': 'Menu - My Likes',
                    'menu-mylists': 'Menu - My Lists',
                    'menu-myfriends': 'Menu - My Friends',
                    'menu-settings': 'Menu - Settings',
                    'menu-addpage': 'Menu - Add A Page',
                    'menu-addinterests': 'Menu - Add Interests',
                    'menu-help': 'Menu - Help',
                    'menu-signout': 'Menu - Signout',
                    'notification-share': 'Notification - Share Clicked',
                    'notification-messagelink': 'Notification - Messages Link Click',
                    'notification-shareslink': 'Notification - Shares Link Click'
                };
                if (mixEvent[action]) {
                    return mixpanel.track(mixEvent[action]);
                }
            }
        };


    }, {}
    ],
    66: [function(require, module, exports) {
        var StumbleUpon;

        StumbleUpon = require('./stumbleupon');

        module.exports = new StumbleUpon();


    }, {
        "./stumbleupon": 49
    }
    ],
    67: [function(require, module, exports) {
        var Chaplin, support, utils;

        Chaplin = require('chaplin');

        utils = require('./utils');

        support = utils.beget(Chaplin.support);

        module.exports = support;


    }, {
        "./utils": 69,
        "chaplin": 268
    }
    ],
    68: [function(require, module, exports) {
        var $, Tooltip, _;

        $ = require('jquery');

        _ = require('lodash');

        module.exports = Tooltip = (function() {
            Tooltip.prototype.dataSelector = '[data-tooltip]';

            function Tooltip(appendSelector) {
                this.appendSelector = appendSelector;
                $('body').on('mouseenter', this.dataSelector, (function(_this) {
                    return function(e) {
                        return _this.displayTooltip(e);
                    };
                })(this)).on('mouseleave click', this.dataSelector, (function(_this) {
                    return function(e) {
                        return _this.removeTooltip(e);
                    };
                })(this));
            }

            Tooltip.prototype.displayTooltip = function(e) {
                return _.defer((function(_this) {
                    return function() {
                        var $targetEl, leftPos, targetClass, tooltipText;
                        $targetEl = $(e.currentTarget);
                        targetClass = $targetEl.attr('class');
                        tooltipText = $targetEl.data('tooltip');
                        leftPos = $targetEl.position().left;
                        return _this.tipTimer = setTimeout(function() {
                            var $tooltipEl;
                            $tooltipEl = $("<div class='tooltip " + targetClass + "'><span class='fa fa-sort-asc fa-2x'></span>" + tooltipText + "</div>").css('left', leftPos + 'px');
                            return $(_this.appendSelector).append($tooltipEl);
                        }, 1000);
                    };
                })(this));
            };

            Tooltip.prototype.removeTooltip = function() {
                return _.defer((function(_this) {
                    return function() {
                        clearTimeout(_this.tipTimer);
                        return $(_this.appendSelector).find('.tooltip').remove();
                    };
                })(this));
            };

            return Tooltip;

        })();


    }, {
        "jquery": 269,
        "lodash": 271
    }
    ],
    69: [function(require, module, exports) {
        var $, Chaplin, SUdebug, config, mediator, root, utils, _;

        $ = require('jquery');

        _ = require('lodash');

        Chaplin = require('chaplin');

        mediator = require('chaplin').mediator;

        config = require('../config');

        root = require('../lib/root');

        SUdebug = require('../su-debug');

        utils = Chaplin.utils.beget(Chaplin.utils);

        utils.queryParams.parse = function(queryString) {
            var current, e, field, pair, pairs, params, value, _i, _len, _ref;
            params = {};
            if (!queryString) {
                return params;
            }
            queryString = queryString.slice(queryString.indexOf('?') + 1);
            pairs = queryString.split('&');
            for (_i = 0, _len = pairs.length; _i < _len; _i++) {
                pair = pairs[_i];
                if (!pair.length) {
                    continue;
                }
                _ref = pair.split('='), field = _ref[0], value = _ref[1];
                if (!field.length) {
                    continue;
                }
                try {
                    field = decodeURIComponent(field);
                    value = decodeURIComponent(value);
                } catch (_error) {
                    e = _error;
                    field = null;
                    value = null;
                }
                if (!!field) {
                    current = params[field];
                }
                if (current) {
                    if (current.push) {
                        current.push(value);
                    } else {
                        params[field] = [current, value];
                    }
                } else if (field) {
                    params[field] = value;
                }
            }
            return params;
        };

        _(utils).extend({
            getCurrentQueryParamValue: function(key) {
                var queryParams;
                queryParams = utils.queryParams.parse(window.location.search);
                return queryParams[key];
            },
            isAndroid: function() {
                var match;
                match = root().navigator.userAgent.match('Android');
                if (match != null) {
                    return true;
                } else {
                    return false;
                }
            },
            isiOS: function() {
                var match;
                match = root().navigator.userAgent.match('iPad|iPhone|iPod');
                if (match != null) {
                    return true;
                } else {
                    return false;
                }
            },
            isIpad: function() {
                var match;
                match = root().navigator.userAgent.match('iPad');
                if (match != null) {
                    return true;
                } else {
                    return false;
                }
            },
            isMobile: function() {
                return this.isiOS() || this.isAndroid();
            },
            isOldSafari: function() {
                var _ref;
                return window.navigator.userAgent.match('Version/5') && ((_ref = window.navigator.vendor) != null ? _ref.match('Apple') : void 0);
            },
            isEmail: function(str) {
                var pattern;
                pattern = new RegExp('[_a-z0-9-]+(\.[_a-z0-9-]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,4})', 'i');
                return pattern.test(str);
            },
            isLoggedIn: function() {
                var _ref;
                return (_ref = mediator.userM) != null ? _ref.has('userid') : void 0;
            },
            isVisitor: function() {
                if (!$.cookie('su_accesstoken')) {
                    return true;
                }
            },
            scrollToTop: function() {
                if (document.body.scrollTop > 0) {
                    return root().scrollTo(0, 0);
                }
            },
            isImage: function(str) {
                var ext, imgExts;
                imgExts = ['jpg', 'jpeg', 'png', 'gif', 'bmp'];
                ext = this.removeParams(str).split('.').pop();
                ext = ext.toLowerCase();
                return _(imgExts).contains(ext);
            },
            isToolbarEnabled: function() {
                if (root().location.href.match('_notoolbar')) {
                    return false;
                } else {
                    return true;
                }
            },
            gotoUrl: function(url) {
                return root().location.assign(url);
            },
            stripProtocol: function(url) {
                return url.split('http://').pop().split('https://').pop();
            },
            getDomain: function(url) {
                var match;
                if (typeof url !== 'string') {
                    throw new TypeError('Must pass a string');
                }
                match = url.match(/\/([^\/]+)\/?/)[1].split("www.");
                if (match) {
                    return _(match).last();
                }
            },
            getSoundcloudPath: function(url) {
                var parts, path;
                if (url.match('soundcloud.com')) {
                    parts = url.split('soundcloud.com');
                    if (parts.length > 0) {
                        path = parts[1];
                    }
                    return path = encodeURIComponent(path);
                }
            },
            getYoutubeId: function(url) {
                var match;
                if (url.match('youtube.com/')) {
                    match = url.match(/^.*(youtu.be\/|v\/|e\/|u\/\w+\/|embed\/|v=)([^#\&\?]*).*/);
                    if ((match != null ? match.length : void 0) === 3) {
                        return match[2];
                    }
                }
            },
            getMetacafeId: function(url) {
                if (url.match('metacafe.com/watch/')) {
                    return url.split('/watch/').pop().split('/').shift().split('?').shift();
                }
            },
            getPinterestId: function(url) {
                if (url.match('pinterest.com/pin/')) {
                    return url.split('pin/').pop().split('/').shift().split('?').shift();
                }
            },
            getFacebookPost: function(url) {
                if (url.match('facebook.com/')) {
                    return url;
                }
            },
            getVineId: function(url) {
                if (url.match('vine.co/v/')) {
                    return url.split('/v/').pop().split('/').shift();
                }
            },
            getPinterestBoardId: function(url) {
                if (url.match('pinterest.com') && !this.getPinterestId(url)) {
                    return url.split('pinterest.com/').pop();
                }
            },
            getDailymotionId: function(url) {
                if (url.match('dailymotion.com/video/')) {
                    return url.split('/video/').pop().split('_').shift();
                }
            },
            getVimeoId: function(url) {
                if (url.match('vimeo.com/')) {
                    return url.split('vimeo.com/').pop().split('/').shift().split('?').shift();
                }
            },
            getTweetId: function(url) {
                if (url.match('twitter.com/')) {
                    return url.split('/status/').pop().split('/').shift();
                }
            },
            getFlickrUsername: function(url) {
                var details;
                details = this.getFlickrDetails(url);
                if (details) {
                    return details.username;
                }
            },
            getFlickrId: function(url) {
                var details;
                details = this.getFlickrDetails(url);
                if (details) {
                    return details.photoid;
                }
            },
            getFlickrDetails: function(url) {
                var flickr;
                if (url.indexOf('flickr.com/photos/') !== - 1) {
                    flickr = url.match('flickr.com/photos/([a-zA-Z0-9@]*)/([0-9]*)');
                    if ((flickr != null ? flickr.length : void 0) === 3 && !!flickr[1] && !!flickr[2]) {
                        return {
                            username: flickr[1],
                            photoid: flickr[2]
                        };
                    }
                }
            },
            getInstagramId: function(url) {
                var insta;
                if (url.indexOf('instagram.com/p/') !== - 1) {
                    insta = url.match('instagram.com/p/([a-zA-Z0-9_@]*)');
                    return insta[1];
                }
            },
            getTedTalkId: function(url) {
                var ted;
                if (url.indexOf('www.ted.com/talks/') !== - 1) {
                    ted = url.match('www.ted.com/talks/([a-zA-Z0-9_@]*)');
                    return ted[1];
                }
            },
            appendParams: function(url, params) {
                var prefix;
                prefix = url.match('\\?') ? '&' : '?';
                return url + prefix + $.param(params);
            },
            removeParams: function(url) {
                return url.split('?').shift();
            },
            isLocalDev: function() {
                if (this.isRemoteDev() || this.isProd()) {
                    return false;
                } else {
                    return true;
                }
            },
            isRemoteDev: function() {
                if (root().location.hostname.match('stumble.net')) {
                    return true;
                } else {
                    return false;
                }
            },
            isDev: function() {
                return this.isLocalDev() || this.isRemoteDev();
            },
            isProd: function() {
                var hostname;
                hostname = root().location.hostname;
                if (hostname.slice( - 16) === '.stumbleupon.com' || hostname === 'stumbleupon.com') {
                    return true;
                } else {
                    return false;
                }
            },
            getMedian: function(values) {
                var half;
                values.sort(function(a, b) {
                    return a - b;
                });
                half = Math.floor(values.length / 2);
                if (values.length % 2) {
                    return values[half];
                } else {
                    return (values[half - 1] + values[half]) / 2.0;
                }
            },
            getStumbleUrl: function() {
                var host, protocol;
                if (this.isLocalDev()) {
                    host = config.localDev.host;
                    protocol = 'http:';
                } else {
                    host = root().location.hostname;
                    protocol = root().location.protocol;
                }
                return protocol + '//' + host;
            },
            isOutOfStumbles: function(res, options) {
                var _ref, _ref1, _ref2;
                if (options == null) {
                    options = {};
                }
                if (((_ref = options.guess_urlids) != null ? _ref.length : void 0) && options.guess_only === 1 && options.guesses === 0) {
                    return false;
                } else {
                    return !((!_.has(res, "url") && !_.has(res, "guesses")) || ((_.has(res, "url") || _.has(res, "guesses")) && (((res != null ? res.url : void 0) != null) || (res != null ? (_ref1 = res.guesses) != null ? (_ref2 = _ref1.values) != null ? _ref2.length : void 0 : void 0 : void 0))));
                }
            },
            toMs: function(str) {
                var duration, hasUnit, unit;
                unit = typeof str.slice === "function" ? str.slice( - 1) : void 0;
                duration = typeof str.slice === "function" ? str.slice(0, - 1) : void 0;
                hasUnit = isNaN(parseInt(unit));
                if (typeof str === 'number' || !hasUnit) {
                    return str;
                } else if (str.slice( - 2) === 'ms') {
                    return parseInt(str.slice(0, - 2));
                } else {
                    switch (unit) {
                    case 's':
                        return duration * 1000;
                    case 'm':
                        return duration * 60000;
                    case 'h':
                        return duration * 3600000;
                    case 'd':
                        return duration * 86400000;
                    case 'w':
                        return duration * 604800000;
                    default:
                        throw Error('Unknown unit ' + unit);
                    }
                }
            },
            whenTruthy: function(key, obj, timeout, frequency) {
                var checking, dfd, giveUp;
                if (obj == null) {
                    obj = mediator;
                }
                if (timeout == null) {
                    timeout = '1m';
                }
                if (frequency == null) {
                    frequency = '100ms';
                }
                dfd = new $.Deferred;
                if (obj[key]) {
                    dfd.resolve(obj[key]);
                } else {
                    giveUp = setTimeout(function() {
                        clearInterval(checking);
                        return dfd.reject(obj[key]);
                    }, this.toMs(timeout));
                    checking = setInterval(function() {
                        if (obj[key]) {
                            clearInterval(giveUp);
                            clearInterval(checking);
                            return dfd.resolve(obj[key]);
                        }
                    }, this.toMs(frequency));
                }
                return dfd.promise();
            },
            unix: function() {
                return Math.floor(_.now() / 1000);
            },
            getAccessTokenKey: function() {
                return $.cookie('su_accesstoken');
            },
            isSUBrowserAddonEnabled: function() {
                return window.suExtensionApi != null;
            },
            disableSpa: function() {
                debugger;
                var date, minutes;
                mixpanel.track('SPA disabled', {
                    branch: SUdebug.branch
                });
                if (!$.cookie('_nospa')) {
                    date = new Date();
                    minutes = 10;
                    date.setTime(date.setMinutes(date.getMinutes() + minutes));
                    $.cookie('_nospa', true, {
                        expires: date
                    });
                    $.removeCookie('su_accesstoken');
                    return window.location.reload(true);
                }
            },
            getNoSpaUrl: function() {
                debugger;
                if (!window.location.href.match('_nospa')) {
                    return this.appendParams(window.location.href, {
                        '_nospa': true
                    });
                }
            },
            getNoToolbarUrl: function() {
                debugger;
                var href;
                href = window.location.href;
                if (!(href.match('_notoolbar') && href.match('_nospa'))) {
                    return this.appendParams(href, {
                        '_notoolbar': true,
                        '_nospa': true
                    });
                }
            },
            gotoNoToolbarUrl: function() {
                if (!(window.location.href.match('_notoolbar') && window.location.href.match('_nospa'))) {
                    return window.location.replace(this.getNoToolbarUrl());
                }
            },
            canDisplayMobilePopup: function() {
                return this.isMobile() && !$.cookie('mobile-popup');
            },
            replaceState: function(path) {
                if (path[0] !== '/') {
                    path = "/" + path;
                }
                return root().history.replaceState({
                    path: path
                }, null, path);
            },
            logLevels: {
                EMERGENCY: 0,
                ALERT: 1,
                CRITICAL: 2,
                ERROR: 3,
                WARNING: 4,
                NOTICE: 5,
                INFORMATIONAL: 6,
                DEBUG: 7,
                TRACE: 8
            },
            consoleLog: function(logLevel, logs) {
                if (config.logLevel >= logLevel) {
                    if (logLevel <= this.logLevels.ERROR) {
                        return typeof console !== "undefined" && console !== null ? console.error.apply(console, logs) : void 0;
                    } else if (logLevel === this.logLevels.WARNING) {
                        return typeof console !== "undefined" && console !== null ? console.warn.apply(console, logs) : void 0;
                    } else if (logLevel === this.logLevels.INFORMATIONAL) {
                        return typeof console !== "undefined" && console !== null ? console.info.apply(console, logs) : void 0;
                    } else if (logLevel === this.logLevels.NOTICE) {
                        return typeof console !== "undefined" && console !== null ? console.log.apply(console, logs) : void 0;
                    } else if (logLevel === this.logLevels.DEBUG) {
                        return typeof console !== "undefined" && console !== null ? console.debug.apply(console, logs) : void 0;
                    } else if (logLevel === this.logLevels.TRACE) {
                        return typeof console !== "undefined" && console !== null ? console.trace.apply(console, logs) : void 0;
                    }
                }
            },
            log: function(logLevel, logs) {
                return this.consoleLog(logLevel, [].slice.call(arguments, 1));
            }
        });

        module.exports = utils;


    }, {
        "../config": 2,
        "../lib/root": 47,
        "../su-debug": 101,
        "chaplin": 268,
        "jquery": 269,
        "lodash": 271
    }
    ],
    70: [function(require, module, exports) {
        var Chaplin, Handlebars, i18n, mediator, moment, root, storage, stumble, utils, _;

        Chaplin = require('chaplin');

        mediator = require('chaplin').mediator;

        i18n = require('./i18n');

        root = require('./root');

        stumble = require('./stumble');

        utils = require('./utils');

        Handlebars = require('hbsfy/runtime');

        moment = require('moment');

        storage = require('simple-storage');

        _ = require('lodash');

        Handlebars.registerHelper('with', function(context, options) {
            if (!context || Handlebars.Utils.isEmpty(context)) {
                return options.inverse(this);
            } else {
                return options.fn(context);
            }
        });

        Handlebars.registerHelper('without', function(context, options) {
            var inverse;
            inverse = options.inverse;
            options.inverse = options.fn;
            options.fn = inverse;
            return Handlebars.helpers["with"].call(this, context, options);
        });

        Handlebars.registerHelper('currentMode', function(prop) {
            var _ref;
            return ((_ref = mediator.modesC.getActive()) != null ? _ref.get(prop) : void 0) || storage.get('activeMode') || 'All Interests';
        });

        Handlebars.registerHelper('currentUrl', function(prop) {
            var _ref;
            return (_ref = stumble.getCollection().getActive()) != null ? _ref.get(prop) : void 0;
        });

        Handlebars.registerHelper('currentUser', function(prop) {
            return mediator.userM.get(prop);
        });

        Handlebars.registerHelper('notificationTotals', function(prop) {
            return mediator.notificationM.get(prop);
        });

        Handlebars.registerHelper('formatTimestamp', function(timestamp) {
            return moment.unix(timestamp).format('MMM Do, YYYY');
        });

        Handlebars.registerHelper('pathName', function() {
            return root().location.pathname;
        });

        Handlebars.registerHelper('i18n', function(phrase) {
            return i18n(phrase);
        });

        Handlebars.registerHelper('titleize', function(str) {
            return _(str).chain().humanize().titleize().value();
        });

        Handlebars.registerHelper('utmSource', function(url) {
            if (url.match('utm_source')) {
                return url;
            } else {
                return utils.appendParams(url, {
                    'utm_source': 'stumbleupon'
                });
            }
        });

        Handlebars.registerHelper("ifCond", function(v1, v2, options) {
            if (v1 === v2) {
                return options.fn(this);
            }
            return options.inverse(this);
        });


        /*
         * Get Chaplin-declared named routes. {{#url "like" "105"}}{{/url}}
        Handlebars.registerHelper 'url', (routeName, params..., options) ->
          Chaplin.utils.reverse routeName, params
         */


    }, {
        "./i18n": 42,
        "./root": 47,
        "./stumble": 48,
        "./utils": 69,
        "chaplin": 268,
        "hbsfy/runtime": 285,
        "lodash": 271,
        "moment": 273,
        "simple-storage": 274
    }
    ],
    71: [function(require, module, exports) {
        var mediator, publish;

        mediator = require('chaplin').mediator;

        publish = function(args, state) {
            var applyArgs;
            applyArgs = ["webfont:" + state].concat(Array.prototype.slice.call(args, 0));
            return mediator.publish.apply(mediator, applyArgs);
        };

        window.WebFontConfig = {
            google: {
                families: ["Oswald::latin", "Lato"]
            },
            loading: function() {
                return publish(arguments, 'loading');
            },
            active: function() {
                window._typekitLoaded = {
                    state: "loaded"
                };
                return publish(arguments, 'active');
            },
            inactive: function() {
                return publish(arguments, 'inactive');
            },
            fontloading: function() {
                return publish(arguments, 'fontloading');
            },
            fontactive: function() {
                return publish(arguments, 'fontactive');
            },
            fontinactive: function() {
                return publish(arguments, 'fontinactive');
            }
        };

        module.exports = {
            loadAll: function() {
                var s, wf;
                wf = document.createElement("script");
                wf.src = "//ajax.googleapis.com/ajax/libs/webfont/1/webfont.js";
                wf.type = "text/javascript";
                wf.async = "true";
                s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(wf, s);
                return null;
            }
        };


    }, {
        "chaplin": 268
    }
    ],
    72: [function(require, module, exports) {
        var AlertModel, Model, request,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Model = require('./base/model');

        request = require('../lib/request');

        module.exports = AlertModel = (function(_super) {
            __extends(AlertModel, _super);

            function AlertModel() {
                return AlertModel.__super__.constructor.apply(this, arguments);
            }

            AlertModel.prototype.defaults = {
                text: 'The selected action could not be completed due to a network error. Please try again.',
                type: 'error',
                delay: true
            };

            return AlertModel;

        })(Model);


    }, {
        "../lib/request": 46,
        "./base/model": 74
    }
    ],
    73: [function(require, module, exports) {
        var AnnounceEvents, Chaplin, Collection, Mixin, Model, StopTimers, WhenPopulated, mediator,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Mixin = require('mixen');

        Chaplin = require('chaplin');

        Model = require('./model');

        mediator = require('chaplin').mediator;

        WhenPopulated = require('../mixins/when-populated');

        StopTimers = require('../../lib/mixins/stop-timers');

        AnnounceEvents = require('../../lib/mixins/announce-events');

        module.exports = Collection = (function(_super) {
            __extends(Collection, _super);

            function Collection() {
                return Collection.__super__.constructor.apply(this, arguments);
            }

            Collection.prototype.model = Model;

            Collection.prototype.set = function() {
                if (!this.disposed) {
                    return Collection.__super__.set.apply(this, arguments);
                }
            };

            return Collection;

        })(Mixin(AnnounceEvents, StopTimers, WhenPopulated, Chaplin.Collection));


    }, {
        "../../lib/mixins/announce-events": 44,
        "../../lib/mixins/stop-timers": 45,
        "../mixins/when-populated": 86,
        "./model": 74,
        "chaplin": 268,
        "mixen": 272
    }
    ],
    74: [function(require, module, exports) {
        var AnnounceEvents, Chaplin, Mixin, Model, StopTimers, WhenPopulated,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Mixin = require('mixen');

        Chaplin = require('chaplin');

        WhenPopulated = require('../mixins/when-populated');

        StopTimers = require('../../lib/mixins/stop-timers');

        AnnounceEvents = require('../../lib/mixins/announce-events');

        module.exports = Model = (function(_super) {
            __extends(Model, _super);

            function Model() {
                return Model.__super__.constructor.apply(this, arguments);
            }

            Model.prototype.set = function() {
                if (!this.disposed) {
                    return Model.__super__.set.apply(this, arguments);
                }
            };

            return Model;

        })(Mixin(AnnounceEvents, StopTimers, WhenPopulated, Chaplin.Model));


    }, {
        "../../lib/mixins/announce-events": 44,
        "../../lib/mixins/stop-timers": 45,
        "../mixins/when-populated": 86,
        "chaplin": 268,
        "mixen": 272
    }
    ],
    75: [function(require, module, exports) {
        var CommentModel, Model, SU, request,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Model = require('./base/model');

        SU = require('../lib/su');

        request = require('../lib/request');

        module.exports = CommentModel = (function(_super) {
            __extends(CommentModel, _super);

            function CommentModel() {
                return CommentModel.__super__.constructor.apply(this, arguments);
            }

            CommentModel.prototype.sync = function(method, model, options) {
                if (options == null) {
                    options = {};
                }
                if (options.data == null) {
                    options.data = model.toJSON();
                }
                switch (method) {
                case 'create':
                    return request(SU.Comment.add, [method, model, options]);
                default:
                    throw new Error(method + ' unsupported');
                }
            };

            return CommentModel;

        })(Model);


    }, {
        "../lib/request": 46,
        "../lib/su": 66,
        "./base/model": 74
    }
    ],
    76: [function(require, module, exports) {
        var Collection, CommentM, CommentsCollection, SU, request,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Collection = require('./base/collection');

        CommentM = require('./comment-model');

        SU = require('../lib/su');

        request = require('../lib/request');

        module.exports = CommentsCollection = (function(_super) {
            __extends(CommentsCollection, _super);

            function CommentsCollection() {
                return CommentsCollection.__super__.constructor.apply(this, arguments);
            }

            CommentsCollection.prototype.model = CommentM;

            CommentsCollection.prototype.initialize = function() {
                CommentsCollection.__super__.initialize.apply(this, arguments);
                return this.on('add', function(model, collection, options) {
                    if (options == null) {
                        options = {};
                    }
                    if (options.data == null) {
                        return model.save().then((function(_this) {
                            return function() {
                                return _this.publishEvent('panel:open', {
                                    name: 'alert',
                                    type: 'success',
                                    text: 'Your comment and tags have been updated.'
                                });
                            };
                        })(this), (function(_this) {
                            return function() {
                                return _this.publishEvent('panel:open', {
                                    name: 'alert',
                                    type: 'error'
                                });
                            };
                        })(this));
                    }
                });
            };

            CommentsCollection.prototype.comparator = function(model) {
                return - model.get('timestamp');
            };

            CommentsCollection.prototype.sync = function(method, model, options) {
                switch (method) {
                case 'read':
                    return request(SU.Comment.get, arguments);
                default:
                    throw new Error(method + ' unsupported');
                }
            };

            CommentsCollection.prototype.parse = function(res) {
                var _ref;
                return (_ref = res.comments) != null ? _ref.values : void 0;
            };

            return CommentsCollection;

        })(Collection);


    }, {
        "../lib/request": 46,
        "../lib/su": 66,
        "./base/collection": 73,
        "./comment-model": 75
    }
    ],
    77: [function(require, module, exports) {
        var ContactModel, Mixin, Model, SetUserThumbnail,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Model = require('./base/model');

        Mixin = require('mixen');

        SetUserThumbnail = require('./mixins/set-user-thumbnail');

        module.exports = ContactModel = (function(_super) {
            __extends(ContactModel, _super);

            function ContactModel() {
                return ContactModel.__super__.constructor.apply(this, arguments);
            }

            ContactModel.prototype.sync = function(method, model, options) {
                switch (method) {
                case 'create':
                    return request(SU.Share.url, arguments);
                default:
                    throw new Error(method + ' unsupported');
                }
            };

            return ContactModel;

        })(Mixin(SetUserThumbnail, Model));


    }, {
        "./base/model": 74,
        "./mixins/set-user-thumbnail": 85,
        "mixen": 272
    }
    ],
    78: [function(require, module, exports) {
        var Collection, ContactM, ContactsCollection, SU, mediator, request,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Collection = require('./base/collection');

        SU = require('../lib/su');

        ContactM = require('./contact-model');

        request = require('../lib/request');

        mediator = require('chaplin').mediator;

        module.exports = ContactsCollection = (function(_super) {
            __extends(ContactsCollection, _super);

            function ContactsCollection() {
                return ContactsCollection.__super__.constructor.apply(this, arguments);
            }

            ContactsCollection.prototype.model = ContactM;

            ContactsCollection.prototype.getMostShared = function(count) {
                return new ContactsCollection(this.toJSON().sort(function(a, b) {
                    return b.share_frequency - a.share_frequency;
                }).filter(function(data) {
                    return data.share_frequency > 0;
                }).slice(0, count));
            };

            ContactsCollection.prototype.sync = function(method, model, options) {
                if (options.data == null) {
                    options.data = {
                        userid: mediator.userM.get('userid')
                    };
                }
                switch (method) {
                case 'read':
                    return request(SU.Contact.get, arguments);
                default:
                    throw new Error(method + ' unsupported');
                }
            };

            ContactsCollection.prototype.parse = function(res) {
                var _ref;
                return (_ref = res.contacts) != null ? _ref.values : void 0;
            };

            return ContactsCollection;

        })(Collection);


    }, {
        "../lib/request": 46,
        "../lib/su": 66,
        "./base/collection": 73,
        "./contact-model": 77,
        "chaplin": 268
    }
    ],
    79: [function(require, module, exports) {
        var Collection, FollowersCollection, SU, mediator, request,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Collection = require('./base/collection');

        SU = require('../lib/su');

        request = require('../lib/request');

        mediator = require('chaplin').mediator;

        module.exports = FollowersCollection = (function(_super) {
            __extends(FollowersCollection, _super);

            function FollowersCollection() {
                return FollowersCollection.__super__.constructor.apply(this, arguments);
            }

            FollowersCollection.prototype.initialize = function() {
                FollowersCollection.__super__.initialize.apply(this, arguments);
                return this.user = new SU.User;
            };

            FollowersCollection.prototype.sync = function(method, model, options) {
                if (options.data == null) {
                    options.data = {
                        userid: mediator.userM.get('userid'),
                        limit: 500
                    };
                }
                switch (method) {
                case 'read':
                    return request(this.user.followers, arguments);
                default:
                    throw new Error(method + ' unsupported');
                }
            };

            FollowersCollection.prototype.parse = function(res) {
                var _ref;
                return (_ref = res.followers) != null ? _ref.values : void 0;
            };

            return FollowersCollection;

        })(Collection);


    }, {
        "../lib/request": 46,
        "../lib/su": 66,
        "./base/collection": 73,
        "chaplin": 268
    }
    ],
    80: [function(require, module, exports) {
        var Collection, FollowingCollection, SU, mediator, request,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Collection = require('./base/collection');

        SU = require('../lib/su');

        request = require('../lib/request');

        mediator = require('chaplin').mediator;

        module.exports = FollowingCollection = (function(_super) {
            __extends(FollowingCollection, _super);

            function FollowingCollection() {
                return FollowingCollection.__super__.constructor.apply(this, arguments);
            }

            FollowingCollection.prototype.initialize = function() {
                FollowingCollection.__super__.initialize.apply(this, arguments);
                return this.user = new SU.User;
            };

            FollowingCollection.prototype.sync = function(method, model, options) {
                if (options.data == null) {
                    options.data = {
                        userid: mediator.userM.get('userid'),
                        limit: 500
                    };
                }
                switch (method) {
                case 'read':
                    return request(this.user.following, arguments);
                default:
                    throw new Error(method + ' unsupported');
                }
            };

            FollowingCollection.prototype.parse = function(res) {
                var _ref;
                return (_ref = res.following) != null ? _ref.values : void 0;
            };

            return FollowingCollection;

        })(Collection);


    }, {
        "../lib/request": 46,
        "../lib/su": 66,
        "./base/collection": 73,
        "chaplin": 268
    }
    ],
    81: [function(require, module, exports) {
        var ListItemCollection, SU, StumbleM, StumblesC, mediator, request, stumble,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        StumblesC = require('./stumbles-collection');

        StumbleM = require('./stumble-model');

        SU = require('../lib/su');

        mediator = require('chaplin').mediator;

        request = require('../lib/request');

        stumble = require('../lib/stumble');

        module.exports = ListItemCollection = (function(_super) {
            __extends(ListItemCollection, _super);

            function ListItemCollection() {
                return ListItemCollection.__super__.constructor.apply(this, arguments);
            }

            ListItemCollection.prototype.model = StumbleM;

            ListItemCollection.prototype.listPosition = null;

            ListItemCollection.prototype.initialize = function() {
                ListItemCollection.__super__.initialize.apply(this, arguments);
                return this.subscribeEvent('mode:activechanged', (function(_this) {
                    return function() {
                        return _this.reset();
                    };
                })(this));
            };

            ListItemCollection.prototype.addCurrentStumble = function() {
                var currentStumble, currentStumbleUrlid, existingM;
                currentStumble = stumble.getCollection().getActive();
                currentStumbleUrlid = currentStumble.get('urlid');
                existingM = this.findWhere({
                    'urlid': currentStumbleUrlid
                });
                if (currentStumble.get('_legacy')) {
                    return this.publishEvent('list:itemadded:error', {}, true);
                } else if (existingM != null) {
                    return this.publishEvent('list:itemadded:error');
                } else {
                    return this.add({
                        'urlid': currentStumbleUrlid
                    });
                }
            };

            ListItemCollection.prototype.fillBuffer = function() {
                return null;
            };

            ListItemCollection.prototype.getNext = function() {
                return this.fetch({
                    fresh: true,
                    merge: true
                }).then((function(_this) {
                    return function(res) {
                        var _ref, _ref1;
                        _this.listPosition = res != null ? (_ref = res.url) != null ? _ref.list_position : void 0 : void 0;
                        return _this.get(res != null ? (_ref1 = res.url) != null ? _ref1.urlid : void 0 : void 0);
                    };
                })(this));
            };

            ListItemCollection.prototype.getListPosition = function() {
                return parseInt(this.listPosition);
            };

            ListItemCollection.prototype.getDefaultOptions = function() {
                var currentMode;
                currentMode = mediator.modesC.getActive();
                return {
                    data: {
                        guesses: 0,
                        listId: currentMode != null ? currentMode.get('listId') : void 0,
                        listPosition: this.getListPosition() + 1 || 0
                    }
                };
            };

            ListItemCollection.prototype.whereSeen = function() {
                return this.filter(function(model) {
                    var currentMode;
                    currentMode = mediator.modesC.getActive();
                    return model.get('_seen') && (currentMode != null ? currentMode.get('listId') : void 0) === model.get('_listId');
                });
            };

            ListItemCollection.prototype.whereUnseen = function() {
                return this.reject(function(model) {
                    return model.get('_seen');
                });
            };

            ListItemCollection.prototype.sync = function(method, model, options) {
                if (options == null) {
                    options = {};
                }
                switch (method) {
                case 'read':
                    return request(SU.Stumble.list, arguments);
                default:
                    throw new Error(method + ' unsupported');
                }
            };

            return ListItemCollection;

        })(StumblesC);


    }, {
        "../lib/request": 46,
        "../lib/stumble": 48,
        "../lib/su": 66,
        "./stumble-model": 93,
        "./stumbles-collection": 94,
        "chaplin": 268
    }
    ],
    82: [function(require, module, exports) {
        var ListItemsC, ListModel, Model, SU, mediator, request,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Model = require('./base/model');

        SU = require('../lib/su');

        request = require('../lib/request');

        ListItemsC = require('./list-items-collection');

        mediator = require('chaplin').mediator;

        module.exports = ListModel = (function(_super) {
            __extends(ListModel, _super);

            function ListModel() {
                return ListModel.__super__.constructor.apply(this, arguments);
            }

            ListModel.prototype.defaults = {
                'name': 'New List',
                'visibility': 'public',
                '_visible': true
            };

            ListModel.prototype.initialize = function() {
                ListModel.__super__.initialize.apply(this, arguments);
                this.set('listItemsC', new ListItemsC());
                this.on('sync', (function(_this) {
                    return function(model, resp) {
                        var _ref;
                        if (!_this.has('id')) {
                            return _this.set('id', (_ref = resp.list) != null ? _ref.id : void 0);
                        }
                    };
                })(this));
                this.get('listItemsC').on('add', (function(_this) {
                    return function() {
                        return _this.save().then(function() {
                            _this.publishEvent('list:loading:end');
                            return _this.publishEvent('list:itemadded', _this);
                        }, function() {
                            _this.publishEvent('list:loading:end');
                            return _this.publishEvent('list:itemadded:error', _this);
                        });
                    };
                })(this));
                return this.on('change:id', (function(_this) {
                    return function() {
                        return _this.publishEvent('list:added', _this);
                    };
                })(this));
            };

            ListModel.prototype.sync = function(method, model, options) {
                var listItemsC;
                if (options == null) {
                    options = {};
                }
                this.publishEvent('model:sync:start', this);
                listItemsC = model.get('listItemsC');
                if (listItemsC.length > 0) {
                    method = 'update';
                    options.data = {
                        listId: this.get('id'),
                        urlid: listItemsC.last().get('urlid')
                    };
                }
                if (method === 'create') {
                    options.data = model.toJSON();
                    delete options.data.listItemsC;
                }
                switch (method) {
                case 'create':
                    return request(SU.Lists.create, arguments);
                case 'update':
                    return request(SU.Lists.addItem, arguments);
                default:
                    throw new Error(method + ' unsupported');
                }
            };

            return ListModel;

        })(Model);


    }, {
        "../lib/request": 46,
        "../lib/su": 66,
        "./base/model": 74,
        "./list-items-collection": 81,
        "chaplin": 268
    }
    ],
    83: [function(require, module, exports) {
        var Collection, ListM, ListsCollection, SU, mediator, request,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Collection = require('./base/collection');

        SU = require('../lib/su');

        ListM = require('./list-model');

        request = require('../lib/request');

        mediator = require('chaplin').mediator;

        module.exports = ListsCollection = (function(_super) {
            __extends(ListsCollection, _super);

            function ListsCollection() {
                return ListsCollection.__super__.constructor.apply(this, arguments);
            }

            ListsCollection.prototype.model = ListM;

            ListsCollection.prototype.sync = function(method, model, options) {
                if (options == null) {
                    options = {};
                }
                if (options.data == null) {
                    options.data = {
                        id: mediator.userM.get('userid')
                    };
                }
                switch (method) {
                case 'read':
                    return request(SU.Lists.get, arguments);
                default:
                    throw new Error(method + ' unsupported');
                }
            };

            ListsCollection.prototype.parse = function(res) {
                var _ref;
                return (_ref = res.lists) != null ? _ref.values : void 0;
            };

            return ListsCollection;

        })(Collection);


    }, {
        "../lib/request": 46,
        "../lib/su": 66,
        "./base/collection": 73,
        "./list-model": 82,
        "chaplin": 268
    }
    ],
    84: [function(require, module, exports) {
        var $, Cache, Chaplin, moment, storage, utils, _;

        _ = require('lodash');

        $ = require('jquery');

        Chaplin = require('chaplin');

        storage = require('simple-storage');

        utils = require('../../lib/utils');

        moment = require('moment');

        module.exports = Cache = (function() {
            function Cache() {}

            Cache.prototype.cache = {
                uid_helper: function() {
                    return Chaplin.mediator.userM.get('userid');
                },
                ttl: '1d',
                checkInterval: '10m'
            };

            Cache.prototype.initialize = function(data, options) {
                if (options == null) {
                    options = {};
                }
                Cache.__super__.initialize.apply(this, arguments);
                if (options.cache != null) {
                    this.cache = _.defaults(options.cache, this.cache);
                    this.cache['key'] = this.generateKey();
                    this.on('add remove change', this.setCache);
                    if (this.checkInterval) {
                        return this.removingExpires = setInterval((function(_this) {
                            return function() {
                                return _this.removeExpired();
                            };
                        })(this), utils.toMs(this.cache.checkInterval));
                    }
                }
            };

            Cache.prototype.getExpires = function() {
                var amount, ttl, unit;
                ttl = this.cache.ttl;
                amount = ttl.slice(0, - 1);
                unit = ttl.slice( - 1);
                return moment().add(unit, amount).unix();
            };

            Cache.prototype.generateKey = function() {
                var _base;
                return this.cache.uid + ((typeof (_base = this.cache).uid_helper === "function" ? _base.uid_helper() : void 0) || '');
            };

            Cache.prototype.getKey = function() {
                var _ref, _ref1;
                return ((_ref = this.collection) != null ? (_ref1 = _ref.cache) != null ? _ref1.key : void 0 : void 0) || this.cache.key;
            };

            Cache.prototype.setCache = _.debounce(function(options) {
                var data;
                data = this.chain().reject({
                    '_nocache': true
                }).transform((function(_this) {
                    return function(result, model) {
                        return result.push({
                            id: model.id,
                            expires: _this.getExpires(),
                            data: model.toJSON()
                        });
                    };
                })(this)).value();
                return storage.set(this.getKey(), data);
            }, 100, {
                leading: true,
                trailing: true
            });

            Cache.prototype.getCache = function() {
                this.removeExpired();
                return _(storage.get(this.getKey())).transform(function(result, item) {
                    return result.push(item.data);
                }).value();
            };

            Cache.prototype.hasCache = function() {
                return !_.isEmpty(storage.get(this.getKey()));
            };

            Cache.prototype.removeCache = function() {
                return storage.remove(this.getKey());
            };

            Cache.prototype.removeExpired = function() {
                var cached, notExpired, now;
                now = moment().unix();
                cached = storage.get(this.getKey());
                if (cached != null) {
                    notExpired = typeof cached.filter === "function" ? cached.filter((function(_this) {
                        return function(item) {
                            var expired;
                            expired = now > item.expires;
                            if (expired) {
                                _this.remove(item.id);
                            }
                            return !expired;
                        };
                    })(this)) : void 0;
                    storage.set(this.getKey(), notExpired || []);
                }
                return this;
            };

            Cache.prototype.fetch = function(options) {
                var dfd;
                if (options == null) {
                    options = {};
                }
                dfd = new $.Deferred;
                if (options.remove == null) {
                    options.remove = false;
                }
                if (this.hasCache() && options.fresh !== true) {
                    _.defer((function(_this) {
                        return function() {
                            var cached;
                            cached = _this.getCache();
                            if (options.remove) {
                                _this.reset(cached, {
                                    silent: true
                                });
                            } else {
                                _this.add(cached, {
                                    silent: true
                                });
                            }
                            _this.trigger('sync');
                            return dfd.resolve(_this, cached, options);
                        };
                    })(this));
                    return dfd.promise();
                } else {
                    return Cache.__super__.fetch.call(this, options);
                }
            };

            return Cache;

        })();


    }, {
        "../../lib/utils": 69,
        "chaplin": 268,
        "jquery": 269,
        "lodash": 271,
        "moment": 273,
        "simple-storage": 274
    }
    ],
    85: [function(require, module, exports) {
        var SetUserThumbnail;

        module.exports = SetUserThumbnail = (function() {
            function SetUserThumbnail() {}

            SetUserThumbnail.prototype.initialize = function() {
                this.setUserThumbnail();
                return this.on('change:picture_small', (function(_this) {
                    return function() {
                        return _this.setUserThumbnail();
                    };
                })(this));
            };

            SetUserThumbnail.prototype.setUserThumbnail = function(url, force) {
                if (force == null) {
                    force = false;
                }
                if (url == null) {
                    url = (typeof this.getThumbUrl === "function" ? this.getThumbUrl() : void 0) || 'https://nb9-stumbleupon.netdna-ssl.com/WcjiEMsHQiBUV9Q-ZK4lDg';
                }
                return ['small', 'med', 'large'].forEach((function(_this) {
                    return function(size) {
                        if (!(force === false && _this.get("picture_" + size))) {
                            return _this.set("picture_" + size, url);
                        }
                    };
                })(this));
            };

            return SetUserThumbnail;

        })();


    }, {}
    ],
    86: [function(require, module, exports) {
        var $, WhenPopulated;

        $ = require('jquery');

        module.exports = WhenPopulated = (function() {
            function WhenPopulated() {}

            WhenPopulated.prototype.whenPopulated = function() {
                var dfd;
                dfd = new $.Deferred;
                if (this.length) {
                    dfd.resolve(this);
                } else {
                    this.on('add', (function(_this) {
                        return function() {
                            return dfd.resolve(_this);
                        };
                    })(this));
                }
                return dfd.promise();
            };

            return WhenPopulated;

        })();


    }, {
        "jquery": 269
    }
    ],
    87: [function(require, module, exports) {
        var ModeModel, Model, SU, request, storage,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        SU = require('../lib/su');

        Model = require('./base/model');

        request = require('../lib/request');

        storage = require('simple-storage');

        module.exports = ModeModel = (function(_super) {
            __extends(ModeModel, _super);

            function ModeModel() {
                return ModeModel.__super__.constructor.apply(this, arguments);
            }

            ModeModel.prototype.defaults = {
                '_sortOrder': 2,
                '_active': false,
                '_hide': false
            };

            ModeModel.prototype.idAttribute = 'name';

            ModeModel.prototype.initialize = function(data, options) {
                ModeModel.__super__.initialize.apply(this, arguments);
                this.options = options;
                this.saveModeType();
                if (this.get('_mode') !== 'domain') {
                    this.set('_active', storage.get('activeMode') === this.get('name'), {
                        silent: true
                    });
                }
                return this.on('change:_active', function() {
                    if (this.get('_active') === true) {
                        return storage.set('activeMode', this.get('name'));
                    }
                });
            };

            ModeModel.prototype.getModeType = function() {
                if (this.get('_mode')) {
                    return this.get('_mode');
                } else if (this.get('is_tag') === true && this.get('id')) {
                    return 'tag';
                } else if (this.get('id')) {
                    return 'topic';
                } else {
                    return 'all';
                }
            };

            ModeModel.prototype.saveModeType = function() {
                return this.set('_mode', this.getModeType());
            };

            return ModeModel;

        })(Model);


    }, {
        "../lib/request": 46,
        "../lib/su": 66,
        "./base/model": 74,
        "simple-storage": 274
    }
    ],
    88: [function(require, module, exports) {
        var $, Collection, ModeM, ModesCollection, SU, mediator, request, storage, utils, _,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Collection = require('./base/collection');

        SU = require('../lib/su');

        ModeM = require('./mode-model');

        request = require('../lib/request');

        mediator = require('chaplin').mediator;

        storage = require('simple-storage');

        _ = require('lodash');

        $ = require('jquery');

        utils = require('../lib/utils');

        module.exports = ModesCollection = (function(_super) {
            __extends(ModesCollection, _super);

            function ModesCollection() {
                return ModesCollection.__super__.constructor.apply(this, arguments);
            }

            ModesCollection.prototype.model = ModeM;

            ModesCollection.prototype.announceEvents = 'mode';

            ModesCollection.prototype.stumbleThruRegex = /stumblethru:([^;\n\/\\\?\#\&\s]+)/;

            ModesCollection.prototype.pidRegex = /pid:([A-Za-z\d]+)/;

            ModesCollection.prototype.domain_cookie = 'surequesturi';

            ModesCollection.prototype.initialize = function() {
                ModesCollection.__super__.initialize.apply(this, arguments);
                this.user = new SU.User();
                this.setInterval((function(_this) {
                    return function() {
                        return _this.fetch();
                    };
                })(this), '10m');
                this.on('sync', (function(_this) {
                    return function() {
                        return _this.addDefaultData();
                    };
                })(this));
                this.addDefaultData();
                return this.setDomainMode();
            };

            ModesCollection.prototype.fetch = function() {
                if (utils.isLoggedIn()) {
                    return ModesCollection.__super__.fetch.apply(this, arguments);
                }
            };

            ModesCollection.prototype.isDomain = function(str) {
                return !!(str != null ? str.match(/\.\w{2,}/) : void 0);
            };

            ModesCollection.prototype.getDomainModel = function(domain) {
                if (!(this.isDomain(domain))) {
                    domain = null;
                }
                if (domain || this.getDomain()) {
                    return new ModeM({
                        _mode: 'domain',
                        _active: true,
                        name: domain || this.getDomain(),
                        _sortOrder: 1
                    });
                }
            };

            ModesCollection.prototype.setDomainMode = function() {
                var domain;
                if ((domain = this.getDomain())) {
                    this.setActive(domain, '_domain');
                    return {
                        urlid: this.parseOutPid(window.location.href),
                        domain: domain
                    };
                }
                return null;
            };

            ModesCollection.prototype.getDomain = function() {
                var domain;
                domain = this.parseOutDomain(window.location.href);
                if (!domain) {
                    domain = this.getDomainInCookie();
                }
                if (!domain) {
                    domain = this.getStoredDomain();
                }
                return domain;
            };

            ModesCollection.prototype.getStoredDomain = function() {
                if (this.isDomain(storage.get('activeMode'))) {
                    return storage.get('activeMode');
                }
            };

            ModesCollection.prototype.getDomainInCookie = function() {
                var cookieVal;
                cookieVal = $.cookie(this.domain_cookie);
                if (cookieVal) {
                    $.removeCookie(this.domain_cookie);
                    return this.parseOutDomain(cookieVal);
                }
            };

            ModesCollection.prototype.setDomainParamFlag = function(domain) {
                return storage.set('domainParamFlag', domain);
            };

            ModesCollection.prototype.getDomainParamFlag = function() {
                return storage.get('domainParamFlag');
            };

            ModesCollection.prototype.clearDomainParamFlag = function(domain) {
                return storage.remove('domainParamFlag');
            };

            ModesCollection.prototype.parseOutPid = function(url) {
                if (this.pidRegex.test(url)) {
                    return url.split(this.pidRegex)[1];
                }
            };

            ModesCollection.prototype.parseOutDomain = function(url) {
                var domain;
                if (url.match('domain=')) {
                    domain = url.split('domain=').pop().split('/').shift().split('&').pop();
                }
                if (this.stumbleThruRegex.test(url)) {
                    domain = url.split(this.stumbleThruRegex)[1];
                }
                if (!domain || domain.match(/<[a-z][\s\S]*>/)) {
                    return void 0;
                }
                if (this.isDomain(domain)) {
                    this.setDomainParamFlag(domain);
                    return domain;
                }
            };

            ModesCollection.prototype.comparator = function(model) {
                return model.get('_sortOrder');
            };

            ModesCollection.prototype.getActive = function() {
                return this.getDomainModel(this.getDomain()) || this.findWhere({
                    '_active': true
                }) || this.findWhere({
                    'name': 'All Interests'
                });
            };

            ModesCollection.prototype.setActive = function(name, mode) {
                var activeModel;
                if (mode === '_domain' || this.isDomain(name)) {
                    if (!this.findWhere({
                        'name': name
                    })) {
                        this.forEach((function(_this) {
                            return function(model) {
                                return model.set('_active', false);
                            };
                        })(this));
                        this.add(this.getDomainModel(name));
                    }
                } else {
                    this.forEach((function(_this) {
                        return function(model) {
                            var _ref;
                            return model.set('_active', ((_ref = model.get('name')) != null ? _ref.toLowerCase() : void 0) === name.toLowerCase());
                        };
                    })(this));
                }
                activeModel = this.findWhere({
                    '_active': true
                }) || this.findWhere({
                    'name': 'All Interests'
                });
                storage.set('activeMode', activeModel != null ? typeof activeModel.get === "function" ? activeModel.get('name') : void 0 : void 0);
                return this.trigger('activechanged', activeModel);
            };

            ModesCollection.prototype.addDefaultData = function() {
                var activeMode, modeInfo;
                modeInfo = storage.get('modeInfo');
                activeMode = storage.get('activeMode') || 'All Interests';
                this.add([
                {
                    _mode: 'all',
                    _sortOrder: 3,
                    _active: true,
                    name: 'All Interests',
                    _faClass: 'fa fa-globe',
                    _hide: true
                }, {
                    _mode: 'activity',
                    _sortOrder: 3,
                    name: 'Activity',
                    _faClass: 'fa fa-users',
                    _hide: true
                }, {
                    _mode: 'trending',
                    _sortOrder: 3,
                    name: 'Trending',
                    _faClass: 'fa fa-line-chart',
                    _hide: true
                }, {
                    _mode: 'photos',
                    _sortOrder: 3,
                    name: 'Photos',
                    _faClass: 'fa fa-photo',
                    _hide: true
                }, {
                    _mode: 'videos',
                    _sortOrder: 3,
                    name: 'Videos',
                    _faClass: 'fa fa-video-camera',
                    _hide: true
                }
                ]);
                if (modeInfo && modeInfo.name === activeMode) {
                    return this.add(_.extend(modeInfo || {}, {
                        name: activeMode,
                        _hide: true
                    }));
                } else {
                    return storage.remove('modeInfo');
                }
            };

            ModesCollection.prototype.sync = function(method, model, options) {
                if (options.data == null) {
                    options.data = {
                        userid: mediator.userM.get('userid')
                    };
                }
                switch (method) {
                case 'read':
                    return request(this.user.getInterests, arguments);
                default:
                    throw new Error(method + ' unsupported');
                }
            };

            ModesCollection.prototype.parse = function(res) {
                var _ref;
                return (_ref = res.interests) != null ? _ref.values : void 0;
            };

            return ModesCollection;

        })(Collection);


    }, {
        "../lib/request": 46,
        "../lib/su": 66,
        "../lib/utils": 69,
        "./base/collection": 73,
        "./mode-model": 87,
        "chaplin": 268,
        "jquery": 269,
        "lodash": 271,
        "simple-storage": 274
    }
    ],
    89: [function(require, module, exports) {
        var Model, NotificationItemModel, SU, mediator, request, utils,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Model = require('./base/model');

        SU = require('../lib/su');

        request = require('../lib/request');

        mediator = require('chaplin').mediator;

        utils = require('../lib/utils');

        module.exports = NotificationItemModel = (function(_super) {
            __extends(NotificationItemModel, _super);

            function NotificationItemModel() {
                return NotificationItemModel.__super__.constructor.apply(this, arguments);
            }

            NotificationItemModel.prototype.defaults = {
                newMessagesCount: 0,
                newSharesCount: 0,
                newTotalCount: 0,
                newUpdatesCount: 0
            };

            NotificationItemModel.prototype.initialize = function() {
                NotificationItemModel.__super__.initialize.apply(this, arguments);
                return this.set('_thumbnail', this.getThumbUrl());
            };

            NotificationItemModel.prototype.getThumbUrl = function() {
                var thumbnail, _ref, _ref1;
                thumbnail = (_ref = this.get('originatingUser')) != null ? (_ref1 = _ref.thumbs) != null ? _ref1.large : void 0 : void 0;
                if (thumbnail != null) {
                    return "//nb9-stumbleupon.netdna-ssl.com/" + thumbnail;
                } else {
                    return 'https://nb9-stumbleupon.netdna-ssl.com/WcjiEMsHQiBUV9Q-ZK4lDg';
                }
            };

            NotificationItemModel.prototype.sync = function(method, model, options) {
                if (options == null) {
                    options = {};
                }
                if (options.data == null) {
                    options.data = {
                        userid: mediator.userM.get('userid')
                    };
                }
                switch (method) {
                case 'read':
                    return request(SU.Notifications.get, arguments);
                default:
                    throw new Error(method + ' unsupported');
                }
            };

            return NotificationItemModel;

        })(Model);


    }, {
        "../lib/request": 46,
        "../lib/su": 66,
        "../lib/utils": 69,
        "./base/model": 74,
        "chaplin": 268
    }
    ],
    90: [function(require, module, exports) {
        var Collection, NotificationItemM, NotificationItemsCollection,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Collection = require('./base/collection');

        NotificationItemM = require('./notification-item-model');

        module.exports = NotificationItemsCollection = (function(_super) {
            __extends(NotificationItemsCollection, _super);

            function NotificationItemsCollection() {
                return NotificationItemsCollection.__super__.constructor.apply(this, arguments);
            }

            NotificationItemsCollection.prototype.model = NotificationItemM;

            return NotificationItemsCollection;

        })(Collection);


    }, {
        "./base/collection": 73,
        "./notification-item-model": 89
    }
    ],
    91: [function(require, module, exports) {
        var Model, NotificationModel, SU, mediator, request, utils,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Model = require('./base/model');

        SU = require('../lib/su');

        request = require('../lib/request');

        mediator = require('chaplin').mediator;

        utils = require('../lib/utils');

        module.exports = NotificationModel = (function(_super) {
            __extends(NotificationModel, _super);

            function NotificationModel() {
                return NotificationModel.__super__.constructor.apply(this, arguments);
            }

            NotificationModel.prototype.defaults = {
                newMessagesCount: 0,
                newSharesCount: 0,
                newTotalCount: 0,
                newUpdatesCount: 0,
                _newNotificationCount: 0
            };

            NotificationModel.prototype.initialize = function() {
                NotificationModel.__super__.initialize.apply(this, arguments);
                this.on('change:newSharesCount', (function(_this) {
                    return function() {
                        return _this.updateNotificationCount();
                    };
                })(this));
                this.on('change:newMessagesCount', (function(_this) {
                    return function() {
                        return _this.updateNotificationCount();
                    };
                })(this));
                this.subscribeEvent('share:loaded', (function(_this) {
                    return function() {
                        return _this.fetch();
                    };
                })(this));
                return this.setInterval((function(_this) {
                    return function() {
                        return _this.fetch();
                    };
                })(this), '15m');
            };

            NotificationModel.prototype.updateNotificationCount = function() {
                this.publishEvent('notifications:new', this);
                return this.set('_newNotificationCount', this.get('newSharesCount') + this.get('newMessagesCount'));
            };

            NotificationModel.prototype.getThumbUrl = function() {
                var thumbUrl, _ref;
                if (this.get((typeof originatingUser !== "undefined" && originatingUser !== null ? (_ref = originatingUser.thumbs) != null ? _ref.small : void 0 : void 0) != null)) {
                    return thumbUrl = 'https://nb9-stumbleupon.netdna-ssl.com/' + this.get(originatingUser.thumbs.small);
                } else {
                    return thumbUrl = null;
                }
            };

            NotificationModel.prototype.sync = function(method, model, options) {
                if (options == null) {
                    options = {};
                }
                if (options.data == null) {
                    options.data = {
                        userid: mediator.userM.get('userid')
                    };
                }
                switch (method) {
                case 'read':
                    return request(SU.Notifications.get, arguments);
                default:
                    throw new Error(method + ' unsupported');
                }
            };

            return NotificationModel;

        })(Model);


    }, {
        "../lib/request": 46,
        "../lib/su": 66,
        "../lib/utils": 69,
        "./base/model": 74,
        "chaplin": 268
    }
    ],
    92: [function(require, module, exports) {
        var Model, SU, ShareModel, request,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Model = require('./base/model');

        SU = require('../lib/su');

        request = require('../lib/request');

        module.exports = ShareModel = (function(_super) {
            __extends(ShareModel, _super);

            function ShareModel() {
                return ShareModel.__super__.constructor.apply(this, arguments);
            }

            ShareModel.prototype.sync = function(method, model, options) {
                if (options == null) {
                    options = {};
                }
                if (method === 'create') {
                    if (options.data == null) {
                        options.data = model.toJSON();
                    }
                }
                switch (method) {
                case 'create':
                    return request(SU.Share.url, arguments);
                default:
                    throw new Error(method + ' unsupported');
                }
            };

            return ShareModel;

        })(Model);


    }, {
        "../lib/request": 46,
        "../lib/su": 66,
        "./base/model": 74
    }
    ],
    93: [function(require, module, exports) {
        var $, Model, SU, StumbleModel, mediator, request, utils, _,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        _ = require('lodash');

        SU = require('../lib/su');

        Model = require('./base/model');

        request = require('../lib/request');

        utils = require('../lib/utils');

        mediator = require('chaplin').mediator;

        $ = require('jquery');

        module.exports = StumbleModel = (function(_super) {
            __extends(StumbleModel, _super);

            function StumbleModel() {
                return StumbleModel.__super__.constructor.apply(this, arguments);
            }

            StumbleModel.prototype.idAttribute = 'urlid';

            StumbleModel.prototype.defaults = {
                '_active': false,
                '_seen': false,
                '_mode': null,
                '_template': 'site'
            };

            StumbleModel.prototype.getInterestName = function() {
                var _ref, _ref1, _ref2;
                return (_ref = this.get('interests')) != null ? (_ref1 = _ref.values) != null ? (_ref2 = _ref1[0]) != null ? _ref2.name : void 0 : void 0 : void 0;
            };

            StumbleModel.prototype.getTemplate = function() {
                if (this.get('_legacy')) {
                    return 'site';
                } else if (utils.isImage(this.get('url'))) {
                    return 'image';
                } else if (this.has('_youtubeid')) {
                    return 'youtube';
                } else if (this.has('_vineid')) {
                    return 'vine';
                } else if (this.has('_dailymotionid')) {
                    return 'dailymotion';
                } else if (this.has('_metacafeid')) {
                    return 'metacafe';
                } else if (this.has('_vimeoid')) {
                    return 'vimeo';
                } else if (this.has('_soundcloudpath')) {
                    return 'soundcloud';
                } else if (this.has('_pinterestid')) {
                    return 'pinterest';
                } else if (this.has('_pinterestboardid')) {
                    return 'pinterest-board';
                } else if (utils.getFacebookPost(this.get('url'))) {
                    return 'facebook';
                } else if (this.has('_tweetid')) {
                    return 'tweet';
                } else if (this.has('_flickruser') && this.has('_flickrid')) {
                    return 'flickr';
                } else if (this.has('_instagramid')) {
                    return 'instagram';
                } else if (this.has('_tedtalkid')) {
                    return 'ted';
                } else {
                    return 'site';
                }
            };

            StumbleModel.prototype.getEmbedCode = function() {
                return this.getTweetApiUrl().then($.getJSON);
            };

            StumbleModel.prototype.getTweetApiUrl = function() {
                var apiUrl, dfd, tweet;
                dfd = $.Deferred();
                if (this.has('_tweetid')) {
                    tweet = this.get('_tweetid');
                    apiUrl = "https://api.twitter.com/1/statuses/oembed.json?id=" + tweet + "&callback=?";
                    dfd.resolve(apiUrl);
                } else {
                    dfd.reject();
                }
                return dfd.promise();
            };

            StumbleModel.prototype.getThumb = function() {
                var _ref, _ref1;
                if (utils.isImage(this.get('url'))) {
                    return this.get('url');
                } else if (((_ref = this.get('thumb')) != null ? _ref.large : void 0) !== null) {
                    return 'https://nb9-stumbleupon.netdna-ssl.com/' + ((_ref1 = this.get('thumb')) != null ? _ref1.large : void 0);
                } else {
                    return '';
                }
            };

            StumbleModel.prototype.getRoute = function() {
                if (this.get('_legacy')) {
                    return this.get('urlid');
                } else {
                    return _(['su', this.get('urlid'), this.get('tracking_code'), this.get('_stripped')]).compact().value().join('/');
                }
            };

            StumbleModel.prototype.savePrivateData = function() {
                var _ref, _ref1;
                this.set('_interest', this.getInterestName());
                this.set('_stripped', utils.stripProtocol(this.get('url')));
                this.set('_domain', utils.getDomain(this.get('url')));
                this.set('_youtubeid', utils.getYoutubeId(this.get('url')));
                this.set('_vineid', utils.getVineId(this.get('url')));
                this.set('_dailymotionid', utils.getDailymotionId(this.get('url')));
                this.set('_vimeoid', utils.getVimeoId(this.get('url')));
                this.set('_metacafeid', utils.getMetacafeId(this.get('url')));
                this.set('_soundcloudpath', utils.getSoundcloudPath(this.get('url')));
                this.set('_pinterestid', utils.getPinterestId(this.get('url')));
                this.set('_pinterestboardid', utils.getPinterestBoardId(this.get('url')));
                this.set('_tweetid', utils.getTweetId(this.get('url')));
                this.set('_flickruser', utils.getFlickrUsername(this.get('url')));
                this.set('_instagramid', utils.getInstagramId(this.get('url')));
                this.set('_tedtalkid', utils.getTedTalkId(this.get('url')));
                this.set('_flickrid', utils.getFlickrId(this.get('url')));
                this.set('_title', this.get('title') || this.get('_domain'));
                this.set('_userThumb', (_ref = mediator.userM) != null ? _ref.get('picture_small') : void 0);
                this.set('_template', this.getTemplate());
                this.set('_route', this.getRoute());
                this.set('_thumb', this.getThumb());
                if ((_ref1 = _.str) != null ? _ref1.numberFormat : void 0) {
                    this.set('_views', _.str.numberFormat(parseInt(this.get('views') || 0)));
                }
                return this.set('_nocache', this.get('_legacy') === true);
            };

            StumbleModel.prototype.avoidDoubleToolbar = function() {
                var url;
                url = this.get('url');
                if ((url != null) && url.match('.stumbleupon.com')) {
                    return this.set('url', utils.appendParams(url, {
                        _notoolbar: true,
                        _nospa: true
                    }));
                }
            };

            StumbleModel.prototype.initialize = function(data, options) {
                if (data != null) {
                    this.options = options;
                    if (this.get('url') != null) {
                        this.savePrivateData();
                    }
                    this.avoidDoubleToolbar();
                    this.on('change:rating', (function(_this) {
                        return function() {
                            return _this.save();
                        };
                    })(this));
                    this.on('change:_domainBlocked', (function(_this) {
                        return function() {
                            return _this.save();
                        };
                    })(this));
                    return this.on('change:_seen', (function(_this) {
                        return function() {
                            if (!_this.get('_byid')) {
                                return _this.save();
                            }
                        };
                    })(this));
                }
            };

            StumbleModel.prototype.sync = function(method, model, options) {
                var changedAttr, updateMethod;
                changedAttr = _(this.changed).keys().pop();
                switch (changedAttr) {
                case 'rating':
                    updateMethod = SU.Stumble.setRating;
                    if (options.data == null) {
                        options.data = {
                            urlid: this.get('urlid'),
                            type: this.get('rating')
                        };
                    }
                    if (this.get('rating') === - 1 && this.get('subrating')) {
                        options.data.subtype = this.get('subrating');
                    }
                    break;
                case '_seen':
                    updateMethod = SU.Stumble.all;
                    options.data = {
                        guess_urlids: [this.get('urlid')],
                        guess_only: 1,
                        guesses: 0
                    };
                    break;
                case '_domainBlocked':
                    updateMethod = SU.Stumble.blockDomain;
                    if (options.data == null) {
                        options.data = {
                            urlid: this.get('urlid')
                        };
                    }
                    break;
                default:
                    updateMethod = function() {};
                }
                if (method === 'read') {
                    this.set('_byid', true);
                }
                if (!utils.isVisitor()) {
                    switch (method) {
                    case 'update':
                        return request(updateMethod, arguments);
                    case 'read':
                        return request(SU.Stumble.urlid, arguments);
                    default:
                        throw new Error(method + ' unsupported');
                    }
                }
            };

            StumbleModel.prototype.parse = function(res) {
                if (typeof res.url === 'string') {
                    return res;
                } else {
                    return res.url;
                }
            };

            StumbleModel.prototype.setActive = function() {
                this.collection.setActive(this.get('urlid'));
                return this;
            };

            return StumbleModel;

        })(Model);


    }, {
        "../lib/request": 46,
        "../lib/su": 66,
        "../lib/utils": 69,
        "./base/model": 74,
        "chaplin": 268,
        "jquery": 269,
        "lodash": 271
    }
    ],
    94: [function(require, module, exports) {
        var $, Collection, SU, StumbleM, StumblesCollection, UserM, mediator, moment, request, utils, _,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        $ = require('jquery');

        _ = require('lodash');

        Collection = require('./base/collection');

        SU = require('../lib/su');

        StumbleM = require('./stumble-model');

        request = require('../lib/request');

        utils = require('../lib/utils');

        mediator = require('chaplin').mediator;

        UserM = require('./user-model');

        moment = require('moment');

        module.exports = StumblesCollection = (function(_super) {
            __extends(StumblesCollection, _super);

            function StumblesCollection() {
                return StumblesCollection.__super__.constructor.apply(this, arguments);
            }

            StumblesCollection.prototype.model = StumbleM;

            StumblesCollection.prototype.maxItems = 100;

            StumblesCollection.prototype.buffer = {
                guesses: 10,
                fillrate: '3s',
                min: 4,
                maxRequests: 1,
                pending: 0,
                errors: [],
                total: 0
            };

            StumblesCollection.prototype.initialize = function() {
                StumblesCollection.__super__.initialize.apply(this, arguments);
                this.subscribeEvent('stumble:next', this.fillBuffer);
                this.subscribeEvent('buffer:started', this.onBufferStarted);
                this.subscribeEvent('buffer:added', this.onBufferAdded);
                this.subscribeEvent('buffer:failed', this.onBufferFailed);
                this.on('add', this.capSize);
                return this.bufferMonitor = this.setInterval((function(_this) {
                    return function() {
                        return _this.fillBuffer();
                    };
                })(this), this.buffer.fillrate);
            };

            StumblesCollection.prototype.setActive = function(urlid) {
                this.forEach((function(_this) {
                    return function(model) {
                        if (model.get('urlid') === urlid) {
                            model.set('_active', true);
                            return model.set('_seen', true);
                        } else {
                            return model.set('_active', false);
                        }
                    };
                })(this));
                return this.publishEvent('stumble:activechanged', this.getActive());
            };

            StumblesCollection.prototype.getActive = function() {
                return this.findWhere({
                    '_active': true
                });
            };

            StumblesCollection.prototype.onBufferStarted = function() {
                this.buffer.pending += 1;
                return this.buffer.total += 1;
            };

            StumblesCollection.prototype.onBufferFailed = function(response) {
                this.buffer.pending -= 1;
                return this.buffer.errors.push(response);
            };

            StumblesCollection.prototype.onBufferAdded = function() {
                return this.buffer.pending -= 1;
            };

            StumblesCollection.prototype.capSize = function() {
                if (this.length > this.maxItems) {
                    return this.remove(this.first(10));
                }
            };

            StumblesCollection.prototype.getLastUrlids = function(amount) {
                if (amount == null) {
                    amount = 50;
                }
                return this.pluck('urlid').reverse().slice(0, amount);
            };

            StumblesCollection.prototype.getDefaultOptions = function() {
                var currentMode, options, _ref;
                currentMode = mediator.modesC.getActive();
                options = {
                    data: {
                        guesses: this.buffer.guesses,
                        userid: mediator.userM.get('userid'),
                        interests: [currentMode != null ? currentMode.get('id') : void 0],
                        filter_urls: this.getLastUrlids(),
                        userids: currentMode != null ? currentMode.get('userids') : void 0,
                        listId: currentMode != null ? currentMode.get('listId') : void 0,
                        prefill_ad_hole: true
                    },
                    _mode: currentMode != null ? currentMode.get('name') : void 0
                };
                if (options != null ? (_ref = options._mode) != null ? _ref.match(/\./) : void 0 : void 0) {
                    options['data']['domains'] = [currentMode != null ? currentMode.get('name') : void 0];
                } else if ((currentMode != null ? currentMode.get('name') : void 0) !== 'All Interests') {
                    options['data']['keyword'] = currentMode != null ? currentMode.get('name') : void 0;
                }
                return options;
            };

            StumblesCollection.prototype.fetch = function(options) {
                if (options == null) {
                    options = {};
                }
                return StumblesCollection.__super__.fetch.call(this, _.defaults(options, this.getDefaultOptions()));
            };

            StumblesCollection.prototype.fillBuffer = function(force) {
                var currentMode, start;
                currentMode = mediator.modesC.getActive();
                if (this.buffer.pending <= this.buffer.maxRequests && utils.isLoggedIn() && this.whereUnseen().length < this.buffer.min && (force === true || ((currentMode != null ? currentMode.get('listId') : void 0) == null))) {
                    this.publishEvent('buffer:started', this.buffer);
                    start = utils.unix();
                    return this.fetch({
                        fresh: true,
                        remove: false,
                        merge: false
                    }).then((function(_this) {
                        return function() {
                            if (_this.whereUnseen().length > 0) {
                                return _this.publishEvent('buffer:added', {
                                    time: utils.unix() - start
                                });
                            } else {
                                return _this.publishEvent('buffer:failed', 'dupes');
                            }
                        };
                    })(this), (function(_this) {
                        return function(xhr, response) {
                            return _this.publishEvent('buffer:failed', response);
                        };
                    })(this));
                }
            };

            StumblesCollection.prototype.getApiMethod = function() {
                var currentMode, _ref;
                currentMode = (_ref = mediator.modesC.getActive()) != null ? _ref.get('_mode') : void 0;
                if (currentMode != null) {
                    currentMode = currentMode.toLowerCase();
                }
                switch (currentMode) {
                case 'activity':
                    return SU.Stumble.activity;
                case 'domain':
                    return SU.Stumble.domain;
                case 'trending':
                    return SU.Stumble.trending;
                case 'photos':
                    return SU.Stumble.photo;
                case 'videos':
                    return SU.Stumble.video;
                case 'topic':
                    return SU.Stumble.interest;
                case 'user':
                    return SU.Stumble.user;
                case 'list':
                    return SU.Stumble.list;
                case 'keyword':
                    return SU.Stumble.keyword;
                default:
                    return SU.Stumble.all;
                }
            };

            StumblesCollection.prototype.sync = function(method, model, options) {
                options['data']['guess_only'] = 1;
                switch (method) {
                case 'read':
                    return request(this.getApiMethod(), arguments);
                default:
                    throw new Error('Unsupported');
                }
            };

            StumblesCollection.prototype.parse = function(res, options) {
                var urls;
                urls = [];
                if (res.guesses.values.length > 0) {
                    res.guesses.values.push(res.url);
                    urls = res.guesses.values;
                    this.lastResponse = res;
                } else {
                    urls.push(res.url);
                }
                return urls.filter(function(url) {
                    return url !== null;
                }).map(function(url) {
                    var _ref, _ref1;
                    url._for = options != null ? (_ref = options.data) != null ? _ref.userid : void 0 : void 0;
                    url._mode = options != null ? options._mode : void 0;
                    url._listId = options != null ? (_ref1 = options.data) != null ? _ref1.listId : void 0 : void 0;
                    return url;
                });
            };

            StumblesCollection.prototype.getById = function(urlid) {
                var dfd, existing, stumbleM;
                if (typeof urlid !== 'string') {
                    throw new TypeError('getById must be passed a string');
                }
                dfd = new $.Deferred();
                existing = this.findWhere({
                    urlid: urlid
                });
                if (existing) {
                    dfd.resolve(existing);
                } else {
                    stumbleM = new StumbleM();
                    stumbleM.fetch({
                        merge: false,
                        data: {
                            urlid: urlid
                        },
                        success: (function(_this) {
                            return function(model) {
                                return dfd.resolve(_this.add(model.toJSON()));
                            };
                        })(this),
                        error: function() {
                            return dfd.rejectWith(this, arguments);
                        }
                    });
                }
                return dfd.promise();
            };

            StumblesCollection.prototype.getByShareId = function(shareid) {
                var shareResp, stumbleM, userM;
                userM = new UserM;
                shareResp = null;
                stumbleM = null;
                return request(SU.Share.get, [
                null, null, {
                    data: {
                        id: shareid
                    }
                }
                ]).then((function(_this) {
                    return function(resp) {
                        shareResp = resp;
                        return _this.getById(resp.urlid);
                    };
                })(this)).then((function(_this) {
                    return function(model) {
                        var sharedTime, _ref, _ref1;
                        stumbleM = model;
                        request(SU.Share.seen, [
                        null, null, {
                            data: {
                                id: shareid
                            }
                        }
                        ]);
                        stumbleM.set('_shareid', shareid);
                        stumbleM.set('_message', shareResp.message);
                        sharedTime = (_ref = _(mediator.notificationM.get('recentNotifications'))) != null ? (_ref1 = _ref.findWhere({
                            publicId: shareid
                        })) != null ? _ref1.timestamp : void 0 : void 0;
                        if (!sharedTime) {
                            sharedTime = moment.utc(shareResp._timestamp, 'X').format('MMM D, YYYY');
                        }
                        if (sharedTime != null) {
                            return stumbleM.set('_sharedTime', sharedTime);
                        }
                    };
                })(this)).then(function() {
                    return userM.fetch({
                        data: shareResp.from
                    });
                }).then(function() {
                    return stumbleM.set('_from', userM.toJSON());
                });
            };

            StumblesCollection.prototype.removeUnseen = function() {
                return this.remove(this.where({
                    '_seen': false
                }));
            };

            StumblesCollection.prototype.whereUnseen = function() {
                var activeMode, modeName;
                activeMode = mediator.modesC.getActive();
                if (!activeMode) {
                    return [];
                } else {
                    modeName = activeMode.get('name');
                    return this.filter(function(model) {
                        return model.get('_mode') === modeName && model.get('_seen') === false;
                    });
                }
            };

            StumblesCollection.prototype.getNext = function() {
                var dfd;
                dfd = new $.Deferred();
                this.checking = this.setInterval((function(_this) {
                    return function() {
                        var unseenM;
                        unseenM = _this.whereUnseen()[0];
                        if (unseenM != null) {
                            clearInterval(_this.checking);
                            _this.publishEvent('stumble:gotnext');
                            return dfd.resolve(unseenM);
                        } else if (!utils.isLoggedIn() && utils.isVisitor()) {
                            dfd.reject({
                                error: "Cant fetch stumblers for a visitor",
                                visitor: true
                            });
                            return clearInterval(_this.checking);
                        }
                    };
                })(this), 250);
                return dfd.promise();
            };

            StumblesCollection.prototype.addLegacy = function(path, query) {
                var appendedPath;
                appendedPath = utils.appendParams(path, {
                    _nospa: true,
                    _notoolbar: true
                });
                appendedPath += query ? '&' + query : '';
                return this.add({
                    url: utils.getStumbleUrl() + '/' + appendedPath,
                    urlid: path,
                    title: 'StumbleUpon',
                    _legacy: true
                });
            };

            return StumblesCollection;

        })(Collection);


    }, {
        "../lib/request": 46,
        "../lib/su": 66,
        "../lib/utils": 69,
        "./base/collection": 73,
        "./stumble-model": 93,
        "./user-model": 98,
        "chaplin": 268,
        "jquery": 269,
        "lodash": 271,
        "moment": 273
    }
    ],
    95: [function(require, module, exports) {
        var Model, SU, ThumbnailModel, request, _,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Model = require('./base/model');

        SU = require('../lib/su');

        request = require('../lib/request');

        _ = require('lodash');

        module.exports = ThumbnailModel = (function(_super) {
            __extends(ThumbnailModel, _super);

            function ThumbnailModel() {
                return ThumbnailModel.__super__.constructor.apply(this, arguments);
            }

            ThumbnailModel.prototype.sync = function(method, model, options) {
                var changedAttr, updateMethod;
                if (options == null) {
                    options = {};
                }
                if (method === 'read') {
                    options.data = {
                        urlid: model.get('urlid')
                    };
                } else if (method === 'create') {
                    changedAttr = _(this.changed).keys().pop();
                    if (changedAttr === 'urlid') {
                        updateMethod = SU.Url.getInfo;
                        options.data = {
                            urlid: model.get('urlid')
                        };
                    } else {
                        updateMethod = SU.Url.addThumb;
                        options.data = {
                            url: model.get('url')
                        };
                    }
                }
                switch (method) {
                case 'create':
                    return request(updateMethod, arguments);
                case 'read':
                    return request(SU.Url.getThumb, arguments);
                default:
                    throw new Error(method + ' unsupported');
                }
            };

            return ThumbnailModel;

        })(Model);


    }, {
        "../lib/request": 46,
        "../lib/su": 66,
        "./base/model": 74,
        "lodash": 271
    }
    ],
    96: [function(require, module, exports) {
        var Model, SU, TimerModel, request, _,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Model = require('./base/model');

        SU = require('../lib/su');

        request = require('../lib/request');

        _ = require('lodash');

        module.exports = TimerModel = (function(_super) {
            __extends(TimerModel, _super);

            function TimerModel() {
                return TimerModel.__super__.constructor.apply(this, arguments);
            }

            TimerModel.prototype.idAttribute = 'urlid';

            TimerModel.prototype.initialize = function() {
                TimerModel.__super__.initialize.apply(this, arguments);
                return this.on('change:nextStumbleClick', (function(_this) {
                    return function() {
                        return _.defer(function() {
                            return _this.save();
                        });
                    };
                })(this));
            };

            TimerModel.prototype.sync = function(method, model, options) {
                var key, stumbleinfo, value, _ref;
                stumbleinfo = [];
                _ref = this.toJSON();
                for (key in _ref) {
                    if (!__hasProp.call(_ref, key)) 
                        continue;
                    value = _ref[key];
                    if (key !== 'urlid') {
                        stumbleinfo.push({
                            event: key,
                            timestamp: value
                        });
                    }
                }
                options.data = {
                    urlid: this.get('urlid'),
                    stumbleinfo: JSON.stringify(stumbleinfo)
                };
                switch (method) {
                case 'update':
                    return request(SU.Report.timers, arguments);
                default:
                    throw new Error(method + ' unsupported');
                }
            };

            return TimerModel;

        })(Model);


    }, {
        "../lib/request": 46,
        "../lib/su": 66,
        "./base/model": 74,
        "lodash": 271
    }
    ],
    97: [function(require, module, exports) {
        var Collection, TimerM, TimersCollection, utils,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Collection = require('./base/collection');

        TimerM = require('./timer-model');

        utils = require('../lib/utils');

        module.exports = TimersCollection = (function(_super) {
            __extends(TimersCollection, _super);

            function TimersCollection() {
                return TimersCollection.__super__.constructor.apply(this, arguments);
            }

            TimersCollection.prototype.model = TimerM;

            TimersCollection.prototype.initialize = function() {
                TimersCollection.__super__.initialize.apply(this, arguments);
                this.subscribeEvent('stumble:startloading', (function(_this) {
                    return function(data) {
                        return _this.add({
                            urlid: data.urlid,
                            startLoad: data.timestamp
                        });
                    };
                })(this));
                this.subscribeEvent('stumble:loaded', (function(_this) {
                    return function(data) {
                        var _ref;
                        return (_ref = _this.findWhere({
                            urlid: data.urlid
                        })) != null ? _ref.set({
                            pageLoaded: utils.unix()
                        }) : void 0;
                    };
                })(this));
                return this.subscribeEvent('stumble:next', (function(_this) {
                    return function(urlid) {
                        var _ref;
                        return (_ref = _this.findWhere({
                            urlid: urlid
                        })) != null ? _ref.set({
                            nextStumbleClick: utils.unix()
                        }) : void 0;
                    };
                })(this));
            };

            return TimersCollection;

        })(Collection);


    }, {
        "../lib/utils": 69,
        "./base/collection": 73,
        "./timer-model": 96
    }
    ],
    98: [function(require, module, exports) {
        var Mixin, Model, SU, SetUserThumbnail, UserModel, analytics, request, storage, utils, _,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        SU = require('../lib/su');

        Model = require('./base/model');

        request = require('../lib/request');

        utils = require('../lib/utils');

        storage = require('simple-storage');

        analytics = require('../lib/analytics');

        _ = require('lodash');

        Mixin = require('mixen');

        SetUserThumbnail = require('./mixins/set-user-thumbnail');

        module.exports = UserModel = (function(_super) {
            __extends(UserModel, _super);

            function UserModel() {
                return UserModel.__super__.constructor.apply(this, arguments);
            }

            UserModel.prototype.idAttribute = 'userid';

            UserModel.prototype.initialize = function(attributes, options) {
                var currentCount, storedCount, _ref;
                if (options == null) {
                    options = {};
                }
                UserModel.__super__.initialize.apply(this, arguments);
                this.user = new SU.User;
                if (options.auth) {
                    this.subscribeEvent('auth:loggedout', this.clear);
                    this.on('change:userid', (function(_this) {
                        return function() {
                            return analytics.trackUser(_this.get('userid'));
                        };
                    })(this));
                    this.on('change', (function(_this) {
                        return function() {
                            return storage.set('user', _this.toJSON());
                        };
                    })(this));
                    this.subscribeEvent('stumble:next', (function(_this) {
                        return function() {
                            _this.set('stumbles_count', _this.get('stumbles_count') + 1);
                            return storage.set('stumbles_count' + _this.get('userid'), _this.get('stumbles_count'));
                        };
                    })(this));
                    storedCount = storage.get('stumbles_count' + this.get('userid'));
                    currentCount = this.get('stumbles_count');
                    if (currentCount < storedCount) {
                        this.set('stumbles_count', storedCount);
                    }
                    switch (Number(this.get('gender'))) {
                    case 1:
                        this.set('_gender', 'male');
                        break;
                    case 2:
                        this.set('_gender', 'female');
                        break;
                    default:
                        this.set('_gender', null);
                    }
                    return (_ref = window.heap) != null ? _ref.identify({
                        userid: this.get('userid'),
                        handle: this.get('username'),
                        gender: this.get('_gender')
                    }) : void 0;
                }
            };

            UserModel.prototype.sync = function(method, model, options) {
                switch (method) {
                case 'read':
                    return request(this.user.get, arguments);
                default:
                    throw new Error(method + ' unsupported');
                }
            };

            UserModel.prototype.parse = function(res) {
                res.user.stumbles_count = Number(res.user.stumbles_count);
                return res.user;
            };

            return UserModel;

        })(Mixin(SetUserThumbnail, Model));


    }, {
        "../lib/analytics": 39,
        "../lib/request": 46,
        "../lib/su": 66,
        "../lib/utils": 69,
        "./base/model": 74,
        "./mixins/set-user-thumbnail": 85,
        "lodash": 271,
        "mixen": 272,
        "simple-storage": 274
    }
    ],
    99: [function(require, module, exports) {
        module.exports = function(match) {
            match('su/api/nextstumble', 'toolbar#stumbleNext');
            match('return', 'toolbar#stumbleNext');
            match('to/stumble/stumblethru:*domain', 'toolbar#stumbleThru');
            match('to/stumble/topic:*topic', 'toolbar#stumbleTopic');
            match('to/s', 'toolbar#stumbleNext');
            match('su/share/:urlid*anything', 'toolbar#share');
            match('su/:urlid*anything', 'toolbar#stumble');
            match('su/*anything', 'toolbar#stumbleNext');
            match('', 'toolbar#stumbleNext');
            match('login', 'login#logout');
            match('logout', 'login#logout');
            return match('*route', 'toolbar#legacyHandler');
        };


    }, {}
    ],
    100: [function(require, module, exports) {
        module.exports = Object.freeze({
            YOUR_LIKES: "Likes",
            YOUR_LISTS: "Lists",
            YOUR_CONNECTIONS: "Connections",
            FOLLOW_MORE: "Follow More...",
            ADD_PAGE: "Add a Page",
            HELP: "Help",
            SETTINGS: "Settings",
            SIGN_OUT: "Sign Out",
            ADD_TO_LIST: "Add to List",
            SHARE_THIS_PAGE: "Share this Page",
            BROADCAST_THIS_PAGE: "Share this page with all of your StumbleUpon Followers",
            BROADCAST_ALREADY_SENT: "You already shared this page with your followers",
            NO_FOLLOWERS: "Sorry, but you have no followers.",
            BROADCAST_SENT: "Your post has been successfully sent!",
            COMMENTS: "Comments",
            LISTS: "Lists",
            LIKES: "Likes",
            DISCOVERED_BY: "Discovered By",
            HOURS_AGO: "hours ago",
            SENT_YOU_MESSAGE: "sent a message",
            SHARED_PAGE_WITH_YOU: "shared a page",
            NOT_FOR_ME: "Not for Me",
            ALREADY_SEEN: "Seen Page Already",
            DOESNT_LOAD: "Page Does Not Load",
            SPAM: "Report as Spam",
            WRONG_TOPIC: "Report Wrong Topic",
            BLOCK_SITE: "Block This Site",
            NEW_SHARES: "New Shares",
            NEW_MESSAGES: "New Messages",
            NEW_UPDATES: "New Updates",
            MOST_RECENT: "Most Recent",
            CREATE_LIST: "Create List",
            NAME: "Name",
            DESCRIPTION: "Description",
            VISIBILITY: "Visibility",
            SAVE: "Save",
            CREATE: "Create",
            CANCEL: "Cancel",
            COMMENTS_ON_THIS_PAGE: "Comments on this page",
            ON: "on",
            YOUR_COMMENT: "Your Comment",
            YOUR_TAGS: "Your Tags",
            VIEW_ALL_COMMENTS: "View all comments",
            COMMENTED_BY: "Commented by",
            TYPE_TO_SEARCH_CREATE_LIST: "Search or Create a New List",
            CREATE_NEW_LIST: "Create New List",
            ALREADY_EXISTS: "already exists",
            CANNOT_ADD_TO_LIST: "Cannot add this page to a list",
            ALREADY_IN_LIST: "Already in the list",
            ADDED_TO: "Added to",
            LIST_NAME_EMPTY: "The list name is empty",
            YOUR_MESSAGE_SENT: "Your message has been sent",
            ADD_EMAIL_OR_USERNAMES: "Enter emails or SU usernames...",
            SPONSORED: "Sponsored",
            WELCOME_BACK: "Welcome back,",
            CLICK_ADD_TO_LIST: "Click here to add this page to a list.",
            TELL_WHAT_YOU_THINK: "Tell other Stumblers what you think about this page.",
            SHARE_TO_FACEBOOK: "Share this page with your friends on Facebook.",
            SHARE_TO_ANYONE: "Share this page with anyone, including through Twitter or LinkedIn.",
            STUMBLE_INTEREST: "Stumble through a specific Interest, Channel, or mode.",
            MENU_HINT: "Browse your Likes, adjust your settings and explore more.",
            DISLIKE_PAGES: "Dislike web pages so we will show you less of stuff like this.",
            LIKE_PAGES: "Like web pages so we can show you even more pages you'll like.",
            CONTINUE: "Continue",
            ADD_TO_LISTS: "Add To Lists",
            STOP_SHARES: "Stop shares from this user",
            ALLOW_SHARES: "Allow shares from this user",
            SAVING: "Saving...",
            VIEW_REPLY: "View & Reply",
            NEW_SHARE: "New Share",
            YOUR_REPLY: "Your Reply",
            SEND: "Send",
            NEXT: "Next"
        });


    }, {}
    ],
    101: [function(require, module, exports) {
        module.exports = {
            spa: true,
            branch: 'master',
            hash: '3099706',
            build_date: 'Mon Nov 24 2014 13:47:57 GMT-0800'
        };


    }, {}
    ],
    "../templates/add-to-list": [function(require, module, exports) {
        module.exports = require('ediDsA');
    }, {}
    ],
    "ediDsA": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", helper, options, helperMissing = helpers.helperMissing, escapeExpression = this.escapeExpression;


            buffer += "<div class=\"modal-view row\">\n  <div class=\"modal-wrap col-xs-11\">\n    <div class=\"title\">"
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "ADD_TO_LIST", options) : helperMissing.call(depth0, "i18n", "ADD_TO_LIST", options)))
            + "</div>\n    <div class=\"modal-body\">\n      <div class=\"dropdown\">\n        <input type=\"text\" placeholder=\""
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "TYPE_TO_SEARCH_CREATE_LIST", options) : helperMissing.call(depth0, "i18n", "TYPE_TO_SEARCH_CREATE_LIST", options)))
            + "\" class=\"dropdown-search\" autocomplete=\"off\" autofocus>\n        <div class=\"dropdown-item dropdown-create-new btn primary submit\">"
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "CREATE_NEW_LIST", options) : helperMissing.call(depth0, "i18n", "CREATE_NEW_LIST", options)))
            + "</div>\n        <div class=\"dropdown-items-wrap addtolist-items\" data-id=\"list-addedtolist\">\n            \n        </div>\n\n      </div>\n    </div>\n    <div class=\"spinner\"></div>\n  </div>\n</div>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "USqgHK": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, functionType = "function", escapeExpression = this.escapeExpression;


            buffer += "<div class=\"alert-wrapper\">\n  <span class=\"alert-text\">";
            if (helper = helpers.text) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.text);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "</span><span class=\"alert-close fa fa-times\"></span>\n</div>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/alert": [function(require, module, exports) {
        module.exports = require('USqgHK');
    }, {}
    ],
    "kv2k5c": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};



            return "<div class=\"android-overlay\">\n  <div class=\"android-overlay-container\">\n    <div class=\"close-btn\">\n      <img class=\"close-btn-img\" src=\"//nb9.stumbleupon.netdna-cdn.com/EIV2-8mkOpJVjviOMbJjfA\">\n    </div>\n    <div class=\"android-splash-header col-xs-12 col-xs-offset-0\">Introducing the all-new <br> StumbleUpon for Android</div>\n    <a class=\"download-app col-xs-8 col-xs-offset-2\" href=\"http://app.appsflyer.com/com.stumbleupon.android.app?pid=su_prod&c=splash_page\" target=\"_blank\"><img src=\"//nb9.stumbleupon.netdna-cdn.com/L9Vk_vaTJexgF8JGvZCmDg\"></a>\n    <div class=\"app-img col-xs-8 col-xs-offset-2\">\n      <img src=\"//nb9.stumbleupon.netdna-cdn.com/Ej_TY--g7qWnf8uP65-6Bg\">\n    </div>\n  </div>\n</div>";
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/android-popup": [function(require, module, exports) {
        module.exports = require('kv2k5c');
    }, {}
    ],
    "../templates/app": [function(require, module, exports) {
        module.exports = require('Whcl4h');
    }, {}
    ],
    "Whcl4h": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};



            return "<div id=\"toolbar-container\"></div>\n<div id=\"panel-container\"></div>\n<div id=\"progress-bar-container\"></div>\n<div id=\"share-bar-container\"></div>\n<div id=\"stumble-container\"></div>\n";
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "4qmo/s": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, options, functionType = "function", escapeExpression = this.escapeExpression, helperMissing = helpers.helperMissing;


            buffer += "<img class=\"thumb\" src=\""
            + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.user)), stack1 == null || stack1 === false ? stack1 : stack1.picture_small)), typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
            + "\" height=\"25\" width=\"25\">\n<div class=\"comment-right\">\n  <div class=\"comment-data\">\n      <span class=\"comment-username\">"
            + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.user)), stack1 == null || stack1 === false ? stack1 : stack1.username)), typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
            + "</span><span class=\"comment-timestamp\">"
            + escapeExpression((helper = helpers.formatTimestamp || (depth0 && depth0.formatTimestamp), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, (depth0 && depth0.timestamp), options) : helperMissing.call(depth0, "formatTimestamp", (depth0 && depth0.timestamp), options)))
            + "</span>\n  </div>\n  <p class=\"comment-text\">\n      ";
            if (helper = helpers.body) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.body);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "\n  </p>\n</div>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/comment": [function(require, module, exports) {
        module.exports = require('4qmo/s');
    }, {}
    ],
    "../templates/comments": [function(require, module, exports) {
        module.exports = require('wGqA+0');
    }, {}
    ],
    "wGqA+0": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", helper, options, helperMissing = helpers.helperMissing, escapeExpression = this.escapeExpression;


            buffer += "<div class=\"row\">\n    <div class=\"title col-xs-11\">Join the Discussion</div>\n</div>\n<div class=\"row\">\n    <div class=\"comments-left col-xs-6\">\n        <div class=\"wrapper-input edit-comment-wrapper\">\n            <div class=\"input\">\n                <textarea id=\"edit-comment\" name=\"edit-comment\" placeholder=\"Your Comment...\" class=\"outline\"></textarea>\n            </div>\n        </div>\n        <div class=\"wrapper-input tags-wrapper\">\n            <div class=\"input\">\n                <textarea id=\"edit-tags\" name=\"edit-tags\" placeholder=\"Tags\" class=\"outline\"></textarea>\n            </div>\n        </div>\n        <div class=\"actions form-stacked\">\n            <div class=\"comments-share-external\"></div>\n            <a class=\"btn close-overlay-btn\" data-id=\"comment-cancel\">"
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "CANCEL", options) : helperMissing.call(depth0, "i18n", "CANCEL", options)))
            + "</a>\n            <a class=\"btn primary submit\" data-id=\"comment-submit\">Comment</a>\n        </div>\n    </div>\n\n\n    <div class=\"comments-right col-xs-5\">\n        \n        <div class=\"spinner\"></div>\n        <div class=\"no-comments hidden\">There are no comments.</div>\n        <div class=\"comments-container\"></div>\n    </div>\n</div>\n\n\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "oshQP7": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, options, helperMissing = helpers.helperMissing, escapeExpression = this.escapeExpression, functionType = "function";


            buffer += "<div class=\"modal-view\">\n  <div class=\"modal-wrap\">\n    <div class=\"title\">"
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "CREATE_LIST", options) : helperMissing.call(depth0, "i18n", "CREATE_LIST", options)))
            + "</div>\n    <div class=\"modal-body\">\n      <form class=\"form-modal\" onsubmit=\"return false\">\n        <div class=\"wrapper-input\">\n          <label for=\"list-edit-name\">"
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "NAME", options) : helperMissing.call(depth0, "i18n", "NAME", options)))
            + "</label>\n          <input type=\"text\" value=\"";
            if (helper = helpers.name) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.name);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "\" id=\"list-edit-name\" maxlength=\"70\">\n        </div>\n        <div class=\"wrapper-input\">\n          <label for=\"list-edit-description\">"
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "DESCRIPTION", options) : helperMissing.call(depth0, "i18n", "DESCRIPTION", options)))
            + "</label>\n          <textarea id=\"list-edit-description\">";
            if (helper = helpers.description) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.description);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "</textarea>\n        </div>\n\n        <div class=\"wrapper-input input-visibility\">\n          <label for=\"list-edit-visibility\" class=\"input-visibility-header\">"
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "VISIBILITY", options) : helperMissing.call(depth0, "i18n", "VISIBILITY", options)))
            + "</label>\n          <label for=\"list-edit-public\" class=\"label-inline\">\n            <input type=\"radio\" name=\"visibility\" id=\"list-edit-public\" value=\"public\" checked>\n              Public\n          </label>\n          <label for=\"list-edit-private\" class=\"label-inline\">\n              <input type=\"radio\" name=\"visibility\" id=\"list-edit-private\" value=\"private\">\n              Private\n          </label>\n        </div>\n\n        <div class=\"modal-actions\">\n          <button class=\"btn close-overlay-btn\" id=\"list-cancel\" data-id=\"list-cancel\">"
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "CANCEL", options) : helperMissing.call(depth0, "i18n", "CANCEL", options)))
            + "</button>\n          <button class=\"btn primary submit\" id=\"list-save\" data-id=\"list-create\">"
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "CREATE", options) : helperMissing.call(depth0, "i18n", "CREATE", options)))
            + "</button>\n        </div>\n      </form>\n    </div>\n    <div class=\"spinner hidden\"></div>\n  </div>\n</div>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/create-list": [function(require, module, exports) {
        module.exports = require('oshQP7');
    }, {}
    ],
    "IK/XRE": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", helper, options, helperMissing = helpers.helperMissing, escapeExpression = this.escapeExpression;


            buffer += "<div class=\"title\">Post on Facebook</div>\n<form id=\"share-form\" class=\"form-stacked facebook-share-form\">\n  <p class=\"comment-data\">"
            + escapeExpression((helper = helpers.currentUrl || (depth0 && depth0.currentUrl), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "url", options) : helperMissing.call(depth0, "currentUrl", "url", options)))
            + "</p>\n  <fieldset>\n      <div class=\"wrapper-input\">\n          <div class=\"input\">\n            <div id=\"fb-root\"></div>\n            <textarea name=\"share-message\" id=\"share-message\" class=\"ui-autocomplete-input\" autocomplete=\"off\" role=\"textbox\" aria-autocomplete=\"list\" aria-haspopup=\"true\"></textarea>\n            <label class=\"share-label\" for=\"share-message\">Use '@' to mention your friends.</label>\n          </div>\n      </div>\n      <div class=\"actions\">\n\n          <a class=\"btn primary submit\" data-id=\"facebook-post\">Post</a>\n      </div>\n  </fieldset>\n  <input type=\"hidden\" name=\"raw-message\" id=\"raw-message\" value=\"\">\n</form>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/facebook": [function(require, module, exports) {
        module.exports = require('IK/XRE');
    }, {}
    ],
    "flnS9y": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, functionType = "function", escapeExpression = this.escapeExpression;


            buffer += "<h1>Oops! An error occurred with SPA</h1>\n<div>\n  You can disable the New Webtoolbar from <a class=\"noscript\" href=\"/settings/labs?_nospa=true\" target=\"_top\">/settings/labs</a>.\n</div>\n<div>\nPlease report this to <a href=\"mailto:";
            if (helper = helpers.email) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.email);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "\">";
            if (helper = helpers.email) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.email);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "</a>\n</div>\n<textarea>";
            if (helper = helpers.diagnostic) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.diagnostic);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "</textarea>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/general-error": [function(require, module, exports) {
        module.exports = require('flnS9y');
    }, {}
    ],
    "hzn+xy": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};



            return "<div class=\"stopscroll\"></div>\n<div class=\"swipe right\"></div>\n<div class=\"swipe-indicator\">\n  <span>Swipe to Stumble</span>\n</div>\n";
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/glass": [function(require, module, exports) {
        module.exports = require('hzn+xy');
    }, {}
    ],
    "../templates/image": [function(require, module, exports) {
        module.exports = require('+kEqd0');
    }, {}
    ],
    "+kEqd0": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, functionType = "function", escapeExpression = this.escapeExpression;


            buffer += "<div class=\"image-viewer\">\n  <div class=\"image\" style=\"background-image: url('";
            if (helper = helpers.url) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.url);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "')\">\n    <img class=\"image-save\" src=\"";
            if (helper = helpers.url) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.url);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "\" alt=\"";
            if (helper = helpers._title) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0._title);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "\">\n  </div>\n</div>\n\n\n<div class=\"stopscroll\"></div>\n<div class=\"swipe right\"></div>\n<div class=\"swipe-indicator\">\n  <span>Swipe to Stumble</span>\n</div>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/info": [function(require, module, exports) {
        module.exports = require('0gFF0M');
    }, {}
    ],
    "0gFF0M": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, options, helperMissing = helpers.helperMissing, escapeExpression = this.escapeExpression, functionType = "function";


            buffer += "<div class=\"info-box\">\n  <div class=\"info-discover\">\n    <img class=\"info-buddyicon\" src=\"/images/combined/jorge.jpg\">\n    <div>\n       "
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "DISCOVERED_BY", options) : helperMissing.call(depth0, "i18n", "DISCOVERED_BY", options)))
            + "\n    </div>\n    <div class=\"info-name\">\n      Jorge Gordon\n    </div>\n    <div>\n      12 "
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "HOURS_AGO", options) : helperMissing.call(depth0, "i18n", "HOURS_AGO", options)))
            + "\n    </div>\n  </div>\n  <div class=\"info-image\">\n    <iframe sandbox src=\"";
            if (helper = helpers.url) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.url);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "\"></iframe>\n  </div>\n  <div class=\"info-desc\">\n    <div class=\"info-top\">\n      <div class=\"info-button share\">\n        <img src=\"/images/combined/share.png\">\n        "
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "SHARE_THIS_PAGE", options) : helperMissing.call(depth0, "i18n", "SHARE_THIS_PAGE", options)))
            + " <span class=\"arrow\">&#x25BC;</span>\n      </div>\n      <div class=\"info-button add\">\n        <img src=\"/images/combined/add.png\">\n        "
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "ADD_TO_LIST", options) : helperMissing.call(depth0, "i18n", "ADD_TO_LIST", options)))
            + "\n      </div>\n      <div class=\"info-button comment\">\n        <img src=\"/images/combined/comment.png\">\n        "
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "COMMENTS", options) : helperMissing.call(depth0, "i18n", "COMMENTS", options)))
            + "\n      </div>\n    </div>\n    <div class=\"info-share-dropdown\">\n      <div class=\"facebook\">\n        <img src=\"/images/combined/facebook.png\">\n        Facebook\n      </div>\n\n      <div class=\"twitter\">\n        <img src=\"/images/combined/twitter.png\">\n        Twitter\n      </div>\n\n      <div class=\"email\">\n        <img src=\"/images/combined/email.png\">\n        Email/Stumblers\n      </div>\n    </div>\n\n    <div class=\"info-bottom\">\n      <div class=\"info-stats\">\n        <span>\n          <span class=\"info-num\">";
            if (helper = helpers.likes) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.likes);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "</span> "
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "LIKES", options) : helperMissing.call(depth0, "i18n", "LIKES", options)))
            + "\n        </span>\n\n        <span>\n          <span class=\"info-num\">45</span> "
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "COMMENTS", options) : helperMissing.call(depth0, "i18n", "COMMENTS", options)))
            + "\n        </span>\n\n        <span>\n          <span class=\"info-num\">37</span> "
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "LISTS", options) : helperMissing.call(depth0, "i18n", "LISTS", options)))
            + "\n        </span>\n      </div>\n    </div>\n\n  </div>\n</div>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/ios-popup": [function(require, module, exports) {
        module.exports = require('VIoAo/');
    }, {}
    ],
    "VIoAo/": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};



            return "<div class=\"ios-overlay\">\n  <div class=\"ios-overlay-container\">\n    <div class=\"close-btn\">\n      <img class=\"close-btn-img\" src=\"//nb9.stumbleupon.netdna-cdn.com/bL-A8pGsd93LXbPswHs4qQ\">\n    </div>\n    <div class=\"ios-splash-header col-xs-12 col-xs-offset-0\">Download the new StumbleUpon <br> app for iPhone and iPad</div>\n    <a class=\"download-app col-xs-8 col-xs-offset-2\" href=\"http://app.appsflyer.com/id386244833?pid=su_prod&c=splash_page\" target=\"_blank\">\n      <img class=\"download-app-svg\" src=\"//nb9.stumbleupon.netdna-cdn.com/0FWNkQYwOCNrYOPvcf3B_Q\">\n    </a>\n    <div class=\"app-img col-xs-8 col-xs-offset-2\">\n      <img src=\"//nb9.stumbleupon.netdna-cdn.com/ogBgwBHbpeiXEvuZetN0qg\">\n    </div>\n    <div class=\"splash-footer col-xs-12 col-xs-offset-0\">Stop Searching and Start Stumbling!</div>\n  </div>\n</div>\n";
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/list-item": [function(require, module, exports) {
        module.exports = require('0F6DJ6');
    }, {}
    ],
    "0F6DJ6": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var stack1, helper, functionType = "function", escapeExpression = this.escapeExpression;


            if (helper = helpers.name) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.name);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            return escapeExpression(stack1);
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "qJsy/N": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};



            return "<div class=\"inner\">\n  <form>\n    <h1>Sign in to StumbleUpon</h1>\n\n    <input id=\"login-username\" type=\"text\" name=\"username\" placeholder=\"Email or Username\" autofocus=\"autofocus\" />\n    <input id=\"login-password\" type=\"password\" name=\"password\" placeholder=\"Password\" />\n\n    <button type=\"submit\" id=\"login-button\">Login</button>\n\n    <div id=\"login-chrome\">\n      Note: This beta currently works most reliably with Google Chrome.\n    </div>\n  </form>\n</div>\n";
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/login": [function(require, module, exports) {
        module.exports = require('qJsy/N');
    }, {}
    ],
    "../templates/menu": [function(require, module, exports) {
        module.exports = require('P4/UXv');
    }, {}
    ],
    "P4/UXv": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", helper, options, helperMissing = helpers.helperMissing, escapeExpression = this.escapeExpression;


            buffer += "<a href=\"/help\" class=\"menu-text\" data-id=\"menu-help\" title=\"Help\">Help</a>\n<a href=\"/settings/profile\" class=\"menu-text\" data-id=\"menu-settings\" title=\"Settings\">Settings</a>\n<a href=\"/logout\" class=\"menu-text\" data-id=\"menu-signout\" title=\"Sign Out\">Sign Out</a>\n<a href=\"/submit\" class=\"menu-text\" data-id=\"menu-addpage\" title=\"Add a Page\">Add a Page</a>\n<a href=\"/discover/interests\" class=\"menu-text\" data-id=\"menu-addinterests\">Add Interests</a></a>\n<a href=\"/stumbler/"
            + escapeExpression((helper = helpers.currentUser || (depth0 && depth0.currentUser), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "username", options) : helperMissing.call(depth0, "currentUser", "username", options)))
            + "/connections\" class=\"menu-text\" data-id=\"menu-myfriends\">My Friends</a>\n<a href=\"/stumbler/"
            + escapeExpression((helper = helpers.currentUser || (depth0 && depth0.currentUser), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "username", options) : helperMissing.call(depth0, "currentUser", "username", options)))
            + "/lists\" class=\"menu-text\" data-id=\"menu-mylists\">My Lists</a>\n<a href=\"/stumbler/"
            + escapeExpression((helper = helpers.currentUser || (depth0 && depth0.currentUser), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "username", options) : helperMissing.call(depth0, "currentUser", "username", options)))
            + "/likes\" class=\"menu-text\" data-id=\"menu-mylikes\">My Likes</a>\n\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/mode": [function(require, module, exports) {
        module.exports = require('Zox6YT');
    }, {}
    ],
    "Zox6YT": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, options, functionType = "function", escapeExpression = this.escapeExpression, self = this, helperMissing = helpers.helperMissing;

            function program1(depth0, data) {

                var buffer = "", stack1, helper;
                buffer += "data-active=\"";
                if (helper = helpers._active) {
                    stack1 = helper.call(depth0, {
                        hash: {},
                        data: data
                    });
                } else {
                    helper = (depth0 && depth0._active);
                    stack1 = typeof helper === functionType ? helper.call(depth0, {
                        hash: {},
                        data: data
                    }) : helper;
                }
                buffer += escapeExpression(stack1)
                + "\"";
                return buffer;
            }

            buffer += "<button ";
            stack1 = helpers['if'].call(depth0, (depth0 && depth0._active), {
                hash: {},
                inverse: self.noop,
                fn: self.program(1, program1, data),
                data: data
            });
            if (stack1 || stack1 === 0) {
                buffer += stack1;
            }
            buffer += " data-mode=\"";
            if (helper = helpers._mode) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0._mode);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "\" data-id=\"mode-selection\" class=\"mode-";
            if (helper = helpers._mode) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0._mode);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "\">\n  <div class=\"interest-thumb\" style=\"background-image: url(";
            if (helper = helpers.pic_thumb) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.pic_thumb);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + ")\"></div> "
            + escapeExpression((helper = helpers.titleize || (depth0 && depth0.titleize), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, (depth0 && depth0.name), options) : helperMissing.call(depth0, "titleize", (depth0 && depth0.name), options)))
            + "\n</button>\n\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "sLiusw": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", helper, options, helperMissing = helpers.helperMissing, escapeExpression = this.escapeExpression;


            buffer += "<div class=\"row\">\n  <div class=\"modes-left col-xs-3\">\n    <div class=\"title\">Top Categories</div>\n    <div class=\"categories\">\n      <div data-active=\"false\" data-mode=\"all\" data-id=\"mode-selection\" class=\"category mode-all\">\n        <span class=\"fa fa-globe\"></span>\n        All Interests\n      </div>\n      <div data-active=\"false\" data-mode=\"activity\" data-id=\"mode-selection\" class=\"category mode-activity\">\n        <span class=\"fa fa-users\"></span>\n        Activity\n      </div>\n     <div data-active=\"false\" data-mode=\"trending\" data-id=\"mode-selection\" class=\"category mode-trending\">\n        <span class=\"fa fa-line-chart\"></span>\n        Trending\n      </div>\n      <div data-active=\"false\" data-mode=\"photos\" data-id=\"mode-selection\" class=\"category mode-photos\">\n        <span class=\"fa fa-photo\"></span>\n        Photos\n      </div>\n      <div data-active=\"false\" data-mode=\"videos\" data-id=\"mode-selection\" class=\"category mode-videos\">\n        <span class=\"fa fa-video-camera\"></span>\n        Videos\n      </div>\n    </div>\n  </div>\n\n  <div class=\"modes-right col-xs-8\">\n    <div class=\"title\">My Interests <span class=\"modes-interestcount\">"
            + escapeExpression((helper = helpers.currentUser || (depth0 && depth0.currentUser), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "interests_count", options) : helperMissing.call(depth0, "currentUser", "interests_count", options)))
            + "</span><span class=\"edit-interests\"><a href=\"/discover/interests\" data-id=\"modes-editinterests\" target=\"_blank\">Add More Interests</a></span></div>\n    <div class=\"modes\"></div>\n  </div>\n</div>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/modes": [function(require, module, exports) {
        module.exports = require('sLiusw');
    }, {}
    ],
    "fkKIUk": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, options, functionType = "function", escapeExpression = this.escapeExpression, helperMissing = helpers.helperMissing;


            buffer += "<a class=\"next btn\" href=\"/su/share/";
            if (helper = helpers.publicId) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.publicId);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "\" data-id=\"next\">"
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "NEXT", options) : helperMissing.call(depth0, "i18n", "NEXT", options)))
            + "</a>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/next-share-button": [function(require, module, exports) {
        module.exports = require('fkKIUk');
    }, {}
    ],
    "SLNN4z": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, functionType = "function", escapeExpression = this.escapeExpression;


            buffer += "404 Unknown Route: ";
            if (helper = helpers.pathName) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.pathName);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/not-found": [function(require, module, exports) {
        module.exports = require('SLNN4z');
    }, {}
    ],
    "../templates/notification-count": [function(require, module, exports) {
        module.exports = require('tKqFU7');
    }, {}
    ],
    "tKqFU7": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, functionType = "function", escapeExpression = this.escapeExpression;


            if (helper = helpers._newNotificationCount) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0._newNotificationCount);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/notification-domain": [function(require, module, exports) {
        module.exports = require('lRNDei');
    }, {}
    ],
    "lRNDei": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, functionType = "function", escapeExpression = this.escapeExpression;


            buffer += "<div class=\"content\">\n  Now stumbling ";
            if (helper = helpers._domain) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0._domain);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + ".\n  You can change your stumble mode anytime.\n</div>\n<div class=\"pointer\"></div>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/notification-message-item": [function(require, module, exports) {
        module.exports = require('WshNnd');
    }, {}
    ],
    "WshNnd": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, options, functionType = "function", escapeExpression = this.escapeExpression, helperMissing = helpers.helperMissing;


            buffer += "<a href=\"/inbox\" class=\"notification-item\">\n    <img src=\"";
            if (helper = helpers._thumbnail) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0._thumbnail);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "\" height=\"25\" width=\"25\">\n    <div class=\"right-block\">\n      <div class=\"notification-username\">"
            + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.originatingUser)), stack1 == null || stack1 === false ? stack1 : stack1.data)), stack1 == null || stack1 === false ? stack1 : stack1.username)), typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
            + "</div>\n      <div class=\"notification-text\">"
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "SENT_YOU_MESSAGE", options) : helperMissing.call(depth0, "i18n", "SENT_YOU_MESSAGE", options)))
            + "</div>\n    </div>\n</a>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "8VEjOZ": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, options, functionType = "function", escapeExpression = this.escapeExpression, helperMissing = helpers.helperMissing;


            buffer += "<a href=\"/su/share/";
            if (helper = helpers.publicId) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.publicId);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "\" class=\"notification-item\">\n    <img src=\"";
            if (helper = helpers._thumbnail) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0._thumbnail);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "\" height=\"25\" width=\"25\">\n    <div class=\"right-block\">\n      <div class=\"notification-username\">"
            + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.originatingUser)), stack1 == null || stack1 === false ? stack1 : stack1.data)), stack1 == null || stack1 === false ? stack1 : stack1.username)), typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
            + "</div>\n      <div class=\"notification-text\">"
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "SHARED_PAGE_WITH_YOU", options) : helperMissing.call(depth0, "i18n", "SHARED_PAGE_WITH_YOU", options)))
            + "</div>\n    </div>\n</a>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/notification-share-item": [function(require, module, exports) {
        module.exports = require('8VEjOZ');
    }, {}
    ],
    "../templates/notification": [function(require, module, exports) {
        module.exports = require('peA8S7');
    }, {}
    ],
    "peA8S7": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, options, functionType = "function", escapeExpression = this.escapeExpression, self = this, helperMissing = helpers.helperMissing;

            function program1(depth0, data) {


                return "\n    <span class=\"notification-label\">Recent:</span><div class=\"recent-notifications\" data-id=\"notification-share\"></div>\n    ";
            }

            function program3(depth0, data) {

                var stack1, helper;
                if (helper = helpers.newMessagesCount) {
                    stack1 = helper.call(depth0, {
                        hash: {},
                        data: data
                    });
                } else {
                    helper = (depth0 && depth0.newMessagesCount);
                    stack1 = typeof helper === functionType ? helper.call(depth0, {
                        hash: {},
                        data: data
                    }) : helper;
                }
                return escapeExpression(stack1);
            }

            function program5(depth0, data) {


                return "0";
            }

            function program7(depth0, data) {

                var stack1, helper;
                if (helper = helpers.newSharesCount) {
                    stack1 = helper.call(depth0, {
                        hash: {},
                        data: data
                    });
                } else {
                    helper = (depth0 && depth0.newSharesCount);
                    stack1 = typeof helper === functionType ? helper.call(depth0, {
                        hash: {},
                        data: data
                    }) : helper;
                }
                return escapeExpression(stack1);
            }

            buffer += "\n<div class=\"menugroup-left\">\n    ";
            stack1 = helpers['if'].call(depth0, (depth0 && depth0.recentNotifications), {
                hash: {},
                inverse: self.noop,
                fn: self.program(1, program1, data),
                data: data
            });
            if (stack1 || stack1 === 0) {
                buffer += stack1;
            }
            buffer += "\n</div>\n<div class=\"menugroup-right\">\n    <a href=\"/inbox\" class=\"menu-text\" data-id=\"notification-messagelink\">\n        Messages <span class=\"statbox\">";
            stack1 = helpers['if'].call(depth0, (depth0 && depth0.newMessagesCount), {
                hash: {},
                inverse: self.program(5, program5, data),
                fn: self.program(3, program3, data),
                data: data
            });
            if (stack1 || stack1 === 0) {
                buffer += stack1;
            }
            buffer += "</span>\n    </a>\n\n    <a href=\"/stumbler/"
            + escapeExpression((helper = helpers.currentUser || (depth0 && depth0.currentUser), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "username", options) : helperMissing.call(depth0, "currentUser", "username", options)))
            + "/shares/received\" class=\"menu-text\" data-id=\"notification-shareslink\">\n        Shares <span class=\"statbox\">";
            stack1 = helpers['if'].call(depth0, (depth0 && depth0.newSharesCount), {
                hash: {},
                inverse: self.program(5, program5, data),
                fn: self.program(7, program7, data),
                data: data
            });
            if (stack1 || stack1 === 0) {
                buffer += stack1;
            }
            buffer += "</span>\n    </a>\n</div>\n\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "qLzDdG": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, functionType = "function", escapeExpression = this.escapeExpression;


            buffer += "<link rel=\"prefetch\" href=\"";
            if (helper = helpers.url) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.url);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "\">\n<link rel=\"prerender\" href=\"";
            if (helper = helpers.url) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.url);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "\">\n<iframe sandbox security=\"restricted\" src=\"";
            if (helper = helpers.url) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.url);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "\"></iframe>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/prerender": [function(require, module, exports) {
        module.exports = require('qLzDdG');
    }, {}
    ],
    "v/RJpn": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, functionType = "function", escapeExpression = this.escapeExpression;


            buffer += "<div class=\"progress-content\">\n  <h1 class=\"progress-message animated fadeIn\"></h1>\n  <div class=\"progress-wrap\">\n    <div class=\"progress-wrap-inner\">\n      <div class=\"progress-bg\"></div>\n      <div class=\"progress-remain\" style=\"width: ";
            if (helper = helpers.percent) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.percent);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "%;\"></div>\n      <div class=\"progress-stops\">\n        \n        <span class=\"stop fa fa-star star\" style=\"left: 100%;\"></span>\n      </div>\n    </div>\n  </div>\n  <span class=\"footest\"></span>\n</div>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/progress-bar/bar": [function(require, module, exports) {
        module.exports = require('v/RJpn');
    }, {}
    ],
    "cvEEgA": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var stack1, helper, functionType = "function", escapeExpression = this.escapeExpression;


            if (helper = helpers.message) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.message);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            return escapeExpression(stack1);
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/progress-bar/message": [function(require, module, exports) {
        module.exports = require('cvEEgA');
    }, {}
    ],
    "../templates/progress-bar/stop": [function(require, module, exports) {
        module.exports = require('nGwmvN');
    }, {}
    ],
    "nGwmvN": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, options, self = this, helperMissing = helpers.helperMissing, functionType = "function", escapeExpression = this.escapeExpression;

            function program1(depth0, data) {


                return "passed";
            }

            function program3(depth0, data) {


                return "active-stop animated fadeIn";
            }

            function program5(depth0, data) {


                return "\nshowing-count\n";
            }

            function program7(depth0, data) {

                var buffer = "", stack1, helper, options;
                buffer += "\n  fa fa-lg\n  ";
                stack1 = (helper = helpers.ifCond || (depth0 && depth0.ifCond), options = {
                    hash: {},
                    inverse: self.noop,
                    fn: self.program(8, program8, data),
                    data: data
                }, helper ? helper.call(depth0, (depth0 && depth0.thumb), "U", options) : helperMissing.call(depth0, "ifCond", (depth0 && depth0.thumb), "U", options));
                if (stack1 || stack1 === 0) {
                    buffer += stack1;
                }
                buffer += "\n  ";
                stack1 = (helper = helpers.ifCond || (depth0 && depth0.ifCond), options = {
                    hash: {},
                    inverse: self.noop,
                    fn: self.program(10, program10, data),
                    data: data
                }, helper ? helper.call(depth0, (depth0 && depth0.thumb), "D", options) : helperMissing.call(depth0, "ifCond", (depth0 && depth0.thumb), "D", options));
                if (stack1 || stack1 === 0) {
                    buffer += stack1;
                }
                buffer += "\n";
                return buffer;
            }
            function program8(depth0, data) {


                return " fa-thumbs-up ";
            }

            function program10(depth0, data) {


                return "fa-thumbs-down";
            }

            function program12(depth0, data) {

                var buffer = "", stack1, helper;
                buffer += "\n    ";
                if (helper = helpers.count) {
                    stack1 = helper.call(depth0, {
                        hash: {},
                        data: data
                    });
                } else {
                    helper = (depth0 && depth0.count);
                    stack1 = typeof helper === functionType ? helper.call(depth0, {
                        hash: {},
                        data: data
                    }) : helper;
                }
                buffer += escapeExpression(stack1)
                + "\n  ";
                return buffer;
            }

            function program14(depth0, data) {


                return "\n    -\n  ";
            }

            buffer += "<span class=\"stop ";
            stack1 = helpers['if'].call(depth0, (depth0 && depth0.passed), {
                hash: {},
                inverse: self.noop,
                fn: self.program(1, program1, data),
                data: data
            });
            if (stack1 || stack1 === 0) {
                buffer += stack1;
            }
            stack1 = helpers['if'].call(depth0, (depth0 && depth0.active), {
                hash: {},
                inverse: self.noop,
                fn: self.program(3, program3, data),
                data: data
            });
            if (stack1 || stack1 === 0) {
                buffer += stack1;
            }
            buffer += "\n";
            stack1 = helpers['if'].call(depth0, (depth0 && depth0.showCount), {
                hash: {},
                inverse: self.program(7, program7, data),
                fn: self.program(5, program5, data),
                data: data
            });
            if (stack1 || stack1 === 0) {
                buffer += stack1;
            }
            buffer += "\" style=\"left: ";
            if (helper = helpers.percent) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.percent);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "%;\">\n  ";
            stack1 = helpers['if'].call(depth0, (depth0 && depth0.showCount), {
                hash: {},
                inverse: self.noop,
                fn: self.program(12, program12, data),
                data: data
            });
            if (stack1 || stack1 === 0) {
                buffer += stack1;
            }
            buffer += "\n  ";
            stack1 = (helper = helpers.ifCond || (depth0 && depth0.ifCond), options = {
                hash: {},
                inverse: self.noop,
                fn: self.program(14, program14, data),
                data: data
            }, helper ? helper.call(depth0, (depth0 && depth0.thumb), "N", options) : helperMissing.call(depth0, "ifCond", (depth0 && depth0.thumb), "N", options));
            if (stack1 || stack1 === 0) {
                buffer += stack1;
            }
            buffer += "\n</span>";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/reply": [function(require, module, exports) {
        module.exports = require('Sy7dO9');
    }, {}
    ],
    "Sy7dO9": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, options, helperMissing = helpers.helperMissing, escapeExpression = this.escapeExpression, functionType = "function";


            buffer += "<div class=\"title new-share\">"
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "NEW_SHARE", options) : helperMissing.call(depth0, "i18n", "NEW_SHARE", options)))
            + "</div>\n<div class=\"message\">\n  <div class=\"message-inner\">\n    <div class=\"thumbnail\">\n      <img src=\""
            + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0._from)), stack1 == null || stack1 === false ? stack1 : stack1.picture_large)), typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
            + "\" class=\"from-thumbnail\">\n    </div>\n    <div class=\"info\">\n      <span class=\"from\">"
            + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0._from)), stack1 == null || stack1 === false ? stack1 : stack1.username)), typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
            + " said:</span>\n      <div class=\"date\">on ";
            if (helper = helpers._sharedTime) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0._sharedTime);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "</div>\n      <div class=\"message-text\">";
            if (helper = helpers._message) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0._message);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "</div>\n    </div>\n  </div>\n</div>\n\n<div class=\"title\">"
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "YOUR_REPLY", options) : helperMissing.call(depth0, "i18n", "YOUR_REPLY", options)))
            + "</div>\n<textarea class=\"reply\"></textarea>\n\n<div class=\"buttons\">\n  <input class=\"btn primary submit\" type=\"button\" value=\""
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "SEND", options) : helperMissing.call(depth0, "i18n", "SEND", options)))
            + "\">\n  <input class=\"btn cancel\" type=\"button\" value=\""
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "CANCEL", options) : helperMissing.call(depth0, "i18n", "CANCEL", options)))
            + "\">\n</div>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "Hi1lD+": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, options, functionType = "function", escapeExpression = this.escapeExpression, self = this, helperMissing = helpers.helperMissing;

            function program1(depth0, data) {

                var buffer = "", stack1, helper;
                buffer += "\n    <strong>"
                + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0._from)), stack1 == null || stack1 === false ? stack1 : stack1.username)), typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
                + " said:</strong> ";
                if (helper = helpers._message) {
                    stack1 = helper.call(depth0, {
                        hash: {},
                        data: data
                    });
                } else {
                    helper = (depth0 && depth0._message);
                    stack1 = typeof helper === functionType ? helper.call(depth0, {
                        hash: {},
                        data: data
                    }) : helper;
                }
                buffer += escapeExpression(stack1)
                + "\n  ";
                return buffer;
            }

            function program3(depth0, data) {

                var buffer = "", stack1;
                buffer += "\n    <strong>"
                + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0._from)), stack1 == null || stack1 === false ? stack1 : stack1.username)), typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
                + "</strong> sent this\n  ";
                return buffer;
            }

            buffer += "<div class=\"left\">\n  <img src=\""
            + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0._from)), stack1 == null || stack1 === false ? stack1 : stack1.picture_large)), typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
            + "\" class=\"from-thumbnail\">\n  ";
            stack1 = helpers['if'].call(depth0, (depth0 && depth0._message), {
                hash: {},
                inverse: self.program(3, program3, data),
                fn: self.program(1, program1, data),
                data: data
            });
            if (stack1 || stack1 === 0) {
                buffer += stack1;
            }
            buffer += "\n</div>\n<div class=\"right\">\n  <span class=\"stop-shares\">"
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "STOP_SHARES", options) : helperMissing.call(depth0, "i18n", "STOP_SHARES", options)))
            + "</span>\n  <span class=\"reply btn primary\">"
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "VIEW_REPLY", options) : helperMissing.call(depth0, "i18n", "VIEW_REPLY", options)))
            + "</span>\n  <span class=\"next-share-button-container\"></span>\n  <span class=\"fa fa-times\"></span>\n</div>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/share-bar": [function(require, module, exports) {
        module.exports = require('Hi1lD+');
    }, {}
    ],
    "../templates/share-contact": [function(require, module, exports) {
        module.exports = require('AOj6MC');
    }, {}
    ],
    "AOj6MC": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, functionType = "function", escapeExpression = this.escapeExpression;


            buffer += "<a class=\"share-contact\">\n    <div class=\"contact-details\">\n      <img src=\"";
            if (helper = helpers.picture_small) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.picture_small);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "\" height=\"25\" width=\"25\">\n        <div class=\"contact-name\">\n          <p><strong>";
            if (helper = helpers.username) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.username);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "</strong></p>\n          <p>";
            if (helper = helpers.name) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.name);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "</p>\n        </div>\n    </div>\n    <input type=\"checkbox\" data-userid=\"";
            if (helper = helpers.userid) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.userid);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "\">\n</a>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "z78zVX": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};



            return "<span class=\"share-external-fb\" data-id=\"share-external-fb\"><span class=\"fa fa-facebook\"></span></span>\n<span class=\"share-external-tw\" data-id=\"share-external-tw\"><span class=\"fa fa-twitter\"></span></span>\n<span class=\"share-external-li\" data-id=\"share-external-li\"><span class=\"fa fa-linkedin\"></span></span>\n\n\n\n";
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/share-external": [function(require, module, exports) {
        module.exports = require('z78zVX');
    }, {}
    ],
    "hepQFm": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", helper, options, helperMissing = helpers.helperMissing, escapeExpression = this.escapeExpression;


            buffer += "<div class=\"row\">\n  <div class=\"title col-xs-11\">Share This Page</div>\n</div>\n<div class=\"row\">\n  <div class=\"share-left col-xs-4\">\n    <ul class=\"webtb-tabs\" id=\"tabs-contact\">\n      <li class=\"mail-to\"><a data-name=\"#webtb-share-to\" data-tabname=\"mail-to\">Email</a></li>\n      <li class=\"most-shared\"><a data-name=\"#webtb-most-shared\" data-tabname=\"most-shared\">Recent</a></li>\n      <li class=\"all-contacts\"><a data-name=\"#webtb-share-contacts\" data-tabname=\"all-contacts\">Contacts</a></li>\n    </ul>\n\n    <form id=\"share-form\" class=\"form-stacked\">\n      <fieldset id=\"webtb-share-to\" class=\"wrapper-input tab-content\">\n        <div class=\"select2\" id=\"contacts-multiselect\">\n          \n        </div>\n      </fieldset>\n      <fieldset id=\"webtb-most-shared\" class=\"tab-content\">\n        \n      </fieldset>\n      <fieldset id=\"webtb-share-contacts\" class=\"tab-content\">\n        \n      </fieldset>\n\n    </form>\n\n  </div>\n  <div class=\"share-right col-xs-6\">\n    <form class=\"form-stacked\">\n      <fieldset class=\"share-right\">\n        <div class=\"wrapper-input\">\n            <div class=\"input\">\n                <textarea name=\"share-message\" id=\"share-message\" placeholder=\"Your Message...\"></textarea>\n                <div class=\"share-stumblewrapper\">\n                  <div class=\"stumbleinfo\">\n                    <div class=\"stumblethumb\"><img src=\""
            + escapeExpression((helper = helpers.currentUrl || (depth0 && depth0.currentUrl), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "_thumb", options) : helperMissing.call(depth0, "currentUrl", "_thumb", options)))
            + "\"></div>\n                    <div class=\"stumbledetails\">\n                      <div class=\"stumbletitle\">"
            + escapeExpression((helper = helpers.currentUrl || (depth0 && depth0.currentUrl), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "_title", options) : helperMissing.call(depth0, "currentUrl", "_title", options)))
            + "</div>\n                      <div class=\"stumbleviews\"><span class=\"fa fa-eye\"></span> "
            + escapeExpression((helper = helpers.currentUrl || (depth0 && depth0.currentUrl), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "_views", options) : helperMissing.call(depth0, "currentUrl", "_views", options)))
            + "</div>\n                    </div>\n                  </div>\n                </div>\n            </div>\n        </div>\n\n        <div class=\"actions\">\n            <a class=\"btn close-overlay-btn\" data-id=\"share-cancel\">Cancel</a>\n            <a class=\"btn primary submit\" data-id=\"share-send\">Send</a>\n        </div>\n\n        <div class=\"share-share-external\"></div>\n      </fieldset>\n    </form>\n  </div>\n</div>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/share": [function(require, module, exports) {
        module.exports = require('hepQFm');
    }, {}
    ],
    "../templates/stumbles/dailymotion": [function(require, module, exports) {
        module.exports = require('wxwSQl');
    }, {}
    ],
    "wxwSQl": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, functionType = "function", escapeExpression = this.escapeExpression;


            buffer += "<iframe class=\"stumble-frame dailymotion video\" src=\"http://www.dailymotion.com/embed/video/";
            if (helper = helpers._dailymotionid) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0._dailymotionid);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "?autoPlay=1&loadRelatedInPlace=1&utm_source=stumbleupon\" allowFullScreen></iframe>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "mZHNVI": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, functionType = "function", escapeExpression = this.escapeExpression;


            buffer += "<div id=\"fb-root\"></div>\n<script>(function(d, s, id) {\n  var js, fjs = d.getElementsByTagName(s)[0];\n  if (d.getElementById(id)) return;\n  js = d.createElement(s); js.id = id;\n  js.src = \"//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.0\";\n  fjs.parentNode.insertBefore(js, fjs);\n}(document, 'script', 'facebook-jssdk'));</script>\n\n<div class=\"facebook-stumble-container\">\n  <div class=\"fb-post\" data-href=\"";
            if (helper = helpers.url) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.url);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "\" data-width=\"500\"></div>\n</div>";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/stumbles/facebook": [function(require, module, exports) {
        module.exports = require('mZHNVI');
    }, {}
    ],
    "../templates/stumbles/flickr": [function(require, module, exports) {
        module.exports = require('H24zAK');
    }, {}
    ],
    "H24zAK": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, functionType = "function", escapeExpression = this.escapeExpression;


            buffer += "<iframe class=\"flickr-frame\" src=\"https://www.flickr.com/photos/";
            if (helper = helpers._flickruser) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0._flickruser);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "/";
            if (helper = helpers._flickrid) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0._flickrid);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "/player/\" allowfullscreen scrolling=\"no\" frameborder=\"no\"></iframe>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "BLHHGo": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, functionType = "function", escapeExpression = this.escapeExpression;


            buffer += "<iframe sandbox=\"allow-forms allow-scripts allow-same-origin\" class=\"stumble-frame\" src=\"";
            if (helper = helpers.url) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.url);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "\"></iframe>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/stumbles/framebreak": [function(require, module, exports) {
        module.exports = require('BLHHGo');
    }, {}
    ],
    "f2O4oI": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, functionType = "function", escapeExpression = this.escapeExpression;


            buffer += "<div class=\"image-viewer\">\n  <div class=\"image\" style=\"background-image: url('";
            if (helper = helpers.url) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.url);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "')\">\n    <img class=\"image-save\" src=\"";
            if (helper = helpers.url) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.url);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "\" alt=\"";
            if (helper = helpers._title) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0._title);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "\">\n  </div>\n</div>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/stumbles/image": [function(require, module, exports) {
        module.exports = require('f2O4oI');
    }, {}
    ],
    "FH8jaf": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, functionType = "function", escapeExpression = this.escapeExpression;


            buffer += "<div class=\"instagram\">\n  <iframe src=\"//instagram.com/p/";
            if (helper = helpers._instagramid) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0._instagramid);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "/embed/\" frameborder=\"0\" scrolling=\"no\">\n</div>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/stumbles/instagram": [function(require, module, exports) {
        module.exports = require('FH8jaf');
    }, {}
    ],
    "39CaF6": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, functionType = "function", escapeExpression = this.escapeExpression;


            buffer += "<iframe class=\"stumble-frame metacafe video\" src=\"http://www.metacafe.com/embed/";
            if (helper = helpers._metacafeid) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0._metacafeid);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "/?ap=1&utm_source=stumbleupon\" allowFullScreen frameborder=0></iframe>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/stumbles/metacafe": [function(require, module, exports) {
        module.exports = require('39CaF6');
    }, {}
    ],
    "1oaJ58": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, functionType = "function", escapeExpression = this.escapeExpression;


            buffer += "<div class=\"pinterest\">\n  <a data-pin-do=\"embedBoard\" href=\"http://www.pinterest.com/";
            if (helper = helpers._pinterestboardid) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0._pinterestboardid);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "/?utm_source=stumbleupon\" data-pin-scale-width=\"200\" data-pin-board-width=\"1280\" data-pin-scale-height=\"1280\"></a>\n  <script type=\"text/javascript\" src=\"//assets.pinterest.com/js/pinit.js\"></script>\n</div>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/stumbles/pinterest-board": [function(require, module, exports) {
        module.exports = require('1oaJ58');
    }, {}
    ],
    "../templates/stumbles/pinterest": [function(require, module, exports) {
        module.exports = require('hnIYJt');
    }, {}
    ],
    "hnIYJt": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, functionType = "function", escapeExpression = this.escapeExpression;


            buffer += "<div class=\"pinterest\">\n  <a data-pin-do=\"embedPin\" href=\"http://www.pinterest.com/pin/";
            if (helper = helpers._pinterestid) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0._pinterestid);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "/?utm_source=stumbleupon\"></a>\n  <script type=\"text/javascript\" src=\"//assets.pinterest.com/js/pinit.js\"></script>\n</div>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/stumbles/site": [function(require, module, exports) {
        module.exports = require('+GQM7K');
    }, {}
    ],
    "+GQM7K": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, self = this, functionType = "function", escapeExpression = this.escapeExpression;

            function program1(depth0, data) {


                return " dd-stumble-frame";
            }

            buffer += "<iframe class=\"stumble-frame";
            stack1 = helpers['if'].call(depth0, (depth0 && depth0._legacy), {
                hash: {},
                inverse: self.noop,
                fn: self.program(1, program1, data),
                data: data
            });
            if (stack1 || stack1 === 0) {
                buffer += stack1;
            }
            buffer += "\" src=\"";
            if (helper = helpers.url) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0.url);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "\"></iframe>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/stumbles/soundcloud": [function(require, module, exports) {
        module.exports = require('zz2tVJ');
    }, {}
    ],
    "zz2tVJ": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, functionType = "function", escapeExpression = this.escapeExpression;


            buffer += "<div class=\"soundcloud\">\n  <iframe class=\"soundcloud-frame\" scrolling=\"no\" frameborder=\"no\" src=\"https://w.soundcloud.com/player/?url=http%3A%2F%2Fapi.soundcloud.com";
            if (helper = helpers._soundcloudpath) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0._soundcloudpath);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "&auto_play=true&auto_advance=true&buying=true&liking=false&download=true&sharing=false&show_artwork=true&show_comments=false&show_playcount=true&show_user=true&utm_source=stumbleupon\"></iframe>\n</div>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "eXr6lw": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, functionType = "function", escapeExpression = this.escapeExpression;


            buffer += "<div class=\"ted\">\n  <iframe src=\"//embed-ssl.ted.com/talks/";
            if (helper = helpers._tedtalkid) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0._tedtalkid);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + ".html\" frameborder=\"0\" scrolling=\"no\" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>\n</div>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/stumbles/ted": [function(require, module, exports) {
        module.exports = require('eXr6lw');
    }, {}
    ],
    "CFQFGf": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};



            return "<div class=\"tweet-container embed-target\"></div>";
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/stumbles/tweet": [function(require, module, exports) {
        module.exports = require('CFQFGf');
    }, {}
    ],
    "5Haky1": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, functionType = "function", escapeExpression = this.escapeExpression;


            buffer += "<iframe class=\"stumble-frame vimeo video\" src=\"//player.vimeo.com/video/";
            if (helper = helpers._vimeoid) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0._vimeoid);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "?autoplay=1&utm_source=stumbleupon\" allowfullscreen></iframe>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/stumbles/vimeo": [function(require, module, exports) {
        module.exports = require('5Haky1');
    }, {}
    ],
    "../templates/stumbles/vine": [function(require, module, exports) {
        module.exports = require('aYyb3r');
    }, {}
    ],
    "aYyb3r": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, functionType = "function", escapeExpression = this.escapeExpression;


            buffer += "<iframe class=\"stumble-frame vine-embed\" src=\"https://vine.co/v/";
            if (helper = helpers._vineid) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0._vineid);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "/embed/simple?audio=1\" frameborder=\"0\"></iframe>\n\n<script async src=\"//platform.vine.co/static/scripts/embed.js\" charset=\"utf-8\"></script>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "gK1GtQ": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, functionType = "function", escapeExpression = this.escapeExpression;


            buffer += "<iframe class=\"stumble-frame youtube video\" src=\"//www.youtube.com/embed/";
            if (helper = helpers._youtubeid) {
                stack1 = helper.call(depth0, {
                    hash: {},
                    data: data
                });
            } else {
                helper = (depth0 && depth0._youtubeid);
                stack1 = typeof helper === functionType ? helper.call(depth0, {
                    hash: {},
                    data: data
                }) : helper;
            }
            buffer += escapeExpression(stack1)
            + "?autoplay=1&utm_source=stumbleupon\" frameborder=\"0\" allowfullscreen></iframe>\n\n\n<div class=\"youtube-hidetop\"></div>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/stumbles/youtube": [function(require, module, exports) {
        module.exports = require('gK1GtQ');
    }, {}
    ],
    "../templates/thumbdown": [function(require, module, exports) {
        module.exports = require('dHJCQ1');
    }, {}
    ],
    "dHJCQ1": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", helper, options, helperMissing = helpers.helperMissing, escapeExpression = this.escapeExpression;


            buffer += "<div class='thumbdown-wrapper'>\n  <a class=\"menu-text\" data-subtype=\"-2\" data-id=\"thumbdown-notforme\">"
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "NOT_FOR_ME", options) : helperMissing.call(depth0, "i18n", "NOT_FOR_ME", options)))
            + "</a>\n  <a class=\"menu-text\" data-subtype=\"-3\" data-id=\"thumbdown-seen\">"
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "ALREADY_SEEN", options) : helperMissing.call(depth0, "i18n", "ALREADY_SEEN", options)))
            + "</a>\n  <a class=\"menu-text\" data-subtype=\"-6\" data-id=\"thumbdown-doesntload\">"
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "DOESNT_LOAD", options) : helperMissing.call(depth0, "i18n", "DOESNT_LOAD", options)))
            + "</a>\n  <a class=\"menu-text\" data-subtype=\"-5\" data-id=\"thumbdown-spam\">"
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "SPAM", options) : helperMissing.call(depth0, "i18n", "SPAM", options)))
            + "</a>\n  <a class=\"menu-text\" data-id=\"thumbdown-wrongtopic\" class=\"noscript\" target=\"_top\" href=\"/content/"
            + escapeExpression((helper = helpers.currentUrl || (depth0 && depth0.currentUrl), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "urlid", options) : helperMissing.call(depth0, "currentUrl", "urlid", options)))
            + "/?showpopup=1&_nospa=true\">"
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "WRONG_TOPIC", options) : helperMissing.call(depth0, "i18n", "WRONG_TOPIC", options)))
            + "</a>\n  <a class=\"menu-text menu-blockdomain\" data-blockdomain=\"1\" data-id=\"thumbdown-block\">"
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "BLOCK_SITE", options) : helperMissing.call(depth0, "i18n", "BLOCK_SITE", options)))
            + "</a>\n<div>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/thumbnail": [function(require, module, exports) {
        module.exports = require('WveYvT');
    }, {}
    ],
    "WveYvT": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, options, functionType = "function", escapeExpression = this.escapeExpression, self = this, helperMissing = helpers.helperMissing;

            function program1(depth0, data) {

                var buffer = "", stack1, helper;
                buffer += " style=\"background-image: url('";
                if (helper = helpers._thumbnail) {
                    stack1 = helper.call(depth0, {
                        hash: {},
                        data: data
                    });
                } else {
                    helper = (depth0 && depth0._thumbnail);
                    stack1 = typeof helper === functionType ? helper.call(depth0, {
                        hash: {},
                        data: data
                    }) : helper;
                }
                buffer += escapeExpression(stack1)
                + "')\"";
                return buffer;
            }

            function program3(depth0, data) {


                return "<span class=\"fa fa-picture-o\"></span>";
            }

            buffer += " <div class=\"thumbnail-bg\"\n";
            stack1 = helpers['if'].call(depth0, (depth0 && depth0._thumbnail), {
                hash: {},
                inverse: self.noop,
                fn: self.program(1, program1, data),
                data: data
            });
            if (stack1 || stack1 === 0) {
                buffer += stack1;
            }
            buffer += ">";
            stack1 = (helper = helpers.without || (depth0 && depth0.without), options = {
                hash: {},
                inverse: self.noop,
                fn: self.program(3, program3, data),
                data: data
            }, helper ? helper.call(depth0, (depth0 && depth0._thumbnail), options) : helperMissing.call(depth0, "without", (depth0 && depth0._thumbnail), options));
            if (stack1 || stack1 === 0) {
                buffer += stack1;
            }
            buffer += "</div>\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    "../templates/toolbar": [function(require, module, exports) {
        module.exports = require('cOr8jn');
    }, {}
    ],
    "cOr8jn": [function(require, module, exports) {
        // hbsfy compiled Handlebars template
        var Handlebars = require('hbsfy/runtime');
        module.exports = Handlebars.template(function (Handlebars, depth0, helpers, partials, data) {
            this.compilerInfo = [4, '>= 1.0.0'];
            helpers = this.merge(helpers, Handlebars.helpers);
            data = data || {};
            var buffer = "", stack1, helper, options, helperMissing = helpers.helperMissing, escapeExpression = this.escapeExpression, self = this;

            function program1(depth0, data) {

                var buffer = "", helper, options;
                buffer += "\n    <a href=\"/sponsored-page\" class=\"sponsored noscript\" target=\"_blank\" data-id=\"sponsored\">\n        <div class=\"sponsored-text\">"
                + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                    hash: {},
                    data: data
                }, helper ? helper.call(depth0, "SPONSORED", options) : helperMissing.call(depth0, "i18n", "SPONSORED", options)))
                + "</div>\n    </a>\n    ";
                return buffer;
            }

            buffer += "<div class=\"inner-container\">\n  <div class=\"toolbar-left\">\n    <a class=\"button addtolist noscript\" data-id=\"addtolist\" data-tooltip=\""
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "CLICK_ADD_TO_LIST", options) : helperMissing.call(depth0, "i18n", "CLICK_ADD_TO_LIST", options)))
            + "\" href=\"javascript:void((function(d)%7Bvar%20e%3Dd.createElement(%27script%27)%3Be.setAttribute(%27type%27,%27text/javascript%27)%3Be.setAttribute(%27charset%27,%27UTF-8%27)%3Be.setAttribute(%27src%27,%27https://www.stumbleupon.com/bookmarkletclient/bookmarklet.js%3Fr%3D%27%2BMath.random())%3Bd.body.appendChild(e)%7D)(document))%3B\">\n      <span class=\"fa fa-plus\"><span style=\"display: none\">"
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "ADD_TO_LIST", options) : helperMissing.call(depth0, "i18n", "ADD_TO_LIST", options)))
            + "</span></span>\n    </a>\n    <div class=\"button comment\" data-id=\"comment\" data-tooltip=\""
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "TELL_WHAT_YOU_THINK", options) : helperMissing.call(depth0, "i18n", "TELL_WHAT_YOU_THINK", options)))
            + "\">\n      <span class=\"fa fa-comment\"></span>\n    </div>\n    <div class=\"button share\" data-id=\"share\" data-tooltip=\""
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "SHARE_TO_ANYONE", options) : helperMissing.call(depth0, "i18n", "SHARE_TO_ANYONE", options)))
            + "\">\n      <span class=\"fa fa-share-square-o\"></span>\n    </div>\n    <div class=\"button info\" data-id=\"interests\" data-touchclick=\"true\" data-tooltip=\""
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "STUMBLE_INTEREST", options) : helperMissing.call(depth0, "i18n", "STUMBLE_INTEREST", options)))
            + "\">\n      <div class=\"mode\">"
            + escapeExpression((helper = helpers.currentMode || (depth0 && depth0.currentMode), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "name", options) : helperMissing.call(depth0, "currentMode", "name", options)))
            + "</div>\n      <span class=\"fa fa-sort-desc\"></span>\n    </div>\n  </div>\n  <div class=\"toolbar-center\">\n    <div class=\"button down\" data-touchclick=\"true\" data-tooltip=\""
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "DISLIKE_PAGES", options) : helperMissing.call(depth0, "i18n", "DISLIKE_PAGES", options)))
            + "\">\n      <span class=\"fa fa-thumbs-down down\" data-id=\"thumbdown\"></span>\n      <span class=\"fa fa-sort-desc down-options\" data-id=\"thumbdownoptions\"></span>\n    </div>\n    <a class=\"button stumble noscript\" data-id=\"stumble\" href=\"http://www.stumbleupon.com/to/stumble/go/?clientid=4544d41498a10a385d3e4a8a43dfc6b1&client_type=bookmark&version=1.0\">\n      <div class=\"icon stumble loading\" data-touchclick=\"true\">\n        <div class=\"loader\"></div>\n        <div class=\"text\">Stumble</div>\n      </div>\n    </a>\n    <div class=\"button up\" data-touchclick=\"true\" data-id=\"thumbup\" data-tooltip=\""
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "LIKE_PAGES", options) : helperMissing.call(depth0, "i18n", "LIKE_PAGES", options)))
            + "\">\n      <span class=\"fa fa-thumbs-up\"></span>\n    </div>\n  </div>\n  <div class=\"toolbar-right\">\n    ";
            stack1 = helpers['if'].call(depth0, (depth0 && depth0.sponsored), {
                hash: {},
                inverse: self.noop,
                fn: self.program(1, program1, data),
                data: data
            });
            if (stack1 || stack1 === 0) {
                buffer += stack1;
            }
            buffer += "\n    <div class=\"button notification\" data-id=\"notification\" data-touchclick=\"true\">\n      <div class=\"icon notification\"></div>\n      <div class=\"triangle-right\"></div>\n    </div>\n    <div class=\"button menu\" data-touchclick=\"true\" data-id=\"menu\" data-tooltip=\""
            + escapeExpression((helper = helpers.i18n || (depth0 && depth0.i18n), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "MENU_HINT", options) : helperMissing.call(depth0, "i18n", "MENU_HINT", options)))
            + "\">\n      <img class=\"profile-thumb\" src=\""
            + escapeExpression((helper = helpers.currentUser || (depth0 && depth0.currentUser), options = {
                hash: {},
                data: data
            }, helper ? helper.call(depth0, "picture_small", options) : helperMissing.call(depth0, "currentUser", "picture_small", options)))
            + "\"/>\n    </div>\n  </div>\n</div>\n\n";
            return buffer;
        });

    }, {
        "hbsfy/runtime": 285
    }
    ],
    208: [function(require, module, exports) {
        var $, AddCommentView, View, mediator, moment, stumble, template, utils,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        $ = require('jquery');

        View = require('./base/view');

        template = require('../templates/comments');

        mediator = require('chaplin').mediator;

        stumble = require('../lib/stumble');

        moment = require('moment');

        utils = require('../lib/utils');

        module.exports = AddCommentView = (function(_super) {
            __extends(AddCommentView, _super);

            function AddCommentView() {
                return AddCommentView.__super__.constructor.apply(this, arguments);
            }

            AddCommentView.prototype.template = template;

            AddCommentView.prototype.events = {
                'click .close-overlay-btn': function() {
                    return this.publishEvent('panel:close', {
                        name: 'comment'
                    });
                },
                'click .submit': 'onSubmit'
            };

            AddCommentView.prototype.listen = {
                'comment:loading:end mediator': 'onLoadingEnd',
                'comment:loading:legacy mediator': 'onLegacyFrame'
            };

            AddCommentView.prototype.onSubmit = function(e) {
                var comment;
                comment = $.trim(this.$el.find('#edit-comment').val());
                this.collection.add({
                    body: comment,
                    urlid: stumble.getCollection().getActive().get('urlid'),
                    timestamp: utils.unix(),
                    user: mediator.userM.toJSON()
                });
                this.$el.find('#edit-comment').val('');
                this.publishEvent('share:submitted', comment);
                return this.publishEvent('panel:close');
            };

            AddCommentView.prototype.onLoadingEnd = function(data) {
                var _ref, _ref1, _ref2;
                if ((data != null ? (_ref = data.comments) != null ? (_ref1 = _ref.values) != null ? _ref1.length : void 0 : void 0 : void 0) === 0) {
                    if ((_ref2 = this.$el) != null) {
                        _ref2.find('.no-comments').removeClass('hidden');
                    }
                }
                return this.$el.find('.spinner').addClass('hidden');
            };

            AddCommentView.prototype.onLegacyFrame = function() {
                this.$el.find('.spinner').addClass('hidden');
                this.$el.find('#edit-comment').attr('disabled', true);
                this.$el.find('#edit-tags').attr('disabled', true);
                return this.$el.find('.comments-container').html("<ul class='comments-user'>Comments are not avaliable.</ul>");
            };

            return AddCommentView;

        })(View);


    }, {
        "../lib/stumble": 48,
        "../lib/utils": 69,
        "../templates/comments": "wGqA+0",
        "./base/view": 214,
        "chaplin": 268,
        "jquery": 269,
        "moment": 273
    }
    ],
    209: [function(require, module, exports) {
        var $, AddToListView, ListsView, View, i18n, jwerty, template, _,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        $ = require('jquery');

        View = require('./base/view');

        ListsView = require('./lists-view');

        template = require('../templates/add-to-list');

        i18n = require('../lib/i18n');

        _ = require('lodash');

        jwerty = require('jwerty').jwerty;

        module.exports = AddToListView = (function(_super) {
            __extends(AddToListView, _super);

            function AddToListView() {
                return AddToListView.__super__.constructor.apply(this, arguments);
            }

            AddToListView.prototype.autoRender = true;

            AddToListView.prototype.className = 'addtolist-container container';

            AddToListView.prototype.id = 'addtolist';

            AddToListView.prototype.template = template;

            AddToListView.prototype.region = 'panel';

            AddToListView.prototype.events = {
                'click .modal-close': function() {
                    return this.publishEvent('panel:close', {
                        name: 'list'
                    });
                },
                'keyup .dropdown-search': 'onKeyUp',
                'click .dropdown-create-new': function() {
                    return this.publishEvent('list:displaycreate', this.$el.find('.dropdown-search').val());
                },
                'mouseenter .dropdown-items': 'clearActive',
                'mouseleave .dropdown-items': 'clearActive',
                'focus .modal-body input': 'onInputFocus',
                'blur .modal-body input': 'onInputBlur'
            };

            AddToListView.prototype.listen = {
                'addedToDOM': 'onAddedToDOM',
                'list:itemadded mediator': 'onItemAdded',
                'list:itemadded:error mediator': 'onItemAddedError',
                'model:sync:start mediator': 'onLoadingStart'
            };

            AddToListView.prototype.onAddedToDOM = function() {
                this.subview('listsV', new ListsView({
                    collection: this.collection
                }));
                this.collection.whenPopulated().then((function(_this) {
                    return function() {
                        return _this.toggleLoading(false);
                    };
                })(this));
                this.resetList();
                return this.setTimeout((function(_this) {
                    return function() {
                        var _ref;
                        return (_ref = _this.$el) != null ? _ref.find('.dropdown-search').focus() : void 0;
                    };
                })(this), 250);
            };

            AddToListView.prototype.onInputFocus = function() {
                return this.$el.find('.modal-body .dropdown').addClass('focus-outline');
            };

            AddToListView.prototype.onInputBlur = function() {
                return this.$el.find('.modal-body .dropdown').removeClass('focus-outline');
            };

            AddToListView.prototype.clearActive = function() {
                var _ref;
                return (_ref = this.$el) != null ? _ref.find('.dropdown-item.touchactive').removeClass('touchactive') : void 0;
            };

            AddToListView.prototype.resetList = function() {
                $("li.dropdown-item").addClass('visible');
                return this.collection.invoke("set", {
                    "_visible": true
                });
            };

            AddToListView.prototype.onKeyUp = function(e) {
                var str;
                str = $(e.currentTarget).val();
                if (!str) {
                    return this.resetList();
                } else {
                    return this.filterSearch(str, this.collection);
                }
            };

            AddToListView.prototype.filterSearch = function(str, collection) {
                this.collection = collection;
                return this.collection.forEach(function(model) {
                    return model.set('_visible', _(model.get('name').toLowerCase()).contains(str.toLowerCase()));
                });
            };

            AddToListView.prototype.onLoadingStart = function(model) {
                var _ref;
                if (model === this.collection.get(model) || model === true) {
                    return (_ref = this.$el) != null ? _ref.find('.spinner').removeClass('hidden') : void 0;
                }
            };

            AddToListView.prototype.toggleLoading = function(force) {
                var _ref;
                if (force == null) {
                    force = false;
                }
                return (_ref = this.$el) != null ? _ref.find('.spinner').toggleClass('hidden', !force) : void 0;
            };

            AddToListView.prototype.onItemAdded = function(listM) {
                var msg;
                this.toggleLoading(false);
                msg = 'Added to ' + listM.get('name');
                return this.displayMsg(msg);
            };

            AddToListView.prototype.onItemAddedError = function(listM, legacy) {
                this.toggleLoading(false);
                if (legacy) {
                    return this.displayMsg(i18n('CANNOT_ADD_TO_LIST'));
                } else {
                    return this.displayMsg(i18n('ALREADY_IN_LIST'));
                }
            };

            AddToListView.prototype.displayMsg = _.debounce(function(msg) {
                return this.publishEvent('panel:open', {
                    name: 'alert',
                    type: 'success',
                    text: msg
                });
            }, 1000);

            return AddToListView;

        })(View);


    }, {
        "../lib/i18n": 42,
        "../templates/add-to-list": "ediDsA",
        "./base/view": 214,
        "./lists-view": 226,
        "jquery": 269,
        "jwerty": 270,
        "lodash": 271
    }
    ],
    210: [function(require, module, exports) {
        var AlertView, View, template,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        template = require('../templates/alert');

        View = require('./base/view');

        module.exports = AlertView = (function(_super) {
            __extends(AlertView, _super);

            function AlertView() {
                return AlertView.__super__.constructor.apply(this, arguments);
            }

            AlertView.prototype.autoRender = true;

            AlertView.prototype.className = 'alert-container container';

            AlertView.prototype.id = 'stumble-alert';

            AlertView.prototype.template = template;

            AlertView.prototype.region = 'panel';

            AlertView.prototype.events = {
                'click .alert-close': function() {
                    return this.publishEvent('panel:close');
                }
            };

            AlertView.prototype.listen = {
                'addedToDOM': 'onAddedToDOM'
            };

            AlertView.prototype.initialize = function() {
                AlertView.__super__.initialize.apply(this, arguments);
                return this.$el.addClass(this.model.get('type'));
            };

            AlertView.prototype.onAddedToDOM = function() {
                this.publishEvent('panel:alert:open');
                return this.setTimeout((function(_this) {
                    return function() {
                        return _this.publishEvent('panel:close', {
                            name: 'alert'
                        });
                    };
                })(this), '4s');
            };

            return AlertView;

        })(View);


    }, {
        "../templates/alert": "USqgHK",
        "./base/view": 214
    }
    ],
    211: [function(require, module, exports) {
        var AndroidPopup, View, template,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        template = require('../templates/android-popup');

        View = require('./base/view');

        module.exports = AndroidPopup = (function(_super) {
            __extends(AndroidPopup, _super);

            function AndroidPopup() {
                return AndroidPopup.__super__.constructor.apply(this, arguments);
            }

            AndroidPopup.prototype.template = template;

            AndroidPopup.prototype.className = 'popup';

            AndroidPopup.prototype.autoRender = true;

            AndroidPopup.prototype.events = {
                'click .close-btn': 'onClose'
            };

            AndroidPopup.prototype.onClose = function() {
                this.$el.hide();
                return this.dispose();
            };

            return AndroidPopup;

        })(View);


    }, {
        "../templates/android-popup": "kv2k5c",
        "./base/view": 214
    }
    ],
    212: [function(require, module, exports) {
        var $, AppView, ClickTracking, Tooltip, View, abTracking, mediator, template, utils, _,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        $ = require('jquery');

        _ = require('lodash');

        template = require('../templates/app');

        View = require('./base/view');

        utils = require('../lib/utils');

        Tooltip = require('../lib/tooltip');

        mediator = require('chaplin').mediator;

        ClickTracking = require('../lib/click-tracking');

        abTracking = require('../lib/ab-tracking');

        module.exports = AppView = (function(_super) {
            __extends(AppView, _super);

            function AppView() {
                return AppView.__super__.constructor.apply(this, arguments);
            }

            AppView.prototype.announceEvents = 'app';

            AppView.prototype.autoRender = true;

            AppView.prototype.container = 'body';

            AppView.prototype.id = 'app-container';

            AppView.prototype.regions = {
                'toolbar': '#toolbar-container',
                'share-bar': '#share-bar-container',
                'panel': '#panel-container',
                'stumble': '#stumble-container',
                'slide-left': '#slide-left-container',
                'slide-right': '#slide-right-container',
                'progress-bar': '#progress-bar-container'
            };

            AppView.prototype.template = template;

            AppView.prototype.listen = {
                'addedToDOM': 'onAddedToDOM'
            };

            AppView.prototype.initialize = function() {
                AppView.__super__.initialize.apply(this, arguments);
                $(window).on('resize orientationchange', _.debounce((function(_this) {
                    return function(e) {
                        return _this.publishEvent('window:resize', e);
                    };
                })(this), 500, {
                    leading: true
                }));
                $(window).on('orientationchange', _.debounce((function(_this) {
                    return function(e) {
                        return _this.publishEvent('window:orientationchange', e);
                    };
                })(this), 500, {
                    leading: true
                }));
                $(window).on('keydown', _.throttle((function(_this) {
                    return function(e) {
                        return _this.publishEvent('window:keydown', e);
                    };
                })(this), 100));
                $(window).on('popstate', (function(_this) {
                    return function(e) {
                        return _this.publishEvent('window:popstate', e);
                    };
                })(this));
                new Tooltip('#app-container');
                new ClickTracking;
                return abTracking.trackAppInit(24);
            };

            AppView.prototype.onAddedToDOM = function() {
                $.smartbanner({
                    author: "StumbleUpon",
                    daysHidden: 0,
                    daysReminder: 0,
                    title: 'StumbleUpon',
                    speedIn: 300,
                    speedOut: 300
                });
                return $(".sb-close").on('click', (function(_this) {
                    return function() {
                        return _this.closeSmartBanner();
                    };
                })(this));
            };

            AppView.prototype.closeSmartBanner = function() {
                return this.publishEvent('smartbanner:closed');
            };

            return AppView;

        })(View);


    }, {
        "../lib/ab-tracking": 38,
        "../lib/click-tracking": 40,
        "../lib/tooltip": 68,
        "../lib/utils": 69,
        "../templates/app": "Whcl4h",
        "./base/view": 214,
        "chaplin": 268,
        "jquery": 269,
        "lodash": 271
    }
    ],
    213: [function(require, module, exports) {
        var AnnounceEvents, Chaplin, CollectionView, Mixin, OldBrowser, StopTimers, View,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        Mixin = require('mixen');

        Chaplin = require('chaplin');

        View = require('./view');

        StopTimers = require('../../lib/mixins/stop-timers');

        AnnounceEvents = require('../../lib/mixins/announce-events');

        OldBrowser = require('../mixins/old-browser');

        module.exports = CollectionView = (function(_super) {
            __extends(CollectionView, _super);

            function CollectionView() {
                return CollectionView.__super__.constructor.apply(this, arguments);
            }

            CollectionView.prototype.getTemplateFunction = View.prototype.getTemplateFunction;

            CollectionView.prototype.useCssAnimation = true;

            return CollectionView;

        })(Mixin(AnnounceEvents, StopTimers, OldBrowser, Chaplin.CollectionView));


    }, {
        "../../lib/mixins/announce-events": 44,
        "../../lib/mixins/stop-timers": 45,
        "../mixins/old-browser": 228,
        "./view": 214,
        "chaplin": 268,
        "mixen": 272
    }
    ],
    214: [function(require, module, exports) {
        var $, AnnounceEvents, Backbone, Chaplin, Mixin, OldBrowser, StopTimers, View, mediator,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        $ = window.jQuery = require('jquery');

        Backbone = require('backbone');

        Backbone.$ = $;

        Mixin = require('mixen');

        Chaplin = require('chaplin');

        StopTimers = require('../../lib/mixins/stop-timers');

        AnnounceEvents = require('../../lib/mixins/announce-events');

        OldBrowser = require('../mixins/old-browser');

        mediator = require('chaplin').mediator;

        require('../../lib/view-helper');

        module.exports = View = (function(_super) {
            __extends(View, _super);

            function View() {
                return View.__super__.constructor.apply(this, arguments);
            }

            View.prototype.initialize = function() {
                View.__super__.initialize.apply(this, arguments);
                this.subscribeEvent('panel:open', this.setPanel);
                this.subscribeEvent('panel:closed', this.unsetPanel);
                if (typeof this.getTemplate === "function" ? this.getTemplate() : void 0) {
                    return this.template = this.getTemplate();
                }
            };

            View.prototype.getTemplateFunction = function() {
                return this.template;
            };

            View.prototype.setPanel = function(options) {
                var _ref;
                if (options == null) {
                    options = {};
                }
                return (_ref = this.$el) != null ? _ref.attr('data-panel', options.name) : void 0;
            };

            View.prototype.unsetPanel = function() {
                var _ref;
                return (_ref = this.$el) != null ? _ref.removeAttr('data-panel') : void 0;
            };

            return View;

        })(Mixin(AnnounceEvents, StopTimers, OldBrowser, Chaplin.View));


    }, {
        "../../lib/mixins/announce-events": 44,
        "../../lib/mixins/stop-timers": 45,
        "../../lib/view-helper": 70,
        "../mixins/old-browser": 228,
        "backbone": 267,
        "chaplin": 268,
        "jquery": 269,
        "mixen": 272
    }
    ],
    215: [function(require, module, exports) {
        var CommentView, View, template,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        template = require('../templates/comment');

        View = require('./base/view');

        module.exports = CommentView = (function(_super) {
            __extends(CommentView, _super);

            CommentView.prototype.template = template;

            CommentView.prototype.tagName = 'li';

            function CommentView() {
                CommentView.__super__.constructor.apply(this, arguments);
                this.setDefaultProfilePhoto();
            }

            CommentView.prototype.setDefaultProfilePhoto = function() {
                var profilePic;
                profilePic = this.model.get('user').picture_small;
                if (!profilePic) {
                    return this.model.get('user').picture_small = 'https://nb9-stumbleupon.netdna-ssl.com/WcjiEMsHQiBUV9Q-ZK4lDg';
                }
            };

            return CommentView;

        })(View);


    }, {
        "../templates/comment": "4qmo/s",
        "./base/view": 214
    }
    ],
    216: [function(require, module, exports) {
        var CollectionView, CommentsView,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        CollectionView = require('./base/collection-view');

        module.exports = CommentsView = (function(_super) {
            __extends(CommentsView, _super);

            function CommentsView() {
                return CommentsView.__super__.constructor.apply(this, arguments);
            }

            CommentsView.prototype.autoRender = true;

            CommentsView.prototype.tagName = 'ul';

            return CommentsView;

        })(CollectionView);


    }, {
        "./base/collection-view": 213
    }
    ],
    217: [function(require, module, exports) {
        var ContactView, View, template,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        template = require('../templates/share-contact');

        View = require('./base/view');

        module.exports = ContactView = (function(_super) {
            __extends(ContactView, _super);

            function ContactView() {
                return ContactView.__super__.constructor.apply(this, arguments);
            }

            ContactView.prototype.template = template;

            return ContactView;

        })(View);


    }, {
        "../templates/share-contact": "AOj6MC",
        "./base/view": 214
    }
    ],
    218: [function(require, module, exports) {
        var CollectionView, ContactsView,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        CollectionView = require('./base/collection-view');

        module.exports = ContactsView = (function(_super) {
            __extends(ContactsView, _super);

            function ContactsView() {
                return ContactsView.__super__.constructor.apply(this, arguments);
            }

            ContactsView.prototype.autoRender = true;

            ContactsView.prototype.useCssAnimation = false;

            ContactsView.prototype.animationDuration = 0;

            return ContactsView;

        })(CollectionView);


    }, {
        "./base/collection-view": 213
    }
    ],
    219: [function(require, module, exports) {
        var $, CreateListView, View, i18n, mediator, template, _,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        View = require('./base/view');

        template = require('../templates/create-list');

        mediator = require('chaplin').mediator;

        i18n = require('../lib/i18n');

        $ = require('jquery');

        _ = require('lodash');

        module.exports = CreateListView = (function(_super) {
            __extends(CreateListView, _super);

            function CreateListView() {
                return CreateListView.__super__.constructor.apply(this, arguments);
            }

            CreateListView.prototype.autoRender = true;

            CreateListView.prototype.className = 'createlist-container container';

            CreateListView.prototype.id = 'createlist';

            CreateListView.prototype.template = template;

            CreateListView.prototype.region = 'panel';

            CreateListView.prototype.events = {
                'click .modal-close': function() {
                    return this.publishEvent('panel:close', {
                        name: 'list'
                    });
                },
                'click #list-cancel': function() {
                    return this.publishEvent('list:displayadd');
                },
                'click #list-save': 'saveNewList'
            };

            CreateListView.prototype.listen = {
                'list:itemadded mediator': 'onItemAdded',
                'list:itemadded:error mediator': 'onItemAddedError',
                'list:itemadded:error mediator': 'onLoadingEnd',
                'list:loading:end mediator': 'onLoadingEnd',
                'model:sync:start mediator': 'onLoadingStart'
            };

            CreateListView.prototype.saveNewList = function() {
                this.model.set({
                    name: $.trim($('#list-edit-name').val()),
                    description: $.trim($('#list-edit-description').val()),
                    visibility: $('input:radio[name=visibility]:checked').val(),
                    userid: mediator.userM.get('userid')
                });
                if (this.model.get('name')) {
                    return this.model.save().error((function(_this) {
                        return function() {
                            _this.publishEvent('list:loading:end');
                            return _this.onListCreateError(_this.model);
                        };
                    })(this));
                } else {
                    return this.displayMsg(i18n('LIST_NAME_EMPTY'));
                }
            };

            CreateListView.prototype.onLoadingStart = function(model) {
                var _ref;
                if (model === this.model) {
                    return (_ref = this.$el) != null ? _ref.find('.spinner').removeClass('hidden') : void 0;
                }
            };

            CreateListView.prototype.onLoadingEnd = function() {
                var _ref;
                return (_ref = this.$el) != null ? _ref.find('.spinner').addClass('hidden') : void 0;
            };

            CreateListView.prototype.onItemAdded = function(listM) {
                var msg;
                msg = i18n('ADDED_TO') + ' ' + (listM != null ? listM.get('name') : void 0);
                return this.displayMsg(msg);
            };

            CreateListView.prototype.onListCreateError = function(listM) {
                var msg;
                msg = (listM != null ? listM.get('name') : void 0) + ' ' + i18n('ALREADY_EXISTS');
                return this.displayMsg(msg);
            };

            CreateListView.prototype.onItemAddedError = function(listM) {
                return this.displayMsg(i18n('ALREADY_IN_LIST'));
            };

            CreateListView.prototype.displayMsg = _.debounce(function(msg) {
                return this.publishEvent('panel:open', {
                    name: 'alert',
                    type: 'success',
                    text: msg
                });
            }, 1000);

            return CreateListView;

        })(View);


    }, {
        "../lib/i18n": 42,
        "../templates/create-list": "oshQP7",
        "./base/view": 214,
        "chaplin": 268,
        "jquery": 269,
        "lodash": 271
    }
    ],
    220: [function(require, module, exports) {
        var $, FacebookView, View, stumble, template,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        View = require('./base/view');

        template = require('../templates/facebook');

        stumble = require('../lib/stumble');

        $ = require('jquery');

        module.exports = FacebookView = (function(_super) {
            __extends(FacebookView, _super);

            function FacebookView() {
                return FacebookView.__super__.constructor.apply(this, arguments);
            }

            FacebookView.prototype.autoRender = true;

            FacebookView.prototype.className = 'facebook-container container';

            FacebookView.prototype.template = template;

            FacebookView.prototype.region = 'panel';

            FacebookView.prototype.events = {
                'click .submit': 'onSubmit'
            };

            FacebookView.prototype.listen = {
                'addedToDOM': 'onAddedToDOM'
            };

            FacebookView.prototype.onAddedToDOM = function() {
                var _ref;
                return (_ref = this.$el) != null ? _ref.find('#share-message').focus() : void 0;
            };

            FacebookView.prototype.onSubmit = function() {
                var $msgInput, _ref;
                $msgInput = this.$el.find('#share-message');
                this.model.set({
                    'message': $.trim($msgInput.val()),
                    'url': (_ref = stumble.getCollection().getActive()) != null ? _ref.get('url') : void 0
                });
                this.model.save().then((function(_this) {
                    return function() {
                        return _this.publishEvent('panel:open', {
                            name: 'alert',
                            type: 'success',
                            text: 'Posted to Facebook.'
                        });
                    };
                })(this), (function(_this) {
                    return function() {
                        return _this.publishEvent('panel:open', {
                            name: 'alert',
                            type: 'error'
                        });
                    };
                })(this));
                $msgInput.val('');
                return this.publishEvent('panel:close');
            };

            return FacebookView;

        })(View);


    }, {
        "../lib/stumble": 48,
        "../templates/facebook": "IK/XRE",
        "./base/view": 214,
        "jquery": 269
    }
    ],
    221: [function(require, module, exports) {
        var $, GeneralErrorView, View, root, storage, template,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        $ = require('jquery');

        template = require('../templates/general-error');

        View = require('./base/view');

        storage = require('simple-storage');

        root = require('../lib/root');

        module.exports = GeneralErrorView = (function(_super) {
            __extends(GeneralErrorView, _super);

            function GeneralErrorView() {
                return GeneralErrorView.__super__.constructor.apply(this, arguments);
            }

            GeneralErrorView.prototype.autoRender = true;

            GeneralErrorView.prototype.className = 'general-error';

            GeneralErrorView.prototype.container = 'body';

            GeneralErrorView.prototype.containerMethod = 'html';

            GeneralErrorView.prototype.template = template;

            GeneralErrorView.prototype.getTemplateData = function() {
                var diagnostic, e, _ref;
                try {
                    diagnostic = {
                        date: new Date,
                        location: root().location,
                        ua: root().navigator.userAgent,
                        userid: (_ref = storage.get('user')) != null ? _ref.userid : void 0,
                        cookies: $.cookie(),
                        assets: root().SUassets
                    };
                } catch (_error) {
                    e = _error;
                    diagnostic = {
                        date: new Date,
                        location: root().location,
                        ua: root().navigator.userAgent
                    };
                }
                return {
                    email: 'engagement@stumbleupon.com',
                    diagnostic: JSON.stringify(diagnostic)
                };
            };

            GeneralErrorView.prototype.events = {
                'click textarea': function(e) {
                    return e.target.select();
                }
            };

            return GeneralErrorView;

        })(View);


    }, {
        "../lib/root": 47,
        "../templates/general-error": "flnS9y",
        "./base/view": 214,
        "jquery": 269,
        "simple-storage": 274
    }
    ],
    222: [function(require, module, exports) {
        var $, GlassView, View, template, utils, _,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        $ = require('jquery');

        _ = require('lodash');

        template = require('../templates/glass');

        View = require('./base/view');

        utils = require('../lib/utils');

        module.exports = GlassView = (function(_super) {
            __extends(GlassView, _super);

            function GlassView() {
                return GlassView.__super__.constructor.apply(this, arguments);
            }

            GlassView.prototype.autoRender = true;

            GlassView.prototype.className = 'glass';

            GlassView.prototype.region = 'stumble';

            GlassView.prototype.template = template;

            GlassView.prototype.events = {
                'click .stopscroll': 'announceClose',
                'touchmove .stopscroll': 'announceClose'
            };

            GlassView.prototype.maxOpacity = 0.6;

            GlassView.prototype.startPos = {
                y: 0,
                x: 0
            };

            GlassView.prototype.announceClose = _.debounce(function(e) {
                e.preventDefault();
                return this.publishEvent('panel:close');
            }, 300, true);

            GlassView.prototype.toggleZoom = function() {
                var _ref;
                return (_ref = this.$el) != null ? _ref.find('.image-viewer').toggleClass('zoomed-in') : void 0;
            };

            GlassView.prototype.onAddedToDom = function() {
                return this.resizeFrame();
            };

            GlassView.prototype.resizeFrame = function() {
                if (!utils.isMobile()) {
                    return _.defer((function(_this) {
                        return function() {
                            var bodyHeight, resizeHeight, toolbarHeight;
                            bodyHeight = $(window).height();
                            toolbarHeight = $('.toolbar').outerHeight();
                            resizeHeight = bodyHeight - toolbarHeight;
                            return _this.$el.css('height', resizeHeight + 'px');
                        };
                    })(this));
                }
            };

            GlassView.prototype.render = function() {
                return this.setTimeout((function(_this) {
                    return function() {
                        return GlassView.__super__.render.apply(_this, arguments);
                    };
                })(this), 750);
            };

            return GlassView;

        })(View);


    }, {
        "../lib/utils": 69,
        "../templates/glass": "hzn+xy",
        "./base/view": 214,
        "jquery": 269,
        "lodash": 271
    }
    ],
    223: [function(require, module, exports) {
        var $, InfoView, View, template,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        $ = require('jquery');

        View = require('./base/view');

        template = require('../templates/info');

        module.exports = InfoView = (function(_super) {
            __extends(InfoView, _super);

            function InfoView() {
                return InfoView.__super__.constructor.apply(this, arguments);
            }

            InfoView.prototype.autoRender = true;

            InfoView.prototype.className = 'info large';

            InfoView.prototype.template = template;

            InfoView.prototype.region = 'panel';

            InfoView.prototype.events = {
                'click .info-button.share': function() {
                    return $('.info-share-dropdown').toggle();
                }
            };

            return InfoView;

        })(View);


    }, {
        "../templates/info": "0gFF0M",
        "./base/view": 214,
        "jquery": 269
    }
    ],
    224: [function(require, module, exports) {
        var IosPopup, View, template,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        template = require('../templates/ios-popup');

        View = require('./base/view');

        module.exports = IosPopup = (function(_super) {
            __extends(IosPopup, _super);

            function IosPopup() {
                return IosPopup.__super__.constructor.apply(this, arguments);
            }

            IosPopup.prototype.template = template;

            IosPopup.prototype.className = 'popup';

            IosPopup.prototype.autoRender = true;

            IosPopup.prototype.events = {
                'click .close-btn': 'onClose'
            };

            IosPopup.prototype.onClose = function() {
                this.$el.hide();
                return this.dispose();
            };

            return IosPopup;

        })(View);


    }, {
        "../templates/ios-popup": "VIoAo/",
        "./base/view": 214
    }
    ],
    225: [function(require, module, exports) {
        var ListView, View, template,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        template = require('../templates/list-item');

        View = require('./base/view');

        module.exports = ListView = (function(_super) {
            __extends(ListView, _super);

            function ListView() {
                return ListView.__super__.constructor.apply(this, arguments);
            }

            ListView.prototype.template = template;

            ListView.prototype.className = 'dropdown-item';

            ListView.prototype.tagName = 'li';

            ListView.prototype.events = {
                'click': function() {
                    return this.publishEvent('list:itemadd', this.model);
                }
            };

            ListView.prototype.initialize = function() {
                ListView.__super__.initialize.apply(this, arguments);
                return this.model.on("change", this.render);
            };

            ListView.prototype.render = function() {
                ListView.__super__.render.apply(this, arguments);
                return this.$el.toggleClass("visible", this.model.get('_visible'));
            };

            return ListView;

        })(View);


    }, {
        "../templates/list-item": "0F6DJ6",
        "./base/view": 214
    }
    ],
    226: [function(require, module, exports) {
        var CollectionView, ListV, ListsView,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        CollectionView = require('./base/collection-view');

        ListV = require('./list-view');

        module.exports = ListsView = (function(_super) {
            __extends(ListsView, _super);

            function ListsView() {
                return ListsView.__super__.constructor.apply(this, arguments);
            }

            ListsView.prototype.autoRender = true;

            ListsView.prototype.className = 'dropdown-items';

            ListsView.prototype.container = '.addtolist-items';

            ListsView.prototype.tagName = 'ul';

            ListsView.prototype.itemView = ListV;

            return ListsView;

        })(CollectionView);


    }, {
        "./base/collection-view": 213,
        "./list-view": 225
    }
    ],
    227: [function(require, module, exports) {
        var MenuView, View, template,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        View = require('./base/view');

        template = require('../templates/menu');

        module.exports = MenuView = (function(_super) {
            __extends(MenuView, _super);

            function MenuView() {
                return MenuView.__super__.constructor.apply(this, arguments);
            }

            MenuView.prototype.autoRender = true;

            MenuView.prototype.className = 'menu-container container';

            MenuView.prototype.template = template;

            MenuView.prototype.region = 'panel';

            return MenuView;

        })(View);


    }, {
        "../templates/menu": "P4/UXv",
        "./base/view": 214
    }
    ],
    228: [function(require, module, exports) {
        var $, OldBrowser, attach, mediator;

        mediator = require('chaplin').mediator;

        $ = require('jquery');

        attach = (function() {
            if ($) {
                return function(view) {
                    var actual;
                    actual = $(view.container);
                    if (typeof view.containerMethod === 'function') {
                        return view.containerMethod(actual, view.el);
                    } else {
                        return actual[view.containerMethod](view.el);
                    }
                };
            } else {
                return function(view) {
                    var actual;
                    actual = typeof view.container === 'string' ? document.querySelector(view.container) : view.container;
                    if (typeof view.containerMethod === 'function') {
                        return view.containerMethod(actual, view.el);
                    } else {
                        return actual[view.containerMethod](view.el);
                    }
                };
            }
        })();

        module.exports = OldBrowser = (function() {
            function OldBrowser() {}

            OldBrowser.prototype.attach = function() {
                if (this.region != null) {
                    mediator.execute('region:show', this.region, this);
                }
                if (this.container && !$.contains(document.body, this.el)) {
                    attach(this);
                    return this.trigger('addedToDOM');
                }
            };

            return OldBrowser;

        })();


    }, {
        "chaplin": 268,
        "jquery": 269
    }
    ],
    229: [function(require, module, exports) {
        var ModeView, View, template,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        template = require('../templates/mode');

        View = require('./base/view');

        module.exports = ModeView = (function(_super) {
            __extends(ModeView, _super);

            function ModeView() {
                return ModeView.__super__.constructor.apply(this, arguments);
            }

            ModeView.prototype.events = {
                'click button': function() {
                    return this.model.collection.setActive(this.model.get('name'));
                }
            };

            ModeView.prototype.autoRender = true;

            ModeView.prototype.className = 'mode-item';

            ModeView.prototype.template = template;

            return ModeView;

        })(View);


    }, {
        "../templates/mode": "Zox6YT",
        "./base/view": 214
    }
    ],
    230: [function(require, module, exports) {
        var $, CollectionView, ModeView, ModesView, storage, template,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        CollectionView = require('./base/collection-view');

        ModeView = require('./mode-view');

        template = require('../templates/modes');

        $ = require('jquery');

        storage = require('simple-storage');

        module.exports = ModesView = (function(_super) {
            __extends(ModesView, _super);

            function ModesView() {
                return ModesView.__super__.constructor.apply(this, arguments);
            }

            ModesView.prototype.autoRender = true;

            ModesView.prototype.itemView = ModeView;

            ModesView.prototype.useCssAnimation = true;

            ModesView.prototype.listSelector = '.modes';

            ModesView.prototype.template = template;

            ModesView.prototype.events = {
                'click .category': 'onClickCategory'
            };

            ModesView.prototype.listen = {
                'change:_active collection': function() {
                    return this.filter(this.filterer);
                },
                'addedToDOM': 'onAddedToDOM'
            };

            ModesView.prototype.onAddedToDOM = function() {
                var activeMode;
                activeMode = storage.get('activeMode') || 'All Interests';
                switch (activeMode) {
                case 'All Interests':
                    return this.$el.find('.mode-all').addClass('selected');
                case 'Activity':
                    return this.$el.find('.mode-activity').addClass('selected');
                case 'Trending':
                    return this.$el.find('.mode-trending').addClass('selected');
                case 'Photos':
                    return this.$el.find('.mode-photos').addClass('selected');
                case 'Videos':
                    return this.$el.find('.mode-videos').addClass('selected');
                }
            };

            ModesView.prototype.onClickCategory = function(e) {
                return this.collection.setActive($(e.target).data('mode'));
            };

            ModesView.prototype.filterCallback = function(view, included) {
                var _ref, _ref1;
                if ((_ref = view.$el) != null) {
                    _ref.toggleClass('selected', (_ref1 = view.model) != null ? _ref1.get('_active') : void 0);
                }
                if (!included) {
                    return view.dispose();
                }
            };

            return ModesView;

        })(CollectionView);


    }, {
        "../templates/modes": "sLiusw",
        "./base/collection-view": 213,
        "./mode-view": 229,
        "jquery": 269,
        "simple-storage": 274
    }
    ],
    231: [function(require, module, exports) {
        var NextShareButtonView, View, template,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        template = require('../templates/next-share-button');

        View = require('./base/view');

        module.exports = NextShareButtonView = (function(_super) {
            __extends(NextShareButtonView, _super);

            function NextShareButtonView() {
                return NextShareButtonView.__super__.constructor.apply(this, arguments);
            }

            NextShareButtonView.prototype.template = template;

            NextShareButtonView.prototype.autoRender = true;

            NextShareButtonView.prototype.className = 'next-share-button';

            return NextShareButtonView;

        })(View);


    }, {
        "../templates/next-share-button": "fkKIUk",
        "./base/view": 214
    }
    ],
    232: [function(require, module, exports) {
        var NotFoundView, View, template,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        template = require('../templates/not-found');

        View = require('./base/view');

        module.exports = NotFoundView = (function(_super) {
            __extends(NotFoundView, _super);

            function NotFoundView() {
                return NotFoundView.__super__.constructor.apply(this, arguments);
            }

            NotFoundView.prototype.autoRender = true;

            NotFoundView.prototype.className = 'not-found';

            NotFoundView.prototype.region = 'stumble';

            NotFoundView.prototype.template = template;

            return NotFoundView;

        })(View);


    }, {
        "../templates/not-found": "SLNN4z",
        "./base/view": 214
    }
    ],
    233: [function(require, module, exports) {
        var NotificationCountView, View, mediator, template,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        View = require('./base/view');

        template = require('../templates/notification-count');

        mediator = require('chaplin').mediator;

        module.exports = NotificationCountView = (function(_super) {
            __extends(NotificationCountView, _super);

            function NotificationCountView() {
                return NotificationCountView.__super__.constructor.apply(this, arguments);
            }

            NotificationCountView.prototype.autoRender = true;

            NotificationCountView.prototype.template = template;

            NotificationCountView.prototype.containerMethod = 'html';

            NotificationCountView.prototype.listen = {
                'change model': 'render',
                'addedToDOM': 'highlightNewNotifications'
            };

            NotificationCountView.prototype.highlightNewNotifications = function() {
                return this.$el.parent().toggleClass('new', mediator.notificationM.get('newSharesCount') > 0);
            };

            NotificationCountView.prototype.render = function() {
                NotificationCountView.__super__.render.apply(this, arguments);
                return this.highlightNewNotifications();
            };

            return NotificationCountView;

        })(View);


    }, {
        "../templates/notification-count": "tKqFU7",
        "./base/view": 214,
        "chaplin": 268
    }
    ],
    234: [function(require, module, exports) {
        var NotificationDomainView, View, mediator, template, utils,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        View = require('./base/view');

        template = require('../templates/notification-domain');

        mediator = require('chaplin').mediator;

        utils = require('../lib/utils');

        module.exports = NotificationDomainView = (function(_super) {
            __extends(NotificationDomainView, _super);

            function NotificationDomainView() {
                return NotificationDomainView.__super__.constructor.apply(this, arguments);
            }

            NotificationDomainView.prototype.autoRender = true;

            NotificationDomainView.prototype.autoAttach = false;

            NotificationDomainView.prototype.template = template;

            NotificationDomainView.prototype.containerMethod = 'prepend';

            NotificationDomainView.prototype.className = 'domain-mode-notification';

            NotificationDomainView.prototype.initialize = function() {
                return NotificationDomainView.__super__.initialize.apply(this, arguments);
            };

            NotificationDomainView.prototype.render = function() {
                if (this.detectAndClearDomainChange()) {
                    NotificationDomainView.__super__.render.apply(this, arguments);
                    return this.attach();
                }
            };

            NotificationDomainView.prototype.detectAndClearDomainChange = function() {
                var domain;
                if ((domain = mediator.modesC.getDomainParamFlag())) {
                    mediator.modesC.clearDomainParamFlag();
                    return domain;
                }
            };

            return NotificationDomainView;

        })(View);


    }, {
        "../lib/utils": 69,
        "../templates/notification-domain": "lRNDei",
        "./base/view": 214,
        "chaplin": 268
    }
    ],
    235: [function(require, module, exports) {
        var NotificationItemView, View,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        View = require('./base/view');

        module.exports = NotificationItemView = (function(_super) {
            __extends(NotificationItemView, _super);

            function NotificationItemView() {
                return NotificationItemView.__super__.constructor.apply(this, arguments);
            }

            NotificationItemView.prototype.autoRender = true;

            NotificationItemView.prototype.className = 'entry-share menu-item';

            NotificationItemView.prototype.initialize = function() {
                var type;
                NotificationItemView.__super__.initialize.apply(this, arguments);
                type = this.model.get('type') || 'message';
                return this.template = require("../templates/notification-" + type + "-item");
            };

            return NotificationItemView;

        })(View);


    }, {
        "./base/view": 214
    }
    ],
    236: [function(require, module, exports) {
        var $, CollectionView, NotificationItemV, NotificationItemsView, _,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        _ = require('lodash');

        $ = require('jquery');

        CollectionView = require('./base/collection-view');

        NotificationItemV = require('./notification-item-view');

        module.exports = NotificationItemsView = (function(_super) {
            __extends(NotificationItemsView, _super);

            function NotificationItemsView() {
                return NotificationItemsView.__super__.constructor.apply(this, arguments);
            }

            NotificationItemsView.prototype.itemView = NotificationItemV;

            NotificationItemsView.prototype.useCssAnimation = true;

            NotificationItemsView.prototype.container = '.recent-notifications';

            NotificationItemsView.prototype.initialize = function() {
                NotificationItemsView.__super__.initialize.apply(this, arguments);
                return this.collection.models = this.collection.filter(function(model) {
                    return model.get('type') === 'share' || model.get('type') === 'message';
                });
            };

            return NotificationItemsView;

        })(CollectionView);


    }, {
        "./base/collection-view": 213,
        "./notification-item-view": 235,
        "jquery": 269,
        "lodash": 271
    }
    ],
    237: [function(require, module, exports) {
        var NotificationView, View, template,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        View = require('./base/view');

        template = require('../templates/notification');

        module.exports = NotificationView = (function(_super) {
            __extends(NotificationView, _super);

            function NotificationView() {
                return NotificationView.__super__.constructor.apply(this, arguments);
            }

            NotificationView.prototype.template = template;

            return NotificationView;

        })(View);


    }, {
        "../templates/notification": "peA8S7",
        "./base/view": 214
    }
    ],
    238: [function(require, module, exports) {
        var PrerenderView, View, template,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        template = require('../templates/prerender');

        View = require('./base/view');

        module.exports = PrerenderView = (function(_super) {
            __extends(PrerenderView, _super);

            function PrerenderView() {
                return PrerenderView.__super__.constructor.apply(this, arguments);
            }

            PrerenderView.prototype.autoRender = true;

            PrerenderView.prototype.className = 'stumble-prerender';

            PrerenderView.prototype.template = template;

            PrerenderView.prototype.region = 'stumble';

            PrerenderView.prototype.initialize = function(options) {
                if (options == null) {
                    options = {};
                }
                this.nextGuessUrl = options.nextGuessUrl;
                return PrerenderView.__super__.initialize.apply(this, arguments);
            };

            PrerenderView.prototype.getTemplateData = function() {
                return {
                    url: this.nextGuessUrl
                };
            };

            return PrerenderView;

        })(View);


    }, {
        "../templates/prerender": "qLzDdG",
        "./base/view": 214
    }
    ],
    239: [function(require, module, exports) {
        var $, MessageView, ProgressBarView, StopListView, View, mediator, storage,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        $ = require('jquery');

        View = require('../base/view');

        storage = require('simple-storage');

        mediator = require('chaplin').mediator;

        MessageView = require('./message-view');

        StopListView = require('./stops-list-view');

        module.exports = ProgressBarView = (function(_super) {
            __extends(ProgressBarView, _super);

            function ProgressBarView() {
                return ProgressBarView.__super__.constructor.apply(this, arguments);
            }

            ProgressBarView.prototype.autoRender = true;

            ProgressBarView.prototype.className = 'progress-bar large animated fadeIn';

            ProgressBarView.prototype.id = 'progress-bar-view-container';

            ProgressBarView.prototype.template = require('../../templates/progress-bar/bar');

            ProgressBarView.prototype.region = 'panel';

            ProgressBarView.prototype.classMap = {
                '1': 'U',
                '0': 'N',
                '-1': 'D'
            };

            ProgressBarView.prototype.listen = {
                'addedToDOM': 'onAddedToDOM',
                'stumble:clicked mediator': 'onStumbleBtnClicked',
                'stumble:rating mediator': 'onStumbleRated',
                'window:orientationchange mediator': 'rerender'
            };

            ProgressBarView.prototype.initialize = function(opts) {
                ProgressBarView.__super__.initialize.apply(this, arguments);
                $("body").addClass("onboarding");
                return this.updateMsg();
            };

            ProgressBarView.prototype.rerender = function() {
                this.render();
                return this.createSubviews();
            };

            ProgressBarView.prototype.createSubviews = function() {
                this.subview('StopList', new StopListView({
                    collection: this.collection
                }));
                return this.subview('Message', new MessageView({
                    model: this.model
                }));
            };

            ProgressBarView.prototype.updateMsg = function() {
                return this.model.set('message', this.model.get('messages')[this.model.get('count')]);
            };

            ProgressBarView.prototype.onAddedToDOM = function() {
                this.createSubviews();
                return this.model.on('change:percent', this.onPercentChange, this);
            };

            ProgressBarView.prototype.onStumbleRated = function(stumbling) {
                var count, per, rating, stop, stops;
                rating = this.getRating();
                count = this.model.get('count');
                stops = this.model.get('stops');
                if (count < this.collection.length) {
                    per = this.calcPerc(count);
                    stop = this.collection.at(count);
                    stop.set({
                        passed: false,
                        percent: per,
                        thumb: this.classMap[rating]
                    });
                    if (stumbling === true) {
                        stop.set({
                            'passed': true,
                            'active': false
                        });
                        count++;
                        if (count < this.collection.length) {
                            this.collection.at(count).set('active', true);
                        }
                    }
                    this.model.set({
                        'count': count,
                        'percent': 100 - this.calcPerc(count)
                    });
                    storage.set("progressBar", JSON.stringify(this.collection.models));
                    storage.set("progressBarCount", count);
                    this.pulseStar();
                    this.updateMsg();
                    if (count === this.collection.length) {
                        return storage.set("progressBarClosed", true);
                    }
                } else if (storage.get('progressBarClosed')) {
                    return this.publishEvent('progress-bar:close');
                } else {
                    return this.updateMsg();
                }
            };

            ProgressBarView.prototype.calcPerc = function(itemCount) {
                return itemCount * (100 / this.collection.length);
            };

            ProgressBarView.prototype.pulseStar = function() {
                if (this.model.get('count') + 1 >= this.collection.length - 1) {
                    return this.$el.find('.star').addClass('animated pulse');
                }
            };

            ProgressBarView.prototype.onPercentChange = function(model, value) {
                var $percentEl;
                $percentEl = this.$percentEl || (this.$percentEl = this.$el.find('.progress-remain'));
                return $percentEl.css('width', value + '%');
            };

            ProgressBarView.prototype.getRating = function() {
                var $down, $up, rating;
                $up = $(".button.up.active");
                $down = $(".button.down.active");
                if ($up.length) {
                    rating = 1;
                } else if ($down.length) {
                    rating = - 1;
                } else {
                    rating = 0;
                }
                return rating;
            };

            ProgressBarView.prototype.onStumbleBtnClicked = function() {
                return this.onStumbleRated(true);
            };

            ProgressBarView.prototype.dispose = function() {
                $("body").removeClass("onboarding");
                $('[data-id="stumble"]').off("click", this.onStumbleBtnClicked);
                return ProgressBarView.__super__.dispose.apply(this, arguments);
            };

            return ProgressBarView;

        })(View);


    }, {
        "../../templates/progress-bar/bar": "v/RJpn",
        "../base/view": 214,
        "./message-view": 240,
        "./stops-list-view": 242,
        "chaplin": 268,
        "jquery": 269,
        "simple-storage": 274
    }
    ],
    240: [function(require, module, exports) {
        var MessageView, View,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        View = require('../base/view');

        module.exports = MessageView = (function(_super) {
            __extends(MessageView, _super);

            function MessageView() {
                return MessageView.__super__.constructor.apply(this, arguments);
            }

            MessageView.prototype.autoRender = true;

            MessageView.prototype.template = require('../../templates/progress-bar/message');

            MessageView.prototype.container = '.progress-message';

            MessageView.prototype.initialize = function() {
                MessageView.__super__.initialize.apply(this, arguments);
                return this.model.on('change:message', this.onMessageChange, this);
            };

            MessageView.prototype.onMessageChange = function(model, value) {
                var _ref;
                return (_ref = this.$el) != null ? _ref.fadeOut((function(_this) {
                    return function() {
                        var _ref1;
                        _this.render();
                        return (_ref1 = _this.$el) != null ? _ref1.fadeIn() : void 0;
                    };
                })(this)) : void 0;
            };

            return MessageView;

        })(View);


    }, {
        "../../templates/progress-bar/message": "cvEEgA",
        "../base/view": 214
    }
    ],
    241: [function(require, module, exports) {
        var StopView, View,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        View = require('../base/view');

        module.exports = StopView = (function(_super) {
            __extends(StopView, _super);

            function StopView() {
                return StopView.__super__.constructor.apply(this, arguments);
            }

            StopView.prototype.autoRender = true;

            StopView.prototype.template = require('../../templates/progress-bar/stop');

            StopView.prototype.initialize = function() {
                StopView.__super__.initialize.apply(this, arguments);
                this.model.on('change:thumb', this.onThumbChange, this);
                return this.model.on('change:active', this.onActiveChange, this);
            };

            StopView.prototype.onThumbChange = function() {
                this.model.set('showCount', false);
                return this.fadeRender();
            };

            StopView.prototype.fadeRender = function() {
                var _ref;
                return (_ref = this.$el) != null ? _ref.fadeOut((function(_this) {
                    return function() {
                        var _ref1;
                        _this.render();
                        return (_ref1 = _this.$el) != null ? _ref1.fadeIn() : void 0;
                    };
                })(this)) : void 0;
            };

            StopView.prototype.onActiveChange = function(model, value) {
                return this.fadeRender();
            };

            return StopView;

        })(View);


    }, {
        "../../templates/progress-bar/stop": "nGwmvN",
        "../base/view": 214
    }
    ],
    242: [function(require, module, exports) {
        var CollectionView, StopView, StopsListView,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        CollectionView = require('../base/collection-view');

        StopView = require('./stop-view');

        module.exports = StopsListView = (function(_super) {
            __extends(StopsListView, _super);

            function StopsListView() {
                return StopsListView.__super__.constructor.apply(this, arguments);
            }

            StopsListView.prototype.container = '.progress-stops';

            StopsListView.prototype.itemView = StopView;

            return StopsListView;

        })(CollectionView);


    }, {
        "../base/collection-view": 213,
        "./stop-view": 241
    }
    ],
    243: [function(require, module, exports) {
        var ReplyView, ShareM, View, i18n, template,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        template = require('../templates/reply');

        View = require('./base/view');

        ShareM = require('../models/share-model');

        i18n = require('../lib/i18n');

        module.exports = ReplyView = (function(_super) {
            __extends(ReplyView, _super);

            function ReplyView() {
                return ReplyView.__super__.constructor.apply(this, arguments);
            }

            ReplyView.prototype.template = template;

            ReplyView.prototype.autoRender = true;

            ReplyView.prototype.events = {
                'click .submit': 'submit',
                'click .cancel': 'cancel'
            };

            ReplyView.prototype.submit = function() {
                var from, message, shareM, userids, _ref, _ref1;
                shareM = new ShareM;
                message = (_ref = this.$el) != null ? _ref.find('.reply').val() : void 0;
                from = (_ref1 = this.model.get('_from')) != null ? _ref1.userid : void 0;
                userids = [from];
                shareM.set('message', message);
                shareM.set('userids', userids);
                shareM.set('url', this.model.get('url'));
                this.publishEvent('panel:close');
                return shareM.save().then((function(_this) {
                    return function() {
                        return _this.publishEvent('panel:open', {
                            name: 'alert',
                            type: 'success',
                            text: i18n('YOUR_MESSAGE_SENT')
                        });
                    };
                })(this), (function(_this) {
                    return function() {
                        return _this.publishEvent('panel:open', {
                            name: 'alert',
                            type: 'error'
                        });
                    };
                })(this));
            };

            ReplyView.prototype.cancel = function() {
                return this.publishEvent('panel:close');
            };

            return ReplyView;

        })(View);


    }, {
        "../lib/i18n": 42,
        "../models/share-model": 92,
        "../templates/reply": "Sy7dO9",
        "./base/view": 214
    }
    ],
    244: [function(require, module, exports) {
        var $, NextShareButtonView, NotificationItemsC, ShareBarView, View, i18n, mediator, template, utils,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        template = require('../templates/share-bar');

        View = require('./base/view');

        utils = require('../lib/utils');

        $ = require('jquery');

        i18n = require('../lib/i18n');

        NotificationItemsC = require('../models/notification-items-collection');

        mediator = require('chaplin').mediator;

        NextShareButtonView = require('./next-share-button-view');

        module.exports = ShareBarView = (function(_super) {
            __extends(ShareBarView, _super);

            function ShareBarView() {
                return ShareBarView.__super__.constructor.apply(this, arguments);
            }

            ShareBarView.prototype.template = template;

            ShareBarView.prototype.autoRender = true;

            ShareBarView.prototype.className = 'share-bar container';

            ShareBarView.prototype.region = 'share-bar';

            ShareBarView.prototype.announceEvents = 'sharebar';

            ShareBarView.prototype.listen = {
                'notifications:new mediator': 'initSubview'
            };

            ShareBarView.prototype.events = {
                'click .fa-times': 'close',
                'click .stop-shares': function() {
                    return this.toggleBlockShares(false);
                },
                'click .allow-shares': function() {
                    return this.toggleBlockShares(true);
                },
                'click .reply': function() {
                    return this.publishEvent('panel:open', {
                        name: 'reply',
                        model: this.model
                    });
                }
            };

            ShareBarView.prototype.initSubview = function() {
                var nextShareM, notificationItemsC;
                notificationItemsC = new NotificationItemsC(mediator.notificationM.get('recentNotifications'));
                nextShareM = notificationItemsC != null ? notificationItemsC.findWhere({
                    'type': 'share'
                }) : void 0;
                if ((nextShareM != null ? nextShareM.get('publicId') : void 0) != null) {
                    return this.subview('next-share-button', new NextShareButtonView({
                        model: nextShareM,
                        container: '.next-share-button-container',
                        tagName: 'span',
                        containerMethod: 'html'
                    }));
                }
            };

            ShareBarView.prototype.toggleBlockShares = function(bool) {
                var prefix, userid, _ref, _ref1;
                prefix = utils.getStumbleUrl();
                userid = (_ref = this.model) != null ? (_ref1 = _ref.get('_from')) != null ? _ref1.userid : void 0 : void 0;
                this.$el.find('.stop-shares,.allow-shares').text(i18n('SAVING'));
                return $.get("" + prefix + "/su/api/blockusershares?src=webtb&userid=" + userid + "&block=" + bool).always((function(_this) {
                    return function() {
                        _this.$el.find('.stop-shares').text(i18n('ALLOW_SHARES'));
                        _this.$el.find('.allow-shares').text(i18n('STOP_SHARES'));
                        return _this.$el.find('.stop-shares,.allow-shares').toggleClass('allow-shares').toggleClass('stop-shares');
                    };
                })(this));
            };

            ShareBarView.prototype.close = function() {
                this.$el.remove();
                return this.trigger('closed');
            };

            return ShareBarView;

        })(View);


    }, {
        "../lib/i18n": 42,
        "../lib/utils": 69,
        "../models/notification-items-collection": 90,
        "../templates/share-bar": "Hi1lD+",
        "./base/view": 214,
        "./next-share-button-view": 231,
        "chaplin": 268,
        "jquery": 269
    }
    ],
    245: [function(require, module, exports) {
        var ShareExternalView, View, stumble, template,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        template = require('../templates/share-external');

        View = require('./base/view');

        stumble = require('../lib/stumble');

        module.exports = ShareExternalView = (function(_super) {
            __extends(ShareExternalView, _super);

            function ShareExternalView() {
                return ShareExternalView.__super__.constructor.apply(this, arguments);
            }

            ShareExternalView.prototype.template = template;

            ShareExternalView.prototype.className = 'share-external';

            ShareExternalView.prototype.events = {
                'click [data-id=share-external-fb]': function() {
                    return this.setExternalShare('fb');
                },
                'click [data-id=share-external-tw]': function() {
                    return this.setExternalShare('tw');
                },
                'click [data-id=share-external-li]': function() {
                    return this.setExternalShare('li');
                }
            };

            ShareExternalView.prototype.listen = {
                'share:submitted mediator': 'saveExternal'
            };

            ShareExternalView.prototype.saveExternal = function(message) {
                var services, _ref;
                services = this.getServices();
                if (message && services.length > 0) {
                    this.model.set({
                        'message': message,
                        'url': (_ref = stumble.getCollection().getActive()) != null ? _ref.get('url') : void 0,
                        'type': 'external',
                        'services': services
                    });
                    return this.model.save().then((function(_this) {
                        return function() {
                            return _this.publishEvent('panel:open', {
                                name: 'alert',
                                type: 'success',
                                text: 'Your message has been sent'
                            });
                        };
                    })(this), (function(_this) {
                        return function() {
                            return _this.publishEvent('panel:open', {
                                name: 'alert',
                                type: 'error'
                            });
                        };
                    })(this));
                }
            };

            ShareExternalView.prototype.setExternalShare = function(platform) {
                return this.$el.find('[data-id=share-external-' + platform + ']').toggleClass('active');
            };

            ShareExternalView.prototype.getServices = function() {
                var services;
                services = [];
                if (this.$el.find('[data-id=share-external-fb]').hasClass('active')) {
                    services.push('facebook');
                }
                if (this.$el.find('[data-id=share-external-tw]').hasClass('active')) {
                    services.push('twitter');
                }
                if (this.$el.find('[data-id=share-external-li]').hasClass('active')) {
                    services.push('linkedin');
                }
                return services;
            };

            return ShareExternalView;

        })(View);


    }, {
        "../lib/stumble": 48,
        "../templates/share-external": "z78zVX",
        "./base/view": 214
    }
    ],
    246: [function(require, module, exports) {
        var $, ShareView, View, i18n, mediator, stumble, template, utils, _,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        $ = require('jquery');

        _ = require('lodash');

        View = require('./base/view');

        template = require('../templates/share');

        mediator = require('chaplin').mediator;

        utils = require('../lib/utils');

        i18n = require('../lib/i18n');

        stumble = require('../lib/stumble');

        module.exports = ShareView = (function(_super) {
            __extends(ShareView, _super);

            function ShareView() {
                return ShareView.__super__.constructor.apply(this, arguments);
            }

            ShareView.prototype.template = template;

            ShareView.prototype.events = {
                'click #tabs-contact': 'onClickTab',
                'click .contact-details': 'selectContact',
                'click .close-overlay-btn': 'closeShare',
                'click .submit': 'onSubmit',
                'click #webtb-share-to': function() {
                    return $('.select2-input').focus();
                },
                'focus #share-message': 'onInputFocus',
                'blur #share-message': 'onInputBlur'
            };

            ShareView.prototype.listen = {
                'addedToDOM': 'onAddedToDOM'
            };

            ShareView.prototype.onAddedToDOM = function() {
                var newArr;
                if (mediator.contactsC.getMostShared().length > 0) {
                    this.switchTabs($('[data-name="#webtb-most-shared"]'));
                } else {
                    this.switchTabs($('[data-name="#webtb-share-contacts"]'));
                }
                newArr = _.map(mediator.contactsC.toJSON(), function(obj, key) {
                    var newObj, user;
                    user = obj.username || obj.email;
                    return newObj = {
                        text: user,
                        id: user
                    };
                });
                return $('#contacts-multiselect').select2({
                    placeholder: i18n('ADD_EMAIL_OR_USERNAMES'),
                    multiple: true,
                    tags: newArr,
                    width: '100%',
                    dropdownCssClass: 'share-dropdown'
                });
            };

            ShareView.prototype.closeShare = function() {
                this.$el.find('#share-message').val('');
                this.closeSelect2();
                return this.publishEvent('panel:close', {
                    name: 'share'
                });
            };

            ShareView.prototype.onInputFocus = function() {
                this.closeSelect2();
                return this.$el.find('.input').addClass('focus-outline');
            };

            ShareView.prototype.onInputBlur = function() {
                return this.$el.find('.input').removeClass('focus-outline');
            };

            ShareView.prototype.closeSelect2 = function() {
                return $('#contacts-multiselect').select2("close");
            };

            ShareView.prototype.onClickTab = function(e) {
                var tab;
                e.preventDefault();
                this.closeSelect2();
                tab = $(e.target);
                if (tab.data('name')) {
                    return this.switchTabs(tab);
                }
            };

            ShareView.prototype.switchTabs = function(tab) {
                var _ref, _ref1;
                if (tab.data('name') === '#webtb-share-to') {
                    if ((_ref = this.$el) != null) {
                        _ref.find('.no-contacts').addClass('hidden');
                    }
                } else if (mediator.contactsC.length === 0) {
                    if ((_ref1 = this.$el) != null) {
                        _ref1.find('.no-contacts').removeClass('hidden');
                    }
                }
                $('#tabs-contact').find('li').removeClass('active');
                tab.closest('li').addClass('active');
                $('.tab-content').removeClass('active');
                return $(tab.data('name')).addClass('active');
            };

            ShareView.prototype.selectContact = function(e) {
                var $checkbox;
                e.preventDefault();
                $checkbox = $(e.target).closest('.share-contact').find(':checkbox');
                if ($checkbox.prop('checked')) {
                    return $checkbox.prop('checked', false);
                } else {
                    return $checkbox.prop('checked', true);
                }
            };

            ShareView.prototype.onSubmit = function() {
                var emails, types, userids, _ref;
                this.closeSelect2();
                this.recipients = $.trim($('#contacts-multiselect').val()).split(",");
                if (!this.recipients[0]) {
                    this.recipients = null;
                }
                types = this.getTypes();
                emails = this.getEmails(this.recipients);
                userids = this.getUserIds(this.recipients);
                this.model.set({
                    message: $.trim(this.$el.find('#share-message').val()),
                    url: (_ref = stumble.getCollection().getActive()) != null ? _ref.get('url') : void 0
                });
                if (types.user) {
                    this.model.set({
                        'type': 'user',
                        'userids': userids
                    });
                    this.updateModel();
                }
                if (types.email) {
                    this.model.set({
                        'type': 'email',
                        'emails': emails
                    });
                    this.updateModel();
                }
                this.publishEvent('share:submitted', this.model.get('message'));
                return this.closeShare();
            };

            ShareView.prototype.updateModel = function() {
                return this.model.save().then((function(_this) {
                    return function() {
                        return _this.publishEvent('panel:open', {
                            name: 'alert',
                            type: 'success',
                            text: i18n('YOUR_MESSAGE_SENT')
                        });
                    };
                })(this), (function(_this) {
                    return function() {
                        return _this.publishEvent('panel:open', {
                            name: 'alert',
                            type: 'error'
                        });
                    };
                })(this));
            };

            ShareView.prototype.getTypes = function() {
                var types;
                types = {
                    user: false,
                    email: false
                };
                if (this.$el.find('.share-contact input:checked').length > 0 || this.getUserIds(this.recipients)[0]) {
                    types.user = true;
                }
                if (this.getEmails(this.recipients)[0]) {
                    types.email = true;
                }
                return types;
            };

            ShareView.prototype.getEmails = function(recipients) {
                if (recipients == null) {
                    recipients = [];
                }
                return _(recipients).filter(utils.isEmail).unique().value();
            };

            ShareView.prototype.getUserIds = function(recipients) {
                var all, contacts, followers, following, userids;
                if (recipients == null) {
                    recipients = [];
                }
                contacts = mediator.contactsC.toJSON();
                followers = mediator.followersC.toJSON();
                following = mediator.followingC.toJSON();
                all = contacts.concat(followers, following);
                userids = _(recipients).map(function(recipient) {
                    var contact;
                    contact = _(all).find({
                        'username': recipient
                    }) || _(all).find({
                        'email': recipient
                    });
                    return contact != null ? contact.userid : void 0;
                });
                this.$el.find('.share-contact input:checked').each(function() {
                    return userids.push($(this).data('userid'));
                });
                return _(userids).without(null).unique().value();
            };

            ShareView.prototype.dispose = function() {
                this.closeSelect2();
                return ShareView.__super__.dispose.apply(this, arguments);
            };

            return ShareView;

        })(View);


    }, {
        "../lib/i18n": 42,
        "../lib/stumble": 48,
        "../lib/utils": 69,
        "../templates/share": "hepQFm",
        "./base/view": 214,
        "chaplin": 268,
        "jquery": 269,
        "lodash": 271
    }
    ],
    247: [function(require, module, exports) {
        var $, Chaplin, StumbleView, View, analytics, mediator, root, storage, stumble, utils, _,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        _ = require('lodash');

        Chaplin = require('chaplin');

        View = require('./base/view');

        utils = require('../lib/utils');

        mediator = require('chaplin').mediator;

        root = require('../lib/root');

        stumble = require('../lib/stumble');

        analytics = require('../lib/analytics');

        storage = require('simple-storage');

        $ = require('jquery');

        module.exports = StumbleView = (function(_super) {
            __extends(StumbleView, _super);

            function StumbleView() {
                return StumbleView.__super__.constructor.apply(this, arguments);
            }

            StumbleView.prototype.autoRender = true;

            StumbleView.prototype.className = 'stumble';

            StumbleView.prototype.region = 'stumble';

            StumbleView.prototype.events = {
                'click .image-viewer': 'toggleZoom'
            };

            StumbleView.prototype.listen = {
                'window:resize mediator': 'resizeFrame',
                'sharebar:closed mediator': 'resizeFrame',
                'smartbanner:closed mediator': function() {
                    return this.resizeFrame(false, true);
                },
                'panel:open mediator': 'onPanelOpen',
                'panel:close mediator': 'onPanelClose',
                'progressbar:close mediator': function() {
                    return this.resizeFrame(false);
                },
                'addedToDOM': 'onAddedToDOM',
                'startloading': function(data) {
                    return this.startedLoading = _.now();
                },
                'loaded': 'onLoaded',
                'stumble:loaded mediator': 'displayCurrentOnly',
                'stumble:prepainttimeout mediator': 'displayCurrentOnly',
                'mode:activechanged mediator': function() {
                    return mediator.loadTimes = [];
                },
                'dd:pageloaded mediator': 'onDDPageload'
            };

            StumbleView.prototype.announcedLoaded = false;

            StumbleView.prototype.announceEvents = 'stumble';

            StumbleView.prototype.maxWait = 2000;

            StumbleView.prototype.minWait = 400;

            StumbleView.prototype.initialize = function() {
                StumbleView.__super__.initialize.apply(this, arguments);
                mediator.sessionStumbleViews += 1;
                return this.model.on('change:rating', (function(_this) {
                    return function() {
                        var event;
                        event = ['stumble:rating'].concat(arguments);
                        return _this.publishEvent.apply(_this, event);
                    };
                })(this));
            };

            StumbleView.prototype.getTemplate = function() {
                var template;
                template = this.model.get('_template');
                return require("../templates/stumbles/" + template);
            };

            StumbleView.prototype.toggleZoom = function() {
                var _ref;
                return (_ref = this.$el) != null ? _ref.find('.image-viewer').toggleClass('zoomed-in') : void 0;
            };

            StumbleView.prototype.displayCurrentOnly = function(urlid) {
                var currentUrlid, _ref, _ref1;
                currentUrlid = stumble.getCollection().getActive().get('urlid');
                if (((_ref = this.model) != null ? _ref.get('urlid') : void 0) !== currentUrlid) {
                    return this.dispose(true);
                } else {
                    return (_ref1 = this.$el) != null ? _ref1.addClass('loaded') : void 0;
                }
            };

            StumbleView.prototype.getPaintTimeout = function() {
                var median, waitTime;
                median = utils.getMedian(mediator.loadTimes) || 2000;
                waitTime = median * 0.3;
                if (waitTime > this.maxWait) {
                    return this.maxWait;
                } else if (waitTime < this.minWait) {
                    return this.minWait;
                } else {
                    return waitTime;
                }
            };

            StumbleView.prototype.onPanelClose = function() {
                var _ref;
                this.resizeFrame(true);
                return (_ref = this.$el) != null ? _ref.find('.stumble-frame').addClass('panel-closing') : void 0;
            };

            StumbleView.prototype.onPanelOpen = function() {
                var _ref;
                this.resizeFrame();
                return (_ref = this.$el) != null ? _ref.find('.stumble-frame').removeClass('panel-closing') : void 0;
            };

            StumbleView.prototype.resizeFrame = function(closed, smartbannerClosed) {
                return _.defer((function(_this) {
                    return function() {
                        var bodyHeight, progressBarHeight, resizeHeight, shareBarHeight, toolbarHeight, _ref;
                        bodyHeight = $(window).height();
                        toolbarHeight = $('.toolbar').outerHeight();
                        shareBarHeight = $('.share-bar').outerHeight();
                        progressBarHeight = $('#panel-container').outerHeight() > 0 && !closed ? 0 : $('#progress-bar-container').outerHeight();
                        resizeHeight = bodyHeight - toolbarHeight - shareBarHeight - progressBarHeight;
                        if ((_ref = _this.$el) != null) {
                            _ref.css('height', resizeHeight + 'px');
                        }
                        $('#stumble-container .stopscroll, .swipe').css({
                            'height': resizeHeight + 'px'
                        });
                        return _this.translatePosition(closed, smartbannerClosed);
                    };
                })(this));
            };

            StumbleView.prototype.translatePosition = function(closed, smartbannerClosed) {
                var offsetY, panelHeight, smartBannerHeight, toolbarTranslate, translate, _ref;
                panelHeight = closed === true ? 0 : $('#panel-container').outerHeight();
                smartBannerHeight = smartbannerClosed === true ? 0 : $('#smartbanner').outerHeight();
                offsetY = panelHeight + smartBannerHeight;
                translate = 'translate3d(0,' + offsetY + 'px, 0)';
                toolbarTranslate = 'translate3d(0,' + smartBannerHeight + 'px, 0)';
                if ((_ref = this.$el) != null) {
                    _ref.css({
                        '-webkit-transform': translate,
                        'transform': translate
                    });
                }
                $('#stumble-container .stopscroll, .swipe').css({
                    '-webkit-transform': translate,
                    'transform': translate
                });
                return $('.toolbar').css({
                    '-webkit-transform': toolbarTranslate,
                    'transform': toolbarTranslate
                });
            };

            StumbleView.prototype.announceLoaded = function(name) {
                if (name == null) {
                    name = 'loaded';
                }
                if (!this.announcedLoaded) {
                    this.trigger(name, {
                        urlid: this.model.get('urlid'),
                        timestamp: utils.unix(),
                        duration: _.now() - this.startedLoading
                    });
                }
                if (name === 'loaded') {
                    return this.announcedLoaded = true;
                }
            };

            StumbleView.prototype.getDDFrame = function() {
                var $ddFrame, _ref;
                $ddFrame = (_ref = this.$el) != null ? _ref.find('.dd-stumble-frame') : void 0;
                if (!_.isEmpty($ddFrame)) {
                    return $ddFrame;
                }
            };

            StumbleView.prototype.stripNoSpaFromTiles = function() {
                var $ddFrame, interval;
                $ddFrame = this.getDDFrame();
                if ($ddFrame != null) {
                    return interval = this.setInterval((function(_this) {
                        return function() {
                            var e, _ref;
                            try {
                                return $ddFrame != null ? (_ref = $ddFrame.contents()) != null ? _ref.find('a[href^="/to/s/"],a[href*="/su/share"],a[href^="/interest/"],a[href*="/stumbler/"]').not('[data-spa-replaced]').each(function() {
                                    var href, route, urlid;
                                    href = this.getAttribute('href');
                                    urlid = href.split('?').shift().split('/to/s/').pop().split('/su/').pop();
                                    if (urlid.match('/interest/') || urlid.match('/stumbler/')) {
                                        route = urlid;
                                    } else {
                                        route = "/su/" + urlid + "?from=" + (encodeURIComponent(href));
                                    }
                                    return $(this).attr('href', route).attr('data-spa-replaced', true).attr('target', '_top').css({
                                        'cursor': 'pointer'
                                    }).one('click', function(e) {
                                        if (!(e.which > 1)) {
                                            e.preventDefault();
                                            clearInterval(interval);
                                            if (!($(e.target).hasClass('make-cover') || $(e.target).hasClass('current-cover'))) {
                                                Chaplin.utils.redirectTo({
                                                    url: route
                                                });
                                            }
                                            return false;
                                        }
                                    });
                                }) : void 0 : void 0;
                            } catch (_error) {
                                e = _error;
                                return clearInterval(interval);
                            }
                        };
                    })(this), 500);
                }
            };

            StumbleView.prototype.overrideOnPageStumble = function() {
                var $ddFrame, interval;
                $ddFrame = this.getDDFrame();
                if ($ddFrame != null) {
                    return interval = this.setInterval((function(_this) {
                        return function() {
                            var $doubleDownStumbleButton, e, mode, stumbleButtonData, _ref, _ref1;
                            try {
                                $doubleDownStumbleButton = $ddFrame != null ? (_ref = $ddFrame.contents()) != null ? _ref.find('.stumble-button').not('[data-spa-replaced]').clone() : void 0 : void 0;
                                if (!_.isEmpty($doubleDownStumbleButton)) {
                                    if ($ddFrame != null) {
                                        if ((_ref1 = $ddFrame.contents()) != null) {
                                            _ref1.find('.stumble-button').replaceWith($doubleDownStumbleButton);
                                        }
                                    }
                                    $doubleDownStumbleButton.attr('data-spa-replaced', true);
                                    stumbleButtonData = $doubleDownStumbleButton.data();
                                    mode = stumbleButtonData != null ? stumbleButtonData.mode : void 0;
                                    return $doubleDownStumbleButton.on('click', function(e) {
                                        var modeInfo;
                                        e.stopImmediatePropagation();
                                        e.preventDefault();
                                        modeInfo = {};
                                        if (mode) {
                                            switch (mode) {
                                            case 'all':
                                                stumbleButtonData.contextual = 'All Interests';
                                                break;
                                            case 'instumbler':
                                                modeInfo = {
                                                    _mode: 'user',
                                                    userids: [stumbleButtonData.stumbler]
                                                };
                                                break;
                                            case 'topic':
                                                modeInfo = {
                                                    _mode: 'topic',
                                                    id: stumbleButtonData.topic
                                                };
                                                break;
                                            case 'tag':
                                                modeInfo = {
                                                    _mode: 'keyword',
                                                    name: stumbleButtonData.contextual,
                                                    keyword: stumbleButtonData.q
                                                };
                                                break;
                                            case 'stumblelist':
                                                modeInfo = {
                                                    _mode: 'list',
                                                    listId: stumbleButtonData.s_prefixed_listid.slice(1)
                                                };
                                            }
                                            modeInfo.name = _.capitalize(stumbleButtonData.contextual);
                                            modeInfo._hide = true;
                                            storage.set('modeInfo', modeInfo);
                                            mediator.modesC.add(_.extend(modeInfo));
                                            return mediator.modesC.setActive(stumbleButtonData.contextual);
                                        } else {
                                            return this.trigger('next');
                                        }
                                    });
                                }
                            } catch (_error) {
                                e = _error;
                                return clearInterval(interval);
                            }
                        };
                    })(this), 500);
                }
            };

            StumbleView.prototype.stripDDPushState = function() {
                var $ddFrame, interval;
                $ddFrame = this.getDDFrame();
                if ($ddFrame != null) {
                    return interval = this.setInterval((function(_this) {
                        return function() {
                            var e, _ref;
                            try {
                                return $ddFrame != null ? (_ref = $ddFrame.contents()) != null ? _ref.find('.nav-homepage-links .pushState').not('[data-spa-replaced]').each(function() {
                                    var $el, updatedHref;
                                    $el = $(this);
                                    updatedHref = $el.attr('href').replace('&_nospa=true', '');
                                    return $el.removeClass('pushState').attr('href', updatedHref).attr('data-spa-replaced', true);
                                }) : void 0 : void 0;
                            } catch (_error) {
                                e = _error;
                                return clearInterval(interval);
                            }
                        };
                    })(this), 500);
                }
            };

            StumbleView.prototype.triggerDeepLink = function() {
                var currentTime, currentUrl, deepLinkUrl, expireDate, postfix, prefix, urlid;
                prefix = 'stumbleupon://urlid/';
                urlid = this.model.get('urlid');
                postfix = window.location.search;
                deepLinkUrl = prefix + urlid + postfix;
                mediator.triedDeepLinking = true;
                currentUrl = window.location.href;
                window.location.href = deepLinkUrl;
                currentTime = (new Date()).getTime();
                expireDate = new Date(currentTime + 60000);
                $.cookie('deeplink_try', 1, {
                    expires: expireDate
                });
                return setTimeout(function() {
                    return window.location.href = currentUrl;
                }, 200);
            };

            StumbleView.prototype.onAddedToDOM = function() {
                var _ref, _ref1, _ref2, _ref3;
                $('body').addClass('loaded');
                $('.spinner-idx').remove();
                this.trigger('startloading', {
                    urlid: this.model.get('urlid'),
                    timestamp: utils.unix()
                });
                this.resizeFrame(true);
                this.model.getEmbedCode().then(this.appendEmbedCode.bind(this));
                if ((_ref = this.$el) != null) {
                    _ref.find('iframe, img').on('load error', (function(_this) {
                        return function() {
                            return _this.announceLoaded();
                        };
                    })(this)).each(function() {
                        if (this.complete) {
                            return $(this).trigger('load');
                        }
                    });
                }
                this.setTimeout((function(_this) {
                    return function() {
                        return _this.announceLoaded('prepainttimeout');
                    };
                })(this), this.getPaintTimeout());
                if ((_ref1 = this.$el) != null ? (_ref2 = _ref1.find('.dd-stumble-frame')) != null ? (_ref3 = _ref2.attr('src')) != null ? _ref3.match(/stumbleupon.com.*(addon|download)/) : void 0 : void 0 : void 0) {
                    console.log('skipping addon/download adx');
                    this.trigger('next');
                }
                if (this.canDeepLink()) {
                    return this.triggerDeepLink();
                }
            };

            StumbleView.prototype.appendEmbedCode = function(data) {
                if (data != null ? data.html : void 0) {
                    return this.$el.find('.embed-target').html(data.html);
                }
            };

            StumbleView.prototype.canDeepLink = function() {
                return !utils.isLoggedIn() && utils.isMobile() && !mediator.triedDeepLinking && !$.cookie('deeplink_try');
            };

            StumbleView.prototype.onDDPageload = function() {
                if (window.top.location.pathname.split('/')[1] === 'invite') {
                    utils.gotoNoToolbarUrl();
                }
                if (window.top.location.pathname === '/submit/complete') {
                    return analytics.trackEvent('dd-submitpage-complete');
                }
            };

            StumbleView.prototype.onLoaded = function(data) {
                var _ref, _ref1, _ref2;
                mediator.loadTimes.push(data.duration);
                if ((_ref = this.$el) != null) {
                    if ((_ref1 = _ref.find('.stumble-frame')[0]) != null) {
                        if ((_ref2 = _ref1.contentWindow) != null) {
                            _ref2.focus();
                        }
                    }
                }
                this.stripNoSpaFromTiles();
                this.overrideOnPageStumble();
                return this.stripDDPushState();
            };

            StumbleView.prototype.dispose = function(force) {
                if (force == null) {
                    force = false;
                }
                if (force || !mediator.userM.has('userid')) {
                    return StumbleView.__super__.dispose.apply(this, arguments);
                }
            };

            return StumbleView;

        })(View);


    }, {
        "../lib/analytics": 39,
        "../lib/root": 47,
        "../lib/stumble": 48,
        "../lib/utils": 69,
        "./base/view": 214,
        "chaplin": 268,
        "jquery": 269,
        "lodash": 271,
        "simple-storage": 274
    }
    ],
    248: [function(require, module, exports) {
        var $, ThumbDownView, View, template,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        View = require('./base/view');

        template = require('../templates/thumbdown');

        $ = require('jquery');

        module.exports = ThumbDownView = (function(_super) {
            __extends(ThumbDownView, _super);

            function ThumbDownView() {
                return ThumbDownView.__super__.constructor.apply(this, arguments);
            }

            ThumbDownView.prototype.autoRender = true;

            ThumbDownView.prototype.className = 'thumbdown-container container';

            ThumbDownView.prototype.template = template;

            ThumbDownView.prototype.region = 'panel';

            ThumbDownView.prototype.events = {
                'click a': 'onItemSelect',
                'click [data-blockdomain]': function() {
                    return this.publishEvent('stumble:blockdomain');
                }
            };

            ThumbDownView.prototype.onItemSelect = function(e) {
                this.publishEvent('stumble:thumbdown', {
                    force: true,
                    subrating: $(e.target).data('subtype')
                });
                return this.publishEvent('panel:close');
            };

            return ThumbDownView;

        })(View);


    }, {
        "../templates/thumbdown": "dHJCQ1",
        "./base/view": 214,
        "jquery": 269
    }
    ],
    249: [function(require, module, exports) {
        var ThumbnailView, View, template,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        template = require('../templates/thumbnail');

        View = require('./base/view');

        module.exports = ThumbnailView = (function(_super) {
            __extends(ThumbnailView, _super);

            function ThumbnailView() {
                return ThumbnailView.__super__.constructor.apply(this, arguments);
            }

            ThumbnailView.prototype.template = template;

            ThumbnailView.prototype.className = 'url-info-img';

            ThumbnailView.prototype.autoRender = true;

            ThumbnailView.prototype.listen = {
                'change model': 'render'
            };

            return ThumbnailView;

        })(View);


    }, {
        "../templates/thumbnail": "WveYvT",
        "./base/view": 214
    }
    ],
    250: [function(require, module, exports) {
        var $, AndroidPopupView, GlassView, IosPopupView, NotificationCountV, NotificationDomainV, PrerenderView, ShareBarView, StumbleView, ToolbarView, View, analytics, mediator, root, storage, stumble, template, utils, _,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) 
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

        _ = require('lodash');

        View = require('./base/view');

        StumbleView = require('./stumble-view');

        storage = require('simple-storage');

        PrerenderView = require('./prerender-view');

        GlassView = require('./glass-view');

        utils = require('../lib/utils');

        mediator = require('chaplin').mediator;

        template = require('../templates/toolbar');

        NotificationCountV = require('./notification-count-view');

        NotificationDomainV = require('./notification-domain-view');

        IosPopupView = require('./ios-popup-view');

        AndroidPopupView = require('./android-popup-view');

        root = require('../lib/root');

        stumble = require('../lib/stumble');

        analytics = require('../lib/analytics');

        $ = require('jquery');

        ShareBarView = require('./share-bar-view');

        module.exports = ToolbarView = (function(_super) {
            __extends(ToolbarView, _super);

            function ToolbarView() {
                return ToolbarView.__super__.constructor.apply(this, arguments);
            }

            ToolbarView.prototype.events = {
                'click .stumble.button': 'stumble',
                'click .up.button': 'thumbUp',
                'click .broadcast.button': function(e) {
                    return this.togglePanel(e, {
                        name: 'broadcast'
                    });
                },
                'click .down.button .down': 'thumbDown',
                'click .down.button .down-options': function(e) {
                    return this.togglePanel(e, {
                        name: 'thumbdown'
                    });
                },
                'click .menu.button': function(e) {
                    return this.togglePanel(e, {
                        name: 'menu'
                    });
                },
                'click .info.button': function(e) {
                    return this.togglePanel(e, {
                        name: 'modes'
                    });
                },
                'click .share.button': function(e) {
                    return this.togglePanel(e, {
                        name: 'share'
                    });
                },
                'click .facebook.button': function(e) {
                    return this.togglePanel(e, {
                        name: 'facebook'
                    });
                },
                'click .addtolist.button': function(e) {
                    return this.togglePanel(e, {
                        name: 'list'
                    });
                },
                'click .comment.button': function(e) {
                    return this.togglePanel(e, {
                        name: 'comment'
                    });
                },
                'click .notification.button': function(e) {
                    return this.togglePanel(e, {
                        name: 'notification'
                    });
                },
                'click .c-tb-btn': 'trackSpecial'
            };

            ToolbarView.prototype.listen = {
                'stumble:next mediator': function() {
                    return this.toggleLoading(true);
                },
                'stumble:loaded mediator': function() {
                    return this.toggleLoading(false, 0);
                },
                'stumble:prepainttimeout mediator': function() {
                    return this.toggleLoading(false, 0);
                },
                'mode:activechanged mediator': 'onModeActiveChanged',
                'change:rating model': 'markRating',
                'addedToDOM': 'onAddedToDOM',
                'stumble:thumbdown mediator': 'thumbDown',
                'stumble:blockdomain mediator': 'blockDomain',
                'progress-bar:count mediator': 'onProgressBarCount',
                'window:popstate mediator': 'onPopstate',
                'toolbar:rendered mediator': 'dispose'
            };

            ToolbarView.prototype.autoRender = true;

            ToolbarView.prototype.region = 'toolbar';

            ToolbarView.prototype.className = 'toolbar';

            ToolbarView.prototype.template = template;

            ToolbarView.prototype.announceEvents = 'toolbar';

            ToolbarView.prototype.hackVisitorSpa = function() {
                if (utils.isVisitor()) {
                    return $("#app-container").addClass('visitor-stumble');
                }
            };

            ToolbarView.prototype.onPopstate = function(e) {
                var _ref, _ref1;
                if (((_ref = e.originalEvent.state) != null ? (_ref1 = _ref.path) != null ? _ref1.indexOf(this.model.get('_route')) : void 0 : void 0) !== - 1) {
                    return window.history.back();
                }
            };

            ToolbarView.prototype.togglePanel = function(e, options) {
                if (e != null) {
                    if (typeof e.preventDefault === "function") {
                        e.preventDefault();
                    }
                }
                return this.publishEvent('panel:toggle', options);
            };

            ToolbarView.prototype.initSubviews = function() {
                var nextM, _ref, _ref1;
                nextM = (_ref = stumble.whereUnseen()) != null ? (_ref1 = _ref.shift()) != null ? _ref1.get('url') : void 0 : void 0;
                this.subview('stumble', new StumbleView({
                    model: this.model
                }));
                if ((nextM != null) && !utils.isMobile()) {
                    this.subview('prerender', new PrerenderView({
                        nextGuessUrl: nextM
                    }));
                }
                this.subview('glass', new GlassView);
                this.subview('notification-count', new NotificationCountV({
                    container: '.icon.notification',
                    model: mediator.notificationM
                }));
                this.subview('notification-domain', new NotificationDomainV({
                    container: '#app-container',
                    model: this.model
                }));
                if (utils.canDisplayMobilePopup()) {
                    if (utils.isiOS()) {
                        this.subview('ios-popup', new IosPopupView({
                            container: 'body'
                        }));
                    }
                    if (utils.isAndroid()) {
                        this.subview('android-popup', new AndroidPopupView({
                            container: 'body'
                        }));
                    }
                    $.cookie("mobile-popup", true, {
                        expires: 1
                    });
                }
                if (this.model.get('_shareid') != null) {
                    return this.subview('share-bar', new ShareBarView({
                        model: this.model
                    }));
                }
            };

            ToolbarView.prototype.stumble = function(e) {
                if (e != null) {
                    if (typeof e.preventDefault === "function") {
                        e.preventDefault();
                    }
                }
                this.publishEvent('stumble:clicked', this.model.get('urlid'));
                this.publishEvent('stumble:next', this.model.get('urlid'));
                return _.defer((function(_this) {
                    return function() {
                        return _this.publishEvent('panel:close');
                    };
                })(this));
            };

            ToolbarView.prototype.toggleLoading = function(force, delay) {
                if (delay == null) {
                    delay = 250;
                }
                return this.setTimeout((function(_this) {
                    return function() {
                        var _ref;
                        return (_ref = _this.$el) != null ? _ref.find('.icon.stumble').toggleClass('loading', force) : void 0;
                    };
                })(this), delay);
            };

            ToolbarView.prototype.thumbUp = _.debounce(function() {
                if (!$('body').hasClass('onboarding')) {
                    this.publishEvent('panel:close');
                }
                if (this.model.get('rating') === 1) {
                    return this.model.set('rating', 0);
                } else {
                    return this.model.set('rating', 1);
                }
            }, 1000, {
                leading: true,
                trailing: false
            });

            ToolbarView.prototype.thumbDown = _.debounce(function(options) {
                if (options == null) {
                    options = {};
                }
                if (this.model.get('rating') === - 1 && options.force !== true) {
                    return this.model.set('rating', 0);
                } else {
                    if (options.subrating) {
                        this.model.set('subrating', options.subrating);
                    } else {
                        this.model.set('subrating', null);
                    }
                    return this.model.set('rating', - 1);
                }
            }, 1000, {
                leading: true,
                trailing: false
            });

            ToolbarView.prototype.markRating = function() {
                var rating;
                rating = this.model.get('rating');
                this.$el.find('.up').toggleClass('active', rating === 1);
                return this.$el.find('.down').toggleClass('active', rating === - 1);
            };

            ToolbarView.prototype.blockDomain = function() {
                return this.model.set('_domainBlocked', true);
            };

            ToolbarView.prototype.onModeActiveChanged = function() {
                this.render();
                return this.stumble();
            };

            ToolbarView.prototype.onProgressBarCount = function(count) {
                if (count === 0) {
                    this.$el.find('.stumble.button').addClass('animated pulse animate-infinite');
                }
                if (count === 1) {
                    this.$el.find('[data-id="thumbup"] .fa').addClass('animated pulse animate-infinite');
                    return this.$el.find('[data-id="thumbdown"].fa').addClass('animated hflip-pulse animate-infinite');
                }
            };

            ToolbarView.prototype.onAddedToDOM = function() {
                this.markRating();
                this.initSubviews();
                this.setTimeout((function(_this) {
                    return function() {
                        return _this.toggleLoading(false);
                    };
                })(this), '1s');
                return this.publishEvent('progress-bar:open');
            };

            ToolbarView.prototype.render = function() {
                ToolbarView.__super__.render.apply(this, arguments);
                this.hackVisitorSpa();
                return this.trigger('rendered', this.cid);
            };

            ToolbarView.prototype.dispose = function(cid) {
                this.publishEvent('panel:close');
                if (typeof cid === 'string' && cid !== this.cid) {
                    return ToolbarView.__super__.dispose.apply(this, arguments);
                }
            };

            ToolbarView.prototype.trackSpecial = function() {
                var _ref;
                analytics.trackEvent('trackSpecial');
                return (_ref = window.heap) != null ? _ref.track('trackSpecial') : void 0;
            };

            return ToolbarView;

        })(View);


    }, {
        "../lib/analytics": 39,
        "../lib/root": 47,
        "../lib/stumble": 48,
        "../lib/utils": 69,
        "../templates/toolbar": "cOr8jn",
        "./android-popup-view": 211,
        "./base/view": 214,
        "./glass-view": 222,
        "./ios-popup-view": 224,
        "./notification-count-view": 233,
        "./notification-domain-view": 234,
        "./prerender-view": 238,
        "./share-bar-view": 244,
        "./stumble-view": 247,
        "chaplin": 268,
        "jquery": 269,
        "lodash": 271,
        "simple-storage": 274
    }
    ],
    251: [function(require, module, exports) {
        /*!
         * jQuery Cookie Plugin v1.4.0
         * https://github.com/carhartl/jquery-cookie
         *
         * Copyright 2013 Klaus Hartl
         * Released under the MIT license
         */
        (function (factory) {
            if (typeof define === 'function' && define.amd) {
                // AMD. Register as anonymous module.
                define(['jquery'], factory);
            } else {
                // Browser globals.
                factory(jQuery);
            }
        }(function ($) {

            var pluses = /\+/g;

            function encode(s) {
                return config.raw ? s : encodeURIComponent(s);
            }

            function decode(s) {
                return config.raw ? s : decodeURIComponent(s);
            }

            function stringifyCookieValue(value) {
                return encode(config.json ? JSON.stringify(value) : String(value));
            }

            function parseCookieValue(s) {
                if (s.indexOf('"') === 0) {
                    // This is a quoted cookie as according to RFC2068, unescape...
                    s = s.slice(1, - 1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
                }

                try {
                    // Replace server-side written pluses with spaces.
                    // If we can't decode the cookie, ignore it, it's unusable.
                    s = decodeURIComponent(s.replace(pluses, ' '));
                } catch (e) {
                    return;
                }

                try {
                    // If we can't parse the cookie, ignore it, it's unusable.
                    return config.json ? JSON.parse(s) : s;
                } catch (e) {}
            }

            function read(s, converter) {
                var value = config.raw ? s : parseCookieValue(s);
                return $.isFunction(converter) ? converter(value) : value;
            }

            var config = $.cookie = function (key, value, options) {

                // Write
                if (value !== undefined && !$.isFunction(value)) {
                    options = $.extend({}, config.defaults, options);

                    if (typeof options.expires === 'number') {
                        var days = options.expires, t = options.expires = new Date();
                        t.setDate(t.getDate() + days);
                    }

                    return (document.cookie = [
                    encode(key), '=', stringifyCookieValue(value),
                    options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
                    options.path ? '; path=' + options.path : '',
                    options.domain ? '; domain=' + options.domain : '',
                    options.secure ? '; secure' : ''
                    ].join(''));
                }

                // Read

                var result = key ? undefined : {};

                // To prevent the for loop in the first place assign an empty array
                // in case there are no cookies at all. Also prevents odd result when
                // calling $.cookie().
                var cookies = document.cookie ? document.cookie.split('; ') : [];

                for (var i = 0, l = cookies.length; i < l; i++) {
                    var parts = cookies[i].split('=');
                    var name = decode(parts.shift());
                    var cookie = parts.join('=');

                    if (key && key === name) {
                        // If second argument (value) is a function it's a converter...
                        result = read(cookie, value);
                        break;
                    }

                    // Prevent storing a cookie that we couldn't decode.
                    if (!key && (cookie = read(cookie)) !== undefined) {
                        result[name] = cookie;
                    }
                }

                return result;
            };

            config.defaults = {};

            $.removeCookie = function (key, options) {
                if ($.cookie(key) !== undefined) {
                    // Must not alter options, thus extending a fresh object...
                    $.cookie(key, '', $.extend({}, options, {
                        expires: - 1 
                    }));
                    return true;
                }
                return false;
            };

        }));

    }, {}
    ],
    252: [function(require, module, exports) {
        /** @license MIT License (c) copyright 2013 original authors */
        /**
         * polyfill / shim plugin for AMD loaders
         *
         * @author Brian Cavalier
         * @author John Hann
         */
        (function (define) {
            define(function (require) {

                var object = require('./object');
                var string = require('./string');
                var date = require('./date');
                require('./array');
                require('./function');
                require('./json');
                require('./xhr');
                require('./setImmediate');
                require('./array-es6');

                return {
                    failIfShimmed: object.failIfShimmed,
                    setWhitespaceChars: string.setWhitespaceChars,
                    setIsoCompatTest: date.setIsoCompatTest
                };

            });
        }(
        typeof define == 'function' && define.amd
        ? define
        : function (factory) {
            module.exports = factory(require);
        }));

    }, {
        "./array": 254,
        "./array-es6": 253,
        "./date": 255,
        "./function": 256,
        "./json": 257,
        "./object": 260,
        "./setImmediate": 261,
        "./string": 262,
        "./xhr": 264
    }
    ],
    253: [function(require, module, exports) {
        /** @license MIT License (c) copyright 2013 original authors */
        /**
         * Array -- a stand-alone module for using ES6 array features.
         *
         * @author Jared Cacurak
         * @author Brian Cavalier
         * @author John Hann
         *
         * Huge thanks to Rick Waldron:
         * https://gist.github.com/rwldrn/5079436
         * https://gist.github.com/rwldrn/5079427
         * https://gist.github.com/rwldrn/1074126
         */
        (function (define) {
            define(function (require) {
                "use strict";

                var base = require('./lib/_base');
                var array = require('./lib/_array');

                var ctor = Array,
                proto = ctor.prototype,
                slice = proto.slice,
                protoFeatureMap,
                ctorFeatureMap,
                _findIndex;

                protoFeatureMap = {
                    'array-find': 'find',
                    'array-findIndex': 'findIndex'
                };

                ctorFeatureMap = {
                    'array-from': 'from',
                    'array-of': 'of'
                };

                function has (feature) {
                    var prop = protoFeatureMap[feature];
                    if (prop) {
                        return base.isFunction(proto[prop]);
                    }
                    prop = ctorFeatureMap[feature];
                    return base.isFunction(ctor[prop]);
                }

                if (!has('array-from')) {
                    Array.from = function (thing) {
                        var ctor, k, o;
                        // sniff if we're being applied to some other constructor
                        ctor = base.isFunction(this) ? this : Array;
                        if (Array === ctor) 
                            return slice.call(thing);
                        k = thing.length;
                        o = new ctor(k);
                        o.length = k;
                        while (--k >= 0) 
                            o[k] = thing[k];
                        return o;
                    };
                }

                if (!has('array-of')) {
                    Array.of = function () {
                        return slice.call(arguments);
                    };
                }

                if (!has('array-findIndex') || !has('array-find')) {
                    _findIndex = function findIndexImpl (lambda /*, thisArg */
                    ) {

                        var foundAt = - 1;

                        array.iterate(this, function (val, i, arr) {
                            if (lambda.call(this, val, i, arr)) {
                                foundAt = i;
                            }
                            return foundAt == - 1;
                            // arguments[+1] is to fool google closure compiler into NOT adding a function argument!
                        }, array.returnValue, arguments[ + 1]);
                        return foundAt;
                    };

                    if (!has('array-findIndex')) {
                        proto.findIndex = function findIndex (lambda) {
                            // arguments[+1] is to fool google closure compiler into NOT adding a function argument!
                            return _findIndex.call(this, lambda, arguments[ + 1]);
                        };
                    }

                    if (!has('array-find')) {
                        proto.find = function find (lambda) {
                            // arguments[+1] is to fool google closure compiler into NOT adding a function argument!
                            return this[_findIndex.call(this, lambda, arguments[ + 1])];
                        }
                    }
                }
            });
        }(
        typeof define == 'function' && define.amd
        ? define
        : function (factory) {
            module.exports = factory(require);
        }));

    }, {
        "./lib/_array": 258,
        "./lib/_base": 259
    }
    ],
    254: [function(require, module, exports) {
        /** @license MIT License (c) copyright 2013 original authors */
        /**
         * Array -- a stand-alone module for using Javascript 1.6 array features
         * in lame-o browsers that don't support Javascript 1.6
         *
         * @author Jared Cacurak
         * @author Brian Cavalier
         * @author John Hann
         */
        /*
        	define(['poly!poly/array'], function () {
        		var items = [1, 2, 3];
        		items.forEach(function (item) {
        			console.log(item);
        		};
        	});

        	All of the wrapper API methods are shimmed and are reasonably close to
        	the ES5 specification, but may vary slightly in unforeseen edge cases:

        	var array = [1, 2, 3];

        	array.forEach(lambda [, context]);
        	array.every(lambda [, context]);
        	array.some(lambda [, context]);
        	array.filter(lambda [, context]);
        	array.map(lambda [, context]);
        	array.indexOf(item [, fromIndex]);
        	array.lastIndexOf(item [, fromIndex]);
        	array.reduce(reduceFunc [, initialValue]);
        	array.reduceRight(reduceFunc [, initialValue]);
        	Array.isArray(object)

         */
        (function (define) {
            define(function (require) {
                "use strict";

                var base = require('./lib/_base');
                var array = require('./lib/_array');

                var proto = Array.prototype,
                featureMap,
                _reduce,
                _find;

                featureMap = {
                    'array-foreach': 'forEach',
                    'array-every': 'every',
                    'array-some': 'some',
                    'array-map': 'map',
                    'array-filter': 'filter',
                    'array-reduce': 'reduce',
                    'array-reduceright': 'reduceRight',
                    'array-indexof': 'indexOf',
                    'array-lastindexof': 'lastIndexOf'
                };

                function has (feature) {
                    var prop = featureMap[feature];
                    return base.isFunction(proto[prop]);
                }

                function returnTruthy () {
                    return 1;
                }

                /***** iterators *****/

                if (!has('array-foreach')) {
                    proto.forEach = function forEach (lambda) {
                        // arguments[+1] is to fool google closure compiler into NOT adding a function argument!
                        array.iterate(this, lambda, returnTruthy, arguments[ + 1]);
                    };
                }

                if (!has('array-every')) {
                    proto.every = function every (lambda) {
                        // arguments[+1] is to fool google closure compiler into NOT adding a function argument!
                        return array.iterate(this, lambda, array.returnValue, arguments[ + 1]);
                    };
                }

                if (!has('array-some')) {
                    proto.some = function some (lambda) {
                        // arguments[+1] is to fool google closure compiler into NOT adding a function argument!
                        return array.iterate(this, lambda, function (val) {
                            return !val;
                        }, arguments[ + 1]);
                    };
                }

                /***** mutators *****/

                if (!has('array-map')) {
                    proto.map = function map (lambda) {
                        var arr, result;

                        arr = this;
                        result = new Array(arr.length);

                        // arguments[+1] is to fool google closure compiler into NOT adding a function argument!
                        array.iterate(arr, lambda, function (val, i) {
                            result[i] = val;
                            return 1;
                        }, arguments[ + 1]);

                        return result;
                    };
                }

                if (!has('array-filter')) {
                    proto.filter = function filter (lambda) {
                        var arr, result;

                        arr = this;
                        result = [];

                        array.iterate(arr, lambda, function (val, i, orig) {
                            // use a copy of the original value in case
                            // the lambda function changed it
                            if (val) {
                                result.push(orig);
                            }
                            return 1;
                        }, arguments[1]);

                        return result;
                    };
                }

                /***** reducers *****/

                if (!has('array-reduce') || !has('array-reduceright')) {

                    _reduce = function _reduce (reduceFunc, inc, initialValue, hasInitialValue) {
                        var reduced, startPos, initialValuePos;

                        startPos = initialValuePos = inc > 0 ? - 1 : array.toArrayLike(this).length >>> 0;

                        // If no initialValue, use first item of array (we know length !== 0 here)
                        // and adjust i to start at second item
                        if (!hasInitialValue) {
                            array.iterate(this, array.returnValue, function (val, i) {
                                reduced = val;
                                initialValuePos = i;
                            }, null, startPos + inc, inc);
                            if (initialValuePos == startPos) {
                                // no intial value and no items in array!
                                throw new TypeError();
                            }
                        } else {
                            // If initialValue provided, use it
                            reduced = initialValue;
                        }

                        // Do the actual reduce
                        array.iterate(this, function (item, i, arr) {
                            reduced = reduceFunc(reduced, item, i, arr);
                        }, returnTruthy, null, initialValuePos + inc, inc);

                        // we have a reduced value!
                        return reduced;
                    };

                    if (!has('array-reduce')) {
                        proto.reduce = function reduce (reduceFunc /*, initialValue */
                        ) {
                            return _reduce.call(this, reduceFunc, 1, arguments[ + 1], arguments.length > 1);
                        };
                    }

                    if (!has('array-reduceright')) {
                        proto.reduceRight = function reduceRight (reduceFunc /*, initialValue */
                        ) {
                            return _reduce.call(this, reduceFunc, - 1, arguments[ + 1], arguments.length > 1);
                        };
                    }
                }

                /***** finders *****/

                if (!has('array-indexof') || !has('array-lastindexof')) {

                    _find = function _find (arr, item, from, forward) {
                        var len = array.toArrayLike(arr).length >>> 0, foundAt = - 1;

                        // convert to number, or default to start or end positions
                        from = isNaN(from) ? (forward ? 0 : len - 1) : Number(from);
                        // negative means it's an offset from the end position
                        if (from < 0) {
                            from = len + from - 1;
                        }

                        array.iterate(arr, array.returnValue, function (val, i) {
                            if (val === item) {
                                foundAt = i;
                            }
                            return foundAt == - 1;
                        }, null, from, forward ? 1 : - 1);

                        return foundAt;
                    };

                    if (!has('array-indexof')) {
                        proto.indexOf = function indexOf (item) {
                            // arguments[+1] is to fool google closure compiler into NOT adding a function argument!
                            return _find(this, item, arguments[ + 1], true);
                        };
                    }

                    if (!has('array-lastindexof')) {
                        proto.lastIndexOf = function lastIndexOf (item) {
                            // arguments[+1] is to fool google closure compiler into NOT adding a function argument!
                            return _find(this, item, arguments[ + 1], false);
                        };
                    }
                }

                if (!Array.isArray) {
                    Array.isArray = base.isArray;
                }

            });
        }(
        typeof define == 'function' && define.amd
        ? define
        : function (factory) {
            module.exports = factory(require);
        }));

    }, {
        "./lib/_array": 258,
        "./lib/_base": 259
    }
    ],
    255: [function(require, module, exports) {
        /** @license MIT License (c) copyright 2013 original authors */
        /**
         * poly/date
         *
         * @author Brian Cavalier
         * @author John Hann
         *
         * ES5-ish Date shims for older browsers.
        */
        (function (origDate, define) {
            define(function (require) {

                var base = require('./lib/_base');

                var origProto,
                origParse,
                featureMap,
                maxDate,
                invalidDate,
                isoCompat,
                isoParseRx,
                ownProp,
                undef;

                origProto = origDate.prototype;
                origParse = origDate.parse;

                ownProp = Object.prototype.hasOwnProperty;

                maxDate = 8.64e15;
                invalidDate = NaN;
                // borrowed this from https://github.com/kriskowal/es5-shim
                isoCompat = function () {
                    return origDate.parse('+275760-09-13T00:00:00.000Z') == maxDate;
                };
                // can't even have spaces in iso date strings
                // in Chrome and FF, the colon in the timezone is optional, but IE, Opera, and Safari need it
                isoParseRx = /^([+\-]\d{6}|\d{4})(?:-(\d{2}))?(?:-(\d{2}))?(?:T(\d{2}):(\d{2})(?::(\d{2})(?:.(\d{1,3}))?)?(?:Z|([+\-])(\d{2})(?::(\d{2}))?)?)?$/;

                featureMap = {
                    'date-now': 'now',
                    'date-tojson': 'toJSON',
                    'date-toisostring': 'toISOString'
                };

                function has (feature) {
                    var prop = featureMap[feature];
                    return prop in origDate || prop in origProto;
                }

                if (!has('date-now')) {
                    origDate.now = function () {
                        return + (new Date);
                    };
                }

                function isInvalidDate (date) {
                    return !isFinite(date);
                }

                function fix2 (number) {
                    // ensures number is formatted to at least two digits
                    return (number < 10 ? '0' : '') + number;
                }

                function isoParse (str) {
                    // parses simplified iso8601 dates, such as
                    // yyyy-mm-ddThh:mm:ssZ
                    // +yyyyyy-mm-ddThh:mm:ss-06:30
                    var result;

                    // prepare for the worst
                    result = invalidDate;

                    // fast parse
                    str.replace(isoParseRx, function (a, y, m, d, h, n, s, ms, tzs, tzh, tzm) {
                        var adjust = 0;

                        // Date.UTC handles years between 0 and 100 as 2-digit years, but
                        // that's not what we want with iso dates. If we move forward
                        // 400 years -- a full cycle in the Gregorian calendar -- then
                        // subtract the 400 years (as milliseconds) afterwards, we can avoid
                        // this problem. (learned of this trick from kriskowal/es5-shim.)
                        if (y >= 0 && y < 100) {
                            y = + y + 400; // convert to number
                            adjust = - 126227808e5; // 400 years
                        }

                        result = Date.UTC(y, (m || 1) - 1, d || 1, h || 0, n || 0, s || 0, ms || 0) + adjust;

                        tzh = + (tzs + tzh); // convert to signed number
                        tzm = + (tzs + tzm); // convert to signed number

                        if (tzh || tzm) {
                            result -= (tzh + tzm / 60) * 36e5;
                            // check if time zone is out of bounds
                            if (tzh > 23 || tzh < - 23 || tzm > 59) 
                                result = invalidDate;
                            // check if time zone pushed us over maximum date value
                            if (result > maxDate) 
                                result = invalidDate;
                        }

                        return ''; // reduces memory used
                    });

                    return result;
                }

                if (!has('date-toisostring')) {

                    origProto.toISOString = function toIsoString () {
                        if (isInvalidDate(this)) {
                            throw new RangeError("toISOString called on invalid value");
                        }
                        return [
                        this.getUTCFullYear(), '-',
                        fix2(this.getUTCMonth() + 1), '-',
                        fix2(this.getUTCDate()), 'T',
                        fix2(this.getUTCHours()), ':',
                        fix2(this.getUTCMinutes()), ':',
                        fix2(this.getUTCSeconds()), '.',
                        (this.getUTCMilliseconds() / 1000).toFixed(3).slice(2), 'Z'
                        ].join('');
                    };

                }

                if (!has('date-tojson')) {

                    origProto.toJSON = function toJSON (key) {
                        // key arg is ignored by Date objects, but since this function
                        // is generic, other Date-like objects could use the key arg.
                        // spec says to throw a TypeError if toISOString is not callable
                        // but that's what happens anyways, so no need for extra code.
                        return this.toISOString();
                    };
                }

                function checkIsoCompat () {
                    // fix Date constructor

                    var newDate = (function () {
                        // Replacement Date constructor
                        return function Date (y, m, d, h, mn, s, ms) {
                            var len, result;

                            // Date called as function, not constructor
                            if (!(this instanceof newDate)) 
                                return origDate.apply(this, arguments);

                            len = arguments.length;

                            if (len === 0) {
                                result = new origDate();
                            } else if (len === 1) {
                                result = new origDate(base.isString(y) ? newDate.parse(y) : y);
                            } else {
                                result = new origDate(y, m, d == undef ? 1 : d, h || 0, mn || 0, s || 0, ms || 0);
                            }

                            result.constructor = newDate;

                            return result;
                        };
                    }());

                    if (!isoCompat()) {

                        newDate.now = origDate.now;
                        newDate.UTC = origDate.UTC;
                        newDate.prototype = origProto;
                        newDate.prototype.constructor = newDate;

                        newDate.parse = function parse (str) {
                            var result;

                            // check for iso date
                            result = isoParse('' + str);

                            if (isInvalidDate(result)) {
                                // try original parse()
                                result = origParse(str);
                            }

                            return result;
                        };

                        // Unfortunate. See cujojs/poly#11
                        // Copy any owned props that may have been previously added to
                        // the Date constructor by 3rd party libs.
                        copyPropsSafely(newDate, origDate);

                        Date = newDate;
                    } else if (Date != origDate) {
                        Date = origDate;
                    }

                }

                function copyPropsSafely(dst, src) {
                    for (var p in src) {
                        if (ownProp.call(src, p) && !ownProp.call(dst, p)) {
                            dst[p] = src[p];
                        }
                    }
                }

                checkIsoCompat();

                return {
                    setIsoCompatTest: function (testFunc) {
                        isoCompat = testFunc;
                        checkIsoCompat();
                    }
                };

            });
        }(
        Date,
        typeof define == 'function' && define.amd
        ? define
        : function (factory) {
            module.exports = factory(require);
        }));

    }, {
        "./lib/_base": 259
    }
    ],
    256: [function(require, module, exports) {
        /** @license MIT License (c) copyright 2013 original authors */
        /**
         * Function polyfill / shims
         *
         * @author Brian Cavalier
         * @author John Hann
         */
        (function (define) {
            define(function (require) {
                "use strict";

                var base = require('./lib/_base');

                var bind,
                slice = [].slice,
                proto = Function.prototype,
                featureMap;

                featureMap = {
                    'function-bind': 'bind'
                };

                function has (feature) {
                    var prop = featureMap[feature];
                    return base.isFunction(proto[prop]);
                }

                // check for missing features
                if (!has('function-bind')) {
                    // adapted from Mozilla Developer Network example at
                    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind
                    bind = function bind (obj) {
                        var args = slice.call(arguments, 1),
                        self = this,
                        nop = function () {},
                        bound = function () {
                            return self.apply(this instanceof nop ? this : (obj || {}), args.concat(slice.call(arguments)));
                        };
                        nop.prototype = this.prototype || {}; // Firefox cries sometimes if prototype is undefined
                        bound.prototype = new nop();
                        return bound;
                    };
                    proto.bind = bind;
                }

                return {};

            });
        }(
        typeof define == 'function' && define.amd
        ? define
        : function (factory) {
            module.exports = factory(require);
        }));

    }, {
        "./lib/_base": 259
    }
    ],
    257: [function(require, module, exports) {
        /** @license MIT License (c) copyright 2013 original authors */
        /**
         * JSON polyfill / shim
         *
         * @author Brian Cavalier
         * @author John Hann
         */
        (function (define) {
            define(function (require) {
                "use strict";
                return require('./support/json3');
            });
        }(
        typeof define == 'function' && define.amd
        ? define
        : function (factory) {
            module.exports = factory(require);
        }));

    }, {
        "./support/json3": 263
    }
    ],
    258: [function(require, module, exports) {
        /** @license MIT License (c) copyright 2013 original authors */
        /**
         * poly common array functions
         *
         * @author Jared Cacurak
         * @author Brian Cavalier
         * @author John Hann
         */
        (function (define) {
            define(function (require) {

                var base = require('./_base');

                var toObject = base.createCaster(Object, 'Array'),
                isFunction = base.isFunction,
                undef;

                return {
                    returnValue: returnValue,
                    iterate: iterate,
                    toArrayLike: toArrayLike
                };

                function toArrayLike (o) {
                    return (base.toString(o) == '[object String]')
                    ? o.split('')
                    : toObject(o);
                }

                function returnValue (val) {
                    return val;
                }

                function iterate (arr, lambda, continueFunc, context, start, inc) {

                    var alo, len, i, end;

                    alo = toArrayLike(arr);
                    len = alo.length >>> 0;

                    if (start === undef) 
                        start = 0;
                    if (!inc) 
                        inc = 1;
                    end = inc < 0 ? - 1 : len;

                    if (!isFunction(lambda)) {
                        throw new TypeError(lambda + ' is not a function');
                    }
                    if (start == end) {
                        return false;
                    }
                    if ((start <= end) ^ (inc > 0)) {
                        throw new TypeError('Invalid length or starting index');
                    }

                    for (i = start; i != end; i = i + inc) {
                        if (i in alo) {
                            if (!continueFunc(lambda.call(context, alo[i], i, alo), i, alo[i])) {
                                return false;
                            }
                        }
                    }

                    return true;
                }

            });
        }(
        typeof define == 'function' && define.amd
        ? define
        : function (factory) {
            module.exports = factory(require);
        }));

    }, {
        "./_base": 259
    }
    ],
    259: [function(require, module, exports) {
        /** @license MIT License (c) copyright 2013 original authors */
        /**
         * poly common functions
         *
         * @author Brian Cavalier
         * @author John Hann
         */
        (function (define) {
            define(function (require, exports) {

                var toString;

                toString = ({}).toString;

                exports.isFunction = function (o) {
                    return typeof o == 'function';
                };

                exports.isString = function (o) {
                    return toString.call(o) == '[object String]';
                };

                exports.isArray = function (o) {
                    return toString.call(o) == '[object Array]';
                };

                exports.toString = function (o) {
                    return toString.apply(o);
                };

                exports.createCaster = function (caster, name) {
                    return function cast (o) {
                        if (o == null) 
                            throw new TypeError(name + ' method called on null or undefined');
                        return caster(o);
                    }
                };

                exports.isElement = function(o) {
                    return typeof HTMLElement == 'undefined'
                    ? 'tagName' in o && 'nodeName' in o
                    : o instanceof HTMLELEMENT;
                };

            });
        }(
        typeof define == 'function' && define.amd
        ? define
        : function (factory) {
            factory(require, exports);
        }));

    }, {}
    ],
    260: [function(require, module, exports) {
        /** @license MIT License (c) copyright 2013 original authors */
        /**
         * Object polyfill / shims
         *
         * @author Brian Cavalier
         * @author John Hann
         */
        /**
         * The goal of these shims is to emulate a JavaScript 1.8.5+ environments as
         * much as possible.  While it's not feasible to fully shim Object,
         * we can try to maximize code compatibility with older js engines.
         *
         * Note: these shims cannot fix `for (var p in obj) {}`. Instead, use this:
         *     Object.keys(obj).forEach(function (p) {}); // shimmed Array
         *
         * Also, these shims can't prevent writing to object properties.
         *
         * If you want your code to fail loudly if a shim can't mimic ES5 closely
         * then set the AMD loader config option `failIfShimmed`.  Possible values
         * for `failIfShimmed` include:
         *
         * true: fail on every shimmed Object function
         * false: fail never
         * function: fail for shims whose name returns true from function (name) {}
         *
         * By default, no shims fail.
         *
         * The following functions are safely shimmed:
         * create (unless the second parameter is specified since that calls defineProperties)
         * keys
         * getOwnPropertyNames
         * getPrototypeOf
         * isExtensible
         *
         * In order to play nicely with several third-party libs (including Promises/A
         * implementations), the following functions don't fail by default even though
         * they can't be correctly shimmed:
         * freeze
         * seal
         * isFrozen
         * isSealed
         *
         * The poly/strict module will set failIfShimmed to fail for some shims.
         * See the documentation for more information.
         *
         * IE missing enum properties fixes copied from kangax:
         * https://github.com/kangax/protolicious/blob/master/experimental/object.for_in.js
         *
         * TODO: fix Object#propertyIsEnumerable for IE's non-enumerable props to match Object.keys()
         */
        (function (define) {
            define(function (require) {
                "use strict";

                var base = require('./lib/_base');

                var refObj,
                refProto,
                has__proto__,
                hasNonEnumerableProps,
                getPrototypeOf,
                keys,
                featureMap,
                shims,
                secrets,
                protoSecretProp,
                hasOwnProp = 'hasOwnProperty',
                doc = typeof document != 'undefined' && document,
                testEl = doc && doc.createElement('p'),
                undef;

                refObj = Object;
                refProto = refObj.prototype;

                has__proto__ = typeof {}.__proto__ == 'object';

                hasNonEnumerableProps = (function () {
                    for (var p in {
                        valueOf: 1 
                    }) 
                        return false;
                    return true;
                }());

                // TODO: this still doesn't work for IE6-8 since object.constructor && object.constructor.prototype are clobbered/replaced when using `new` on a constructor that has a prototype. srsly.
                // devs will have to do the following if they want this to work in IE6-8:
                // Ctor.prototype.constructor = Ctor
                getPrototypeOf = has__proto__
                ? function (object) {
                    assertIsObject(object);
                    return object.__proto__;
                } : function (object) {
                    assertIsObject(object);
                    // return null according to the investigation result at:
                    // https://github.com/cujojs/poly/pull/21
                    if (object == refProto) {
                        return null;
                    }
                    return protoSecretProp && object[protoSecretProp](secrets)
                    ? object[protoSecretProp](secrets.proto)
                    : object.constructor ? object.constructor.prototype : refProto;
                };

                keys = !hasNonEnumerableProps
                ? _keys
                : (function (masked) {
                    return function (object) {
                        var result = _keys(object), i = 0, m;
                        while (m = masked[i++]) {
                            if (hasProp(object, m)) 
                                result.push(m);
                        }
                        return result;
                    }
                }([ 'constructor', hasOwnProp, 'isPrototypeOf', 'propertyIsEnumerable', 'toString', 'toLocaleString', 'valueOf' ]));

                featureMap = {
                    'object-create': 'create',
                    'object-freeze': 'freeze',
                    'object-isfrozen': 'isFrozen',
                    'object-seal': 'seal',
                    'object-issealed': 'isSealed',
                    'object-getprototypeof': 'getPrototypeOf',
                    'object-keys': 'keys',
                    'object-getownpropertynames': 'getOwnPropertyNames',
                    'object-isextensible': 'isExtensible',
                    'object-preventextensions': 'preventExtensions',
                    'object-defineproperty-obj': function () {
                        return hasDefineProperty({});
                    },
                    'object-defineproperty-dom': function () {
                        return doc && hasDefineProperty(testEl);
                    },
                    'object-defineproperties-obj': function () {
                        return hasDefineProperties({});
                    },
                    'object-defineproperties-dom': function () {
                        return doc && hasDefineProperties(testEl);
                    },
                    'object-getownpropertydescriptor-obj': function () {
                        return hasGetOwnPropertyDescriptor({});
                    },
                    'object-getownpropertydescriptor-dom': function () {
                        return doc && hasGetOwnPropertyDescriptor(testEl);
                    }
                };

                shims = {};

                secrets = {
                    proto: {}
                };

                protoSecretProp = !has('object-getprototypeof') && !has__proto__ && hasNonEnumerableProps && hasOwnProp;

                // we might create an owned property to hold the secrets, but make it look
                // like it's not an owned property.  (affects getOwnPropertyNames, too)
                if (protoSecretProp) (function (_hop) {
                    refProto[hasOwnProp] = function (name) {
                        if (name == protoSecretProp) 
                            return false;
                        return _hop.call(this, name);
                    };
                }(refProto[hasOwnProp]));

                if (!has('object-create')) {
                    Object.create = shims.create = create;
                }

                if (!has('object-freeze')) {
                    Object.freeze = shims.freeze = noop;
                }

                if (!has('object-isfrozen')) {
                    Object.isFrozen = shims.isFrozen = nope;
                }

                if (!has('object-seal')) {
                    Object.seal = shims.seal = noop;
                }

                if (!has('object-issealed')) {
                    Object.isSealed = shims.isSealed = nope;
                }

                if (!has('object-getprototypeof')) {
                    Object.getPrototypeOf = shims.getPrototypeOf = getPrototypeOf;
                }

                if (!has('object-keys')) {
                    Object.keys = keys;
                }

                if (!has('object-getownpropertynames')) {
                    Object.getOwnPropertyNames = shims.getOwnPropertyNames
                    = getOwnPropertyNames;
                }

                if (!has('object-defineproperties-obj')) {
                    // check if dom has it (IE8)
                    Object.defineProperties = shims.defineProperties
                    = has('object-defineproperties-dom')
                    ? useNativeForDom(Object.defineProperties, defineProperties)
                    : defineProperties;
                }

                if (!has('object-defineproperty-obj')) {
                    // check if dom has it (IE8)
                    Object.defineProperty = shims.defineProperty
                    = has('object-defineproperty-dom')
                    ? useNativeForDom(Object.defineProperty, defineProperty)
                    : defineProperty;
                }

                if (!has('object-isextensible')) {
                    Object.isExtensible = shims.isExtensible = isExtensible;
                }

                if (!has('object-preventextensions')) {
                    Object.preventExtensions = shims.preventExtensions = preventExtensions;
                }

                if (!has('object-getownpropertydescriptor-obj')) {
                    // check if dom has it (IE8)
                    Object.getOwnPropertyDescriptor = shims.getOwnPropertyDescriptor
                    = has('object-getownpropertydescriptor-dom')
                    ? useNativeForDom(Object.getOwnPropertyDescriptor, getOwnPropertyDescriptor)
                    : getOwnPropertyDescriptor;
                }

                function hasDefineProperty (object) {
                    if (('defineProperty' in Object)) {
                        try {
                            // test it
                            Object.defineProperty(object, 'sentinel1', {
                                value: 1 
                            })
                            return 'sentinel1' in object;
                        } catch (ex) {
                            /* squelch */
                        }
                    }
                }

                // Note: MSDN docs say that IE8 has this function, but tests show
                // that it does not! JMH
                function hasDefineProperties (object) {
                    if (('defineProperties' in Object)) {
                        try {
                            // test it
                            Object.defineProperties(object, {
                                'sentinel2': {
                                    value: 1 
                                }
                            })
                            return 'sentinel2' in object;
                        } catch (ex) {
                            /* squelch */
                        }
                    }
                }

                function hasGetOwnPropertyDescriptor (object) {
                    if (('getOwnPropertyDescriptor' in Object)) {
                        object['sentinel3'] = true;
                        try {
                            return (Object.getOwnPropertyDescriptor(object, 'sentinel3').value);
                        } catch (ex) {
                            /* squelch */
                        }
                    }
                }

                function PolyBase () {}

                // for better compression
                function hasProp (object, name) {
                    return object.hasOwnProperty(name);
                }

                function _keys (object) {
                    var result = [];
                    for (var p in object) {
                        if (hasProp(object, p)) {
                            result.push(p);
                        }
                    }
                    return result;
                }

                function create (proto, props) {
                    var obj;

                    if (typeof proto != 'object') 
                        throw new TypeError('prototype is not of type Object or Null.');

                    PolyBase.prototype = proto;
                    obj = new PolyBase();
                    PolyBase.prototype = null;

                    // provide a mechanism for retrieving the prototype in IE 6-8
                    if (protoSecretProp) {
                        var orig = obj[protoSecretProp];
                        obj[protoSecretProp] = function (name) {
                            if (name == secrets) 
                                return true; // yes, we're using secrets
                            if (name == secrets.proto) 
                                return proto;
                            return orig.call(this, name);
                        };
                    }

                    if (arguments.length > 1) {
                        // defineProperties could throw depending on `failIfShimmed`
                        Object.defineProperties(obj, props);
                    }

                    return obj;
                }

                function defineProperties (object, descriptors) {
                    var names, name;
                    names = keys(descriptors);
                    while ((name = names.pop())) {
                        Object.defineProperty(object, name, descriptors[name]);
                    }
                    return object;
                }

                function defineProperty (object, name, descriptor) {
                    object[name] = descriptor && descriptor.value;
                    return object;
                }

                function getOwnPropertyDescriptor (object, name) {
                    return hasProp(object, name)
                    ? {
                        value: object[name],
                        enumerable: true,
                        configurable: true,
                        writable: true
                    } : undef;
                }

                function getOwnPropertyNames (object) {
                    return keys(object);
                }

                function isExtensible (object) {
                    var prop = '_poly_';
                    try {
                        // create unique property name
                        while (prop in object) 
                            prop += '_';
                        // try to set it
                        object[prop] = 1;
                        return hasProp(object, prop);
                    } catch (ex) {
                        return false;
                    } finally {
                        try {
                            delete object[prop];
                        } catch (ex) {
                            /* squelch */
                        }
                    }
                }

                function preventExtensions (object) {
                    return object;
                }

                function useNativeForDom (orig, shim) {
                    return function (obj) {
                        if (base.isElement(obj)) 
                            return orig.apply(this, arguments);
                        else 
                            return shim.apply(this, arguments);
                    };
                }

                function failIfShimmed (failTest) {
                    var shouldThrow;

                    if (typeof failTest == 'function') {
                        shouldThrow = failTest;
                    } else {
                        // assume truthy/falsey
                        shouldThrow = function () {
                            return failTest;
                        };
                    }

                    // create throwers for some features
                    for (var feature in shims) {
                        Object[feature] = shouldThrow(feature)
                        ? createFlameThrower(feature)
                        : shims[feature];
                    }
                }

                function assertIsObject (o) {
                    if (typeof o != 'object') {
                        throw new TypeError('Object.getPrototypeOf called on non-object');
                    }
                }

                function createFlameThrower (feature) {
                    return function () {
                        throw new Error('poly/object: ' + feature + ' is not safely supported.');
                    }
                }

                function has (feature) {
                    var ret;
                    var prop = featureMap[feature];

                    if (base.isFunction(prop)) {
                        // cache return value, ensure boolean
                        ret = featureMap[feature] = !!prop(refObj);
                    } else if (base.isString(prop)) {
                        ret = featureMap[feature] = prop in refObj;
                    } else {
                        // return cached evaluate result
                        ret = prop;
                    }

                    return ret;
                }

                function noop (it) {
                    return it;
                }

                function nope (it) {
                    return false;
                }

                return {
                    failIfShimmed: failIfShimmed
                };

            });
        }(
        typeof define == 'function' && define.amd
        ? define
        : function (factory) {
            module.exports = factory(require);
        }));

    }, {
        "./lib/_base": 259
    }
    ],
    261: [function(require, module, exports) {
        /** @license MIT License (c) copyright 2013 original authors */
        /**
         * setImmediate polyfill / shim
         *
         * @author Jared Cacurak
         * @author Brian Cavalier
         * @author John Hann
         *
         * Based on NobleJS's setImmediate. (https://github.com/NobleJS/setImmediate)
         */
        (function (global, define) {
            define(function (require) {
                "use strict";

                var base = require('./lib/_base');

                var testCache,
                tasks;

                testCache = {};
                tasks = (function () {
                    var nextHandle,
                    tasksByHandle,
                    currentlyRunningATask;

                    nextHandle = 1; // Spec says greater than zero
                    tasksByHandle = {};
                    currentlyRunningATask = false;

                    function Task (handler, args) {
                        this.handler = handler;
                        this.args = Array.prototype.slice.call(args);
                    }

                    Task.prototype.run = function () {
                        // See steps in section 5 of the spec.
                        if (base.isFunction(this.handler)) {
                            // Choice of `thisArg` is not in the setImmediate spec; `undefined` is in the setTimeout spec though:
                            // http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html
                            this.handler.apply(undefined, this.args);
                        } else {
                            var scriptSource = '' + this.handler;
                            eval(scriptSource);
                        }
                    };

                    return {
                        addFromSetImmediateArguments: function (args) {
                            var handler,
                            argsToHandle,
                            task,
                            thisHandle;

                            handler = args[0];
                            argsToHandle = Array.prototype.slice.call(args, 1);
                            task = new Task(handler, argsToHandle);

                            thisHandle = nextHandle++;
                            tasksByHandle[thisHandle] = task;
                            return thisHandle;
                        },
                        runIfPresent: function (handle) {
                            // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
                            // So if we're currently running a task, we'll need to delay this invocation.
                            if (!currentlyRunningATask) {
                                var task = tasksByHandle[handle];
                                if (task) {
                                    currentlyRunningATask = true;
                                    try {
                                        task.run();
                                    } finally {
                                        delete tasksByHandle[handle];
                                        currentlyRunningATask = false;
                                    }
                                }
                            } else {
                                // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
                                // "too much recursion" error.
                                global.setTimeout(function () {
                                    tasks.runIfPresent(handle);
                                }, 0);
                            }
                        },
                        remove: function (handle) {
                            delete tasksByHandle[handle];
                        }
                    };
                }());

                function has (name) {
                    if (base.isFunction(testCache[name])) {
                        testCache[name] = testCache[name](global);
                    }
                    return testCache[name];
                }

                function add (name, test, now) {
                    testCache[name] = now ? test(global, d, el) : test;
                }

                function aliasMicrosoftImplementation (attachTo) {
                    attachTo.setImmediate = global.msSetImmediate;
                    attachTo.clearImmediate = global.msClearImmediate;
                }

                function installPostMessageImplementation (attachTo) {
                    // Installs an event handler on `global` for the `message` event: see
                    // * https://developer.mozilla.org/en/DOM/window.postMessage
                    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

                    var MESSAGE_PREFIX = 'cujojs/poly.setImmediate' + Math.random();

                    function isStringAndStartsWith (string, putativeStart) {
                        return typeof string === 'string' && string.substring(0, putativeStart.length) === putativeStart;
                    }

                    function onGlobalMessage (event) {
                        // This will catch all incoming messages (even from other windows!), so we need to try reasonably hard to
                        // avoid letting anyone else trick us into firing off. We test the origin is still this window, and that a
                        // (randomly generated) unpredictable identifying prefix is present.
                        if (event.source === global && isStringAndStartsWith(event.data, MESSAGE_PREFIX)) {
                            var handle = event.data.substring(MESSAGE_PREFIX.length);
                            tasks.runIfPresent(handle);
                        }
                    }
                    global.addEventListener('message', onGlobalMessage, false);

                    attachTo.setImmediate = function () {
                        var handle = tasks.addFromSetImmediateArguments(arguments);

                        // Make `global` post a message to itself with the handle and identifying prefix, thus asynchronously
                        // invoking our onGlobalMessage listener above.
                        global.postMessage(MESSAGE_PREFIX + handle, '*');
                        return handle;
                    };
                }

                function installReadyStateChangeImplementation(attachTo) {
                    attachTo.setImmediate = function () {
                        var handle = tasks.addFromSetImmediateArguments(arguments);

                        // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
                        // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
                        var scriptEl = global.document.createElement('script');
                        scriptEl.onreadystatechange = function () {
                            tasks.runIfPresent(handle);

                            scriptEl.onreadystatechange = null;
                            scriptEl.parentNode.removeChild(scriptEl);
                            scriptEl = null;
                        };
                        global.document.documentElement.appendChild(scriptEl);
                        return handle;
                    };
                }

                function installSetTimeoutImplementation(attachTo) {
                    attachTo.setImmediate = function () {
                        var handle = tasks.addFromSetImmediateArguments(arguments);

                        global.setTimeout(function () {
                            tasks.runIfPresent(handle);
                        }, 0);
                        return handle;
                    };
                }

                add('setimmediate', function (g) {
                    return base.isFunction(g.setImmediate);
                });

                add('ms-setimmediate', function (g) {
                    return base.isFunction(g.msSetImmediate);
                });

                add('post-message', function (g) {
                    // Note: this is only for the async postMessage, not the buggy sync
                    // version in IE8
                    var postMessageIsAsynchronous,
                    oldOnMessage;

                    postMessageIsAsynchronous = true;
                    oldOnMessage = g.onmessage;

                    if (!g.postMessage) {
                        return false;
                    }

                    g.onmessage = function () {
                        postMessageIsAsynchronous = false;
                    };
                    g.postMessage('', '*');
                    g.onmessage = oldOnMessage;
                    return postMessageIsAsynchronous;
                });

                add('script-onreadystatechange', function (g) {
                    return 'document' in g && 'onreadystatechange' in g.document.createElement('script');
                });

                if (!has('setimmediate')) {
                    if (has('ms-setimmediate')) {
                        aliasMicrosoftImplementation(global);
                    } else {
                        if (has('post-message')) {
                            installPostMessageImplementation(global);
                        } else if (has('script-onreadystatechange')) {
                            installReadyStateChangeImplementation(global);
                        } else {
                            installSetTimeoutImplementation(global);
                        }
                        global.clearImmediate = tasks.remove;
                    }
                }
            });
        }(
        this.global || this,
        typeof define == 'function' && define.amd
        ? define
        : function (factory) {
            module.exports = factory(require);
        }));

    }, {
        "./lib/_base": 259
    }
    ],
    262: [function(require, module, exports) {
        /** @license MIT License (c) copyright 2013 original authors */
        /**
         * String polyfill / shims
         *
         * @author Brian Cavalier
         * @author John Hann
         *
         * Adds str.trim(), str.trimRight(), and str.trimLeft()
         *
         * Note: we don't bother trimming all possible ES5 white-space characters.
         * If you truly need strict ES5 whitespace compliance in all browsers,
         * create your own trim function.
         * from http://perfectionkills.com/whitespace-deviations/
         * '\x09-\x0D\x20\xA0\u1680\u180E\u2000-\u200A\u202F\u205F\u3000\u2028\u2029'
         */
        (function (define) {
            define(function (require) {
                "use strict";

                var base = require('./lib/_base');

                var proto = String.prototype,
                featureMap,
                has,
                toString;

                featureMap = {
                    'string-trim': 'trim',
                    'string-trimleft': 'trimLeft',
                    'string-trimright': 'trimRight'
                };

                function checkFeature (feature) {
                    var prop = featureMap[feature];
                    return base.isFunction(proto[prop]);
                }

                function neg () {
                    return false;
                }

                has = checkFeature;

                // compressibility helper
                function remove (str, rx) {
                    return str.replace(rx, '');
                }

                toString = base.createCaster(String, 'String');

                var trimRightRx, trimLeftRx;

                trimRightRx = /\s+$/;
                trimLeftRx = /^\s+/;

                function checkShims () {
                    if (!has('string-trim')) {
                        proto.trim = function trim () {
                            return remove(remove(toString(this), trimLeftRx), trimRightRx);
                        };
                    }

                    if (!has('string-trimleft')) {
                        proto.trimLeft = function trimLeft () {
                            return remove(toString(this), trimLeftRx);
                        };
                    }

                    if (!has('string-trimright')) {
                        proto.trimRight = function trimRight () {
                            return remove(toString(this), trimRightRx);
                        };
                    }

                }

                checkShims();

                return {
                    setWhitespaceChars: function (wsc) {
                        trimRightRx = new RegExp(wsc + '$');
                        trimLeftRx = new RegExp('^' + wsc);
                        // fail all has() checks and check shims again
                        has = neg;
                        checkShims();
                    }
                };

            });
        }(
        typeof define == 'function' && define.amd
        ? define
        : function (factory) {
            module.exports = factory(require);
        }));

    }, {
        "./lib/_base": 259
    }
    ],
    263: [function(require, module, exports) {
        /*! JSON v3.2.4 | http://bestiejs.github.com/json3 | Copyright 2012, Kit Cambridge | http://kit.mit-license.org */
        ;
        (function () {
            // Convenience aliases.
            var getClass = {}.toString, isProperty, forEach, undef;

            // Detect the `define` function exposed by asynchronous module loaders. The
            // strict `define` check is necessary for compatibility with `r.js`.
            var isLoader = typeof define === "function" && define.amd, JSON3 = !isLoader && typeof exports == "object" && exports;

            if (JSON3 || isLoader) {
                if (typeof JSON == "object" && JSON) {
                    // Delegate to the native `stringify` and `parse` implementations in
                    // asynchronous module loaders and CommonJS environments.
                    if (isLoader) {
                        JSON3 = JSON;
                    } else {
                        JSON3.stringify = JSON.stringify;
                        JSON3.parse = JSON.parse;
                    }
                } else if (isLoader) {
                    JSON3 = this.JSON = {};
                }
            } else {
                // Export for web browsers and JavaScript engines.
                JSON3 = this.JSON || (this.JSON = {});
            }

            // Local variables.
            var Escapes, toPaddedString, quote, serialize;
            var fromCharCode, Unescapes, abort, lex, get, walk, update, Index, Source;

            // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
            var isExtended = new Date( - 3509827334573292), floor, Months, getDay;

            try {
                // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
                // results for certain dates in Opera >= 10.53.
                isExtended = isExtended.getUTCFullYear() == - 109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() == 1 &&
                // Safari < 2.0.2 stores the internal millisecond time value correctly,
                // but clips the values returned by the date methods to the range of
                // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
                isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
            } catch (exception) {}

            // Internal: Determines whether the native `JSON.stringify` and `parse`
            // implementations are spec-compliant. Based on work by Ken Snyder.
            function has(name) {
                var stringifySupported, parseSupported, value, serialized = '{"A":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}', all = name == "json";
                if (all || name == "json-stringify" || name == "json-parse") {
                    // Test `JSON.stringify`.
                    if (name == "json-stringify" || all) {
                        if ((stringifySupported = typeof JSON3.stringify == "function" && isExtended)) {
                            // A test function object with a custom `toJSON` method.
                            (value = function () {
                                return 1;
                            }).toJSON = value;
                            try {
                                stringifySupported =
                                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                                // primitives as object literals.
                                JSON3.stringify(0) === "0" &&
                                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                                // literals.
                                JSON3.stringify(new Number()) === "0" &&
                                JSON3.stringify(new String()) == '""' &&
                                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                                // does not define a canonical JSON representation (this applies to
                                // objects with `toJSON` properties as well, *unless* they are nested
                                // within an object or array).
                                JSON3.stringify(getClass) === undef &&
                                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                                // FF 3.1b3 pass this test.
                                JSON3.stringify(undef) === undef &&
                                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                                // respectively, if the value is omitted entirely.
                                JSON3.stringify() === undef &&
                                // FF 3.1b1, 2 throw an error if the given value is not a number,
                                // string, array, object, Boolean, or `null` literal. This applies to
                                // objects with custom `toJSON` methods as well, unless they are nested
                                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                                // methods entirely.
                                JSON3.stringify(value) === "1" &&
                                JSON3.stringify([value]) == "[1]" &&
                                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                                // `"[null]"`.
                                JSON3.stringify([undef]) == "[null]" &&
                                // YUI 3.0.0b1 fails to serialize `null` literals.
                                JSON3.stringify(null) == "null" &&
                                // FF 3.1b1, 2 halts serialization if an array contains a function:
                                // `[1, true, getClass, 1]` serializes as "[1,true,],". These versions
                                // of Firefox also allow trailing commas in JSON objects and arrays.
                                // FF 3.1b3 elides non-JSON values from objects and arrays, unless they
                                // define custom `toJSON` methods.
                                JSON3.stringify([undef, getClass, null]) == "[null,null,null]" &&
                                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                                JSON3.stringify({
                                    "A": [value, true, false, null, "\0\b\n\f\r\t"] 
                                }) == serialized &&
                                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                                JSON3.stringify(null, value) === "1" &&
                                JSON3.stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                                // serialize extended years.
                                JSON3.stringify(new Date( - 8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                                // The milliseconds are optional in ES 5, but required in 5.1.
                                JSON3.stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                                // four-digit years instead of six-digit years. Credits: @Yaffle.
                                JSON3.stringify(new Date( - 621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                                // values less than 1000. Credits: @Yaffle.
                                JSON3.stringify(new Date( - 1)) == '"1969-12-31T23:59:59.999Z"';
                            } catch (exception) {
                                stringifySupported = false;
                            }
                        }
                        if (!all) {
                            return stringifySupported;
                        }
                    }
                    // Test `JSON.parse`.
                    if (name == "json-parse" || all) {
                        if (typeof JSON3.parse == "function") {
                            try {
                                // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
                                // Conforming implementations should also coerce the initial argument to
                                // a string prior to parsing.
                                if (JSON3.parse("0") === 0 && !JSON3.parse(false)) {
                                    // Simple parsing test.
                                    value = JSON3.parse(serialized);
                                    if ((parseSupported = value.A.length == 5 && value.A[0] == 1)) {
                                        try {
                                            // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                                            parseSupported = !JSON3.parse('"\t"');
                                        } catch (exception) {}
                                        if (parseSupported) {
                                            try {
                                                // FF 4.0 and 4.0.1 allow leading `+` signs, and leading and
                                                // trailing decimal points. FF 4.0, 4.0.1, and IE 9-10 also
                                                // allow certain octal literals.
                                                parseSupported = JSON3.parse("01") != 1;
                                            } catch (exception) {}
                                        }
                                    }
                                }
                            } catch (exception) {
                                parseSupported = false;
                            }
                        }
                        if (!all) {
                            return parseSupported;
                        }
                    }
                    return stringifySupported && parseSupported;
                }
            }

            if (!has("json")) {
                // Define additional utility methods if the `Date` methods are buggy.
                if (!isExtended) {
                    floor = Math.floor;
                    // A mapping between the months of the year and the number of days between
                    // January 1st and the first of the respective month.
                    Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
                    // Internal: Calculates the number of days between the Unix epoch and the
                    // first day of the given month.
                    getDay = function (year, month) {
                        return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = + (month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
                    };
                }

                // Internal: Determines if a property is a direct property of the given
                // object. Delegates to the native `Object#hasOwnProperty` method.
                if (!(isProperty = {}.hasOwnProperty)) {
                    isProperty = function (property) {
                        var members = {}, constructor;
                        if ((members.__proto__ = null, members.__proto__ = {
                            // The *proto* property cannot be set multiple times in recent
                            // versions of Firefox and SeaMonkey.
                            "toString": 1
                        }, members).toString != getClass) {
                            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
                            // supports the mutable *proto* property.
                            isProperty = function (property) {
                                // Capture and break the object's prototype chain (see section 8.6.2
                                // of the ES 5.1 spec). The parenthesized expression prevents an
                                // unsafe transformation by the Closure Compiler.
                                var original = this.__proto__, result = property in (this.__proto__ = null, this);
                                // Restore the original prototype chain.
                                this.__proto__ = original;
                                return result;
                            };
                        } else {
                            // Capture a reference to the top-level `Object` constructor.
                            constructor = members.constructor;
                            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
                            // other environments.
                            isProperty = function (property) {
                                var parent = (this.constructor || constructor).prototype;
                                return property in this && !(property in parent && this[property] === parent[property]);
                            };
                        }
                        members = null;
                        return isProperty.call(this, property);
                    };
                }

                // Internal: Normalizes the `for...in` iteration algorithm across
                // environments. Each enumerated key is yielded to a `callback` function.
                forEach = function (object, callback) {
                    var size = 0, Properties, members, property, forEach;

                    // Tests for bugs in the current environment's `for...in` algorithm. The
                    // `valueOf` property inherits the non-enumerable flag from
                    // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
                    (Properties = function () {
                        this.valueOf = 0;
                    }).prototype.valueOf = 0;

                    // Iterate over a new instance of the `Properties` class.
                    members = new Properties();
                    for (property in members) {
                        // Ignore all properties inherited from `Object.prototype`.
                        if (isProperty.call(members, property)) {
                            size++;
                        }
                    }
                    Properties = members = null;

                    // Normalize the iteration algorithm.
                    if (!size) {
                        // A list of non-enumerable properties inherited from `Object.prototype`.
                        members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
                        // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
                        // properties.
                        forEach = function (object, callback) {
                            var isFunction = getClass.call(object) == "[object Function]", property, length;
                            for (property in object) {
                                // Gecko <= 1.0 enumerates the `prototype` property of functions under
                                // certain conditions; IE does not.
                                if (!(isFunction && property == "prototype") && isProperty.call(object, property)) {
                                    callback(property);
                                }
                            }
                            // Manually invoke the callback for each non-enumerable property.
                            for (length = members.length; property = members[--length]; isProperty.call(object, property) 
                                && callback(property));
                        };
                    } else if (size == 2) {
                        // Safari <= 2.0.4 enumerates shadowed properties twice.
                        forEach = function (object, callback) {
                            // Create a set of iterated properties.
                            var members = {}, isFunction = getClass.call(object) == "[object Function]", property;
                            for (property in object) {
                                // Store each property name to prevent double enumeration. The
                                // `prototype` property of functions is not enumerated due to cross-
                                // environment inconsistencies.
                                if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                                    callback(property);
                                }
                            }
                        };
                    } else {
                        // No bugs detected; use the standard `for...in` algorithm.
                        forEach = function (object, callback) {
                            var isFunction = getClass.call(object) == "[object Function]", property, isConstructor;
                            for (property in object) {
                                if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                                    callback(property);
                                }
                            }
                            // Manually invoke the callback for the `constructor` property due to
                            // cross-environment inconsistencies.
                            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
                                callback(property);
                            }
                        };
                    }
                    return forEach(object, callback);
                };

                // Public: Serializes a JavaScript `value` as a JSON string. The optional
                // `filter` argument may specify either a function that alters how object and
                // array members are serialized, or an array of strings and numbers that
                // indicates which properties should be serialized. The optional `width`
                // argument may be either a string or number that specifies the indentation
                // level of the output.
                if (!has("json-stringify")) {
                    // Internal: A map of control characters and their escaped equivalents.
                    Escapes = {
                        "\\": "\\\\",
                        '"': '\\"',
                        "\b": "\\b",
                        "\f": "\\f",
                        "\n": "\\n",
                        "\r": "\\r",
                        "\t": "\\t"
                    };

                    // Internal: Converts `value` into a zero-padded string such that its
                    // length is at least equal to `width`. The `width` must be <= 6.
                    toPaddedString = function (width, value) {
                        // The `|| 0` expression is necessary to work around a bug in
                        // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
                        return ("000000" + (value || 0)).slice( - width);
                    };

                    // Internal: Double-quotes a string `value`, replacing all ASCII control
                    // characters (characters with code unit values between 0 and 31) with
                    // their escaped equivalents. This is an implementation of the
                    // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
                    quote = function (value) {
                        var result = '"', index = 0, symbol;
                        for (; symbol = value.charAt(index); index++) {
                            // Escape the reverse solidus, double quote, backspace, form feed, line
                            // feed, carriage return, and tab characters.
                            result += '\\"\b\f\n\r\t'.indexOf(symbol) > - 1 ? Escapes[symbol] :
                            // If the character is a control character, append its Unicode escape
                            // sequence; otherwise, append the character as-is.
                            (Escapes[symbol] = symbol < " " ? "\\u00" + toPaddedString(2, symbol.charCodeAt(0).toString(16)) : symbol);
                        }
                        return result + '"';
                    };

                    // Internal: Recursively serializes an object. Implements the
                    // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
                    serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
                        var value = object[property], className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, any, result;
                        if (typeof value == "object" && value) {
                            className = getClass.call(value);
                            if (className == "[object Date]" && !isProperty.call(value, "toJSON")) {
                                if (value > - 1 / 0 && value < 1 / 0) {
                                    // Dates are serialized according to the `Date#toJSON` method
                                    // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                                    // for the ISO 8601 date time string format.
                                    if (getDay) {
                                        // Manually compute the year, month, date, hours, minutes,
                                        // seconds, and milliseconds if the `getUTC*` methods are
                                        // buggy. Adapted from @Yaffle's `date-shim` project.
                                        date = floor(value / 864e5);
                                        for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                                        for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                                        date = 1 + date - getDay(year, month);
                                        // The `time` value specifies the time within the day (see ES
                                        // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                                        // to compute `A modulo B`, as the `%` operator does not
                                        // correspond to the `modulo` operation for negative numbers.
                                        time = (value % 864e5 + 864e5) % 864e5;
                                        // The hours, minutes, seconds, and milliseconds are obtained by
                                        // decomposing the time within the day. See section 15.9.1.10.
                                        hours = floor(time / 36e5) % 24;
                                        minutes = floor(time / 6e4) % 60;
                                        seconds = floor(time / 1e3) % 60;
                                        milliseconds = time % 1e3;
                                    } else {
                                        year = value.getUTCFullYear();
                                        month = value.getUTCMonth();
                                        date = value.getUTCDate();
                                        hours = value.getUTCHours();
                                        minutes = value.getUTCMinutes();
                                        seconds = value.getUTCSeconds();
                                        milliseconds = value.getUTCMilliseconds();
                                    }
                                    // Serialize extended years correctly.
                                    value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? - year : year) : toPaddedString(4, year)) +
                                    "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                                    // Months, dates, hours, minutes, and seconds should have two
                                    // digits; milliseconds should have three.
                                    "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                                    // Milliseconds are optional in ES 5.0, but required in 5.1.
                                    "." + toPaddedString(3, milliseconds) + "Z";
                                } else {
                                    value = null;
                                }
                            } else if (typeof value.toJSON == "function" && ((className != "[object Number]" && className != "[object String]" && className != "[object Array]") || isProperty.call(value, "toJSON"))) {
                                // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
                                // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
                                // ignores all `toJSON` methods on these objects unless they are
                                // defined directly on an instance.
                                value = value.toJSON(property);
                            }
                        }
                        if (callback) {
                            // If a replacement function was provided, call it to obtain the value
                            // for serialization.
                            value = callback.call(object, property, value);
                        }
                        if (value === null) {
                            return "null";
                        }
                        className = getClass.call(value);
                        if (className == "[object Boolean]") {
                            // Booleans are represented literally.
                            return "" + value;
                        } else if (className == "[object Number]") {
                            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
                            // `"null"`.
                            return value > - 1 / 0 && value < 1 / 0 ? "" + value : "null";
                        } else if (className == "[object String]") {
                            // Strings are double-quoted and escaped.
                            return quote(value);
                        }
                        // Recursively serialize objects and arrays.
                        if (typeof value == "object") {
                            // Check for cyclic structures. This is a linear search; performance
                            // is inversely proportional to the number of unique nested objects.
                            for (length = stack.length; length--;) {
                                if (stack[length] === value) {
                                    // Cyclic structures cannot be serialized by `JSON.stringify`.
                                    throw TypeError();
                                }
                            }
                            // Add the object to the stack of traversed objects.
                            stack.push(value);
                            results = [];
                            // Save the current indentation level and indent one additional level.
                            prefix = indentation;
                            indentation += whitespace;
                            if (className == "[object Array]") {
                                // Recursively serialize array elements.
                                for (index = 0, length = value.length; index < length; any || (any = true)
                                    , index++) {
                                    element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                                    results.push(element === undef ? "null" : element);
                                }
                                result = any ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
                            } else {
                                // Recursively serialize object members. Members are selected from
                                // either a user-specified list of property names, or the object
                                // itself.
                                forEach(properties || value, function (property) {
                                    var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                                    if (element !== undef) {
                                        // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                                        // is not the empty string, let `member` {quote(property) + ":"}
                                        // be the concatenation of `member` and the `space` character."
                                        // The "`space` character" refers to the literal space
                                        // character, not the `space` {width} argument provided to
                                        // `JSON.stringify`.
                                        results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                                    }
                                    any || (any = true);
                                });
                                result = any ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
                            }
                            // Remove the object from the traversed object stack.
                            stack.pop();
                            return result;
                        }
                    };

                    // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
                    JSON3.stringify = function (source, filter, width) {
                        var whitespace, callback, properties, index, length, value;
                        if (typeof filter == "function" || typeof filter == "object" && filter) {
                            if (getClass.call(filter) == "[object Function]") {
                                callback = filter;
                            } else if (getClass.call(filter) == "[object Array]") {
                                // Convert the property names array into a makeshift set.
                                properties = {};
                                for (index = 0, length = filter.length; index < length; value = filter[index++], ((getClass.call(value) 
                                    == "[object String]" || getClass.call(value) == "[object Number]") && (properties[value] = 1)));
                            }
                        }
                        if (width) {
                            if (getClass.call(width) == "[object Number]") {
                                // Convert the `width` to an integer and create a string containing
                                // `width` number of space characters.
                                if ((width -= width % 1) > 0) {
                                    for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
                                }
                            } else if (getClass.call(width) == "[object String]") {
                                whitespace = width.length <= 10 ? width : width.slice(0, 10);
                            }
                        }
                        // Opera <= 7.54u2 discards the values associated with empty string keys
                        // (`""`) only if they are used directly within an object member list
                        // (e.g., `!("" in { "": 1})`).
                        return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
                    };
                }

                // Public: Parses a JSON source string.
                if (!has("json-parse")) {
                    fromCharCode = String.fromCharCode;
                    // Internal: A map of escaped control characters and their unescaped
                    // equivalents.
                    Unescapes = {
                        "\\": "\\",
                        '"': '"',
                        "/": "/",
                        "b": "\b",
                        "t": "\t",
                        "n": "\n",
                        "f": "\f",
                        "r": "\r"
                    };

                    // Internal: Resets the parser state and throws a `SyntaxError`.
                    abort = function() {
                        Index = Source = null;
                        throw SyntaxError();
                    };

                    // Internal: Returns the next token, or `"$"` if the parser has reached
                    // the end of the source string. A token may be a string, number, `null`
                    // literal, or Boolean literal.
                    lex = function () {
                        var source = Source, length = source.length, symbol, value, begin, position, sign;
                        while (Index < length) {
                            symbol = source.charAt(Index);
                            if ("\t\r\n ".indexOf(symbol) > - 1) {
                                // Skip whitespace tokens, including tabs, carriage returns, line
                                // feeds, and space characters.
                                Index++;
                            } else if ("{}[]:,".indexOf(symbol) > - 1) {
                                // Parse a punctuator token at the current position.
                                Index++;
                                return symbol;
                            } else if (symbol == '"') {
                                // Advance to the next character and parse a JSON string at the
                                // current position. String tokens are prefixed with the sentinel
                                // `@` character to distinguish them from punctuators.
                                for (value = "@", Index++; Index < length;) {
                                    symbol = source.charAt(Index);
                                    if (symbol < " ") {
                                        // Unescaped ASCII control characters are not permitted.
                                        abort();
                                    } else if (symbol == "\\") {
                                        // Parse escaped JSON control characters, `"`, `\`, `/`, and
                                        // Unicode escape sequences.
                                        symbol = source.charAt(++Index);
                                        if ('\\"/btnfr'.indexOf(symbol) > - 1) {
                                            // Revive escaped control characters.
                                            value += Unescapes[symbol];
                                            Index++;
                                        } else if (symbol == "u") {
                                            // Advance to the first character of the escape sequence.
                                            begin = ++Index;
                                            // Validate the Unicode escape sequence.
                                            for (position = Index + 4; Index < position; Index++) {
                                                symbol = source.charAt(Index);
                                                // A valid sequence comprises four hexdigits that form a
                                                // single hexadecimal value.
                                                if (!(symbol >= "0" && symbol <= "9" || symbol >= "a" && symbol <= "f" || symbol >= "A" && symbol <= "F")) {
                                                    // Invalid Unicode escape sequence.
                                                    abort();
                                                }
                                            }
                                            // Revive the escaped character.
                                            value += fromCharCode("0x" + source.slice(begin, Index));
                                        } else {
                                            // Invalid escape sequence.
                                            abort();
                                        }
                                    } else {
                                        if (symbol == '"') {
                                            // An unescaped double-quote character marks the end of the
                                            // string.
                                            break;
                                        }
                                        // Append the original character as-is.
                                        value += symbol;
                                        Index++;
                                    }
                                }
                                if (source.charAt(Index) == '"') {
                                    Index++;
                                    // Return the revived string.
                                    return value;
                                }
                                // Unterminated string.
                                abort();
                            } else {
                                // Parse numbers and literals.
                                begin = Index;
                                // Advance the scanner's position past the sign, if one is
                                // specified.
                                if (symbol == "-") {
                                    sign = true;
                                    symbol = source.charAt(++Index);
                                }
                                // Parse an integer or floating-point value.
                                if (symbol >= "0" && symbol <= "9") {
                                    // Leading zeroes are interpreted as octal literals.
                                    if (symbol == "0" && (symbol = source.charAt(Index + 1), symbol >= "0" && symbol <= "9")) {
                                        // Illegal octal literal.
                                        abort();
                                    }
                                    sign = false;
                                    // Parse the integer component.
                                    for (; Index < length && (symbol = source.charAt(Index), symbol >= "0" && symbol <= "9"); Index++);
                                    // Floats cannot contain a leading decimal point; however, this
                                    // case is already accounted for by the parser.
                                    if (source.charAt(Index) == ".") {
                                        position = ++Index;
                                        // Parse the decimal component.
                                        for (; position < length && (symbol = source.charAt(position), symbol >= "0" && symbol <= "9"); position++);
                                        if (position == Index) {
                                            // Illegal trailing decimal.
                                            abort();
                                        }
                                        Index = position;
                                    }
                                    // Parse exponents.
                                    symbol = source.charAt(Index);
                                    if (symbol == "e" || symbol == "E") {
                                        // Skip past the sign following the exponent, if one is
                                        // specified.
                                        symbol = source.charAt(++Index);
                                        if (symbol == "+" || symbol == "-") {
                                            Index++;
                                        }
                                        // Parse the exponential component.
                                        for (position = Index; position < length && (symbol = source.charAt(position), symbol >= "0" && symbol <= "9"); position++);
                                        if (position == Index) {
                                            // Illegal empty exponent.
                                            abort();
                                        }
                                        Index = position;
                                    }
                                    // Coerce the parsed value to a JavaScript number.
                                    return + source.slice(begin, Index);
                                }
                                // A negative sign may only precede numbers.
                                if (sign) {
                                    abort();
                                }
                                // `true`, `false`, and `null` literals.
                                if (source.slice(Index, Index + 4) == "true") {
                                    Index += 4;
                                    return true;
                                } else if (source.slice(Index, Index + 5) == "false") {
                                    Index += 5;
                                    return false;
                                } else if (source.slice(Index, Index + 4) == "null") {
                                    Index += 4;
                                    return null;
                                }
                                // Unrecognized token.
                                abort();
                            }
                        }
                        // Return the sentinel `$` character if the parser has reached the end
                        // of the source string.
                        return "$";
                    };

                    // Internal: Parses a JSON `value` token.
                    get = function (value) {
                        var results, any, key;
                        if (value == "$") {
                            // Unexpected end of input.
                            abort();
                        }
                        if (typeof value == "string") {
                            if (value.charAt(0) == "@") {
                                // Remove the sentinel `@` character.
                                return value.slice(1);
                            }
                            // Parse object and array literals.
                            if (value == "[") {
                                // Parses a JSON array, returning a new JavaScript array.
                                results = [];
                                for (; ; any || (any = true)) {
                                    value = lex();
                                    // A closing square bracket marks the end of the array literal.
                                    if (value == "]") {
                                        break;
                                    }
                                    // If the array literal contains elements, the current token
                                    // should be a comma separating the previous element from the
                                    // next.
                                    if (any) {
                                        if (value == ",") {
                                            value = lex();
                                            if (value == "]") {
                                                // Unexpected trailing `,` in array literal.
                                                abort();
                                            }
                                        } else {
                                            // A `,` must separate each array element.
                                            abort();
                                        }
                                    }
                                    // Elisions and leading commas are not permitted.
                                    if (value == ",") {
                                        abort();
                                    }
                                    results.push(get(value));
                                }
                                return results;
                            } else if (value == "{") {
                                // Parses a JSON object, returning a new JavaScript object.
                                results = {};
                                for (; ; any || (any = true)) {
                                    value = lex();
                                    // A closing curly brace marks the end of the object literal.
                                    if (value == "}") {
                                        break;
                                    }
                                    // If the object literal contains members, the current token
                                    // should be a comma separator.
                                    if (any) {
                                        if (value == ",") {
                                            value = lex();
                                            if (value == "}") {
                                                // Unexpected trailing `,` in object literal.
                                                abort();
                                            }
                                        } else {
                                            // A `,` must separate each object member.
                                            abort();
                                        }
                                    }
                                    // Leading commas are not permitted, object property names must be
                                    // double-quoted strings, and a `:` must separate each property
                                    // name and value.
                                    if (value == "," || typeof value != "string" || value.charAt(0) != "@" || lex() != ":") {
                                        abort();
                                    }
                                    results[value.slice(1)] = get(lex());
                                }
                                return results;
                            }
                            // Unexpected token encountered.
                            abort();
                        }
                        return value;
                    };

                    // Internal: Updates a traversed object member.
                    update = function(source, property, callback) {
                        var element = walk(source, property, callback);
                        if (element === undef) {
                            delete source[property];
                        } else {
                            source[property] = element;
                        }
                    };

                    // Internal: Recursively traverses a parsed JSON object, invoking the
                    // `callback` function for each value. This is an implementation of the
                    // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
                    walk = function (source, property, callback) {
                        var value = source[property], length;
                        if (typeof value == "object" && value) {
                            if (getClass.call(value) == "[object Array]") {
                                for (length = value.length; length--;) {
                                    update(value, length, callback);
                                }
                            } else {
                                // `forEach` can't be used to traverse an array in Opera <= 8.54,
                                // as `Object#hasOwnProperty` returns `false` for array indices
                                // (e.g., `![1, 2, 3].hasOwnProperty("0")`).
                                forEach(value, function (property) {
                                    update(value, property, callback);
                                });
                            }
                        }
                        return callback.call(source, property, value);
                    };

                    // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
                    JSON3.parse = function (source, callback) {
                        var result, value;
                        Index = 0;
                        Source = source;
                        result = get(lex());
                        // If a JSON string contains multiple tokens, it is invalid.
                        if (lex() != "$") {
                            abort();
                        }
                        // Reset the parser state.
                        Index = Source = null;
                        return callback && getClass.call(callback) == "[object Function]" ? walk((value = {}, value[""] = result, value), "", callback) : result;
                    };
                }
            }

            // Export for asynchronous module loaders.
            if (isLoader) {
                define(function () {
                    return JSON3;
                });
            }
        }).call(this);
    }, {}
    ],
    264: [function(require, module, exports) {
        var global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}; /** @license MIT License (c) copyright 2013 original authors */
        /**
         * XHR polyfill / shims
         *
         * @author Brian Cavalier
         * @author John Hann
         */
        (function (global, define) {
            define(function (require) {
                "use strict";

                var progIds;

                // find XHR implementation
                if (typeof XMLHttpRequest == 'undefined') {
                    // create xhr impl that will fail if called.
                    assignCtor(function () {
                        throw new Error("poly/xhr: XMLHttpRequest not available");
                    });
                    // keep trying progIds until we find the correct one,
                    progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];
                    while (progIds.length && tryProgId(progIds.shift())) {}
                }

                function assignCtor (ctor) {
                    // assign global.XMLHttpRequest function
                    global.XMLHttpRequest = ctor;
                }

                function tryProgId (progId) {
                    try {
                        new ActiveXObject(progId);
                        assignCtor(function () {
                            return new ActiveXObject(progId);
                        });
                        return true;
                    } catch (ex) {}
                }

            });
        }(
        typeof global != 'undefined' && global || this.global || this,
        typeof define == 'function' && define.amd
        ? define
        : function (factory) {
            module.exports = factory(require);
        }));

    }, {}
    ],
    265: [function(require, module, exports) {
        /*
        Copyright 2012 Igor Vaynberg

        Version: 3.4.5 Timestamp: Mon Nov  4 08:22:42 PST 2013

        This software is licensed under the Apache License, Version 2.0 (the "Apache License") or the GNU
        General Public License version 2 (the "GPL License"). You may choose either license to govern your
        use of this software only upon the condition that you accept all of the terms of either the Apache
        License or the GPL License.

        You may obtain a copy of the Apache License and the GPL License at:

            http://www.apache.org/licenses/LICENSE-2.0
            http://www.gnu.org/licenses/gpl-2.0.html

        Unless required by applicable law or agreed to in writing, software distributed under the
        Apache License or the GPL Licesnse is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
        CONDITIONS OF ANY KIND, either express or implied. See the Apache License and the GPL License for
        the specific language governing permissions and limitations under the Apache License and the GPL License.
        */
        (function ($) {
            if (typeof $.fn.each2 == "undefined") {
                $.extend($.fn, {
                    /*
                                * 4-10 times faster .each replacement
                                * use it carefully, as it overrides jQuery context of element on each iteration
                                */
                    each2 : function (c) {
                        var j = $([0]), i = - 1, l = this.length;
                        while (
                        ++i < l
                        && (j.context = j[0] = this[i])
                        && c.call(j[0], i, j) !== false //"this"=DOM, i=index, j=jQuery object
                        );
                        return this;
                    }
                });
            }
        })(jQuery);

        (function ($, undefined) {
            "use strict";
            /*global document, window, jQuery, console */

            if (window.Select2 !== undefined) {
                return;
            }

            var KEY, AbstractSelect2, SingleSelect2, MultiSelect2, nextUid, sizer,
            lastMousePosition = {
                x: 0,
                y: 0
            }, $document, scrollBarDimensions,
            KEY = {
                TAB: 9,
                ENTER: 13,
                ESC: 27,
                SPACE: 32,
                LEFT: 37,
                UP: 38,
                RIGHT: 39,
                DOWN: 40,
                SHIFT: 16,
                CTRL: 17,
                ALT: 18,
                PAGE_UP: 33,
                PAGE_DOWN: 34,
                HOME: 36,
                END: 35,
                BACKSPACE: 8,
                DELETE: 46,
                isArrow: function (k) {
                    k = k.which ? k.which : k;
                    switch (k) {
                    case KEY.LEFT:
                    case KEY.RIGHT:
                    case KEY.UP:
                    case KEY.DOWN:
                        return true;
                    }
                    return false;
                },
                isControl: function (e) {
                    var k = e.which;
                    switch (k) {
                    case KEY.SHIFT:
                    case KEY.CTRL:
                    case KEY.ALT:
                        return true;
                    }

                    if (e.metaKey) 
                        return true;

                    return false;
                },
                isFunctionKey: function (k) {
                    k = k.which ? k.which : k;
                    return k >= 112 && k <= 123;
                }
            },
            MEASURE_SCROLLBAR_TEMPLATE = "<div class='select2-measure-scrollbar'></div>",
            DIACRITICS = {
                "\u24B6": "A",
                "\uFF21": "A",
                "\u00C0": "A",
                "\u00C1": "A",
                "\u00C2": "A",
                "\u1EA6": "A",
                "\u1EA4": "A",
                "\u1EAA": "A",
                "\u1EA8": "A",
                "\u00C3": "A",
                "\u0100": "A",
                "\u0102": "A",
                "\u1EB0": "A",
                "\u1EAE": "A",
                "\u1EB4": "A",
                "\u1EB2": "A",
                "\u0226": "A",
                "\u01E0": "A",
                "\u00C4": "A",
                "\u01DE": "A",
                "\u1EA2": "A",
                "\u00C5": "A",
                "\u01FA": "A",
                "\u01CD": "A",
                "\u0200": "A",
                "\u0202": "A",
                "\u1EA0": "A",
                "\u1EAC": "A",
                "\u1EB6": "A",
                "\u1E00": "A",
                "\u0104": "A",
                "\u023A": "A",
                "\u2C6F": "A",
                "\uA732": "AA",
                "\u00C6": "AE",
                "\u01FC": "AE",
                "\u01E2": "AE",
                "\uA734": "AO",
                "\uA736": "AU",
                "\uA738": "AV",
                "\uA73A": "AV",
                "\uA73C": "AY",
                "\u24B7": "B",
                "\uFF22": "B",
                "\u1E02": "B",
                "\u1E04": "B",
                "\u1E06": "B",
                "\u0243": "B",
                "\u0182": "B",
                "\u0181": "B",
                "\u24B8": "C",
                "\uFF23": "C",
                "\u0106": "C",
                "\u0108": "C",
                "\u010A": "C",
                "\u010C": "C",
                "\u00C7": "C",
                "\u1E08": "C",
                "\u0187": "C",
                "\u023B": "C",
                "\uA73E": "C",
                "\u24B9": "D",
                "\uFF24": "D",
                "\u1E0A": "D",
                "\u010E": "D",
                "\u1E0C": "D",
                "\u1E10": "D",
                "\u1E12": "D",
                "\u1E0E": "D",
                "\u0110": "D",
                "\u018B": "D",
                "\u018A": "D",
                "\u0189": "D",
                "\uA779": "D",
                "\u01F1": "DZ",
                "\u01C4": "DZ",
                "\u01F2": "Dz",
                "\u01C5": "Dz",
                "\u24BA": "E",
                "\uFF25": "E",
                "\u00C8": "E",
                "\u00C9": "E",
                "\u00CA": "E",
                "\u1EC0": "E",
                "\u1EBE": "E",
                "\u1EC4": "E",
                "\u1EC2": "E",
                "\u1EBC": "E",
                "\u0112": "E",
                "\u1E14": "E",
                "\u1E16": "E",
                "\u0114": "E",
                "\u0116": "E",
                "\u00CB": "E",
                "\u1EBA": "E",
                "\u011A": "E",
                "\u0204": "E",
                "\u0206": "E",
                "\u1EB8": "E",
                "\u1EC6": "E",
                "\u0228": "E",
                "\u1E1C": "E",
                "\u0118": "E",
                "\u1E18": "E",
                "\u1E1A": "E",
                "\u0190": "E",
                "\u018E": "E",
                "\u24BB": "F",
                "\uFF26": "F",
                "\u1E1E": "F",
                "\u0191": "F",
                "\uA77B": "F",
                "\u24BC": "G",
                "\uFF27": "G",
                "\u01F4": "G",
                "\u011C": "G",
                "\u1E20": "G",
                "\u011E": "G",
                "\u0120": "G",
                "\u01E6": "G",
                "\u0122": "G",
                "\u01E4": "G",
                "\u0193": "G",
                "\uA7A0": "G",
                "\uA77D": "G",
                "\uA77E": "G",
                "\u24BD": "H",
                "\uFF28": "H",
                "\u0124": "H",
                "\u1E22": "H",
                "\u1E26": "H",
                "\u021E": "H",
                "\u1E24": "H",
                "\u1E28": "H",
                "\u1E2A": "H",
                "\u0126": "H",
                "\u2C67": "H",
                "\u2C75": "H",
                "\uA78D": "H",
                "\u24BE": "I",
                "\uFF29": "I",
                "\u00CC": "I",
                "\u00CD": "I",
                "\u00CE": "I",
                "\u0128": "I",
                "\u012A": "I",
                "\u012C": "I",
                "\u0130": "I",
                "\u00CF": "I",
                "\u1E2E": "I",
                "\u1EC8": "I",
                "\u01CF": "I",
                "\u0208": "I",
                "\u020A": "I",
                "\u1ECA": "I",
                "\u012E": "I",
                "\u1E2C": "I",
                "\u0197": "I",
                "\u24BF": "J",
                "\uFF2A": "J",
                "\u0134": "J",
                "\u0248": "J",
                "\u24C0": "K",
                "\uFF2B": "K",
                "\u1E30": "K",
                "\u01E8": "K",
                "\u1E32": "K",
                "\u0136": "K",
                "\u1E34": "K",
                "\u0198": "K",
                "\u2C69": "K",
                "\uA740": "K",
                "\uA742": "K",
                "\uA744": "K",
                "\uA7A2": "K",
                "\u24C1": "L",
                "\uFF2C": "L",
                "\u013F": "L",
                "\u0139": "L",
                "\u013D": "L",
                "\u1E36": "L",
                "\u1E38": "L",
                "\u013B": "L",
                "\u1E3C": "L",
                "\u1E3A": "L",
                "\u0141": "L",
                "\u023D": "L",
                "\u2C62": "L",
                "\u2C60": "L",
                "\uA748": "L",
                "\uA746": "L",
                "\uA780": "L",
                "\u01C7": "LJ",
                "\u01C8": "Lj",
                "\u24C2": "M",
                "\uFF2D": "M",
                "\u1E3E": "M",
                "\u1E40": "M",
                "\u1E42": "M",
                "\u2C6E": "M",
                "\u019C": "M",
                "\u24C3": "N",
                "\uFF2E": "N",
                "\u01F8": "N",
                "\u0143": "N",
                "\u00D1": "N",
                "\u1E44": "N",
                "\u0147": "N",
                "\u1E46": "N",
                "\u0145": "N",
                "\u1E4A": "N",
                "\u1E48": "N",
                "\u0220": "N",
                "\u019D": "N",
                "\uA790": "N",
                "\uA7A4": "N",
                "\u01CA": "NJ",
                "\u01CB": "Nj",
                "\u24C4": "O",
                "\uFF2F": "O",
                "\u00D2": "O",
                "\u00D3": "O",
                "\u00D4": "O",
                "\u1ED2": "O",
                "\u1ED0": "O",
                "\u1ED6": "O",
                "\u1ED4": "O",
                "\u00D5": "O",
                "\u1E4C": "O",
                "\u022C": "O",
                "\u1E4E": "O",
                "\u014C": "O",
                "\u1E50": "O",
                "\u1E52": "O",
                "\u014E": "O",
                "\u022E": "O",
                "\u0230": "O",
                "\u00D6": "O",
                "\u022A": "O",
                "\u1ECE": "O",
                "\u0150": "O",
                "\u01D1": "O",
                "\u020C": "O",
                "\u020E": "O",
                "\u01A0": "O",
                "\u1EDC": "O",
                "\u1EDA": "O",
                "\u1EE0": "O",
                "\u1EDE": "O",
                "\u1EE2": "O",
                "\u1ECC": "O",
                "\u1ED8": "O",
                "\u01EA": "O",
                "\u01EC": "O",
                "\u00D8": "O",
                "\u01FE": "O",
                "\u0186": "O",
                "\u019F": "O",
                "\uA74A": "O",
                "\uA74C": "O",
                "\u01A2": "OI",
                "\uA74E": "OO",
                "\u0222": "OU",
                "\u24C5": "P",
                "\uFF30": "P",
                "\u1E54": "P",
                "\u1E56": "P",
                "\u01A4": "P",
                "\u2C63": "P",
                "\uA750": "P",
                "\uA752": "P",
                "\uA754": "P",
                "\u24C6": "Q",
                "\uFF31": "Q",
                "\uA756": "Q",
                "\uA758": "Q",
                "\u024A": "Q",
                "\u24C7": "R",
                "\uFF32": "R",
                "\u0154": "R",
                "\u1E58": "R",
                "\u0158": "R",
                "\u0210": "R",
                "\u0212": "R",
                "\u1E5A": "R",
                "\u1E5C": "R",
                "\u0156": "R",
                "\u1E5E": "R",
                "\u024C": "R",
                "\u2C64": "R",
                "\uA75A": "R",
                "\uA7A6": "R",
                "\uA782": "R",
                "\u24C8": "S",
                "\uFF33": "S",
                "\u1E9E": "S",
                "\u015A": "S",
                "\u1E64": "S",
                "\u015C": "S",
                "\u1E60": "S",
                "\u0160": "S",
                "\u1E66": "S",
                "\u1E62": "S",
                "\u1E68": "S",
                "\u0218": "S",
                "\u015E": "S",
                "\u2C7E": "S",
                "\uA7A8": "S",
                "\uA784": "S",
                "\u24C9": "T",
                "\uFF34": "T",
                "\u1E6A": "T",
                "\u0164": "T",
                "\u1E6C": "T",
                "\u021A": "T",
                "\u0162": "T",
                "\u1E70": "T",
                "\u1E6E": "T",
                "\u0166": "T",
                "\u01AC": "T",
                "\u01AE": "T",
                "\u023E": "T",
                "\uA786": "T",
                "\uA728": "TZ",
                "\u24CA": "U",
                "\uFF35": "U",
                "\u00D9": "U",
                "\u00DA": "U",
                "\u00DB": "U",
                "\u0168": "U",
                "\u1E78": "U",
                "\u016A": "U",
                "\u1E7A": "U",
                "\u016C": "U",
                "\u00DC": "U",
                "\u01DB": "U",
                "\u01D7": "U",
                "\u01D5": "U",
                "\u01D9": "U",
                "\u1EE6": "U",
                "\u016E": "U",
                "\u0170": "U",
                "\u01D3": "U",
                "\u0214": "U",
                "\u0216": "U",
                "\u01AF": "U",
                "\u1EEA": "U",
                "\u1EE8": "U",
                "\u1EEE": "U",
                "\u1EEC": "U",
                "\u1EF0": "U",
                "\u1EE4": "U",
                "\u1E72": "U",
                "\u0172": "U",
                "\u1E76": "U",
                "\u1E74": "U",
                "\u0244": "U",
                "\u24CB": "V",
                "\uFF36": "V",
                "\u1E7C": "V",
                "\u1E7E": "V",
                "\u01B2": "V",
                "\uA75E": "V",
                "\u0245": "V",
                "\uA760": "VY",
                "\u24CC": "W",
                "\uFF37": "W",
                "\u1E80": "W",
                "\u1E82": "W",
                "\u0174": "W",
                "\u1E86": "W",
                "\u1E84": "W",
                "\u1E88": "W",
                "\u2C72": "W",
                "\u24CD": "X",
                "\uFF38": "X",
                "\u1E8A": "X",
                "\u1E8C": "X",
                "\u24CE": "Y",
                "\uFF39": "Y",
                "\u1EF2": "Y",
                "\u00DD": "Y",
                "\u0176": "Y",
                "\u1EF8": "Y",
                "\u0232": "Y",
                "\u1E8E": "Y",
                "\u0178": "Y",
                "\u1EF6": "Y",
                "\u1EF4": "Y",
                "\u01B3": "Y",
                "\u024E": "Y",
                "\u1EFE": "Y",
                "\u24CF": "Z",
                "\uFF3A": "Z",
                "\u0179": "Z",
                "\u1E90": "Z",
                "\u017B": "Z",
                "\u017D": "Z",
                "\u1E92": "Z",
                "\u1E94": "Z",
                "\u01B5": "Z",
                "\u0224": "Z",
                "\u2C7F": "Z",
                "\u2C6B": "Z",
                "\uA762": "Z",
                "\u24D0": "a",
                "\uFF41": "a",
                "\u1E9A": "a",
                "\u00E0": "a",
                "\u00E1": "a",
                "\u00E2": "a",
                "\u1EA7": "a",
                "\u1EA5": "a",
                "\u1EAB": "a",
                "\u1EA9": "a",
                "\u00E3": "a",
                "\u0101": "a",
                "\u0103": "a",
                "\u1EB1": "a",
                "\u1EAF": "a",
                "\u1EB5": "a",
                "\u1EB3": "a",
                "\u0227": "a",
                "\u01E1": "a",
                "\u00E4": "a",
                "\u01DF": "a",
                "\u1EA3": "a",
                "\u00E5": "a",
                "\u01FB": "a",
                "\u01CE": "a",
                "\u0201": "a",
                "\u0203": "a",
                "\u1EA1": "a",
                "\u1EAD": "a",
                "\u1EB7": "a",
                "\u1E01": "a",
                "\u0105": "a",
                "\u2C65": "a",
                "\u0250": "a",
                "\uA733": "aa",
                "\u00E6": "ae",
                "\u01FD": "ae",
                "\u01E3": "ae",
                "\uA735": "ao",
                "\uA737": "au",
                "\uA739": "av",
                "\uA73B": "av",
                "\uA73D": "ay",
                "\u24D1": "b",
                "\uFF42": "b",
                "\u1E03": "b",
                "\u1E05": "b",
                "\u1E07": "b",
                "\u0180": "b",
                "\u0183": "b",
                "\u0253": "b",
                "\u24D2": "c",
                "\uFF43": "c",
                "\u0107": "c",
                "\u0109": "c",
                "\u010B": "c",
                "\u010D": "c",
                "\u00E7": "c",
                "\u1E09": "c",
                "\u0188": "c",
                "\u023C": "c",
                "\uA73F": "c",
                "\u2184": "c",
                "\u24D3": "d",
                "\uFF44": "d",
                "\u1E0B": "d",
                "\u010F": "d",
                "\u1E0D": "d",
                "\u1E11": "d",
                "\u1E13": "d",
                "\u1E0F": "d",
                "\u0111": "d",
                "\u018C": "d",
                "\u0256": "d",
                "\u0257": "d",
                "\uA77A": "d",
                "\u01F3": "dz",
                "\u01C6": "dz",
                "\u24D4": "e",
                "\uFF45": "e",
                "\u00E8": "e",
                "\u00E9": "e",
                "\u00EA": "e",
                "\u1EC1": "e",
                "\u1EBF": "e",
                "\u1EC5": "e",
                "\u1EC3": "e",
                "\u1EBD": "e",
                "\u0113": "e",
                "\u1E15": "e",
                "\u1E17": "e",
                "\u0115": "e",
                "\u0117": "e",
                "\u00EB": "e",
                "\u1EBB": "e",
                "\u011B": "e",
                "\u0205": "e",
                "\u0207": "e",
                "\u1EB9": "e",
                "\u1EC7": "e",
                "\u0229": "e",
                "\u1E1D": "e",
                "\u0119": "e",
                "\u1E19": "e",
                "\u1E1B": "e",
                "\u0247": "e",
                "\u025B": "e",
                "\u01DD": "e",
                "\u24D5": "f",
                "\uFF46": "f",
                "\u1E1F": "f",
                "\u0192": "f",
                "\uA77C": "f",
                "\u24D6": "g",
                "\uFF47": "g",
                "\u01F5": "g",
                "\u011D": "g",
                "\u1E21": "g",
                "\u011F": "g",
                "\u0121": "g",
                "\u01E7": "g",
                "\u0123": "g",
                "\u01E5": "g",
                "\u0260": "g",
                "\uA7A1": "g",
                "\u1D79": "g",
                "\uA77F": "g",
                "\u24D7": "h",
                "\uFF48": "h",
                "\u0125": "h",
                "\u1E23": "h",
                "\u1E27": "h",
                "\u021F": "h",
                "\u1E25": "h",
                "\u1E29": "h",
                "\u1E2B": "h",
                "\u1E96": "h",
                "\u0127": "h",
                "\u2C68": "h",
                "\u2C76": "h",
                "\u0265": "h",
                "\u0195": "hv",
                "\u24D8": "i",
                "\uFF49": "i",
                "\u00EC": "i",
                "\u00ED": "i",
                "\u00EE": "i",
                "\u0129": "i",
                "\u012B": "i",
                "\u012D": "i",
                "\u00EF": "i",
                "\u1E2F": "i",
                "\u1EC9": "i",
                "\u01D0": "i",
                "\u0209": "i",
                "\u020B": "i",
                "\u1ECB": "i",
                "\u012F": "i",
                "\u1E2D": "i",
                "\u0268": "i",
                "\u0131": "i",
                "\u24D9": "j",
                "\uFF4A": "j",
                "\u0135": "j",
                "\u01F0": "j",
                "\u0249": "j",
                "\u24DA": "k",
                "\uFF4B": "k",
                "\u1E31": "k",
                "\u01E9": "k",
                "\u1E33": "k",
                "\u0137": "k",
                "\u1E35": "k",
                "\u0199": "k",
                "\u2C6A": "k",
                "\uA741": "k",
                "\uA743": "k",
                "\uA745": "k",
                "\uA7A3": "k",
                "\u24DB": "l",
                "\uFF4C": "l",
                "\u0140": "l",
                "\u013A": "l",
                "\u013E": "l",
                "\u1E37": "l",
                "\u1E39": "l",
                "\u013C": "l",
                "\u1E3D": "l",
                "\u1E3B": "l",
                "\u017F": "l",
                "\u0142": "l",
                "\u019A": "l",
                "\u026B": "l",
                "\u2C61": "l",
                "\uA749": "l",
                "\uA781": "l",
                "\uA747": "l",
                "\u01C9": "lj",
                "\u24DC": "m",
                "\uFF4D": "m",
                "\u1E3F": "m",
                "\u1E41": "m",
                "\u1E43": "m",
                "\u0271": "m",
                "\u026F": "m",
                "\u24DD": "n",
                "\uFF4E": "n",
                "\u01F9": "n",
                "\u0144": "n",
                "\u00F1": "n",
                "\u1E45": "n",
                "\u0148": "n",
                "\u1E47": "n",
                "\u0146": "n",
                "\u1E4B": "n",
                "\u1E49": "n",
                "\u019E": "n",
                "\u0272": "n",
                "\u0149": "n",
                "\uA791": "n",
                "\uA7A5": "n",
                "\u01CC": "nj",
                "\u24DE": "o",
                "\uFF4F": "o",
                "\u00F2": "o",
                "\u00F3": "o",
                "\u00F4": "o",
                "\u1ED3": "o",
                "\u1ED1": "o",
                "\u1ED7": "o",
                "\u1ED5": "o",
                "\u00F5": "o",
                "\u1E4D": "o",
                "\u022D": "o",
                "\u1E4F": "o",
                "\u014D": "o",
                "\u1E51": "o",
                "\u1E53": "o",
                "\u014F": "o",
                "\u022F": "o",
                "\u0231": "o",
                "\u00F6": "o",
                "\u022B": "o",
                "\u1ECF": "o",
                "\u0151": "o",
                "\u01D2": "o",
                "\u020D": "o",
                "\u020F": "o",
                "\u01A1": "o",
                "\u1EDD": "o",
                "\u1EDB": "o",
                "\u1EE1": "o",
                "\u1EDF": "o",
                "\u1EE3": "o",
                "\u1ECD": "o",
                "\u1ED9": "o",
                "\u01EB": "o",
                "\u01ED": "o",
                "\u00F8": "o",
                "\u01FF": "o",
                "\u0254": "o",
                "\uA74B": "o",
                "\uA74D": "o",
                "\u0275": "o",
                "\u01A3": "oi",
                "\u0223": "ou",
                "\uA74F": "oo",
                "\u24DF": "p",
                "\uFF50": "p",
                "\u1E55": "p",
                "\u1E57": "p",
                "\u01A5": "p",
                "\u1D7D": "p",
                "\uA751": "p",
                "\uA753": "p",
                "\uA755": "p",
                "\u24E0": "q",
                "\uFF51": "q",
                "\u024B": "q",
                "\uA757": "q",
                "\uA759": "q",
                "\u24E1": "r",
                "\uFF52": "r",
                "\u0155": "r",
                "\u1E59": "r",
                "\u0159": "r",
                "\u0211": "r",
                "\u0213": "r",
                "\u1E5B": "r",
                "\u1E5D": "r",
                "\u0157": "r",
                "\u1E5F": "r",
                "\u024D": "r",
                "\u027D": "r",
                "\uA75B": "r",
                "\uA7A7": "r",
                "\uA783": "r",
                "\u24E2": "s",
                "\uFF53": "s",
                "\u00DF": "s",
                "\u015B": "s",
                "\u1E65": "s",
                "\u015D": "s",
                "\u1E61": "s",
                "\u0161": "s",
                "\u1E67": "s",
                "\u1E63": "s",
                "\u1E69": "s",
                "\u0219": "s",
                "\u015F": "s",
                "\u023F": "s",
                "\uA7A9": "s",
                "\uA785": "s",
                "\u1E9B": "s",
                "\u24E3": "t",
                "\uFF54": "t",
                "\u1E6B": "t",
                "\u1E97": "t",
                "\u0165": "t",
                "\u1E6D": "t",
                "\u021B": "t",
                "\u0163": "t",
                "\u1E71": "t",
                "\u1E6F": "t",
                "\u0167": "t",
                "\u01AD": "t",
                "\u0288": "t",
                "\u2C66": "t",
                "\uA787": "t",
                "\uA729": "tz",
                "\u24E4": "u",
                "\uFF55": "u",
                "\u00F9": "u",
                "\u00FA": "u",
                "\u00FB": "u",
                "\u0169": "u",
                "\u1E79": "u",
                "\u016B": "u",
                "\u1E7B": "u",
                "\u016D": "u",
                "\u00FC": "u",
                "\u01DC": "u",
                "\u01D8": "u",
                "\u01D6": "u",
                "\u01DA": "u",
                "\u1EE7": "u",
                "\u016F": "u",
                "\u0171": "u",
                "\u01D4": "u",
                "\u0215": "u",
                "\u0217": "u",
                "\u01B0": "u",
                "\u1EEB": "u",
                "\u1EE9": "u",
                "\u1EEF": "u",
                "\u1EED": "u",
                "\u1EF1": "u",
                "\u1EE5": "u",
                "\u1E73": "u",
                "\u0173": "u",
                "\u1E77": "u",
                "\u1E75": "u",
                "\u0289": "u",
                "\u24E5": "v",
                "\uFF56": "v",
                "\u1E7D": "v",
                "\u1E7F": "v",
                "\u028B": "v",
                "\uA75F": "v",
                "\u028C": "v",
                "\uA761": "vy",
                "\u24E6": "w",
                "\uFF57": "w",
                "\u1E81": "w",
                "\u1E83": "w",
                "\u0175": "w",
                "\u1E87": "w",
                "\u1E85": "w",
                "\u1E98": "w",
                "\u1E89": "w",
                "\u2C73": "w",
                "\u24E7": "x",
                "\uFF58": "x",
                "\u1E8B": "x",
                "\u1E8D": "x",
                "\u24E8": "y",
                "\uFF59": "y",
                "\u1EF3": "y",
                "\u00FD": "y",
                "\u0177": "y",
                "\u1EF9": "y",
                "\u0233": "y",
                "\u1E8F": "y",
                "\u00FF": "y",
                "\u1EF7": "y",
                "\u1E99": "y",
                "\u1EF5": "y",
                "\u01B4": "y",
                "\u024F": "y",
                "\u1EFF": "y",
                "\u24E9": "z",
                "\uFF5A": "z",
                "\u017A": "z",
                "\u1E91": "z",
                "\u017C": "z",
                "\u017E": "z",
                "\u1E93": "z",
                "\u1E95": "z",
                "\u01B6": "z",
                "\u0225": "z",
                "\u0240": "z",
                "\u2C6C": "z",
                "\uA763": "z"
            };

            $document = $(document);

            nextUid = (function() {
                var counter = 1;
                return function() {
                    return counter++;
                };
            }());


            function stripDiacritics(str) {
                var ret, i, l, c;

                if (!str || str.length < 1) 
                    return str;

                ret = "";
                for (i = 0, l = str.length; i < l; i++) {
                    c = str.charAt(i);
                    ret += DIACRITICS[c] || c;
                }
                return ret;
            }

            function indexOf(value, array) {
                var i = 0, l = array.length;
                for (; i < l; i = i + 1) {
                    if (equal(value, array[i])) 
                        return i;
                }
                return - 1;
            }

            function measureScrollbar () {
                var $template = $( MEASURE_SCROLLBAR_TEMPLATE );
                $template.appendTo('body');

                var dim = {
                    width: $template.width() - $template[0].clientWidth,
                    height: $template.height() - $template[0].clientHeight
                };
                $template.remove();

                return dim;
            }

            /**
                 * Compares equality of a and b
                 * @param a
                 * @param b
                 */
            function equal(a, b) {
                if (a === b) 
                    return true;
                if (a === undefined || b === undefined) 
                    return false;
                if (a === null || b === null) 
                    return false;
                // Check whether 'a' or 'b' is a string (primitive or object).
                // The concatenation of an empty string (+'') converts its argument to a string's primitive.
                if (a.constructor === String) 
                    return a + '' === b + ''; // a+'' - in case 'a' is a String object
                if (b.constructor === String) 
                    return b + '' === a + ''; // b+'' - in case 'b' is a String object
                return false;
            }

            /**
                 * Splits the string into an array of values, trimming each value. An empty array is returned for nulls or empty
                 * strings
                 * @param string
                 * @param separator
                 */
            function splitVal(string, separator) {
                var val, i, l;
                if (string === null || string.length < 1) 
                    return [];
                val = string.split(separator);
                for (i = 0, l = val.length; i < l; i = i + 1) 
                    val[i] = $.trim(val[i]);
                return val;
            }

            function getSideBorderPadding(element) {
                return element.outerWidth(false) - element.width();
            }

            function installKeyUpChangeEvent(element) {
                var key = "keyup-change-value";
                element.on("keydown", function () {
                    if ($.data(element, key) === undefined) {
                        $.data(element, key, element.val());
                    }
                });
                element.on("keyup", function () {
                    var val = $.data(element, key);
                    if (val !== undefined && element.val() !== val) {
                        $.removeData(element, key);
                        element.trigger("keyup-change");
                    }
                });
            }

            $document.on("mousemove", function (e) {
                lastMousePosition.x = e.pageX;
                lastMousePosition.y = e.pageY;
            });

            /**
                 * filters mouse events so an event is fired only if the mouse moved.
                 *
                 * filters out mouse events that occur when mouse is stationary but
                 * the elements under the pointer are scrolled.
                 */
            function installFilteredMouseMove(element) {
                element.on("mousemove", function (e) {
                    var lastpos = lastMousePosition;
                    if (lastpos === undefined || lastpos.x !== e.pageX || lastpos.y !== e.pageY) {
                        $(e.target).trigger("mousemove-filtered", e);
                    }
                });
            }

            /**
                 * Debounces a function. Returns a function that calls the original fn function only if no invocations have been made
                 * within the last quietMillis milliseconds.
                 *
                 * @param quietMillis number of milliseconds to wait before invoking fn
                 * @param fn function to be debounced
                 * @param ctx object to be used as this reference within fn
                 * @return debounced version of fn
                 */
            function debounce(quietMillis, fn, ctx) {
                ctx = ctx || undefined;
                var timeout;
                return function () {
                    var args = arguments;
                    window.clearTimeout(timeout);
                    timeout = window.setTimeout(function() {
                        fn.apply(ctx, args);
                    }, quietMillis);
                };
            }

            /**
                 * A simple implementation of a thunk
                 * @param formula function used to lazily initialize the thunk
                 * @return {Function}
                 */
            function thunk(formula) {
                var evaluated = false,
                value;
                return function() {
                    if (evaluated === false) {
                        value = formula();
                        evaluated = true;
                    }
                    return value;
                };
            };

            function installDebouncedScroll(threshold, element) {
                var notify = debounce(threshold, function (e) {
                    element.trigger("scroll-debounced", e);
                });
                element.on("scroll", function (e) {
                    if (indexOf(e.target, element.get()) >= 0) 
                        notify(e);
                });
            }

            function focus($el) {
                if ($el[0] === document.activeElement) 
                    return;

                /* set the focus in a 0 timeout - that way the focus is set after the processing
                            of the current event has finished - which seems like the only reliable way
                            to set focus */
                window.setTimeout(function() {
                    var el = $el[0], pos = $el.val().length, range;

                    $el.focus();

                    /* make sure el received focus so we do not error out when trying to manipulate the caret.
                                    sometimes modals or others listeners may steal it after its set */
                    if ($el.is(":visible") && el === document.activeElement) {

                        /* after the focus is set move the caret to the end, necessary when we val()
                                            just before setting focus */
                        if (el.setSelectionRange)
                        {
                            el.setSelectionRange(pos, pos);
                        } else if (el.createTextRange) {
                            range = el.createTextRange();
                            range.collapse(false);
                            range.select();
                        }
                    }
                }, 0);
            }

            function getCursorInfo(el) {
                el = $(el)[0];
                var offset = 0;
                var length = 0;
                if ('selectionStart' in el) {
                    offset = el.selectionStart;
                    length = el.selectionEnd - offset;
                } else if ('selection' in document) {
                    el.focus();
                    var sel = document.selection.createRange();
                    length = document.selection.createRange().text.length;
                    sel.moveStart('character', - el.value.length);
                    offset = sel.text.length - length;
                }
                return {
                    offset: offset,
                    length: length 
                };
            }

            function killEvent(event) {
                event.preventDefault();
                event.stopPropagation();
            }
            function killEventImmediately(event) {
                event.preventDefault();
                event.stopImmediatePropagation();
            }

            function measureTextWidth(e) {
                if (!sizer) {
                    var style = e[0].currentStyle || window.getComputedStyle(e[0], null);
                    sizer = $(document.createElement("div")).css({
                        position: "absolute",
                        left: "-10000px",
                        top: "-10000px",
                        display: "none",
                        fontSize: style.fontSize,
                        fontFamily: style.fontFamily,
                        fontStyle: style.fontStyle,
                        fontWeight: style.fontWeight,
                        letterSpacing: style.letterSpacing,
                        textTransform: style.textTransform,
                        whiteSpace: "nowrap"
                    });
                    sizer.attr("class", "select2-sizer");
                    $("body").append(sizer);
                }
                sizer.text(e.val());
                return sizer.width();
            }

            function syncCssClasses(dest, src, adapter) {
                var classes, replacements = [], adapted;

                classes = dest.attr("class");
                if (classes) {
                    classes = '' + classes; // for IE which returns object
                    $(classes.split(" ")).each2(function() {
                        if (this.indexOf("select2-") === 0) {
                            replacements.push(this);
                        }
                    });
                }
                classes = src.attr("class");
                if (classes) {
                    classes = '' + classes; // for IE which returns object
                    $(classes.split(" ")).each2(function() {
                        if (this.indexOf("select2-") !== 0) {
                            adapted = adapter(this);
                            if (adapted) {
                                replacements.push(adapted);
                            }
                        }
                    });
                }
                dest.attr("class", replacements.join(" "));
            }


            function markMatch(text, term, markup, escapeMarkup) {
                var match = stripDiacritics(text.toUpperCase()).indexOf(stripDiacritics(term.toUpperCase())),
                tl = term.length;

                if (match < 0) {
                    markup.push(escapeMarkup(text));
                    return;
                }

                markup.push(escapeMarkup(text.substring(0, match)));
                markup.push("<span class='select2-match'>");
                markup.push(escapeMarkup(text.substring(match, match + tl)));
                markup.push("</span>");
                markup.push(escapeMarkup(text.substring(match + tl, text.length)));
            }

            function defaultEscapeMarkup(markup) {
                var replace_map = {
                    '\\': '&#92;',
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#39;',
                    "/": '&#47;'
                };

                return String(markup).replace(/[&<>"'\/\\]/g, function (match) {
                    return replace_map[match];
                });
            }

            /**
                 * Produces an ajax-based query function
                 *
                 * @param options object containing configuration paramters
                 * @param options.params parameter map for the transport ajax call, can contain such options as cache, jsonpCallback, etc. see $.ajax
                 * @param options.transport function that will be used to execute the ajax request. must be compatible with parameters supported by $.ajax
                 * @param options.url url for the data
                 * @param options.data a function(searchTerm, pageNumber, context) that should return an object containing query string parameters for the above url.
                 * @param options.dataType request data type: ajax, jsonp, other datatatypes supported by jQuery's $.ajax function or the transport function if specified
                 * @param options.quietMillis (optional) milliseconds to wait before making the ajaxRequest, helps debounce the ajax function if invoked too often
                 * @param options.results a function(remoteData, pageNumber) that converts data returned form the remote request to the format expected by Select2.
                 *      The expected format is an object containing the following keys:
                 *      results array of objects that will be used as choices
                 *      more (optional) boolean indicating whether there are more results available
                 *      Example: {results:[{id:1, text:'Red'},{id:2, text:'Blue'}], more:true}
                 */
            function ajax(options) {
                var timeout, // current scheduled but not yet executed request
                handler = null,
                quietMillis = options.quietMillis || 100,
                ajaxUrl = options.url,
                self = this;

                return function (query) {
                    window.clearTimeout(timeout);
                    timeout = window.setTimeout(function () {
                        var data = options.data, // ajax data function
                        url = ajaxUrl, // ajax url string or function
                        transport = options.transport || $.fn.select2.ajaxDefaults.transport,
                        // deprecated - to be removed in 4.0  - use params instead
                        deprecated = {
                            type: options.type || 'GET',
                            // set type of request (GET or POST)
                            cache: options.cache || false,
                            jsonpCallback: options.jsonpCallback || undefined,
                            dataType: options.dataType || "json"
                        },
                        params = $.extend({}, $.fn.select2.ajaxDefaults.params, deprecated);

                        data = data ? data.call(self, query.term, query.page, query.context) : null;
                        url = (typeof url === 'function') ? url.call(self, query.term, query.page, query.context) : url;

                        if (handler) {
                            handler.abort();
                        }

                        if (options.params) {
                            if ($.isFunction(options.params)) {
                                $.extend(params, options.params.call(self));
                            } else {
                                $.extend(params, options.params);
                            }
                        }

                        $.extend(params, {
                            url: url,
                            dataType: options.dataType,
                            data: data,
                            success: function (data) {
                                // TODO - replace query.page with query so users have access to term, page, etc.
                                var results = options.results(data, query.page);
                                query.callback(results);
                            }
                        });
                        handler = transport.call(self, params);
                    }, quietMillis);
                };
            }

            /**
                 * Produces a query function that works with a local array
                 *
                 * @param options object containing configuration parameters. The options parameter can either be an array or an
                 * object.
                 *
                 * If the array form is used it is assumed that it contains objects with 'id' and 'text' keys.
                 *
                 * If the object form is used ti is assumed that it contains 'data' and 'text' keys. The 'data' key should contain
                 * an array of objects that will be used as choices. These objects must contain at least an 'id' key. The 'text'
                 * key can either be a String in which case it is expected that each element in the 'data' array has a key with the
                 * value of 'text' which will be used to match choices. Alternatively, text can be a function(item) that can extract
                 * the text.
                 */
            function local(options) {
                var data = options, // data elements
                dataText,
                tmp,
                text = function (item) {
                    return "" + item.text;
                }; // function used to retrieve the text portion of a data item that is matched against the search

                if ($.isArray(data)) {
                    tmp = data;
                    data = {
                        results: tmp 
                    };
                }

                if ($.isFunction(data) === false) {
                    tmp = data;
                    data = function() {
                        return tmp;
                    };
                }

                var dataItem = data();
                if (dataItem.text) {
                    text = dataItem.text;
                    // if text is not a function we assume it to be a key name
                    if (!$.isFunction(text)) {
                        dataText = dataItem.text; // we need to store this in a separate variable because in the next step data gets reset and data.text is no longer available
                        text = function (item) {
                            return item[dataText];
                        };
                    }
                }

                return function (query) {
                    var t = query.term, filtered = {
                        results: [] 
                    }, process;
                    if (t === "") {
                        query.callback(data());
                        return;
                    }

                    process = function(datum, collection) {
                        var group, attr;
                        datum = datum[0];
                        if (datum.children) {
                            group = {};
                            for (attr in datum) {
                                if (datum.hasOwnProperty(attr)) 
                                    group[attr] = datum[attr];
                            }
                            group.children = [];
                            $(datum.children).each2(function(i, childDatum) {
                                process(childDatum, group.children);
                            });
                            if (group.children.length || query.matcher(t, text(group), datum)) {
                                collection.push(group);
                            }
                        } else {
                            if (query.matcher(t, text(datum), datum)) {
                                collection.push(datum);
                            }
                        }
                    };

                    $(data().results).each2(function(i, datum) {
                        process(datum, filtered.results);
                    });
                    query.callback(filtered);
                };
            }

            // TODO javadoc
            function tags(data) {
                var isFunc = $.isFunction(data);
                return function (query) {
                    var t = query.term, filtered = {
                        results: []
                    };
                    $(isFunc ? data() : data).each(function () {
                        var isObject = this.text !== undefined,
                        text = isObject ? this.text : this;
                        if (t === "" || query.matcher(t, text)) {
                            filtered.results.push(isObject ? this : {
                                id: this,
                                text: this
                            });
                        }
                    });
                    query.callback(filtered);
                };
            }

            /**
                 * Checks if the formatter function should be used.
                 *
                 * Throws an error if it is not a function. Returns true if it should be used,
                 * false if no formatting should be performed.
                 *
                 * @param formatter
                 */
            function checkFormatter(formatter, formatterName) {
                if ($.isFunction(formatter)) 
                    return true;
                if (!formatter) 
                    return false;
                throw new Error(formatterName + " must be a function or a falsy value");
            }

            function evaluate(val) {
                return $.isFunction(val) ? val() : val;
            }

            function countResults(results) {
                var count = 0;
                $.each(results, function(i, item) {
                    if (item.children) {
                        count += countResults(item.children);
                    } else {
                        count++;
                    }
                });
                return count;
            }

            /**
                 * Default tokenizer. This function uses breaks the input on substring match of any string from the
                 * opts.tokenSeparators array and uses opts.createSearchChoice to create the choice object. Both of those
                 * two options have to be defined in order for the tokenizer to work.
                 *
                 * @param input text user has typed so far or pasted into the search field
                 * @param selection currently selected choices
                 * @param selectCallback function(choice) callback tho add the choice to selection
                 * @param opts select2's opts
                 * @return undefined/null to leave the current input unchanged, or a string to change the input to the returned value
                 */
            function defaultTokenizer(input, selection, selectCallback, opts) {
                var original = input, // store the original so we can compare and know if we need to tell the search to update its text
                dupe = false, // check for whether a token we extracted represents a duplicate selected choice
                token, // token
                index, // position at which the separator was found
                i, l, // looping variables
                separator; // the matched separator

                if (!opts.createSearchChoice || !opts.tokenSeparators || opts.tokenSeparators.length < 1) 
                    return undefined;

                while (true) {
                    index = - 1;

                    for (i = 0, l = opts.tokenSeparators.length; i < l; i++) {
                        separator = opts.tokenSeparators[i];
                        index = input.indexOf(separator);
                        if (index >= 0) 
                            break;
                    }

                    if (index < 0) 
                        break; // did not find any token separator in the input string, bail

                    token = input.substring(0, index);
                    input = input.substring(index + separator.length);

                    if (token.length > 0) {
                        token = opts.createSearchChoice.call(this, token, selection);
                        if (token !== undefined && token !== null && opts.id(token) !== undefined && opts.id(token) !== null) {
                            dupe = false;
                            for (i = 0, l = selection.length; i < l; i++) {
                                if (equal(opts.id(token), opts.id(selection[i]))) {
                                    dupe = true;
                                    break;
                                }
                            }

                            if (!dupe) 
                                selectCallback(token);
                        }
                    }
                }

                if (original !== input) 
                    return input;
            }

            /**
                 * Creates a new class
                 *
                 * @param superClass
                 * @param methods
                 */
            function clazz(SuperClass, methods) {
                var constructor = function () {};
                constructor.prototype = new SuperClass;
                constructor.prototype.constructor = constructor;
                constructor.prototype.parent = SuperClass.prototype;
                constructor.prototype = $.extend(constructor.prototype, methods);
                return constructor;
            }

            AbstractSelect2 = clazz(Object, {

                // abstract
                bind: function (func) {
                    var self = this;
                    return function () {
                        func.apply(self, arguments);
                    };
                },

                // abstract
                init: function (opts) {
                    var results, search, resultsSelector = ".select2-results";

                    // prepare options
                    this.opts = opts = this.prepareOpts(opts);

                    this.id = opts.id;

                    // destroy if called on an existing component
                    if (opts.element.data("select2") !== undefined &&
                    opts.element.data("select2") !== null) {
                        opts.element.data("select2").destroy();
                    }

                    this.container = this.createContainer();

                    this.containerId = "s2id_" + (opts.element.attr("id") || "autogen" + nextUid());
                    this.containerSelector = "#" + this.containerId.replace(/([;&,\.\+\*\~':"\!\^#$%@\[\]\(\)=>\|])/g, '\\$1');
                    this.container.attr("id", this.containerId);

                    // cache the body so future lookups are cheap
                    this.body = thunk(function() {
                        return opts.element.closest("body");
                    });

                    syncCssClasses(this.container, this.opts.element, this.opts.adaptContainerCssClass);

                    this.container.attr("style", opts.element.attr("style"));
                    this.container.css(evaluate(opts.containerCss));
                    this.container.addClass(evaluate(opts.containerCssClass));

                    this.elementTabIndex = this.opts.element.attr("tabindex");

                    // swap container for the element
                    this.opts.element
                    .data("select2", this)
                    .attr("tabindex", "-1")
                    .before(this.container)
                    .on("click.select2", killEvent); // do not leak click events

                    this.container.data("select2", this);

                    this.dropdown = this.container.find(".select2-drop");

                    syncCssClasses(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass);

                    this.dropdown.addClass(evaluate(opts.dropdownCssClass));
                    this.dropdown.data("select2", this);
                    this.dropdown.on("click", killEvent);

                    this.results = results = this.container.find(resultsSelector);
                    this.search = search = this.container.find("input.select2-input");

                    this.queryCount = 0;
                    this.resultsPage = 0;
                    this.context = null;

                    // initialize the container
                    this.initContainer();

                    this.container.on("click", killEvent);

                    installFilteredMouseMove(this.results);
                    this.dropdown.on("mousemove-filtered touchstart touchmove touchend", resultsSelector, this.bind(this.highlightUnderEvent));

                    installDebouncedScroll(80, this.results);
                    this.dropdown.on("scroll-debounced", resultsSelector, this.bind(this.loadMoreIfNeeded));

                    // do not propagate change event from the search field out of the component
                    $(this.container).on("change", ".select2-input", function(e) {
                        e.stopPropagation();
                    });
                    $(this.dropdown).on("change", ".select2-input", function(e) {
                        e.stopPropagation();
                    });

                    // if jquery.mousewheel plugin is installed we can prevent out-of-bounds scrolling of results via mousewheel
                    if ($.fn.mousewheel) {
                        results.mousewheel(function (e, delta, deltaX, deltaY) {
                            var top = results.scrollTop();
                            if (deltaY > 0 && top - deltaY <= 0) {
                                results.scrollTop(0);
                                killEvent(e);
                            } else if (deltaY < 0 && results.get(0).scrollHeight - results.scrollTop() + deltaY <= results.height()) {
                                results.scrollTop(results.get(0).scrollHeight - results.height());
                                killEvent(e);
                            }
                        });
                    }

                    installKeyUpChangeEvent(search);
                    search.on("keyup-change input paste", this.bind(this.updateResults));
                    search.on("focus", function () {
                        search.addClass("select2-focused");
                    });
                    search.on("blur", function () {
                        search.removeClass("select2-focused");
                    });

                    this.dropdown.on("mouseup", resultsSelector, this.bind(function (e) {
                        if ($(e.target).closest(".select2-result-selectable").length > 0) {
                            this.highlightUnderEvent(e);
                            this.selectHighlighted(e);
                        }
                    }));

                    // trap all mouse events from leaving the dropdown. sometimes there may be a modal that is listening
                    // for mouse events outside of itself so it can close itself. since the dropdown is now outside the select2's
                    // dom it will trigger the popup close, which is not what we want
                    this.dropdown.on("click mouseup mousedown", function (e) {
                        e.stopPropagation();
                    });

                    if ($.isFunction(this.opts.initSelection)) {
                        // initialize selection based on the current value of the source element
                        this.initSelection();

                        // if the user has provided a function that can set selection based on the value of the source element
                        // we monitor the change event on the element and trigger it, allowing for two way synchronization
                        this.monitorSource();
                    }

                    if (opts.maximumInputLength !== null) {
                        this.search.attr("maxlength", opts.maximumInputLength);
                    }

                    var disabled = opts.element.prop("disabled");
                    if (disabled === undefined) 
                        disabled = false;
                    this.enable(!disabled);

                    var readonly = opts.element.prop("readonly");
                    if (readonly === undefined) 
                        readonly = false;
                    this.readonly(readonly);

                    // Calculate size of scrollbar
                    scrollBarDimensions = scrollBarDimensions || measureScrollbar();

                    this.autofocus = opts.element.prop("autofocus");
                    opts.element.prop("autofocus", false);
                    if (this.autofocus) 
                        this.focus();

                    this.nextSearchTerm = undefined;
                },

                // abstract
                destroy: function () {
                    var element = this.opts.element, select2 = element.data("select2");

                    this.close();

                    if (this.propertyObserver) {
                        delete this.propertyObserver;
                        this.propertyObserver = null;
                    }

                    if (select2 !== undefined) {
                        select2.container.remove();
                        select2.dropdown.remove();
                        element
                        .removeClass("select2-offscreen")
                        .removeData("select2")
                        .off(".select2")
                        .prop("autofocus", this.autofocus || false);
                        if (this.elementTabIndex) {
                            element.attr({
                                tabindex: this.elementTabIndex
                            });
                        } else {
                            element.removeAttr("tabindex");
                        }
                        element.show();
                    }
                },

                // abstract
                optionToData: function(element) {
                    if (element.is("option")) {
                        return {
                            id: element.prop("value"),
                            text: element.text(),
                            element: element.get(),
                            css: element.attr("class"),
                            disabled: element.prop("disabled"),
                            locked: equal(element.attr("locked"), "locked") || equal(element.data("locked"), true)
                        };
                    } else if (element.is("optgroup")) {
                        return {
                            text: element.attr("label"),
                            children: [],
                            element: element.get(),
                            css: element.attr("class")
                        };
                    }
                },

                // abstract
                prepareOpts: function (opts) {
                    var element, select, idKey, ajaxUrl, self = this;

                    element = opts.element;

                    if (element.get(0).tagName.toLowerCase() === "select") {
                        this.select = select = opts.element;
                    }

                    if (select) {
                        // these options are not allowed when attached to a select because they are picked up off the element itself
                        $.each(["id", "multiple", "ajax", "query", "createSearchChoice", "initSelection", "data", "tags"], function () {
                            if (this in opts) {
                                throw new Error("Option '" + this + "' is not allowed for Select2 when attached to a <select> element.");
                            }
                        });
                    }

                    opts = $.extend({}, {
                        populateResults: function(container, results, query) {
                            var populate, id = this.opts.id;

                            populate = function(results, container, depth) {

                                var i, l, result, selectable, disabled, compound, node, label, innerContainer, formatted;

                                results = opts.sortResults(results, container, query);

                                for (i = 0, l = results.length; i < l; i = i + 1) {

                                    result = results[i];

                                    disabled = (result.disabled === true);
                                    selectable = (!disabled) && (id(result) !== undefined);

                                    compound = result.children && result.children.length > 0;

                                    node = $("<li></li>");
                                    node.addClass("select2-results-dept-" + depth);
                                    node.addClass("select2-result");
                                    node.addClass(selectable ? "select2-result-selectable" : "select2-result-unselectable");
                                    if (disabled) {
                                        node.addClass("select2-disabled");
                                    }
                                    if (compound) {
                                        node.addClass("select2-result-with-children");
                                    }
                                    node.addClass(self.opts.formatResultCssClass(result));

                                    label = $(document.createElement("div"));
                                    label.addClass("select2-result-label");

                                    formatted = opts.formatResult(result, label, query, self.opts.escapeMarkup);
                                    if (formatted !== undefined) {
                                        label.html(formatted);
                                    }

                                    node.append(label);

                                    if (compound) {

                                        innerContainer = $("<ul></ul>");
                                        innerContainer.addClass("select2-result-sub");
                                        populate(result.children, innerContainer, depth + 1);
                                        node.append(innerContainer);
                                    }

                                    node.data("select2-data", result);
                                    container.append(node);
                                }
                            };

                            populate(results, container, 0);
                        }
                    }, $.fn.select2.defaults, opts);

                    if (typeof(opts.id) !== "function") {
                        idKey = opts.id;
                        opts.id = function (e) {
                            return e[idKey];
                        };
                    }

                    if ($.isArray(opts.element.data("select2Tags"))) {
                        if ("tags" in opts) {
                            throw "tags specified as both an attribute 'data-select2-tags' and in options of Select2 " + opts.element.attr("id");
                        }
                        opts.tags = opts.element.data("select2Tags");
                    }

                    if (select) {
                        opts.query = this.bind(function (query) {
                            var data = {
                                results: [],
                                more: false 
                            },
                            term = query.term,
                            children, placeholderOption, process;

                            process = function(element, collection) {
                                var group;
                                if (element.is("option")) {
                                    if (query.matcher(term, element.text(), element)) {
                                        collection.push(self.optionToData(element));
                                    }
                                } else if (element.is("optgroup")) {
                                    group = self.optionToData(element);
                                    element.children().each2(function(i, elm) {
                                        process(elm, group.children);
                                    });
                                    if (group.children.length > 0) {
                                        collection.push(group);
                                    }
                                }
                            };

                            children = element.children();

                            // ignore the placeholder option if there is one
                            if (this.getPlaceholder() !== undefined && children.length > 0) {
                                placeholderOption = this.getPlaceholderOption();
                                if (placeholderOption) {
                                    children = children.not(placeholderOption);
                                }
                            }

                            children.each2(function(i, elm) {
                                process(elm, data.results);
                            });

                            query.callback(data);
                        });
                        // this is needed because inside val() we construct choices from options and there id is hardcoded
                        opts.id = function(e) {
                            return e.id;
                        };
                        opts.formatResultCssClass = function(data) {
                            return data.css;
                        };
                    } else {
                        if (!("query" in opts)) {

                            if ("ajax" in opts) {
                                ajaxUrl = opts.element.data("ajax-url");
                                if (ajaxUrl && ajaxUrl.length > 0) {
                                    opts.ajax.url = ajaxUrl;
                                }
                                opts.query = ajax.call(opts.element, opts.ajax);
                            } else if ("data" in opts) {
                                opts.query = local(opts.data);
                            } else if ("tags" in opts) {
                                opts.query = tags(opts.tags);
                                if (opts.createSearchChoice === undefined) {
                                    opts.createSearchChoice = function (term) {
                                        return {
                                            id: $.trim(term),
                                            text: $.trim(term)
                                        };
                                    };
                                }
                                if (opts.initSelection === undefined) {
                                    opts.initSelection = function (element, callback) {
                                        var data = [];
                                        $(splitVal(element.val(), opts.separator)).each(function () {
                                            var obj = {
                                                id: this,
                                                text: this 
                                            },
                                            tags = opts.tags;
                                            if ($.isFunction(tags)) 
                                                tags = tags();
                                            $(tags).each(function() {
                                                if (equal(this.id, obj.id)) {
                                                    obj = this;
                                                    return false;
                                                }
                                            });
                                            data.push(obj);
                                        });

                                        callback(data);
                                    };
                                }
                            }
                        }
                    }
                    if (typeof(opts.query) !== "function") {
                        throw "query function not defined for Select2 " + opts.element.attr("id");
                    }

                    return opts;
                },

                /**
                         * Monitor the original element for changes and update select2 accordingly
                         */
                // abstract
                monitorSource: function () {
                    var el = this.opts.element, sync, observer;

                    el.on("change.select2", this.bind(function (e) {
                        if (this.opts.element.data("select2-change-triggered") !== true) {
                            this.initSelection();
                        }
                    }));

                    sync = this.bind(function () {

                        // sync enabled state
                        var disabled = el.prop("disabled");
                        if (disabled === undefined) 
                            disabled = false;
                        this.enable(!disabled);

                        var readonly = el.prop("readonly");
                        if (readonly === undefined) 
                            readonly = false;
                        this.readonly(readonly);

                        syncCssClasses(this.container, this.opts.element, this.opts.adaptContainerCssClass);
                        this.container.addClass(evaluate(this.opts.containerCssClass));

                        syncCssClasses(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass);
                        this.dropdown.addClass(evaluate(this.opts.dropdownCssClass));

                    });

                    // IE8-10
                    el.on("propertychange.select2", sync);

                    // hold onto a reference of the callback to work around a chromium bug
                    if (this.mutationCallback === undefined) {
                        this.mutationCallback = function (mutations) {
                            mutations.forEach(sync);
                        }
                    }

                    // safari, chrome, firefox, IE11
                    observer = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;
                    if (observer !== undefined) {
                        if (this.propertyObserver) {
                            delete this.propertyObserver;
                            this.propertyObserver = null;
                        }
                        this.propertyObserver = new observer(this.mutationCallback);
                        this.propertyObserver.observe(el.get(0), {
                            attributes: true,
                            subtree: false 
                        });
                    }
                },

                // abstract
                triggerSelect: function(data) {
                    var evt = $.Event("select2-selecting", {
                        val: this.id(data),
                        object: data 
                    });
                    this.opts.element.trigger(evt);
                    return !evt.isDefaultPrevented();
                },

                /**
                         * Triggers the change event on the source element
                         */
                // abstract
                triggerChange: function (details) {

                    details = details || {};
                    details = $.extend({}, details, {
                        type: "change",
                        val: this.val() 
                    });
                    // prevents recursive triggering
                    this.opts.element.data("select2-change-triggered", true);
                    this.opts.element.trigger(details);
                    this.opts.element.data("select2-change-triggered", false);

                    // some validation frameworks ignore the change event and listen instead to keyup, click for selects
                    // so here we trigger the click event manually
                    this.opts.element.click();

                    // ValidationEngine ignorea the change event and listens instead to blur
                    // so here we trigger the blur event manually if so desired
                    if (this.opts.blurOnChange)
                        this.opts.element.blur();
                },

                //abstract
                isInterfaceEnabled: function()
                {
                    return this.enabledInterface === true;
                },

                // abstract
                enableInterface: function() {
                    var enabled = this._enabled && !this._readonly,
                    disabled = !enabled;

                    if (enabled === this.enabledInterface) 
                        return false;

                    this.container.toggleClass("select2-container-disabled", disabled);
                    this.close();
                    this.enabledInterface = enabled;

                    return true;
                },

                // abstract
                enable: function(enabled) {
                    if (enabled === undefined) 
                        enabled = true;
                    if (this._enabled === enabled) 
                        return;
                    this._enabled = enabled;

                    this.opts.element.prop("disabled", !enabled);
                    this.enableInterface();
                },

                // abstract
                disable: function() {
                    this.enable(false);
                },

                // abstract
                readonly: function(enabled) {
                    if (enabled === undefined) 
                        enabled = false;
                    if (this._readonly === enabled) 
                        return false;
                    this._readonly = enabled;

                    this.opts.element.prop("readonly", enabled);
                    this.enableInterface();
                    return true;
                },

                // abstract
                opened: function () {
                    return this.container.hasClass("select2-dropdown-open");
                },

                // abstract
                positionDropdown: function() {
                    var $dropdown = this.dropdown,
                    offset = this.container.offset(),
                    height = this.container.outerHeight(false),
                    width = this.container.outerWidth(false),
                    dropHeight = $dropdown.outerHeight(false),
                    $window = $(window),
                    windowWidth = $window.width(),
                    windowHeight = $window.height(),
                    viewPortRight = $window.scrollLeft() + windowWidth,
                    viewportBottom = $window.scrollTop() + windowHeight,
                    dropTop = offset.top + height,
                    dropLeft = offset.left,
                    enoughRoomBelow = dropTop + dropHeight <= viewportBottom,
                    enoughRoomAbove = (offset.top - dropHeight) >= this.body().scrollTop(),
                    dropWidth = $dropdown.outerWidth(false),
                    enoughRoomOnRight = dropLeft + dropWidth <= viewPortRight,
                    aboveNow = $dropdown.hasClass("select2-drop-above"),
                    bodyOffset,
                    above,
                    changeDirection,
                    css,
                    resultsListNode;

                    // always prefer the current above/below alignment, unless there is not enough room
                    if (aboveNow) {
                        above = true;
                        if (!enoughRoomAbove && enoughRoomBelow) {
                            changeDirection = true;
                            above = false;
                        }
                    } else {
                        above = false;
                        if (!enoughRoomBelow && enoughRoomAbove) {
                            changeDirection = true;
                            above = true;
                        }
                    }

                    //if we are changing direction we need to get positions when dropdown is hidden;
                    if (changeDirection) {
                        $dropdown.hide();
                        offset = this.container.offset();
                        height = this.container.outerHeight(false);
                        width = this.container.outerWidth(false);
                        dropHeight = $dropdown.outerHeight(false);
                        viewPortRight = $window.scrollLeft() + windowWidth;
                        viewportBottom = $window.scrollTop() + windowHeight;
                        dropTop = offset.top + height;
                        dropLeft = offset.left;
                        dropWidth = $dropdown.outerWidth(false);
                        enoughRoomOnRight = dropLeft + dropWidth <= viewPortRight;
                        $dropdown.show();
                    }

                    if (this.opts.dropdownAutoWidth) {
                        resultsListNode = $('.select2-results', $dropdown)[0];
                        $dropdown.addClass('select2-drop-auto-width');
                        $dropdown.css('width', '');
                        // Add scrollbar width to dropdown if vertical scrollbar is present
                        dropWidth = $dropdown.outerWidth(false) + (resultsListNode.scrollHeight === resultsListNode.clientHeight ? 0 : scrollBarDimensions.width);
                        dropWidth > width ? width = dropWidth : dropWidth = width;
                        enoughRoomOnRight = dropLeft + dropWidth <= viewPortRight;
                    } else {
                        this.container.removeClass('select2-drop-auto-width');
                    }

                    //console.log("below/ droptop:", dropTop, "dropHeight", dropHeight, "sum", (dropTop+dropHeight)+" viewport bottom", viewportBottom, "enough?", enoughRoomBelow);
                    //console.log("above/ offset.top", offset.top, "dropHeight", dropHeight, "top", (offset.top-dropHeight), "scrollTop", this.body().scrollTop(), "enough?", enoughRoomAbove);

                    // fix positioning when body has an offset and is not position: static
                    if (this.body().css('position') !== 'static') {
                        bodyOffset = this.body().offset();
                        dropTop -= bodyOffset.top;
                        dropLeft -= bodyOffset.left;
                    }

                    if (!enoughRoomOnRight) {
                        dropLeft = offset.left + width - dropWidth;
                    }

                    css = {
                        left: dropLeft,
                        width: width
                    };

                    if (above) {
                        css.bottom = windowHeight - offset.top;
                        css.top = 'auto';
                        this.container.addClass("select2-drop-above");
                        $dropdown.addClass("select2-drop-above");
                    } else {
                        css.top = dropTop;
                        css.bottom = 'auto';
                        this.container.removeClass("select2-drop-above");
                        $dropdown.removeClass("select2-drop-above");
                    }
                    css = $.extend(css, evaluate(this.opts.dropdownCss));

                    $dropdown.css(css);
                },

                // abstract
                shouldOpen: function() {
                    var event;

                    if (this.opened()) 
                        return false;

                    if (this._enabled === false || this._readonly === true) 
                        return false;

                    event = $.Event("select2-opening");
                    this.opts.element.trigger(event);
                    return !event.isDefaultPrevented();
                },

                // abstract
                clearDropdownAlignmentPreference: function() {
                    // clear the classes used to figure out the preference of where the dropdown should be opened
                    this.container.removeClass("select2-drop-above");
                    this.dropdown.removeClass("select2-drop-above");
                },

                /**
                         * Opens the dropdown
                         *
                         * @return {Boolean} whether or not dropdown was opened. This method will return false if, for example,
                         * the dropdown is already open, or if the 'open' event listener on the element called preventDefault().
                         */
                // abstract
                open: function () {

                    if (!this.shouldOpen()) 
                        return false;

                    this.opening();

                    return true;
                },

                /**
                         * Performs the opening of the dropdown
                         */
                // abstract
                opening: function() {
                    var cid = this.containerId,
                    scroll = "scroll." + cid,
                    resize = "resize." + cid,
                    orient = "orientationchange." + cid,
                    mask;

                    this.container.addClass("select2-dropdown-open").addClass("select2-container-active");

                    this.clearDropdownAlignmentPreference();

                    if (this.dropdown[0] !== this.body().children().last()[0]) {
                        this.dropdown.detach().appendTo(this.body());
                    }

                    // create the dropdown mask if doesnt already exist
                    mask = $("#select2-drop-mask");
                    if (mask.length == 0) {
                        mask = $(document.createElement("div"));
                        mask.attr("id", "select2-drop-mask").attr("class", "select2-drop-mask");
                        mask.hide();
                        mask.appendTo(this.body());
                        mask.on("mousedown touchstart click", function (e) {
                            var dropdown = $("#select2-drop"), self;
                            if (dropdown.length > 0) {
                                self = dropdown.data("select2");
                                if (self.opts.selectOnBlur) {
                                    self.selectHighlighted({
                                        noFocus: true
                                    });
                                }
                                self.close({
                                    focus: true
                                });
                                e.preventDefault();
                                e.stopPropagation();
                            }
                        });
                    }

                    // ensure the mask is always right before the dropdown
                    if (this.dropdown.prev()[0] !== mask[0]) {
                        this.dropdown.before(mask);
                    }

                    // move the global id to the correct dropdown
                    $("#select2-drop").removeAttr("id");
                    this.dropdown.attr("id", "select2-drop");

                    // show the elements
                    mask.show();

                    this.positionDropdown();
                    this.dropdown.show();
                    this.positionDropdown();

                    this.dropdown.addClass("select2-drop-active");

                    // attach listeners to events that can change the position of the container and thus require
                    // the position of the dropdown to be updated as well so it does not come unglued from the container
                    var that = this;
                    this.container.parents().add(window).each(function () {
                        $(this).on(resize + " " + scroll + " " + orient, function (e) {
                            that.positionDropdown();
                        });
                    });


                },

                // abstract
                close: function () {
                    if (!this.opened()) 
                        return;

                    var cid = this.containerId,
                    scroll = "scroll." + cid,
                    resize = "resize." + cid,
                    orient = "orientationchange." + cid;

                    // unbind event listeners
                    this.container.parents().add(window).each(function () {
                        $(this).off(scroll).off(resize).off(orient);
                    });

                    this.clearDropdownAlignmentPreference();

                    $("#select2-drop-mask").hide();
                    this.dropdown.removeAttr("id"); // only the active dropdown has the select2-drop id
                    this.dropdown.hide();
                    this.container.removeClass("select2-dropdown-open").removeClass("select2-container-active");
                    this.results.empty();


                    this.clearSearch();
                    this.search.removeClass("select2-active");
                    this.opts.element.trigger($.Event("select2-close"));
                },

                /**
                         * Opens control, sets input value, and updates results.
                         */
                // abstract
                externalSearch: function (term) {
                    this.open();
                    this.search.val(term);
                    this.updateResults(false);
                },

                // abstract
                clearSearch: function () {
},

                //abstract
                getMaximumSelectionSize: function() {
                    return evaluate(this.opts.maximumSelectionSize);
                },

                // abstract
                ensureHighlightVisible: function () {
                    var results = this.results, children, index, child, hb, rb, y, more;

                    index = this.highlight();

                    if (index < 0) 
                        return;

                    if (index == 0) {

                        // if the first element is highlighted scroll all the way to the top,
                        // that way any unselectable headers above it will also be scrolled
                        // into view

                        results.scrollTop(0);
                        return;
                    }

                    children = this.findHighlightableChoices().find('.select2-result-label');

                    child = $(children[index]);

                    hb = child.offset().top + child.outerHeight(true);

                    // if this is the last child lets also make sure select2-more-results is visible
                    if (index === children.length - 1) {
                        more = results.find("li.select2-more-results");
                        if (more.length > 0) {
                            hb = more.offset().top + more.outerHeight(true);
                        }
                    }

                    rb = results.offset().top + results.outerHeight(true);
                    if (hb > rb) {
                        results.scrollTop(results.scrollTop() + (hb - rb));
                    }
                    y = child.offset().top - results.offset().top;

                    // make sure the top of the element is visible
                    if (y < 0 && child.css('display') != 'none' ) {
                        results.scrollTop(results.scrollTop() + y); // y is negative
                    }
                },

                // abstract
                findHighlightableChoices: function() {
                    return this.results.find(".select2-result-selectable:not(.select2-disabled, .select2-selected)");
                },

                // abstract
                moveHighlight: function (delta) {
                    var choices = this.findHighlightableChoices(),
                    index = this.highlight();

                    while (index > - 1 && index < choices.length) {
                        index += delta;
                        var choice = $(choices[index]);
                        if (choice.hasClass("select2-result-selectable") && !choice.hasClass("select2-disabled") && !choice.hasClass("select2-selected")) {
                            this.highlight(index);
                            break;
                        }
                    }
                },

                // abstract
                highlight: function (index) {
                    var choices = this.findHighlightableChoices(),
                    choice,
                    data;

                    if (arguments.length === 0) {
                        return indexOf(choices.filter(".select2-highlighted")[0], choices.get());
                    }

                    if (index >= choices.length) 
                        index = choices.length - 1;
                    if (index < 0) 
                        index = 0;

                    this.removeHighlight();

                    choice = $(choices[index]);
                    choice.addClass("select2-highlighted");

                    this.ensureHighlightVisible();

                    data = choice.data("select2-data");
                    if (data) {
                        this.opts.element.trigger({
                            type: "select2-highlight",
                            val: this.id(data),
                            choice: data 
                        });
                    }
                },

                removeHighlight: function() {
                    this.results.find(".select2-highlighted").removeClass("select2-highlighted");
                },

                // abstract
                countSelectableResults: function() {
                    return this.findHighlightableChoices().length;
                },

                // abstract
                highlightUnderEvent: function (event) {
                    var el = $(event.target).closest(".select2-result-selectable");
                    if (el.length > 0 && !el.is(".select2-highlighted")) {
                        var choices = this.findHighlightableChoices();
                        this.highlight(choices.index(el));
                    } else if (el.length == 0) {
                        // if we are over an unselectable item remove all highlights
                        this.removeHighlight();
                    }
                },

                // abstract
                loadMoreIfNeeded: function () {
                    var results = this.results,
                    more = results.find("li.select2-more-results"),
                    below, // pixels the element is below the scroll fold, below==0 is when the element is starting to be visible
                    page = this.resultsPage + 1,
                    self = this,
                    term = this.search.val(),
                    context = this.context;

                    if (more.length === 0) 
                        return;
                    below = more.offset().top - results.offset().top - results.height();

                    if (below <= this.opts.loadMorePadding) {
                        more.addClass("select2-active");
                        this.opts.query({
                            element: this.opts.element,
                            term: term,
                            page: page,
                            context: context,
                            matcher: this.opts.matcher,
                            callback: this.bind(function (data) {

                                // ignore a response if the select2 has been closed before it was received
                                if (!self.opened()) 
                                    return;


                                self.opts.populateResults.call(this, results, data.results, {
                                    term: term,
                                    page: page,
                                    context: context
                                });
                                self.postprocessResults(data, false, false);

                                if (data.more === true) {
                                    more.detach().appendTo(results).text(self.opts.formatLoadMore(page + 1));
                                    window.setTimeout(function() {
                                        self.loadMoreIfNeeded();
                                    }, 10);
                                } else {
                                    more.remove();
                                }
                                self.positionDropdown();
                                self.resultsPage = page;
                                self.context = data.context;
                                this.opts.element.trigger({
                                    type: "select2-loaded",
                                    items: data 
                                });
                            })
                        });
                    }
                },

                /**
                         * Default tokenizer function which does nothing
                         */
                tokenize: function() {
},

                /**
                         * @param initial whether or not this is the call to this method right after the dropdown has been opened
                         */
                // abstract
                updateResults: function (initial) {
                    var search = this.search,
                    results = this.results,
                    opts = this.opts,
                    data,
                    self = this,
                    input,
                    term = search.val(),
                    lastTerm = $.data(this.container, "select2-last-term"),
                    // sequence number used to drop out-of-order responses
                    queryNumber;

                    // prevent duplicate queries against the same term
                    if (initial !== true && lastTerm && equal(term, lastTerm)) 
                        return;

                    $.data(this.container, "select2-last-term", term);

                    // if the search is currently hidden we do not alter the results
                    if (initial !== true && (this.showSearchInput === false || !this.opened())) {
                        return;
                    }

                    function postRender() {
                        search.removeClass("select2-active");
                        self.positionDropdown();
                    }

                    function render(html) {
                        results.html(html);
                        postRender();
                    }

                    queryNumber = ++this.queryCount;

                    var maxSelSize = this.getMaximumSelectionSize();
                    if (maxSelSize >= 1) {
                        data = this.data();
                        if ($.isArray(data) && data.length >= maxSelSize && checkFormatter(opts.formatSelectionTooBig, "formatSelectionTooBig")) {
                            render("<li class='select2-selection-limit'>" + opts.formatSelectionTooBig(maxSelSize) + "</li>");
                            return;
                        }
                    }

                    if (search.val().length < opts.minimumInputLength) {
                        if (checkFormatter(opts.formatInputTooShort, "formatInputTooShort")) {
                            render("<li class='select2-no-results'>" + opts.formatInputTooShort(search.val(), opts.minimumInputLength) + "</li>");
                        } else {
                            render("");
                        }
                        if (initial && this.showSearch) 
                            this.showSearch(true);
                        return;
                    }

                    if (opts.maximumInputLength && search.val().length > opts.maximumInputLength) {
                        if (checkFormatter(opts.formatInputTooLong, "formatInputTooLong")) {
                            render("<li class='select2-no-results'>" + opts.formatInputTooLong(search.val(), opts.maximumInputLength) + "</li>");
                        } else {
                            render("");
                        }
                        return;
                    }

                    if (opts.formatSearching && this.findHighlightableChoices().length === 0) {
                        render("<li class='select2-searching'>" + opts.formatSearching() + "</li>");
                    }

                    search.addClass("select2-active");

                    this.removeHighlight();

                    // give the tokenizer a chance to pre-process the input
                    input = this.tokenize();
                    if (input != undefined && input != null) {
                        search.val(input);
                    }

                    this.resultsPage = 1;

                    opts.query({
                        element: opts.element,
                        term: search.val(),
                        page: this.resultsPage,
                        context: null,
                        matcher: opts.matcher,
                        callback: this.bind(function (data) {
                            var def; // default choice

                            // ignore old responses
                            if (queryNumber != this.queryCount) {
                                return;
                            }

                            // ignore a response if the select2 has been closed before it was received
                            if (!this.opened()) {
                                this.search.removeClass("select2-active");
                                return;
                            }

                            // save context, if any
                            this.context = (data.context === undefined) ? null : data.context;
                            // create a default choice and prepend it to the list
                            if (this.opts.createSearchChoice && search.val() !== "") {
                                def = this.opts.createSearchChoice.call(self, search.val(), data.results);
                                if (def !== undefined && def !== null && self.id(def) !== undefined && self.id(def) !== null) {
                                    if ($(data.results).filter(
                                    function () {
                                        return equal(self.id(this), self.id(def));
                                    }).length === 0) {
                                        data.results.unshift(def);
                                    }
                                }
                            }

                            if (data.results.length === 0 && checkFormatter(opts.formatNoMatches, "formatNoMatches")) {
                                render("<li class='select2-no-results'>" + opts.formatNoMatches(search.val()) + "</li>");
                                return;
                            }

                            results.empty();
                            self.opts.populateResults.call(this, results, data.results, {
                                term: search.val(),
                                page: this.resultsPage,
                                context: null
                            });

                            if (data.more === true && checkFormatter(opts.formatLoadMore, "formatLoadMore")) {
                                results.append("<li class='select2-more-results'>" + self.opts.escapeMarkup(opts.formatLoadMore(this.resultsPage)) + "</li>");
                                window.setTimeout(function() {
                                    self.loadMoreIfNeeded();
                                }, 10);
                            }

                            this.postprocessResults(data, initial);

                            postRender();

                            this.opts.element.trigger({
                                type: "select2-loaded",
                                items: data 
                            });
                        })
                    });
                },

                // abstract
                cancel: function () {
                    this.close();
                },

                // abstract
                blur: function () {
                    // if selectOnBlur == true, select the currently highlighted option
                    if (this.opts.selectOnBlur)
                        this.selectHighlighted({
                            noFocus: true
                        });

                    this.close();
                    this.container.removeClass("select2-container-active");
                    // synonymous to .is(':focus'), which is available in jquery >= 1.6
                    if (this.search[0] === document.activeElement) {
                        this.search.blur();
                    }
                    this.clearSearch();
                    this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
                },

                // abstract
                focusSearch: function () {
                    focus(this.search);
                },

                // abstract
                selectHighlighted: function (options) {
                    var index = this.highlight(),
                    highlighted = this.results.find(".select2-highlighted"),
                    data = highlighted.closest('.select2-result').data("select2-data");

                    if (data) {
                        this.highlight(index);
                        this.onSelect(data, options);
                    } else if (options && options.noFocus) {
                        this.close();
                    }
                },

                // abstract
                getPlaceholder: function () {
                    var placeholderOption;
                    return this.opts.element.attr("placeholder") ||
                    this.opts.element.attr("data-placeholder") || // jquery 1.4 compat
                    this.opts.element.data("placeholder") ||
                    this.opts.placeholder ||
                    ((placeholderOption = this.getPlaceholderOption()) !== undefined ? placeholderOption.text() : undefined);
                },

                // abstract
                getPlaceholderOption: function() {
                    if (this.select) {
                        var firstOption = this.select.children('option').first();
                        if (this.opts.placeholderOption !== undefined ) {
                            //Determine the placeholder option based on the specified placeholderOption setting
                            return (this.opts.placeholderOption === "first" && firstOption) ||
                            (typeof this.opts.placeholderOption === "function" && this.opts.placeholderOption(this.select));
                        } else if (firstOption.text() === "" && firstOption.val() === "") {
                            //No explicit placeholder option specified, use the first if it's blank
                            return firstOption;
                        }
                    }
                },

                /**
                         * Get the desired width for the container element.  This is
                         * derived first from option `width` passed to select2, then
                         * the inline 'style' on the original element, and finally
                         * falls back to the jQuery calculated element width.
                         */
                // abstract
                initContainerWidth: function () {
                    function resolveContainerWidth() {
                        var style, attrs, matches, i, l, attr;

                        if (this.opts.width === "off") {
                            return null;
                        } else if (this.opts.width === "element") {
                            return this.opts.element.outerWidth(false) === 0 ? 'auto' : this.opts.element.outerWidth(false) + 'px';
                        } else if (this.opts.width === "copy" || this.opts.width === "resolve") {
                            // check if there is inline style on the element that contains width
                            style = this.opts.element.attr('style');
                            if (style !== undefined) {
                                attrs = style.split(';');
                                for (i = 0, l = attrs.length; i < l; i = i + 1) {
                                    attr = attrs[i].replace(/\s/g, '');
                                    matches = attr.match(/^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i);
                                    if (matches !== null && matches.length >= 1)
                                        return matches[1];
                                }
                            }

                            if (this.opts.width === "resolve") {
                                // next check if css('width') can resolve a width that is percent based, this is sometimes possible
                                // when attached to input type=hidden or elements hidden via css
                                style = this.opts.element.css('width');
                                if (style.indexOf("%") > 0) 
                                    return style;

                                // finally, fallback on the calculated width of the element
                                return (this.opts.element.outerWidth(false) === 0 ? 'auto' : this.opts.element.outerWidth(false) + 'px');
                            }

                            return null;
                        } else if ($.isFunction(this.opts.width)) {
                            return this.opts.width();
                        } else {
                            return this.opts.width;
                        }
                    };

                    var width = resolveContainerWidth.call(this);
                    if (width !== null) {
                        this.container.css("width", width);
                    }
                }
            });

            SingleSelect2 = clazz(AbstractSelect2, {

                // single

                createContainer: function () {
                    var container = $(document.createElement("div")).attr({
                        "class": "select2-container"
                    }).html([
                    "<a href='javascript:void(0)' onclick='return false;' class='select2-choice' tabindex='-1'>",
                    "   <span class='select2-chosen'>&nbsp;</span><abbr class='select2-search-choice-close'></abbr>",
                    "   <span class='select2-arrow'><b></b></span>",
                    "</a>",
                    "<input class='select2-focusser select2-offscreen' type='text'/>",
                    "<div class='select2-drop select2-display-none'>",
                    "   <div class='select2-search'>",
                    "       <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input'/>",
                    "   </div>",
                    "   <ul class='select2-results'>",
                    "   </ul>",
                    "</div>"].join(""));
                    return container;
                },

                // single
                enableInterface: function() {
                    if (this.parent.enableInterface.apply(this, arguments)) {
                        this.focusser.prop("disabled", !this.isInterfaceEnabled());
                    }
                },

                // single
                opening: function () {
                    var el, range, len;

                    if (this.opts.minimumResultsForSearch >= 0) {
                        this.showSearch(true);
                    }

                    this.parent.opening.apply(this, arguments);

                    if (this.showSearchInput !== false) {
                        // IE appends focusser.val() at the end of field :/ so we manually insert it at the beginning using a range
                        // all other browsers handle this just fine

                        this.search.val(this.focusser.val());
                    }
                    this.search.focus();
                    // move the cursor to the end after focussing, otherwise it will be at the beginning and
                    // new text will appear *before* focusser.val()
                    el = this.search.get(0);
                    if (el.createTextRange) {
                        range = el.createTextRange();
                        range.collapse(false);
                        range.select();
                    } else if (el.setSelectionRange) {
                        len = this.search.val().length;
                        el.setSelectionRange(len, len);
                    }

                    // initializes search's value with nextSearchTerm (if defined by user)
                    // ignore nextSearchTerm if the dropdown is opened by the user pressing a letter
                    if (this.search.val() === "") {
                        if (this.nextSearchTerm != undefined) {
                            this.search.val(this.nextSearchTerm);
                            this.search.select();
                        }
                    }

                    this.focusser.prop("disabled", true).val("");
                    this.updateResults(true);
                    this.opts.element.trigger($.Event("select2-open"));
                },

                // single
                close: function (params) {
                    if (!this.opened()) 
                        return;
                    this.parent.close.apply(this, arguments);

                    params = params || {
                        focus: true
                    };
                    this.focusser.removeAttr("disabled");

                    if (params.focus) {
                        this.focusser.focus();
                    }
                },

                // single
                focus: function () {
                    if (this.opened()) {
                        this.close();
                    } else {
                        this.focusser.removeAttr("disabled");
                        this.focusser.focus();
                    }
                },

                // single
                isFocused: function () {
                    return this.container.hasClass("select2-container-active");
                },

                // single
                cancel: function () {
                    this.parent.cancel.apply(this, arguments);
                    this.focusser.removeAttr("disabled");
                    this.focusser.focus();
                },

                // single
                destroy: function() {
                    $("label[for='" + this.focusser.attr('id') + "']")
                    .attr('for', this.opts.element.attr("id"));
                    this.parent.destroy.apply(this, arguments);
                },

                // single
                initContainer: function () {

                    var selection,
                    container = this.container,
                    dropdown = this.dropdown;

                    if (this.opts.minimumResultsForSearch < 0) {
                        this.showSearch(false);
                    } else {
                        this.showSearch(true);
                    }

                    this.selection = selection = container.find(".select2-choice");

                    this.focusser = container.find(".select2-focusser");

                    // rewrite labels from original element to focusser
                    this.focusser.attr("id", "s2id_autogen" + nextUid());

                    $("label[for='" + this.opts.element.attr("id") + "']")
                    .attr('for', this.focusser.attr('id'));

                    this.focusser.attr("tabindex", this.elementTabIndex);

                    this.search.on("keydown", this.bind(function (e) {
                        if (!this.isInterfaceEnabled()) 
                            return;

                        if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
                            // prevent the page from scrolling
                            killEvent(e);
                            return;
                        }

                        switch (e.which) {
                        case KEY.UP:
                        case KEY.DOWN:
                            this.moveHighlight((e.which === KEY.UP) ? - 1 : 1);
                            killEvent(e);
                            return;
                        case KEY.ENTER:
                            this.selectHighlighted();
                            killEvent(e);
                            return;
                        case KEY.TAB:
                            this.selectHighlighted({
                                noFocus: true
                            });
                            return;
                        case KEY.ESC:
                            this.cancel(e);
                            killEvent(e);
                            return;
                        }
                    }));

                    this.search.on("blur", this.bind(function(e) {
                        // a workaround for chrome to keep the search field focussed when the scroll bar is used to scroll the dropdown.
                        // without this the search field loses focus which is annoying
                        if (document.activeElement === this.body().get(0)) {
                            window.setTimeout(this.bind(function() {
                                this.search.focus();
                            }), 0);
                        }
                    }));

                    this.focusser.on("keydown", this.bind(function (e) {
                        if (!this.isInterfaceEnabled()) 
                            return;

                        if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC) {
                            return;
                        }

                        if (this.opts.openOnEnter === false && e.which === KEY.ENTER) {
                            killEvent(e);
                            return;
                        }

                        if (e.which == KEY.DOWN || e.which == KEY.UP
                        || (e.which == KEY.ENTER && this.opts.openOnEnter)) {

                            if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) 
                                return;

                            this.open();
                            killEvent(e);
                            return;
                        }

                        if (e.which == KEY.DELETE || e.which == KEY.BACKSPACE) {
                            if (this.opts.allowClear) {
                                this.clear();
                            }
                            killEvent(e);
                            return;
                        }
                    }));


                    installKeyUpChangeEvent(this.focusser);
                    this.focusser.on("keyup-change input", this.bind(function(e) {
                        if (this.opts.minimumResultsForSearch >= 0) {
                            e.stopPropagation();
                            if (this.opened()) 
                                return;
                            this.open();
                        }
                    }));

                    selection.on("mousedown", "abbr", this.bind(function (e) {
                        if (!this.isInterfaceEnabled()) 
                            return;
                        this.clear();
                        killEventImmediately(e);
                        this.close();
                        this.selection.focus();
                    }));

                    selection.on("mousedown", this.bind(function (e) {

                        if (!this.container.hasClass("select2-container-active")) {
                            this.opts.element.trigger($.Event("select2-focus"));
                        }

                        if (this.opened()) {
                            this.close();
                        } else if (this.isInterfaceEnabled()) {
                            this.open();
                        }

                        killEvent(e);
                    }));

                    dropdown.on("mousedown", this.bind(function() {
                        this.search.focus();
                    }));

                    selection.on("focus", this.bind(function(e) {
                        killEvent(e);
                    }));

                    this.focusser.on("focus", this.bind(function() {
                        if (!this.container.hasClass("select2-container-active")) {
                            this.opts.element.trigger($.Event("select2-focus"));
                        }
                        this.container.addClass("select2-container-active");
                    })).on("blur", this.bind(function() {
                        if (!this.opened()) {
                            this.container.removeClass("select2-container-active");
                            this.opts.element.trigger($.Event("select2-blur"));
                        }
                    }));
                    this.search.on("focus", this.bind(function() {
                        if (!this.container.hasClass("select2-container-active")) {
                            this.opts.element.trigger($.Event("select2-focus"));
                        }
                        this.container.addClass("select2-container-active");
                    }));

                    this.initContainerWidth();
                    this.opts.element.addClass("select2-offscreen");
                    this.setPlaceholder();

                },

                // single
                clear: function(triggerChange) {
                    var data = this.selection.data("select2-data");
                    if (data) {
                        // guard against queued quick consecutive clicks
                        var evt = $.Event("select2-clearing");
                        this.opts.element.trigger(evt);
                        if (evt.isDefaultPrevented()) {
                            return;
                        }
                        var placeholderOption = this.getPlaceholderOption();
                        this.opts.element.val(placeholderOption ? placeholderOption.val() : "");
                        this.selection.find(".select2-chosen").empty();
                        this.selection.removeData("select2-data");
                        this.setPlaceholder();

                        if (triggerChange !== false) {
                            this.opts.element.trigger({
                                type: "select2-removed",
                                val: this.id(data),
                                choice: data 
                            });
                            this.triggerChange({
                                removed: data
                            });
                        }
                    }
                },

                /**
                         * Sets selection based on source element's value
                         */
                // single
                initSelection: function () {
                    var selected;
                    if (this.isPlaceholderOptionSelected()) {
                        this.updateSelection(null);
                        this.close();
                        this.setPlaceholder();
                    } else {
                        var self = this;
                        this.opts.initSelection.call(null, this.opts.element, function(selected) {
                            if (selected !== undefined && selected !== null) {
                                self.updateSelection(selected);
                                self.close();
                                self.setPlaceholder();
                            }
                        });
                    }
                },

                isPlaceholderOptionSelected: function() {
                    var placeholderOption;
                    if (!this.getPlaceholder()) 
                        return false; // no placeholder specified so no option should be considered
                    return ((placeholderOption = this.getPlaceholderOption()) !== undefined && placeholderOption.prop("selected"))
                    || (this.opts.element.val() === "")
                    || (this.opts.element.val() === undefined)
                    || (this.opts.element.val() === null);
                },

                // single
                prepareOpts: function () {
                    var opts = this.parent.prepareOpts.apply(this, arguments),
                    self = this;

                    if (opts.element.get(0).tagName.toLowerCase() === "select") {
                        // install the selection initializer
                        opts.initSelection = function (element, callback) {
                            var selected = element.find("option").filter(function() {
                                return this.selected 
                            });
                            // a single select box always has a value, no need to null check 'selected'
                            callback(self.optionToData(selected));
                        };
                    } else if ("data" in opts) {
                        // install default initSelection when applied to hidden input and data is local
                        opts.initSelection = opts.initSelection || function (element, callback) {
                            var id = element.val();
                            //search in data by id, storing the actual matching item
                            var match = null;
                            opts.query({
                                matcher: function(term, text, el) {
                                    var is_match = equal(id, opts.id(el));
                                    if (is_match) {
                                        match = el;
                                    }
                                    return is_match;
                                },
                                callback: !$.isFunction(callback) ? $.noop : function() {
                                    callback(match);
                                }
                            });
                        };
                    }

                    return opts;
                },

                // single
                getPlaceholder: function() {
                    // if a placeholder is specified on a single select without a valid placeholder option ignore it
                    if (this.select) {
                        if (this.getPlaceholderOption() === undefined) {
                            return undefined;
                        }
                    }

                    return this.parent.getPlaceholder.apply(this, arguments);
                },

                // single
                setPlaceholder: function () {
                    var placeholder = this.getPlaceholder();

                    if (this.isPlaceholderOptionSelected() && placeholder !== undefined) {

                        // check for a placeholder option if attached to a select
                        if (this.select && this.getPlaceholderOption() === undefined) 
                            return;

                        this.selection.find(".select2-chosen").html(this.opts.escapeMarkup(placeholder));

                        this.selection.addClass("select2-default");

                        this.container.removeClass("select2-allowclear");
                    }
                },

                // single
                postprocessResults: function (data, initial, noHighlightUpdate) {
                    var selected = 0, self = this, showSearchInput = true;

                    // find the selected element in the result list

                    this.findHighlightableChoices().each2(function (i, elm) {
                        if (equal(self.id(elm.data("select2-data")), self.opts.element.val())) {
                            selected = i;
                            return false;
                        }
                    });

                    // and highlight it
                    if (noHighlightUpdate !== false) {
                        if (initial === true && selected >= 0) {
                            this.highlight(selected);
                        } else {
                            this.highlight(0);
                        }
                    }

                    // hide the search box if this is the first we got the results and there are enough of them for search

                    if (initial === true) {
                        var min = this.opts.minimumResultsForSearch;
                        if (min >= 0) {
                            this.showSearch(countResults(data.results) >= min);
                        }
                    }
                },

                // single
                showSearch: function(showSearchInput) {
                    if (this.showSearchInput === showSearchInput) 
                        return;

                    this.showSearchInput = showSearchInput;

                    this.dropdown.find(".select2-search").toggleClass("select2-search-hidden", !showSearchInput);
                    this.dropdown.find(".select2-search").toggleClass("select2-offscreen", !showSearchInput);
                    //add "select2-with-searchbox" to the container if search box is shown
                    $(this.dropdown, this.container).toggleClass("select2-with-searchbox", showSearchInput);
                },

                // single
                onSelect: function (data, options) {

                    if (!this.triggerSelect(data)) {
                        return;
                    }

                    var old = this.opts.element.val(),
                    oldData = this.data();

                    this.opts.element.val(this.id(data));
                    this.updateSelection(data);

                    this.opts.element.trigger({
                        type: "select2-selected",
                        val: this.id(data),
                        choice: data 
                    });

                    this.nextSearchTerm = this.opts.nextSearchTerm(data, this.search.val());
                    this.close();

                    if (!options || !options.noFocus)
                        this.focusser.focus();

                    if (!equal(old, this.id(data))) {
                        this.triggerChange({
                            added: data,
                            removed: oldData
                        });
                    }
                },

                // single
                updateSelection: function (data) {

                    var container = this.selection.find(".select2-chosen"), formatted, cssClass;

                    this.selection.data("select2-data", data);

                    container.empty();
                    if (data !== null) {
                        formatted = this.opts.formatSelection(data, container, this.opts.escapeMarkup);
                    }
                    if (formatted !== undefined) {
                        container.append(formatted);
                    }
                    cssClass = this.opts.formatSelectionCssClass(data, container);
                    if (cssClass !== undefined) {
                        container.addClass(cssClass);
                    }

                    this.selection.removeClass("select2-default");

                    if (this.opts.allowClear && this.getPlaceholder() !== undefined) {
                        this.container.addClass("select2-allowclear");
                    }
                },

                // single
                val: function () {
                    var val,
                    triggerChange = false,
                    data = null,
                    self = this,
                    oldData = this.data();

                    if (arguments.length === 0) {
                        return this.opts.element.val();
                    }

                    val = arguments[0];

                    if (arguments.length > 1) {
                        triggerChange = arguments[1];
                    }

                    if (this.select) {
                        this.select
                        .val(val)
                        .find("option").filter(function() {
                            return this.selected 
                        }).each2(function (i, elm) {
                            data = self.optionToData(elm);
                            return false;
                        });
                        this.updateSelection(data);
                        this.setPlaceholder();
                        if (triggerChange) {
                            this.triggerChange({
                                added: data,
                                removed: oldData
                            });
                        }
                    } else {
                        // val is an id. !val is true for [undefined,null,'',0] - 0 is legal
                        if (!val && val !== 0) {
                            this.clear(triggerChange);
                            return;
                        }
                        if (this.opts.initSelection === undefined) {
                            throw new Error("cannot call val() if initSelection() is not defined");
                        }
                        this.opts.element.val(val);
                        this.opts.initSelection(this.opts.element, function(data) {
                            self.opts.element.val(!data ? "" : self.id(data));
                            self.updateSelection(data);
                            self.setPlaceholder();
                            if (triggerChange) {
                                self.triggerChange({
                                    added: data,
                                    removed: oldData
                                });
                            }
                        });
                    }
                },

                // single
                clearSearch: function () {
                    this.search.val("");
                    this.focusser.val("");
                },

                // single
                data: function(value) {
                    var data,
                    triggerChange = false;

                    if (arguments.length === 0) {
                        data = this.selection.data("select2-data");
                        if (data == undefined) 
                            data = null;
                        return data;
                    } else {
                        if (arguments.length > 1) {
                            triggerChange = arguments[1];
                        }
                        if (!value) {
                            this.clear(triggerChange);
                        } else {
                            data = this.data();
                            this.opts.element.val(!value ? "" : this.id(value));
                            this.updateSelection(value);
                            if (triggerChange) {
                                this.triggerChange({
                                    added: value,
                                    removed: data
                                });
                            }
                        }
                    }
                }
            });

            MultiSelect2 = clazz(AbstractSelect2, {

                // multi
                createContainer: function () {
                    var container = $(document.createElement("div")).attr({
                        "class": "select2-container select2-container-multi"
                    }).html([
                    "<ul class='select2-choices'>",
                    "  <li class='select2-search-field'>",
                    "    <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input'>",
                    "  </li>",
                    "</ul>",
                    "<div class='select2-drop select2-drop-multi select2-display-none'>",
                    "   <ul class='select2-results'>",
                    "   </ul>",
                    "</div>"].join(""));
                    return container;
                },

                // multi
                prepareOpts: function () {
                    var opts = this.parent.prepareOpts.apply(this, arguments),
                    self = this;

                    // TODO validate placeholder is a string if specified

                    if (opts.element.get(0).tagName.toLowerCase() === "select") {
                        // install sthe selection initializer
                        opts.initSelection = function (element, callback) {

                            var data = [];

                            element.find("option").filter(function() {
                                return this.selected 
                            }).each2(function (i, elm) {
                                data.push(self.optionToData(elm));
                            });
                            callback(data);
                        };
                    } else if ("data" in opts) {
                        // install default initSelection when applied to hidden input and data is local
                        opts.initSelection = opts.initSelection || function (element, callback) {
                            var ids = splitVal(element.val(), opts.separator);
                            //search in data by array of ids, storing matching items in a list
                            var matches = [];
                            opts.query({
                                matcher: function(term, text, el) {
                                    var is_match = $.grep(ids, function(id) {
                                        return equal(id, opts.id(el));
                                    }).length;
                                    if (is_match) {
                                        matches.push(el);
                                    }
                                    return is_match;
                                },
                                callback: !$.isFunction(callback) ? $.noop : function() {
                                    // reorder matches based on the order they appear in the ids array because right now
                                    // they are in the order in which they appear in data array
                                    var ordered = [];
                                    for (var i = 0; i < ids.length; i++) {
                                        var id = ids[i];
                                        for (var j = 0; j < matches.length; j++) {
                                            var match = matches[j];
                                            if (equal(id, opts.id(match))) {
                                                ordered.push(match);
                                                matches.splice(j, 1);
                                                break;
                                            }
                                        }
                                    }
                                    callback(ordered);
                                }
                            });
                        };
                    }

                    return opts;
                },

                // multi
                selectChoice: function (choice) {

                    var selected = this.container.find(".select2-search-choice-focus");
                    if (selected.length && choice && choice[0] == selected[0]) {
} else {
                        if (selected.length) {
                            this.opts.element.trigger("choice-deselected", selected);
                        }
                        selected.removeClass("select2-search-choice-focus");
                        if (choice && choice.length) {
                            this.close();
                            choice.addClass("select2-search-choice-focus");
                            this.opts.element.trigger("choice-selected", choice);
                        }
                    }
                },

                // multi
                destroy: function() {
                    $("label[for='" + this.search.attr('id') + "']")
                    .attr('for', this.opts.element.attr("id"));
                    this.parent.destroy.apply(this, arguments);
                },

                // multi
                initContainer: function () {

                    var selector = ".select2-choices", selection;

                    this.searchContainer = this.container.find(".select2-search-field");
                    this.selection = selection = this.container.find(selector);

                    var _this = this;
                    this.selection.on("click", ".select2-search-choice:not(.select2-locked)", function (e) {
                        //killEvent(e);
                        _this.search[0].focus();
                        _this.selectChoice($(this));
                    });

                    // rewrite labels from original element to focusser
                    this.search.attr("id", "s2id_autogen" + nextUid());
                    $("label[for='" + this.opts.element.attr("id") + "']")
                    .attr('for', this.search.attr('id'));

                    this.search.on("input paste", this.bind(function() {
                        if (!this.isInterfaceEnabled()) 
                            return;
                        if (!this.opened()) {
                            this.open();
                        }
                    }));

                    this.search.attr("tabindex", this.elementTabIndex);

                    this.keydowns = 0;
                    this.search.on("keydown", this.bind(function (e) {
                        if (!this.isInterfaceEnabled()) 
                            return;

                        ++this.keydowns;
                        var selected = selection.find(".select2-search-choice-focus");
                        var prev = selected.prev(".select2-search-choice:not(.select2-locked)");
                        var next = selected.next(".select2-search-choice:not(.select2-locked)");
                        var pos = getCursorInfo(this.search);

                        if (selected.length &&
                        (e.which == KEY.LEFT || e.which == KEY.RIGHT || e.which == KEY.BACKSPACE || e.which == KEY.DELETE || e.which == KEY.ENTER)) {
                            var selectedChoice = selected;
                            if (e.which == KEY.LEFT && prev.length) {
                                selectedChoice = prev;
                            } else if (e.which == KEY.RIGHT) {
                                selectedChoice = next.length ? next : null;
                            } else if (e.which === KEY.BACKSPACE) {
                                this.unselect(selected.first());
                                this.search.width(10);
                                selectedChoice = prev.length ? prev : next;
                            } else if (e.which == KEY.DELETE) {
                                this.unselect(selected.first());
                                this.search.width(10);
                                selectedChoice = next.length ? next : null;
                            } else if (e.which == KEY.ENTER) {
                                selectedChoice = null;
                            }

                            this.selectChoice(selectedChoice);
                            killEvent(e);
                            if (!selectedChoice || !selectedChoice.length) {
                                this.open();
                            }
                            return;
                        } else if (((e.which === KEY.BACKSPACE && this.keydowns == 1)
                        || e.which == KEY.LEFT) && (pos.offset == 0 && !pos.length)) {

                            this.selectChoice(selection.find(".select2-search-choice:not(.select2-locked)").last());
                            killEvent(e);
                            return;
                        } else {
                            this.selectChoice(null);
                        }

                        if (this.opened()) {
                            switch (e.which) {
                            case KEY.UP:
                            case KEY.DOWN:
                                this.moveHighlight((e.which === KEY.UP) ? - 1 : 1);
                                killEvent(e);
                                return;
                            case KEY.ENTER:
                                this.selectHighlighted();
                                killEvent(e);
                                return;
                            case KEY.TAB:
                                this.selectHighlighted({
                                    noFocus: true
                                });
                                this.close();
                                return;
                            case KEY.ESC:
                                this.cancel(e);
                                killEvent(e);
                                return;
                            }
                        }

                        if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e)
                        || e.which === KEY.BACKSPACE || e.which === KEY.ESC) {
                            return;
                        }

                        if (e.which === KEY.ENTER) {
                            if (this.opts.openOnEnter === false) {
                                return;
                            } else if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {
                                return;
                            }
                        }

                        this.open();

                        if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
                            // prevent the page from scrolling
                            killEvent(e);
                        }

                        if (e.which === KEY.ENTER) {
                            // prevent form from being submitted
                            killEvent(e);
                        }

                    }));

                    this.search.on("keyup", this.bind(function (e) {
                        this.keydowns = 0;
                        this.resizeSearch();
                    })
                    );

                    this.search.on("blur", this.bind(function(e) {
                        this.container.removeClass("select2-container-active");
                        this.search.removeClass("select2-focused");
                        this.selectChoice(null);
                        if (!this.opened()) 
                            this.clearSearch();
                        e.stopImmediatePropagation();
                        this.opts.element.trigger($.Event("select2-blur"));
                    }));

                    this.container.on("click", selector, this.bind(function (e) {
                        if (!this.isInterfaceEnabled()) 
                            return;
                        if ($(e.target).closest(".select2-search-choice").length > 0) {
                            // clicked inside a select2 search choice, do not open
                            return;
                        }
                        this.selectChoice(null);
                        this.clearPlaceholder();
                        if (!this.container.hasClass("select2-container-active")) {
                            this.opts.element.trigger($.Event("select2-focus"));
                        }
                        this.open();
                        this.focusSearch();
                        e.preventDefault();
                    }));

                    this.container.on("focus", selector, this.bind(function () {
                        if (!this.isInterfaceEnabled()) 
                            return;
                        if (!this.container.hasClass("select2-container-active")) {
                            this.opts.element.trigger($.Event("select2-focus"));
                        }
                        this.container.addClass("select2-container-active");
                        this.dropdown.addClass("select2-drop-active");
                        this.clearPlaceholder();
                    }));

                    this.initContainerWidth();
                    this.opts.element.addClass("select2-offscreen");

                    // set the placeholder if necessary
                    this.clearSearch();
                },

                // multi
                enableInterface: function() {
                    if (this.parent.enableInterface.apply(this, arguments)) {
                        this.search.prop("disabled", !this.isInterfaceEnabled());
                    }
                },

                // multi
                initSelection: function () {
                    var data;
                    if (this.opts.element.val() === "" && this.opts.element.text() === "") {
                        this.updateSelection([]);
                        this.close();
                        // set the placeholder if necessary
                        this.clearSearch();
                    }
                    if (this.select || this.opts.element.val() !== "") {
                        var self = this;
                        this.opts.initSelection.call(null, this.opts.element, function(data) {
                            if (data !== undefined && data !== null) {
                                self.updateSelection(data);
                                self.close();
                                // set the placeholder if necessary
                                self.clearSearch();
                            }
                        });
                    }
                },

                // multi
                clearSearch: function () {
                    var placeholder = this.getPlaceholder(),
                    maxWidth = this.getMaxSearchWidth();

                    if (placeholder !== undefined && this.getVal().length === 0 && this.search.hasClass("select2-focused") === false) {
                        this.search.val(placeholder).addClass("select2-default");
                        // stretch the search box to full width of the container so as much of the placeholder is visible as possible
                        // we could call this.resizeSearch(), but we do not because that requires a sizer and we do not want to create one so early because of a firefox bug, see #944
                        this.search.width(maxWidth > 0 ? maxWidth : this.container.css("width"));
                    } else {
                        this.search.val("").width(10);
                    }
                },

                // multi
                clearPlaceholder: function () {
                    if (this.search.hasClass("select2-default")) {
                        this.search.val("").removeClass("select2-default");
                    }
                },

                // multi
                opening: function () {
                    this.clearPlaceholder(); // should be done before super so placeholder is not used to search
                    this.resizeSearch();

                    this.parent.opening.apply(this, arguments);

                    this.focusSearch();

                    this.updateResults(true);
                    this.search.focus();
                    this.opts.element.trigger($.Event("select2-open"));
                },

                // multi
                close: function () {
                    if (!this.opened()) 
                        return;
                    this.parent.close.apply(this, arguments);
                },

                // multi
                focus: function () {
                    this.close();
                    this.search.focus();
                },

                // multi
                isFocused: function () {
                    return this.search.hasClass("select2-focused");
                },

                // multi
                updateSelection: function (data) {
                    var ids = [], filtered = [], self = this;

                    // filter out duplicates
                    $(data).each(function () {
                        if (indexOf(self.id(this), ids) < 0) {
                            ids.push(self.id(this));
                            filtered.push(this);
                        }
                    });
                    data = filtered;

                    this.selection.find(".select2-search-choice").remove();
                    $(data).each(function () {
                        self.addSelectedChoice(this);
                    });
                    self.postprocessResults();
                },

                // multi
                tokenize: function() {
                    var input = this.search.val();
                    input = this.opts.tokenizer.call(this, input, this.data(), this.bind(this.onSelect), this.opts);
                    if (input != null && input != undefined) {
                        this.search.val(input);
                        if (input.length > 0) {
                            this.open();
                        }
                    }

                },

                // multi
                onSelect: function (data, options) {

                    if (!this.triggerSelect(data)) {
                        return;
                    }

                    this.addSelectedChoice(data);

                    this.opts.element.trigger({
                        type: "selected",
                        val: this.id(data),
                        choice: data 
                    });

                    if (this.select || !this.opts.closeOnSelect) 
                        this.postprocessResults(data, false, this.opts.closeOnSelect === true);

                    if (this.opts.closeOnSelect) {
                        this.close();
                        this.search.width(10);
                    } else {
                        if (this.countSelectableResults() > 0) {
                            this.search.width(10);
                            this.resizeSearch();
                            if (this.getMaximumSelectionSize() > 0 && this.val().length >= this.getMaximumSelectionSize()) {
                                // if we reached max selection size repaint the results so choices
                                // are replaced with the max selection reached message
                                this.updateResults(true);
                            }
                            this.positionDropdown();
                        } else {
                            // if nothing left to select close
                            this.close();
                            this.search.width(10);
                        }
                    }

                    // since its not possible to select an element that has already been
                    // added we do not need to check if this is a new element before firing change
                    this.triggerChange({
                        added: data 
                    });

                    if (!options || !options.noFocus)
                        this.focusSearch();
                },

                // multi
                cancel: function () {
                    this.close();
                    this.focusSearch();
                },

                addSelectedChoice: function (data) {
                    var enableChoice = !data.locked,
                    enabledItem = $(
                    "<li class='select2-search-choice'>" +
                    "    <div></div>" +
                    "    <a href='#' onclick='return false;' class='select2-search-choice-close' tabindex='-1'></a>" +
                    "</li>"),
                    disabledItem = $(
                    "<li class='select2-search-choice select2-locked'>" +
                    "<div></div>" +
                    "</li>");
                    var choice = enableChoice ? enabledItem : disabledItem,
                    id = this.id(data),
                    val = this.getVal(),
                    formatted,
                    cssClass;

                    formatted = this.opts.formatSelection(data, choice.find("div"), this.opts.escapeMarkup);
                    if (formatted != undefined) {
                        choice.find("div").replaceWith("<div>" + formatted + "</div>");
                    }
                    cssClass = this.opts.formatSelectionCssClass(data, choice.find("div"));
                    if (cssClass != undefined) {
                        choice.addClass(cssClass);
                    }

                    if (enableChoice) {
                        choice.find(".select2-search-choice-close")
                        .on("mousedown", killEvent)
                        .on("click dblclick", this.bind(function (e) {
                            if (!this.isInterfaceEnabled()) 
                                return;

                            $(e.target).closest(".select2-search-choice").fadeOut('fast', this.bind(function() {
                                this.unselect($(e.target));
                                this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
                                this.close();
                                this.focusSearch();
                            })).dequeue();
                            killEvent(e);
                        })).on("focus", this.bind(function () {
                            if (!this.isInterfaceEnabled()) 
                                return;
                            this.container.addClass("select2-container-active");
                            this.dropdown.addClass("select2-drop-active");
                        }));
                    }

                    choice.data("select2-data", data);
                    choice.insertBefore(this.searchContainer);

                    val.push(id);
                    this.setVal(val);
                },

                // multi
                unselect: function (selected) {
                    var val = this.getVal(),
                    data,
                    index;
                    selected = selected.closest(".select2-search-choice");

                    if (selected.length === 0) {
                        throw "Invalid argument: " + selected + ". Must be .select2-search-choice";
                    }

                    data = selected.data("select2-data");

                    if (!data) {
                        // prevent a race condition when the 'x' is clicked really fast repeatedly the event can be queued
                        // and invoked on an element already removed
                        return;
                    }

                    while ((index = indexOf(this.id(data), val)) >= 0) {
                        val.splice(index, 1);
                        this.setVal(val);
                        if (this.select) 
                            this.postprocessResults();
                    }

                    var evt = $.Event("select2-removing");
                    evt.val = this.id(data);
                    evt.choice = data;
                    this.opts.element.trigger(evt);

                    if (evt.isDefaultPrevented()) {
                        return;
                    }

                    selected.remove();

                    this.opts.element.trigger({
                        type: "select2-removed",
                        val: this.id(data),
                        choice: data 
                    });
                    this.triggerChange({
                        removed: data 
                    });
                },

                // multi
                postprocessResults: function (data, initial, noHighlightUpdate) {
                    var val = this.getVal(),
                    choices = this.results.find(".select2-result"),
                    compound = this.results.find(".select2-result-with-children"),
                    self = this;

                    choices.each2(function (i, choice) {
                        var id = self.id(choice.data("select2-data"));
                        if (indexOf(id, val) >= 0) {
                            choice.addClass("select2-selected");
                            // mark all children of the selected parent as selected
                            choice.find(".select2-result-selectable").addClass("select2-selected");
                        }
                    });

                    compound.each2(function(i, choice) {
                        // hide an optgroup if it doesnt have any selectable children
                        if (!choice.is('.select2-result-selectable')
                        && choice.find(".select2-result-selectable:not(.select2-selected)").length === 0) {
                            choice.addClass("select2-selected");
                        }
                    });

                    if (this.highlight() == - 1 && noHighlightUpdate !== false) {
                        self.highlight(0);
                    }

                    //If all results are chosen render formatNoMAtches
                    if (!this.opts.createSearchChoice && !choices.filter('.select2-result:not(.select2-selected)').length > 0) {
                        if (!data || data && !data.more && this.results.find(".select2-no-results").length === 0) {
                            if (checkFormatter(self.opts.formatNoMatches, "formatNoMatches")) {
                                this.results.append("<li class='select2-no-results'>" + self.opts.formatNoMatches(self.search.val()) + "</li>");
                            }
                        }
                    }

                },

                // multi
                getMaxSearchWidth: function() {
                    return this.selection.width() - getSideBorderPadding(this.search);
                },

                // multi
                resizeSearch: function () {
                    var minimumWidth, left, maxWidth, containerLeft, searchWidth,
                    sideBorderPadding = getSideBorderPadding(this.search);

                    minimumWidth = measureTextWidth(this.search) + 10;

                    left = this.search.offset().left;

                    maxWidth = this.selection.width();
                    containerLeft = this.selection.offset().left;

                    searchWidth = maxWidth - (left - containerLeft) - sideBorderPadding;

                    if (searchWidth < minimumWidth) {
                        searchWidth = maxWidth - sideBorderPadding;
                    }

                    if (searchWidth < 40) {
                        searchWidth = maxWidth - sideBorderPadding;
                    }

                    if (searchWidth <= 0) {
                        searchWidth = minimumWidth;
                    }

                    this.search.width(Math.floor(searchWidth));
                },

                // multi
                getVal: function () {
                    var val;
                    if (this.select) {
                        val = this.select.val();
                        return val === null ? [] : val;
                    } else {
                        val = this.opts.element.val();
                        return splitVal(val, this.opts.separator);
                    }
                },

                // multi
                setVal: function (val) {
                    var unique;
                    if (this.select) {
                        this.select.val(val);
                    } else {
                        unique = [];
                        // filter out duplicates
                        $(val).each(function () {
                            if (indexOf(this, unique) < 0) 
                                unique.push(this);
                        });
                        this.opts.element.val(unique.length === 0 ? "" : unique.join(this.opts.separator));
                    }
                },

                // multi
                buildChangeDetails: function (old, current) {
                    var current = current.slice(0),
                    old = old.slice(0);

                    // remove intersection from each array
                    for (var i = 0; i < current.length; i++) {
                        for (var j = 0; j < old.length; j++) {
                            if (equal(this.opts.id(current[i]), this.opts.id(old[j]))) {
                                current.splice(i, 1);
                                if (i > 0) {
                                    i--;
                                }
                                old.splice(j, 1);
                                j--;
                            }
                        }
                    }

                    return {
                        added: current,
                        removed: old
                    };
                },


                // multi
                val: function (val, triggerChange) {
                    var oldData, self = this;

                    if (arguments.length === 0) {
                        return this.getVal();
                    }

                    oldData = this.data();
                    if (!oldData.length) 
                        oldData = [];

                    // val is an id. !val is true for [undefined,null,'',0] - 0 is legal
                    if (!val && val !== 0) {
                        this.opts.element.val("");
                        this.updateSelection([]);
                        this.clearSearch();
                        if (triggerChange) {
                            this.triggerChange({
                                added: this.data(),
                                removed: oldData
                            });
                        }
                        return;
                    }

                    // val is a list of ids
                    this.setVal(val);

                    if (this.select) {
                        this.opts.initSelection(this.select, this.bind(this.updateSelection));
                        if (triggerChange) {
                            this.triggerChange(this.buildChangeDetails(oldData, this.data()));
                        }
                    } else {
                        if (this.opts.initSelection === undefined) {
                            throw new Error("val() cannot be called if initSelection() is not defined");
                        }

                        this.opts.initSelection(this.opts.element, function(data) {
                            var ids = $.map(data, self.id);
                            self.setVal(ids);
                            self.updateSelection(data);
                            self.clearSearch();
                            if (triggerChange) {
                                self.triggerChange(self.buildChangeDetails(oldData, self.data()));
                            }
                        });
                    }
                    this.clearSearch();
                },

                // multi
                onSortStart: function() {
                    if (this.select) {
                        throw new Error("Sorting of elements is not supported when attached to <select>. Attach to <input type='hidden'/> instead.");
                    }

                    // collapse search field into 0 width so its container can be collapsed as well
                    this.search.width(0);
                    // hide the container
                    this.searchContainer.hide();
                },

                // multi
                onSortEnd: function() {

                    var val = [], self = this;

                    // show search and move it to the end of the list
                    this.searchContainer.show();
                    // make sure the search container is the last item in the list
                    this.searchContainer.appendTo(this.searchContainer.parent());
                    // since we collapsed the width in dragStarted, we resize it here
                    this.resizeSearch();

                    // update selection
                    this.selection.find(".select2-search-choice").each(function() {
                        val.push(self.opts.id($(this).data("select2-data")));
                    });
                    this.setVal(val);
                    this.triggerChange();
                },

                // multi
                data: function(values, triggerChange) {
                    var self = this, ids, old;
                    if (arguments.length === 0) {
                        return this.selection
                        .find(".select2-search-choice")
                        .map(function() {
                            return $(this).data("select2-data");
                        })
                        .get();
                    } else {
                        old = this.data();
                        if (!values) {
                            values = [];
                        }
                        ids = $.map(values, function(e) {
                            return self.opts.id(e);
                        });
                        this.setVal(ids);
                        this.updateSelection(values);
                        this.clearSearch();
                        if (triggerChange) {
                            this.triggerChange(this.buildChangeDetails(old, this.data()));
                        }
                    }
                }
            });

            $.fn.select2 = function () {

                var args = Array.prototype.slice.call(arguments, 0),
                opts,
                select2,
                method, value, multiple,
                allowedMethods = ["val", "destroy", "opened", "open", "close", "focus", "isFocused", "container", "dropdown", "onSortStart", "onSortEnd", "enable", "disable", "readonly", "positionDropdown", "data", "search"],
                valueMethods = ["opened", "isFocused", "container", "dropdown"],
                propertyMethods = ["val", "data"],
                methodsMap = {
                    search: "externalSearch" 
                };

                this.each(function () {
                    if (args.length === 0 || typeof(args[0]) === "object") {
                        opts = args.length === 0 ? {} : $.extend({}, args[0]);
                        opts.element = $(this);

                        if (opts.element.get(0).tagName.toLowerCase() === "select") {
                            multiple = opts.element.prop("multiple");
                        } else {
                            multiple = opts.multiple || false;
                            if ("tags" in opts) {
                                opts.multiple = multiple = true;
                            }
                        }

                        select2 = multiple ? new MultiSelect2() : new SingleSelect2();
                        select2.init(opts);
                    } else if (typeof(args[0]) === "string") {

                        if (indexOf(args[0], allowedMethods) < 0) {
                            throw "Unknown method: " + args[0];
                        }

                        value = undefined;
                        select2 = $(this).data("select2");
                        if (select2 === undefined) 
                            return;

                        method = args[0];

                        if (method === "container") {
                            value = select2.container;
                        } else if (method === "dropdown") {
                            value = select2.dropdown;
                        } else {
                            if (methodsMap[method]) 
                                method = methodsMap[method];

                            value = select2[method].apply(select2, args.slice(1));
                        }
                        if (indexOf(args[0], valueMethods) >= 0
                        || (indexOf(args[0], propertyMethods) && args.length == 1)) {
                            return false; // abort the iteration, ready to return first matched value
                        }
                    } else {
                        throw "Invalid arguments to select2 plugin: " + args;
                    }
                });
                return (value === undefined) ? this : value;
            };

            // plugin defaults, accessible to users
            $.fn.select2.defaults = {
                width: "copy",
                loadMorePadding: 0,
                closeOnSelect: true,
                openOnEnter: true,
                containerCss: {},
                dropdownCss: {},
                containerCssClass: "",
                dropdownCssClass: "",
                formatResult: function(result, container, query, escapeMarkup) {
                    var markup = [];
                    markMatch(result.text, query.term, markup, escapeMarkup);
                    return markup.join("");
                },
                formatSelection: function (data, container, escapeMarkup) {
                    return data ? escapeMarkup(data.text) : undefined;
                },
                sortResults: function (results, container, query) {
                    return results;
                },
                formatResultCssClass: function(data) {
                    return undefined;
                },
                formatSelectionCssClass: function(data, container) {
                    return undefined;
                },
                formatNoMatches: function () {
                    return "No matches found";
                },
                formatInputTooShort: function (input, min) {
                    var n = min - input.length;
                    return "Please enter " + n + " more character" + (n == 1 ? "" : "s");
                },
                formatInputTooLong: function (input, max) {
                    var n = input.length - max;
                    return "Please delete " + n + " character" + (n == 1 ? "" : "s");
                },
                formatSelectionTooBig: function (limit) {
                    return "You can only select " + limit + " item" + (limit == 1 ? "" : "s");
                },
                formatLoadMore: function (pageNumber) {
                    return "Loading more results...";
                },
                formatSearching: function () {
                    return "Searching...";
                },
                minimumResultsForSearch: 0,
                minimumInputLength: 0,
                maximumInputLength: null,
                maximumSelectionSize: 0,
                id: function (e) {
                    return e.id;
                },
                matcher: function(term, text) {
                    return stripDiacritics('' + text).toUpperCase().indexOf(stripDiacritics('' + term).toUpperCase()) >= 0;
                },
                separator: ",",
                tokenSeparators: [],
                tokenizer: defaultTokenizer,
                escapeMarkup: defaultEscapeMarkup,
                blurOnChange: false,
                selectOnBlur: false,
                adaptContainerCssClass: function(c) {
                    return c;
                },
                adaptDropdownCssClass: function(c) {
                    return null;
                },
                nextSearchTerm: function(selectedObject, currentSearchTerm) {
                    return undefined;
                }
            };

            $.fn.select2.ajaxDefaults = {
                transport: $.ajax,
                params: {
                    type: "GET",
                    cache: false,
                    dataType: "json"
                }
            };

            // exports
            window.Select2 = {
                query: {
                    ajax: ajax,
                    local: local,
                    tags: tags
                },
                util: {
                    debounce: debounce,
                    markMatch: markMatch,
                    escapeMarkup: defaultEscapeMarkup,
                    stripDiacritics: stripDiacritics
                },
                "class": {
                    "abstract": AbstractSelect2,
                    "single": SingleSelect2,
                    "multi": MultiSelect2
                }
            };

        }(jQuery));

    }, {}
    ],
    266: [function(require, module, exports) {
        /*! jQuery.ajaxRetry v0.1.3 | (c) 2013 Daniel Herman | opensource.org/licenses/MIT | https://github.com/dcherman/jQuery.ajaxRetry */
        (function( $ ) {
            "use strict";

            var retryKey = "__RETRY__" + new Date().getTime();

            function isPromiseResolved( promise ) {
                if ( promise.state ) {
                    return promise.state() !== "pending";
                } else {
                    return promise.isResolved() || promise.isRejected();
                }
            }

            $.ajaxPrefilter(function( options, originalOptions, jqXHR ) {
                // Don't handle a call that's already "fixed" or that doesn't specify a shouldRetry option
                if ( options[retryKey] || typeof options.shouldRetry === "undefined" ) {
                    return;
                }

                // Mark this as having been processed so the prefilter doesn't touch subsequent retried requests
                originalOptions[ retryKey ] = true;

                var
                // A deferred that will be resolved to satisfy the success, error, done, fail, and always handlers and deferreds
                dfr = $.Deferred(),
                // A deferred that'll be resolved to satisy the complete handler and deferred
                completeDeferred = $.Deferred(),
                // Any status code specific callbacks that should be invoked
                statusCode = {},
                // The number of times our request has been retried thus far
                retryCount = 0,
                // The options that'll be passed to our ajax handler if a retry is needed
                newOptions,
                // When the request finally completes, this will be the statusCode that the XHR returned
                finalStatusCode,
                // Returns either a boolean or a promise that'll be resolved with a boolean to determine
                // whether or not we should retry a given request.
                shouldRetry = function( jqXHR, retryCount, method ) {
                    var result,
                    test = options.shouldRetry,
                    type = typeof test;

                    switch ( type ) {
                    case "number":
                        result = retryCount < test;
                        break;
                    case "boolean":
                        result = test;
                        break;
                    case "function":
                        result = test( jqXHR, retryCount, method );
                        break;
                    }

                    if ( typeof result === "object" && typeof result.then === "function" ) {
                        // If the value returned from a function is a promise, then ensure that
                        // if it's rejecteded, the promise returned from the function is resolved with false
                        // in order to avoid any situations where the request just hangs if someone rejects a promise.
                        // We can't simply use .then or .pipe here since those did not exist in 1.5
                        return $.Deferred(function( dfr ) {
                            result.then( dfr.resolve, function() {
                                dfr.resolve( false );
                            });
                        }).promise();
                    }

                    return $.when( result );
                };

                newOptions = $.extend({}, originalOptions, {
                    success: $.noop,
                    error: $.noop,
                    complete: $.noop,
                    statusCode: {}
                });

                (function tryRequest( options, lastJqXHR, finalizer ) {
                    // If lastJqXHR === undefined at this point, then it's the first ever request.
                    // Ensure that we always proceed without calling the shouldRetry function in that case
                    ( !lastJqXHR ? $.when(true) : shouldRetry(lastJqXHR, retryCount++, options.type || "GET") ).done(function( willRetry ) {
                        if ( willRetry === true ) {
                            (!lastJqXHR ? jqXHR : $.ajax(options) ).then(
                            function( data, textStatus, jqXHR ) {
                                finalStatusCode = jqXHR.status;
                                dfr.resolveWith( this, arguments );
                                dfr.done( statusCode[finalStatusCode] );
                                completeDeferred.resolveWith( this, [ jqXHR, textStatus ]);
                            },
                            function( jqXHR, textStatus ) {
                                var failureArgs = arguments,
                                failureContext = this;

                                tryRequest( options, jqXHR, function() {
                                    finalStatusCode = jqXHR.status;
                                    dfr.rejectWith( failureContext, failureArgs );
                                    dfr.fail( statusCode[finalStatusCode] );
                                    completeDeferred.resolveWith( failureContext, [ jqXHR, textStatus ]);
                                });
                            });
                        } else {
                            finalizer();
                        }


                    });
                }( newOptions ));

                // Install legacy deferred style functions.  These are deprecated,
                // and presumably will be removed as a group at some point.
                // To maintain API compatibility, first check if we should even install these.
                if ( jqXHR.complete ) {
                    jqXHR.complete = completeDeferred.done;
                    jqXHR.success = dfr.done;
                    jqXHR.error = dfr.fail;
                }

                // Override the promise methods on the jqXHR.  Don't use the .promise(obj) syntax
                // here since that wasn't introduced until 1.6.
                $.extend( jqXHR, dfr.promise() );

                jqXHR.statusCode = function( map ) {
                    var code;

                    if ( map ) {
                        if ( isPromiseResolved(dfr) ) {
                            // Execute the appropriate callbacks.  Don't use .always() since it's not 1.5 compatible.
                            dfr.then( map[finalStatusCode], map[finalStatusCode] );
                        } else {
                            for ( code in map ) {
                                // Lazy-add the new callback in a way that preserves old ones
                                statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
                            }
                        }
                    }

                    return this;
                };
            });
        }( jQuery ));

    }, {}
    ],
    267: [function(require, module, exports) {
        //     Backbone.js 1.1.0

        //     (c) 2010-2011 Jeremy Ashkenas, DocumentCloud Inc.
        //     (c) 2011-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
        //     Backbone may be freely distributed under the MIT license.
        //     For all details and documentation:
        //     http://backbonejs.org

        (function() {

            // Initial Setup
            // -------------

            // Save a reference to the global object (`window` in the browser, `exports`
            // on the server).
            var root = this;

            // Save the previous value of the `Backbone` variable, so that it can be
            // restored later on, if `noConflict` is used.
            var previousBackbone = root.Backbone;

            // Create local references to array methods we'll want to use later.
            var array = [];
            var push = array.push;
            var slice = array.slice;
            var splice = array.splice;

            // The top-level namespace. All public Backbone classes and modules will
            // be attached to this. Exported for both the browser and the server.
            var Backbone;
            if (typeof exports !== 'undefined') {
                Backbone = exports;
            } else {
                Backbone = root.Backbone = {};
            }

            // Current version of the library. Keep in sync with `package.json`.
            Backbone.VERSION = '1.1.0';

            // Require Underscore, if we're on the server, and it's not already present.
            var _ = root._;
            if (!_ && (typeof require !== 'undefined')) 
                _ = require('underscore');

            // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
            // the `$` variable.
            Backbone.$ = root.jQuery || root.Zepto || root.ender || root.$;

            // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
            // to its previous owner. Returns a reference to this Backbone object.
            Backbone.noConflict = function() {
                root.Backbone = previousBackbone;
                return this;
            };

            // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
            // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
            // set a `X-Http-Method-Override` header.
            Backbone.emulateHTTP = false;

            // Turn on `emulateJSON` to support legacy servers that can't deal with direct
            // `application/json` requests ... will encode the body as
            // `application/x-www-form-urlencoded` instead and will send the model in a
            // form param named `model`.
            Backbone.emulateJSON = false;

            // Backbone.Events
            // ---------------

            // A module that can be mixed in to *any object* in order to provide it with
            // custom events. You may bind with `on` or remove with `off` callback
            // functions to an event; `trigger`-ing an event fires all callbacks in
            // succession.
            //
            //     var object = {};
            //     _.extend(object, Backbone.Events);
            //     object.on('expand', function(){ alert('expanded'); });
            //     object.trigger('expand');
            //
            var Events = Backbone.Events = {

                // Bind an event to a `callback` function. Passing `"all"` will bind
                // the callback to all events fired.
                on: function(name, callback, context) {
                    if (!eventsApi(this, 'on', name, [callback, context]) || !callback) 
                        return this;
                    this._events || (this._events = {});
                    var events = this._events[name] || (this._events[name] = []);
                    events.push({
                        callback: callback,
                        context: context,
                        ctx: context || this
                    });
                    return this;
                },

                // Bind an event to only be triggered a single time. After the first time
                // the callback is invoked, it will be removed.
                once: function(name, callback, context) {
                    if (!eventsApi(this, 'once', name, [callback, context]) || !callback) 
                        return this;
                    var self = this;
                    var once = _.once(function() {
                        self.off(name, once);
                        callback.apply(this, arguments);
                    });
                    once._callback = callback;
                    return this.on(name, once, context);
                },

                // Remove one or many callbacks. If `context` is null, removes all
                // callbacks with that function. If `callback` is null, removes all
                // callbacks for the event. If `name` is null, removes all bound
                // callbacks for all events.
                off: function(name, callback, context) {
                    var retain, ev, events, names, i, l, j, k;
                    if (!this._events || !eventsApi(this, 'off', name, [callback, context])) 
                        return this;
                    if (!name && !callback && !context) {
                        this._events = {};
                        return this;
                    }
                    names = name ? [name] : _.keys(this._events);
                    for (i = 0, l = names.length; i < l; i++) {
                        name = names[i];
                        if (events = this._events[name]) {
                            this._events[name] = retain = [];
                            if (callback || context) {
                                for (j = 0, k = events.length; j < k; j++) {
                                    ev = events[j];
                                    if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                                    (context && context !== ev.context)) {
                                        retain.push(ev);
                                    }
                                }
                            }
                            if (!retain.length) 
                                delete this._events[name];
                        }
                    }

                    return this;
                },

                // Trigger one or many events, firing all bound callbacks. Callbacks are
                // passed the same arguments as `trigger` is, apart from the event name
                // (unless you're listening on `"all"`, which will cause your callback to
                // receive the true name of the event as the first argument).
                trigger: function(name) {
                    if (!this._events) 
                        return this;
                    var args = slice.call(arguments, 1);
                    if (!eventsApi(this, 'trigger', name, args)) 
                        return this;
                    var events = this._events[name];
                    var allEvents = this._events.all;
                    if (events) 
                        triggerEvents(events, args);
                    if (allEvents) 
                        triggerEvents(allEvents, arguments);
                    return this;
                },

                // Tell this object to stop listening to either specific events ... or
                // to every object it's currently listening to.
                stopListening: function(obj, name, callback) {
                    var listeningTo = this._listeningTo;
                    if (!listeningTo) 
                        return this;
                    var remove = !name && !callback;
                    if (!callback && typeof name === 'object') 
                        callback = this;
                    if (obj) (listeningTo = {})
                        [obj._listenId] = obj;
                    for (var id in listeningTo) {
                        obj = listeningTo[id];
                        obj.off(name, callback, this);
                        if (remove || _.isEmpty(obj._events)) 
                            delete this._listeningTo[id];
                    }
                    return this;
                }

            };

            // Regular expression used to split event strings.
            var eventSplitter = /\s+/;

            // Implement fancy features of the Events API such as multiple event
            // names `"change blur"` and jQuery-style event maps `{change: action}`
            // in terms of the existing API.
            var eventsApi = function(obj, action, name, rest) {
                if (!name) 
                    return true;

                // Handle event maps.
                if (typeof name === 'object') {
                    for (var key in name) {
                        obj[action].apply(obj, [key, name[key]].concat(rest));
                    }
                    return false;
                }

                // Handle space separated event names.
                if (eventSplitter.test(name)) {
                    var names = name.split(eventSplitter);
                    for (var i = 0, l = names.length; i < l; i++) {
                        obj[action].apply(obj, [names[i]].concat(rest));
                    }
                    return false;
                }

                return true;
            };

            // A difficult-to-believe, but optimized internal dispatch function for
            // triggering events. Tries to keep the usual cases speedy (most internal
            // Backbone events have 3 arguments).
            var triggerEvents = function(events, args) {
                var ev, i = - 1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
                switch (args.length) {
                case 0:
                    while (++i < l) (ev = events[i]).callback.call(ev.ctx);
                    return;
                case 1:
                    while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1);
                    return;
                case 2:
                    while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2);
                    return;
                case 3:
                    while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);
                    return;
                default:
                    while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
                }
            };

            var listenMethods = {
                listenTo: 'on',
                listenToOnce: 'once'
            };

            // Inversion-of-control versions of `on` and `once`. Tell *this* object to
            // listen to an event in another object ... keeping track of what it's
            // listening to.
            _.each(listenMethods, function(implementation, method) {
                Events[method] = function(obj, name, callback) {
                    var listeningTo = this._listeningTo || (this._listeningTo = {});
                    var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
                    listeningTo[id] = obj;
                    if (!callback && typeof name === 'object') 
                        callback = this;
                    obj[implementation](name, callback, this);
                    return this;
                };
            });

            // Aliases for backwards compatibility.
            Events.bind = Events.on;
            Events.unbind = Events.off;

            // Allow the `Backbone` object to serve as a global event bus, for folks who
            // want global "pubsub" in a convenient place.
            _.extend(Backbone, Events);

            // Backbone.Model
            // --------------

            // Backbone **Models** are the basic data object in the framework --
            // frequently representing a row in a table in a database on your server.
            // A discrete chunk of data and a bunch of useful, related methods for
            // performing computations and transformations on that data.

            // Create a new model with the specified attributes. A client id (`cid`)
            // is automatically generated and assigned for you.
            var Model = Backbone.Model = function(attributes, options) {
                var attrs = attributes || {};
                options || (options = {});
                this.cid = _.uniqueId('c');
                this.attributes = {};
                if (options.collection) 
                    this.collection = options.collection;
                if (options.parse) 
                    attrs = this.parse(attrs, options) || {};
                attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
                this.set(attrs, options);
                this.changed = {};
                this.initialize.apply(this, arguments);
            };

            // Attach all inheritable methods to the Model prototype.
            _.extend(Model.prototype, Events, {

                // A hash of attributes whose current and previous value differ.
                changed: null,

                // The value returned during the last failed validation.
                validationError: null,

                // The default name for the JSON `id` attribute is `"id"`. MongoDB and
                // CouchDB users may want to set this to `"_id"`.
                idAttribute: 'id',

                // Initialize is an empty function by default. Override it with your own
                // initialization logic.
                initialize: function() {},

                // Return a copy of the model's `attributes` object.
                toJSON: function(options) {
                    return _.clone(this.attributes);
                },

                // Proxy `Backbone.sync` by default -- but override this if you need
                // custom syncing semantics for *this* particular model.
                sync: function() {
                    return Backbone.sync.apply(this, arguments);
                },

                // Get the value of an attribute.
                get: function(attr) {
                    return this.attributes[attr];
                },

                // Get the HTML-escaped value of an attribute.
                escape: function(attr) {
                    return _.escape(this.get(attr));
                },

                // Returns `true` if the attribute contains a value that is not null
                // or undefined.
                has: function(attr) {
                    return this.get(attr) != null;
                },

                // Set a hash of model attributes on the object, firing `"change"`. This is
                // the core primitive operation of a model, updating the data and notifying
                // anyone who needs to know about the change in state. The heart of the beast.
                set: function(key, val, options) {
                    var attr, attrs, unset, changes, silent, changing, prev, current;
                    if (key == null) 
                        return this;

                    // Handle both `"key", value` and `{key: value}` -style arguments.
                    if (typeof key === 'object') {
                        attrs = key;
                        options = val;
                    } else {
                        (attrs = {})[key] = val;
                    }

                    options || (options = {});

                    // Run validation.
                    if (!this._validate(attrs, options)) 
                        return false;

                    // Extract attributes and options.
                    unset = options.unset;
                    silent = options.silent;
                    changes = [];
                    changing = this._changing;
                    this._changing = true;

                    if (!changing) {
                        this._previousAttributes = _.clone(this.attributes);
                        this.changed = {};
                    }
                    current = this.attributes, prev = this._previousAttributes;

                    // Check for changes of `id`.
                    if (this.idAttribute in attrs) 
                        this.id = attrs[this.idAttribute];

                    // For each `set` attribute, update or delete the current value.
                    for (attr in attrs) {
                        val = attrs[attr];
                        if (!_.isEqual(current[attr], val)) 
                            changes.push(attr);
                        if (!_.isEqual(prev[attr], val)) {
                            this.changed[attr] = val;
                        } else {
                            delete this.changed[attr];
                        }
                        unset ? delete current[attr] : current[attr] = val;
                    }

                    // Trigger all relevant attribute changes.
                    if (!silent) {
                        if (changes.length) 
                            this._pending = true;
                        for (var i = 0, l = changes.length; i < l; i++) {
                            this.trigger('change:' + changes[i], this, current[changes[i]], options);
                        }
                    }

                    // You might be wondering why there's a `while` loop here. Changes can
                    // be recursively nested within `"change"` events.
                    if (changing) 
                        return this;
                    if (!silent) {
                        while (this._pending) {
                            this._pending = false;
                            this.trigger('change', this, options);
                        }
                    }
                    this._pending = false;
                    this._changing = false;
                    return this;
                },

                // Remove an attribute from the model, firing `"change"`. `unset` is a noop
                // if the attribute doesn't exist.
                unset: function(attr, options) {
                    return this.set(attr, void 0, _.extend({}, options, {
                        unset : true
                    }));
                },

                // Clear all attributes on the model, firing `"change"`.
                clear: function(options) {
                    var attrs = {};
                    for (var key in this.attributes) 
                        attrs[key] = void 0;
                    return this.set(attrs, _.extend({}, options, {
                        unset: true
                    }));
                },

                // Determine if the model has changed since the last `"change"` event.
                // If you specify an attribute name, determine if that attribute has changed.
                hasChanged: function(attr) {
                    if (attr == null) 
                        return !_.isEmpty(this.changed);
                    return _.has(this.changed, attr);
                },

                // Return an object containing all the attributes that have changed, or
                // false if there are no changed attributes. Useful for determining what
                // parts of a view need to be updated and/or what attributes need to be
                // persisted to the server. Unset attributes will be set to undefined.
                // You can also pass an attributes object to diff against the model,
                // determining if there *would be* a change.
                changedAttributes: function(diff) {
                    if (!diff) 
                        return this.hasChanged() ? _.clone(this.changed) : false;
                    var val, changed = false;
                    var old = this._changing ? this._previousAttributes : this.attributes;
                    for (var attr in diff) {
                        if (_.isEqual(old[attr], (val = diff[attr]))) 
                            continue;
                        (changed || (changed = {}))[attr] = val;
                    }
                    return changed;
                },

                // Get the previous value of an attribute, recorded at the time the last
                // `"change"` event was fired.
                previous: function(attr) {
                    if (attr == null || !this._previousAttributes) 
                        return null;
                    return this._previousAttributes[attr];
                },

                // Get all of the attributes of the model at the time of the previous
                // `"change"` event.
                previousAttributes: function() {
                    return _.clone(this._previousAttributes);
                },

                // Fetch the model from the server. If the server's representation of the
                // model differs from its current attributes, they will be overridden,
                // triggering a `"change"` event.
                fetch: function(options) {
                    options = options ? _.clone(options) : {};
                    if (options.parse === void 0) 
                        options.parse = true;
                    var model = this;
                    var success = options.success;
                    options.success = function(resp) {
                        if (!model.set(model.parse(resp, options), options)) 
                            return false;
                        if (success) 
                            success(model, resp, options);
                        model.trigger('sync', model, resp, options);
                    };
                    wrapError(this, options);
                    return this.sync('read', this, options);
                },

                // Set a hash of model attributes, and sync the model to the server.
                // If the server returns an attributes hash that differs, the model's
                // state will be `set` again.
                save: function(key, val, options) {
                    var attrs, method, xhr, attributes = this.attributes;

                    // Handle both `"key", value` and `{key: value}` -style arguments.
                    if (key == null || typeof key === 'object') {
                        attrs = key;
                        options = val;
                    } else {
                        (attrs = {})[key] = val;
                    }

                    options = _.extend({
                        validate: true
                    }, options);

                    // If we're not waiting and attributes exist, save acts as
                    // `set(attr).save(null, opts)` with validation. Otherwise, check if
                    // the model will be valid when the attributes, if any, are set.
                    if (attrs && !options.wait) {
                        if (!this.set(attrs, options)) 
                            return false;
                    } else {
                        if (!this._validate(attrs, options)) 
                            return false;
                    }

                    // Set temporary attributes if `{wait: true}`.
                    if (attrs && options.wait) {
                        this.attributes = _.extend({}, attributes, attrs);
                    }

                    // After a successful server-side save, the client is (optionally)
                    // updated with the server-side state.
                    if (options.parse === void 0) 
                        options.parse = true;
                    var model = this;
                    var success = options.success;
                    options.success = function(resp) {
                        // Ensure attributes are restored during synchronous saves.
                        model.attributes = attributes;
                        var serverAttrs = model.parse(resp, options);
                        if (options.wait) 
                            serverAttrs = _.extend(attrs || {}, serverAttrs);
                        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
                            return false;
                        }
                        if (success) 
                            success(model, resp, options);
                        model.trigger('sync', model, resp, options);
                    };
                    wrapError(this, options);

                    method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
                    if (method === 'patch') 
                        options.attrs = attrs;
                    xhr = this.sync(method, this, options);

                    // Restore attributes.
                    if (attrs && options.wait) 
                        this.attributes = attributes;

                    return xhr;
                },

                // Destroy this model on the server if it was already persisted.
                // Optimistically removes the model from its collection, if it has one.
                // If `wait: true` is passed, waits for the server to respond before removal.
                destroy: function(options) {
                    options = options ? _.clone(options) : {};
                    var model = this;
                    var success = options.success;

                    var destroy = function() {
                        model.trigger('destroy', model, model.collection, options);
                    };

                    options.success = function(resp) {
                        if (options.wait || model.isNew()) 
                            destroy();
                        if (success) 
                            success(model, resp, options);
                        if (!model.isNew()) 
                            model.trigger('sync', model, resp, options);
                    };

                    if (this.isNew()) {
                        options.success();
                        return false;
                    }
                    wrapError(this, options);

                    var xhr = this.sync('delete', this, options);
                    if (!options.wait) 
                        destroy();
                    return xhr;
                },

                // Default URL for the model's representation on the server -- if you're
                // using Backbone's restful methods, override this to change the endpoint
                // that will be called.
                url: function() {
                    var base = _.result(this, 'urlRoot') || _.result(this.collection, 'url') || urlError();
                    if (this.isNew()) 
                        return base;
                    return base + (base.charAt(base.length - 1) === '/' ? '' : '/') + encodeURIComponent(this.id);
                },

                // **parse** converts a response into the hash of attributes to be `set` on
                // the model. The default implementation is just to pass the response along.
                parse: function(resp, options) {
                    return resp;
                },

                // Create a new model with identical attributes to this one.
                clone: function() {
                    return new this.constructor(this.attributes);
                },

                // A model is new if it has never been saved to the server, and lacks an id.
                isNew: function() {
                    return this.id == null;
                },

                // Check if the model is currently in a valid state.
                isValid: function(options) {
                    return this._validate({}, _.extend(options || {}, {
                        validate: true 
                    }));
                },

                // Run validation against the next complete set of model attributes,
                // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
                _validate: function(attrs, options) {
                    if (!options.validate || !this.validate) 
                        return true;
                    attrs = _.extend({}, this.attributes, attrs);
                    var error = this.validationError = this.validate(attrs, options) || null;
                    if (!error) 
                        return true;
                    this.trigger('invalid', this, error, _.extend(options, {
                        validationError: error
                    }));
                    return false;
                }

            });

            // Underscore methods that we want to implement on the Model.
            var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];

            // Mix in each Underscore method as a proxy to `Model#attributes`.
            _.each(modelMethods, function(method) {
                Model.prototype[method] = function() {
                    var args = slice.call(arguments);
                    args.unshift(this.attributes);
                    return _[method].apply(_, args);
                };
            });

            // Backbone.Collection
            // -------------------

            // If models tend to represent a single row of data, a Backbone Collection is
            // more analagous to a table full of data ... or a small slice or page of that
            // table, or a collection of rows that belong together for a particular reason
            // -- all of the messages in this particular folder, all of the documents
            // belonging to this particular author, and so on. Collections maintain
            // indexes of their models, both in order, and for lookup by `id`.

            // Create a new **Collection**, perhaps to contain a specific type of `model`.
            // If a `comparator` is specified, the Collection will maintain
            // its models in sort order, as they're added and removed.
            var Collection = Backbone.Collection = function(models, options) {
                options || (options = {});
                if (options.model) 
                    this.model = options.model;
                if (options.comparator !== void 0) 
                    this.comparator = options.comparator;
                this._reset();
                this.initialize.apply(this, arguments);
                if (models) 
                    this.reset(models, _.extend({
                        silent: true
                    }, options));
            };

            // Default options for `Collection#set`.
            var setOptions = {
                add: true,
                remove: true,
                merge: true
            };
            var addOptions = {
                add: true,
                remove: false
            };

            // Define the Collection's inheritable methods.
            _.extend(Collection.prototype, Events, {

                // The default model for a collection is just a **Backbone.Model**.
                // This should be overridden in most cases.
                model: Model,

                // Initialize is an empty function by default. Override it with your own
                // initialization logic.
                initialize: function() {},

                // The JSON representation of a Collection is an array of the
                // models' attributes.
                toJSON: function(options) {
                    return this.map(function(model) {
                        return model.toJSON(options);
                    });
                },

                // Proxy `Backbone.sync` by default.
                sync: function() {
                    return Backbone.sync.apply(this, arguments);
                },

                // Add a model, or list of models to the set.
                add: function(models, options) {
                    return this.set(models, _.extend({
                        merge: false
                    }, options, addOptions));
                },

                // Remove a model, or a list of models from the set.
                remove: function(models, options) {
                    var singular = !_.isArray(models);
                    models = singular ? [models] : _.clone(models);
                    options || (options = {});
                    var i, l, index, model;
                    for (i = 0, l = models.length; i < l; i++) {
                        model = models[i] = this.get(models[i]);
                        if (!model) 
                            continue;
                        delete this._byId[model.id];
                        delete this._byId[model.cid];
                        index = this.indexOf(model);
                        this.models.splice(index, 1);
                        this.length--;
                        if (!options.silent) {
                            options.index = index;
                            model.trigger('remove', model, this, options);
                        }
                        this._removeReference(model);
                    }
                    return singular ? models[0] : models;
                },

                // Update a collection by `set`-ing a new list of models, adding new ones,
                // removing models that are no longer present, and merging models that
                // already exist in the collection, as necessary. Similar to **Model#set**,
                // the core operation for updating the data contained by the collection.
                set: function(models, options) {
                    options = _.defaults({}, options, setOptions);
                    if (options.parse) 
                        models = this.parse(models, options);
                    var singular = !_.isArray(models);
                    models = singular ? (models ? [models] : []) : _.clone(models);
                    var i, l, id, model, attrs, existing, sort;
                    var at = options.at;
                    var targetModel = this.model;
                    var sortable = this.comparator && (at == null) && options.sort !== false;
                    var sortAttr = _.isString(this.comparator) ? this.comparator : null;
                    var toAdd = [], toRemove = [], modelMap = {};
                    var add = options.add, merge = options.merge, remove = options.remove;
                    var order = !sortable && add && remove ? [] : false;

                    // Turn bare objects into model references, and prevent invalid models
                    // from being added.
                    for (i = 0, l = models.length; i < l; i++) {
                        attrs = models[i];
                        if (attrs instanceof Model) {
                            id = model = attrs;
                        } else {
                            id = attrs[targetModel.prototype.idAttribute];
                        }

                        // If a duplicate is found, prevent it from being added and
                        // optionally merge it into the existing model.
                        if (existing = this.get(id)) {
                            if (remove) 
                                modelMap[existing.cid] = true;
                            if (merge) {
                                attrs = attrs === model ? model.attributes : attrs;
                                if (options.parse) 
                                    attrs = existing.parse(attrs, options);
                                existing.set(attrs, options);
                                if (sortable && !sort && existing.hasChanged(sortAttr)) 
                                    sort = true;
                            }
                            models[i] = existing;

                            // If this is a new, valid model, push it to the `toAdd` list.
                        } else if (add) {
                            model = models[i] = this._prepareModel(attrs, options);
                            if (!model) 
                                continue;
                            toAdd.push(model);

                            // Listen to added models' events, and index models for lookup by
                            // `id` and by `cid`.
                            model.on('all', this._onModelEvent, this);
                            this._byId[model.cid] = model;
                            if (model.id != null) 
                                this._byId[model.id] = model;
                        }
                        if (order) 
                            order.push(existing || model);
                    }

                    // Remove nonexistent models if appropriate.
                    if (remove) {
                        for (i = 0, l = this.length; i < l; ++i) {
                            if (!modelMap[(model = this.models[i]).cid]) 
                                toRemove.push(model);
                        }
                        if (toRemove.length) 
                            this.remove(toRemove, options);
                    }

                    // See if sorting is needed, update `length` and splice in new models.
                    if (toAdd.length || (order && order.length)) {
                        if (sortable) 
                            sort = true;
                        this.length += toAdd.length;
                        if (at != null) {
                            for (i = 0, l = toAdd.length; i < l; i++) {
                                this.models.splice(at + i, 0, toAdd[i]);
                            }
                        } else {
                            if (order) 
                                this.models.length = 0;
                            var orderedModels = order || toAdd;
                            for (i = 0, l = orderedModels.length; i < l; i++) {
                                this.models.push(orderedModels[i]);
                            }
                        }
                    }

                    // Silently sort the collection if appropriate.
                    if (sort) 
                        this.sort({
                            silent: true
                        });

                    // Unless silenced, it's time to fire all appropriate add/sort events.
                    if (!options.silent) {
                        for (i = 0, l = toAdd.length; i < l; i++) {
                            (model = toAdd[i]).trigger('add', model, this, options);
                        }
                        if (sort || (order && order.length)) 
                            this.trigger('sort', this, options);
                    }

                    // Return the added (or merged) model (or models).
                    return singular ? models[0] : models;
                },

                // When you have more items than you want to add or remove individually,
                // you can reset the entire set with a new list of models, without firing
                // any granular `add` or `remove` events. Fires `reset` when finished.
                // Useful for bulk operations and optimizations.
                reset: function(models, options) {
                    options || (options = {});
                    for (var i = 0, l = this.models.length; i < l; i++) {
                        this._removeReference(this.models[i]);
                    }
                    options.previousModels = this.models;
                    this._reset();
                    models = this.add(models, _.extend({
                        silent: true
                    }, options));
                    if (!options.silent) 
                        this.trigger('reset', this, options);
                    return models;
                },

                // Add a model to the end of the collection.
                push: function(model, options) {
                    return this.add(model, _.extend({
                        at: this.length
                    }, options));
                },

                // Remove a model from the end of the collection.
                pop: function(options) {
                    var model = this.at(this.length - 1);
                    this.remove(model, options);
                    return model;
                },

                // Add a model to the beginning of the collection.
                unshift: function(model, options) {
                    return this.add(model, _.extend({
                        at: 0
                    }, options));
                },

                // Remove a model from the beginning of the collection.
                shift: function(options) {
                    var model = this.at(0);
                    this.remove(model, options);
                    return model;
                },

                // Slice out a sub-array of models from the collection.
                slice: function() {
                    return slice.apply(this.models, arguments);
                },

                // Get a model from the set by id.
                get: function(obj) {
                    if (obj == null) 
                        return void 0;
                    return this._byId[obj.id] || this._byId[obj.cid] || this._byId[obj];
                },

                // Get the model at the given index.
                at: function(index) {
                    return this.models[index];
                },

                // Return models with matching attributes. Useful for simple cases of
                // `filter`.
                where: function(attrs, first) {
                    if (_.isEmpty(attrs)) 
                        return first ? void 0 : [];
                    return this[first ? 'find' : 'filter'](function(model) {
                        for (var key in attrs) {
                            if (attrs[key] !== model.get(key)) 
                                return false;
                        }
                        return true;
                    });
                },

                // Return the first model with matching attributes. Useful for simple cases
                // of `find`.
                findWhere: function(attrs) {
                    return this.where(attrs, true);
                },

                // Force the collection to re-sort itself. You don't need to call this under
                // normal circumstances, as the set will maintain sort order as each item
                // is added.
                sort: function(options) {
                    if (!this.comparator) 
                        throw new Error('Cannot sort a set without a comparator');
                    options || (options = {});

                    // Run sort based on type of `comparator`.
                    if (_.isString(this.comparator) || this.comparator.length === 1) {
                        this.models = this.sortBy(this.comparator, this);
                    } else {
                        this.models.sort(_.bind(this.comparator, this));
                    }

                    if (!options.silent) 
                        this.trigger('sort', this, options);
                    return this;
                },

                // Pluck an attribute from each model in the collection.
                pluck: function(attr) {
                    return _.invoke(this.models, 'get', attr);
                },

                // Fetch the default set of models for this collection, resetting the
                // collection when they arrive. If `reset: true` is passed, the response
                // data will be passed through the `reset` method instead of `set`.
                fetch: function(options) {
                    options = options ? _.clone(options) : {};
                    if (options.parse === void 0) 
                        options.parse = true;
                    var success = options.success;
                    var collection = this;
                    options.success = function(resp) {
                        var method = options.reset ? 'reset' : 'set';
                        collection[method](resp, options);
                        if (success) 
                            success(collection, resp, options);
                        collection.trigger('sync', collection, resp, options);
                    };
                    wrapError(this, options);
                    return this.sync('read', this, options);
                },

                // Create a new instance of a model in this collection. Add the model to the
                // collection immediately, unless `wait: true` is passed, in which case we
                // wait for the server to agree.
                create: function(model, options) {
                    options = options ? _.clone(options) : {};
                    if (!(model = this._prepareModel(model, options))) 
                        return false;
                    if (!options.wait) 
                        this.add(model, options);
                    var collection = this;
                    var success = options.success;
                    options.success = function(model, resp, options) {
                        if (options.wait) 
                            collection.add(model, options);
                        if (success) 
                            success(model, resp, options);
                    };
                    model.save(null, options);
                    return model;
                },

                // **parse** converts a response into a list of models to be added to the
                // collection. The default implementation is just to pass it through.
                parse: function(resp, options) {
                    return resp;
                },

                // Create a new collection with an identical list of models as this one.
                clone: function() {
                    return new this.constructor(this.models);
                },

                // Private method to reset all internal state. Called when the collection
                // is first initialized or reset.
                _reset: function() {
                    this.length = 0;
                    this.models = [];
                    this._byId = {};
                },

                // Prepare a hash of attributes (or other model) to be added to this
                // collection.
                _prepareModel: function(attrs, options) {
                    if (attrs instanceof Model) {
                        if (!attrs.collection) 
                            attrs.collection = this;
                        return attrs;
                    }
                    options = options ? _.clone(options) : {};
                    options.collection = this;
                    var model = new this.model(attrs, options);
                    if (!model.validationError) 
                        return model;
                    this.trigger('invalid', this, model.validationError, options);
                    return false;
                },

                // Internal method to sever a model's ties to a collection.
                _removeReference: function(model) {
                    if (this === model.collection) 
                        delete model.collection;
                    model.off('all', this._onModelEvent, this);
                },

                // Internal method called every time a model in the set fires an event.
                // Sets need to update their indexes when models change ids. All other
                // events simply proxy through. "add" and "remove" events that originate
                // in other collections are ignored.
                _onModelEvent: function(event, model, collection, options) {
                    if ((event === 'add' || event === 'remove') && collection !== this) 
                        return;
                    if (event === 'destroy') 
                        this.remove(model, options);
                    if (model && event === 'change:' + model.idAttribute) {
                        delete this._byId[model.previous(model.idAttribute)];
                        if (model.id != null) 
                            this._byId[model.id] = model;
                    }
                    this.trigger.apply(this, arguments);
                }

            });

            // Underscore methods that we want to implement on the Collection.
            // 90% of the core usefulness of Backbone Collections is actually implemented
            // right here:
            var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
            'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
            'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
            'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
            'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',
            'lastIndexOf', 'isEmpty', 'chain'];

            // Mix in each Underscore method as a proxy to `Collection#models`.
            _.each(methods, function(method) {
                Collection.prototype[method] = function() {
                    var args = slice.call(arguments);
                    args.unshift(this.models);
                    return _[method].apply(_, args);
                };
            });

            // Underscore methods that take a property name as an argument.
            var attributeMethods = ['groupBy', 'countBy', 'sortBy'];

            // Use attributes instead of properties.
            _.each(attributeMethods, function(method) {
                Collection.prototype[method] = function(value, context) {
                    var iterator = _.isFunction(value) ? value : function(model) {
                        return model.get(value);
                    };
                    return _[method](this.models, iterator, context);
                };
            });

            // Backbone.View
            // -------------

            // Backbone Views are almost more convention than they are actual code. A View
            // is simply a JavaScript object that represents a logical chunk of UI in the
            // DOM. This might be a single item, an entire list, a sidebar or panel, or
            // even the surrounding frame which wraps your whole app. Defining a chunk of
            // UI as a **View** allows you to define your DOM events declaratively, without
            // having to worry about render order ... and makes it easy for the view to
            // react to specific changes in the state of your models.

            // Creating a Backbone.View creates its initial element outside of the DOM,
            // if an existing element is not provided...
            var View = Backbone.View = function(options) {
                this.cid = _.uniqueId('view');
                options || (options = {});
                _.extend(this, _.pick(options, viewOptions));
                this._ensureElement();
                this.initialize.apply(this, arguments);
                this.delegateEvents();
            };

            // Cached regex to split keys for `delegate`.
            var delegateEventSplitter = /^(\S+)\s*(.*)$/;

            // List of view options to be merged as properties.
            var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

            // Set up all inheritable **Backbone.View** properties and methods.
            _.extend(View.prototype, Events, {

                // The default `tagName` of a View's element is `"div"`.
                tagName: 'div',

                // jQuery delegate for element lookup, scoped to DOM elements within the
                // current view. This should be preferred to global lookups where possible.
                $: function(selector) {
                    return this.$el.find(selector);
                },

                // Initialize is an empty function by default. Override it with your own
                // initialization logic.
                initialize: function() {},

                // **render** is the core function that your view should override, in order
                // to populate its element (`this.el`), with the appropriate HTML. The
                // convention is for **render** to always return `this`.
                render: function() {
                    return this;
                },

                // Remove this view by taking the element out of the DOM, and removing any
                // applicable Backbone.Events listeners.
                remove: function() {
                    this.$el.remove();
                    this.stopListening();
                    return this;
                },

                // Change the view's element (`this.el` property), including event
                // re-delegation.
                setElement: function(element, delegate) {
                    if (this.$el) 
                        this.undelegateEvents();
                    this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
                    this.el = this.$el[0];
                    if (delegate !== false) 
                        this.delegateEvents();
                    return this;
                },

                // Set callbacks, where `this.events` is a hash of
                //
                // *{"event selector": "callback"}*
                //
                //     {
                //       'mousedown .title':  'edit',
                //       'click .button':     'save',
                //       'click .open':       function(e) { ... }
                //     }
                //
                // pairs. Callbacks will be bound to the view, with `this` set properly.
                // Uses event delegation for efficiency.
                // Omitting the selector binds the event to `this.el`.
                // This only works for delegate-able events: not `focus`, `blur`, and
                // not `change`, `submit`, and `reset` in Internet Explorer.
                delegateEvents: function(events) {
                    if (!(events || (events = _.result(this, 'events')))) 
                        return this;
                    this.undelegateEvents();
                    for (var key in events) {
                        var method = events[key];
                        if (!_.isFunction(method)) 
                            method = this[events[key]];
                        if (!method) 
                            continue;

                        var match = key.match(delegateEventSplitter);
                        var eventName = match[1], selector = match[2];
                        method = _.bind(method, this);
                        eventName += '.delegateEvents' + this.cid;
                        if (selector === '') {
                            this.$el.on(eventName, method);
                        } else {
                            this.$el.on(eventName, selector, method);
                        }
                    }
                    return this;
                },

                // Clears all callbacks previously bound to the view with `delegateEvents`.
                // You usually don't need to use this, but may wish to if you have multiple
                // Backbone views attached to the same DOM element.
                undelegateEvents: function() {
                    this.$el.off('.delegateEvents' + this.cid);
                    return this;
                },

                // Ensure that the View has a DOM element to render into.
                // If `this.el` is a string, pass it through `$()`, take the first
                // matching element, and re-assign it to `el`. Otherwise, create
                // an element from the `id`, `className` and `tagName` properties.
                _ensureElement: function() {
                    if (!this.el) {
                        var attrs = _.extend({}, _.result(this, 'attributes'));
                        if (this.id) 
                            attrs.id = _.result(this, 'id');
                        if (this.className) 
                            attrs['class'] = _.result(this, 'className');
                        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
                        this.setElement($el, false);
                    } else {
                        this.setElement(_.result(this, 'el'), false);
                    }
                }

            });

            // Backbone.sync
            // -------------

            // Override this function to change the manner in which Backbone persists
            // models to the server. You will be passed the type of request, and the
            // model in question. By default, makes a RESTful Ajax request
            // to the model's `url()`. Some possible customizations could be:
            //
            // * Use `setTimeout` to batch rapid-fire updates into a single request.
            // * Send up the models as XML instead of JSON.
            // * Persist models via WebSockets instead of Ajax.
            //
            // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
            // as `POST`, with a `_method` parameter containing the true HTTP method,
            // as well as all requests with the body as `application/x-www-form-urlencoded`
            // instead of `application/json` with the model in a param named `model`.
            // Useful when interfacing with server-side languages like **PHP** that make
            // it difficult to read the body of `PUT` requests.
            Backbone.sync = function(method, model, options) {
                var type = methodMap[method];

                // Default options, unless specified.
                _.defaults(options || (options = {}), {
                    emulateHTTP: Backbone.emulateHTTP,
                    emulateJSON: Backbone.emulateJSON
                });

                // Default JSON-request options.
                var params = {
                    type: type,
                    dataType: 'json'
                };

                // Ensure that we have a URL.
                if (!options.url) {
                    params.url = _.result(model, 'url') || urlError();
                }

                // Ensure that we have the appropriate request data.
                if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
                    params.contentType = 'application/json';
                    params.data = JSON.stringify(options.attrs || model.toJSON(options));
                }

                // For older servers, emulate JSON by encoding the request into an HTML-form.
                if (options.emulateJSON) {
                    params.contentType = 'application/x-www-form-urlencoded';
                    params.data = params.data ? {
                        model: params.data
                    } : {};
                }

                // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
                // And an `X-HTTP-Method-Override` header.
                if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
                    params.type = 'POST';
                    if (options.emulateJSON) 
                        params.data._method = type;
                    var beforeSend = options.beforeSend;
                    options.beforeSend = function(xhr) {
                        xhr.setRequestHeader('X-HTTP-Method-Override', type);
                        if (beforeSend) 
                            return beforeSend.apply(this, arguments);
                    };
                }

                // Don't process data on a non-GET request.
                if (params.type !== 'GET' && !options.emulateJSON) {
                    params.processData = false;
                }

                // If we're sending a `PATCH` request, and we're in an old Internet Explorer
                // that still has ActiveX enabled by default, override jQuery to use that
                // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
                if (params.type === 'PATCH' && noXhrPatch) {
                    params.xhr = function() {
                        return new ActiveXObject("Microsoft.XMLHTTP");
                    };
                }

                // Make the request, allowing the user to override any Ajax options.
                var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
                model.trigger('request', model, xhr, options);
                return xhr;
            };

            var noXhrPatch = typeof window !== 'undefined' && !!window.ActiveXObject && !(window.XMLHttpRequest && (new XMLHttpRequest).dispatchEvent);

            // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
            var methodMap = {
                'create': 'POST',
                'update': 'PUT',
                'patch': 'PATCH',
                'delete': 'DELETE',
                'read': 'GET'
            };

            // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
            // Override this if you'd like to use a different library.
            Backbone.ajax = function() {
                return Backbone.$.ajax.apply(Backbone.$, arguments);
            };

            // Backbone.Router
            // ---------------

            // Routers map faux-URLs to actions, and fire events when routes are
            // matched. Creating a new one sets its `routes` hash, if not set statically.
            var Router = Backbone.Router = function(options) {
                options || (options = {});
                if (options.routes) 
                    this.routes = options.routes;
                this._bindRoutes();
                this.initialize.apply(this, arguments);
            };

            // Cached regular expressions for matching named param parts and splatted
            // parts of route strings.
            var optionalParam = /\((.*?)\)/g;
            var namedParam = /(\(\?)?:\w+/g;
            var splatParam = /\*\w+/g;
            var escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g;

            // Set up all inheritable **Backbone.Router** properties and methods.
            _.extend(Router.prototype, Events, {

                // Initialize is an empty function by default. Override it with your own
                // initialization logic.
                initialize: function() {},

                // Manually bind a single named route to a callback. For example:
                //
                //     this.route('search/:query/p:num', 'search', function(query, num) {
                //       ...
                //     });
                //
                route: function(route, name, callback) {
                    if (!_.isRegExp(route)) 
                        route = this._routeToRegExp(route);
                    if (_.isFunction(name)) {
                        callback = name;
                        name = '';
                    }
                    if (!callback) 
                        callback = this[name];
                    var router = this;
                    Backbone.history.route(route, function(fragment) {
                        var args = router._extractParameters(route, fragment);
                        callback && callback.apply(router, args);
                        router.trigger.apply(router, ['route:' + name].concat(args));
                        router.trigger('route', name, args);
                        Backbone.history.trigger('route', router, name, args);
                    });
                    return this;
                },

                // Simple proxy to `Backbone.history` to save a fragment into the history.
                navigate: function(fragment, options) {
                    Backbone.history.navigate(fragment, options);
                    return this;
                },

                // Bind all defined routes to `Backbone.history`. We have to reverse the
                // order of the routes here to support behavior where the most general
                // routes can be defined at the bottom of the route map.
                _bindRoutes: function() {
                    if (!this.routes) 
                        return;
                    this.routes = _.result(this, 'routes');
                    var route, routes = _.keys(this.routes);
                    while ((route = routes.pop()) != null) {
                        this.route(route, this.routes[route]);
                    }
                },

                // Convert a route string into a regular expression, suitable for matching
                // against the current location hash.
                _routeToRegExp: function(route) {
                    route = route.replace(escapeRegExp, '\\$&')
                    .replace(optionalParam, '(?:$1)?')
                    .replace(namedParam, function(match, optional) {
                        return optional ? match : '([^\/]+)';
                    })
                    .replace(splatParam, '(.*?)');
                    return new RegExp('^' + route + '$');
                },

                // Given a route, and a URL fragment that it matches, return the array of
                // extracted decoded parameters. Empty or unmatched parameters will be
                // treated as `null` to normalize cross-browser behavior.
                _extractParameters: function(route, fragment) {
                    var params = route.exec(fragment).slice(1);
                    return _.map(params, function(param) {
                        return param ? decodeURIComponent(param) : null;
                    });
                }

            });

            // Backbone.History
            // ----------------

            // Handles cross-browser history management, based on either
            // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
            // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
            // and URL fragments. If the browser supports neither (old IE, natch),
            // falls back to polling.
            var History = Backbone.History = function() {
                this.handlers = [];
                _.bindAll(this, 'checkUrl');

                // Ensure that `History` can be used outside of the browser.
                if (typeof window !== 'undefined') {
                    this.location = window.location;
                    this.history = window.history;
                }
            };

            // Cached regex for stripping a leading hash/slash and trailing space.
            var routeStripper = /^[#\/]|\s+$/g;

            // Cached regex for stripping leading and trailing slashes.
            var rootStripper = /^\/+|\/+$/g;

            // Cached regex for detecting MSIE.
            var isExplorer = /msie [\w.]+/;

            // Cached regex for removing a trailing slash.
            var trailingSlash = /\/$/;

            // Cached regex for stripping urls of hash and query.
            var pathStripper = /[?#].*$/;

            // Has the history handling already been started?
            History.started = false;

            // Set up all inheritable **Backbone.History** properties and methods.
            _.extend(History.prototype, Events, {

                // The default interval to poll for hash changes, if necessary, is
                // twenty times a second.
                interval: 50,

                // Gets the true hash value. Cannot use location.hash directly due to bug
                // in Firefox where location.hash will always be decoded.
                getHash: function(window) {
                    var match = (window || this).location.href.match(/#(.*)$/);
                    return match ? match[1] : '';
                },

                // Get the cross-browser normalized URL fragment, either from the URL,
                // the hash, or the override.
                getFragment: function(fragment, forcePushState) {
                    if (fragment == null) {
                        if (this._hasPushState || !this._wantsHashChange || forcePushState) {
                            fragment = this.location.pathname;
                            var root = this.root.replace(trailingSlash, '');
                            if (!fragment.indexOf(root)) 
                                fragment = fragment.slice(root.length);
                        } else {
                            fragment = this.getHash();
                        }
                    }
                    return fragment.replace(routeStripper, '');
                },

                // Start the hash change handling, returning `true` if the current URL matches
                // an existing route, and `false` otherwise.
                start: function(options) {
                    if (History.started) 
                        throw new Error("Backbone.history has already been started");
                    History.started = true;

                    // Figure out the initial configuration. Do we need an iframe?
                    // Is pushState desired ... is it available?
                    this.options = _.extend({
                        root: '/'
                    }, this.options, options);
                    this.root = this.options.root;
                    this._wantsHashChange = this.options.hashChange !== false;
                    this._wantsPushState = !!this.options.pushState;
                    this._hasPushState = !!(this.options.pushState && this.history && this.history.pushState);
                    var fragment = this.getFragment();
                    var docMode = document.documentMode;
                    var oldIE = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));

                    // Normalize root to always include a leading and trailing slash.
                    this.root = ('/' + this.root + '/').replace(rootStripper, '/');

                    if (oldIE && this._wantsHashChange) {
                        this.iframe = Backbone.$('<iframe src="javascript:0" tabindex="-1" />').hide().appendTo('body')[0].contentWindow;
                        this.navigate(fragment);
                    }

                    // Depending on whether we're using pushState or hashes, and whether
                    // 'onhashchange' is supported, determine how we check the URL state.
                    if (this._hasPushState) {
                        Backbone.$(window).on('popstate', this.checkUrl);
                    } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
                        Backbone.$(window).on('hashchange', this.checkUrl);
                    } else if (this._wantsHashChange) {
                        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
                    }

                    // Determine if we need to change the base url, for a pushState link
                    // opened by a non-pushState browser.
                    this.fragment = fragment;
                    var loc = this.location;
                    var atRoot = loc.pathname.replace(/[^\/]$/, '$&/') === this.root;

                    // Transition from hashChange to pushState or vice versa if both are
                    // requested.
                    if (this._wantsHashChange && this._wantsPushState) {

                        // If we've started off with a route from a `pushState`-enabled
                        // browser, but we're currently in a browser that doesn't support it...
                        if (!this._hasPushState && !atRoot) {
                            this.fragment = this.getFragment(null, true);
                            this.location.replace(this.root + this.location.search + '#' + this.fragment);
                            // Return immediately as browser will do redirect to new url
                            return true;

                            // Or if we've started out with a hash-based route, but we're currently
                            // in a browser where it could be `pushState`-based instead...
                        } else if (this._hasPushState && atRoot && loc.hash) {
                            this.fragment = this.getHash().replace(routeStripper, '');
                            this.history.replaceState({}, document.title, this.root + this.fragment + loc.search);
                        }

                    }

                    if (!this.options.silent) 
                        return this.loadUrl();
                },

                // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
                // but possibly useful for unit testing Routers.
                stop: function() {
                    Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
                    clearInterval(this._checkUrlInterval);
                    History.started = false;
                },

                // Add a route to be tested when the fragment changes. Routes added later
                // may override previous routes.
                route: function(route, callback) {
                    this.handlers.unshift({
                        route: route,
                        callback: callback
                    });
                },

                // Checks the current URL to see if it has changed, and if it has,
                // calls `loadUrl`, normalizing across the hidden iframe.
                checkUrl: function(e) {
                    var current = this.getFragment();
                    if (current === this.fragment && this.iframe) {
                        current = this.getFragment(this.getHash(this.iframe));
                    }
                    if (current === this.fragment) 
                        return false;
                    if (this.iframe) 
                        this.navigate(current);
                    this.loadUrl();
                },

                // Attempt to load the current URL fragment. If a route succeeds with a
                // match, returns `true`. If no defined routes matches the fragment,
                // returns `false`.
                loadUrl: function(fragment) {
                    fragment = this.fragment = this.getFragment(fragment);
                    return _.any(this.handlers, function(handler) {
                        if (handler.route.test(fragment)) {
                            handler.callback(fragment);
                            return true;
                        }
                    });
                },

                // Save a fragment into the hash history, or replace the URL state if the
                // 'replace' option is passed. You are responsible for properly URL-encoding
                // the fragment in advance.
                //
                // The options object can contain `trigger: true` if you wish to have the
                // route callback be fired (not usually desirable), or `replace: true`, if
                // you wish to modify the current URL without adding an entry to the history.
                navigate: function(fragment, options) {
                    if (!History.started) 
                        return false;
                    if (!options || options === true) 
                        options = {
                            trigger: !!options
                        };

                    var url = this.root + (fragment = this.getFragment(fragment || ''));

                    // Strip the fragment of the query and hash for matching.
                    fragment = fragment.replace(pathStripper, '');

                    if (this.fragment === fragment) 
                        return;
                    this.fragment = fragment;

                    // Don't include a trailing slash on the root.
                    if (fragment === '' && url !== '/') 
                        url = url.slice(0, - 1);

                    // If pushState is available, we use it to set the fragment as a real URL.
                    if (this._hasPushState) {
                        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

                        // If hash changes haven't been explicitly disabled, update the hash
                        // fragment to store history.
                    } else if (this._wantsHashChange) {
                        this._updateHash(this.location, fragment, options.replace);
                        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
                            // Opening and closing the iframe tricks IE7 and earlier to push a
                            // history entry on hash-tag change.  When replace is true, we don't
                            // want this.
                            if (!options.replace) 
                                this.iframe.document.open().close();
                            this._updateHash(this.iframe.location, fragment, options.replace);
                        }

                        // If you've told us that you explicitly don't want fallback hashchange-
                        // based history, then `navigate` becomes a page refresh.
                    } else {
                        return this.location.assign(url);
                    }
                    if (options.trigger) 
                        return this.loadUrl(fragment);
                },

                // Update the hash location, either replacing the current entry, or adding
                // a new one to the browser history.
                _updateHash: function(location, fragment, replace) {
                    if (replace) {
                        var href = location.href.replace(/(javascript:|#).*$/, '');
                        location.replace(href + '#' + fragment);
                    } else {
                        // Some browsers require that `hash` contains a leading #.
                        location.hash = '#' + fragment;
                    }
                }

            });

            // Create the default Backbone.history.
            Backbone.history = new History;

            // Helpers
            // -------

            // Helper function to correctly set up the prototype chain, for subclasses.
            // Similar to `goog.inherits`, but uses a hash of prototype properties and
            // class properties to be extended.
            var extend = function(protoProps, staticProps) {
                var parent = this;
                var child;

                // The constructor function for the new subclass is either defined by you
                // (the "constructor" property in your `extend` definition), or defaulted
                // by us to simply call the parent's constructor.
                if (protoProps && _.has(protoProps, 'constructor')) {
                    child = protoProps.constructor;
                } else {
                    child = function() {
                        return parent.apply(this, arguments);
                    };
                }

                // Add static properties to the constructor function, if supplied.
                _.extend(child, parent, staticProps);

                // Set the prototype chain to inherit from `parent`, without calling
                // `parent`'s constructor function.
                var Surrogate = function() {
                    this.constructor = child;
                };
                Surrogate.prototype = parent.prototype;
                child.prototype = new Surrogate;

                // Add prototype properties (instance properties) to the subclass,
                // if supplied.
                if (protoProps) 
                    _.extend(child.prototype, protoProps);

                // Set a convenience property in case the parent's prototype is needed
                // later.
                child.__super__ = parent.prototype;

                return child;
            };

            // Set up inheritance for the model, collection, router, view and history.
            Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

            // Throw an error when a URL is needed, and none is supplied.
            var urlError = function() {
                throw new Error('A "url" property or function must be specified');
            };

            // Wrap an optional error callback with a fallback error event.
            var wrapError = function(model, options) {
                var error = options.error;
                options.error = function(resp) {
                    if (error) 
                        error(model, resp, options);
                    model.trigger('error', model, resp, options);
                };
            };

        }).call(this);

    }, {
        "underscore": 276
    }
    ],
    268: [function(require, module, exports) {
        /*!
         * Chaplin 1.0.0
         *
         * Chaplin may be freely distributed under the MIT license.
         * For all details and documentation:
         * http://chaplinjs.org
         */

        (function() {

            var loader = (function() {
                var modules = {};
                var cache = {};

                var dummy = function() {
                    return function() {};
                };
                var initModule = function(name, definition) {
                    var module = {
                        id: name,
                        exports: {}
                    };
                    definition(module.exports, dummy(), module);
                    var exports = cache[name] = module.exports;
                    return exports;
                };

                var loader = function(path) {
                    if (cache.hasOwnProperty(path)) 
                        return cache[path];
                    if (modules.hasOwnProperty(path)) 
                        return initModule(path, modules[path]);
                    throw new Error('Cannot find module "' + path + '"');
                };

                loader.register = function(bundle, fn) {
                    modules[bundle] = fn;
                };
                return loader;
            })();

            loader.register('chaplin/application', function(e, r, module) {
                'use strict';

                var Application, Backbone, Composer, Dispatcher, EventBroker, Layout, Router, mediator, _;

                _ = loader('underscore');

                Backbone = loader('backbone');

                Dispatcher = loader('chaplin/dispatcher');

                Layout = loader('chaplin/views/layout');

                Composer = loader('chaplin/composer');

                Router = loader('chaplin/lib/router');

                EventBroker = loader('chaplin/lib/event_broker');

                mediator = loader('chaplin/mediator');

                module.exports = Application = (function() {

                    Application.extend = Backbone.Model.extend;

                    _.extend(Application.prototype, EventBroker);

                    Application.prototype.title = '';

                    Application.prototype.dispatcher = null;

                    Application.prototype.layout = null;

                    Application.prototype.router = null;

                    Application.prototype.composer = null;

                    Application.prototype.started = false;

                    function Application(options) {
                        if (options == null) {
                            options = {};
                        }
                        this.initialize(options);
                    }

                    Application.prototype.initialize = function(options) {
                        if (options == null) {
                            options = {};
                        }
                        if (this.started) {
                            throw new Error('Application#initialize: App was already started');
                        }
                        this.initRouter(options.routes, options);
                        this.initDispatcher(options);
                        this.initLayout(options);
                        this.initComposer(options);
                        this.initMediator();
                        return this.start();
                    };

                    Application.prototype.initDispatcher = function(options) {
                        return this.dispatcher = new Dispatcher(options);
                    };

                    Application.prototype.initLayout = function(options) {
                        var _ref;
                        if (options == null) {
                            options = {};
                        }
                        if ((_ref = options.title) == null) {
                            options.title = this.title;
                        }
                        return this.layout = new Layout(options);
                    };

                    Application.prototype.initComposer = function(options) {
                        if (options == null) {
                            options = {};
                        }
                        return this.composer = new Composer(options);
                    };

                    Application.prototype.initMediator = function() {
                        return mediator.seal();
                    };

                    Application.prototype.initRouter = function(routes, options) {
                        this.router = new Router(options);
                        return typeof routes === "function" ? routes(this.router.match) : void 0;
                    };

                    Application.prototype.start = function() {
                        this.router.startHistory();
                        this.started = true;
                        return typeof Object.freeze === "function" ? Object.freeze(this) : void 0;
                    };

                    Application.prototype.disposed = false;

                    Application.prototype.dispose = function() {
                        var prop, properties, _i, _len;
                        if (this.disposed) {
                            return;
                        }
                        properties = ['dispatcher', 'layout', 'router', 'composer'];
                        for (_i = 0, _len = properties.length; _i < _len; _i++) {
                            prop = properties[_i];
                            if (this[prop] != null) {
                                this[prop].dispose();
                            }
                        }
                        this.disposed = true;
                        return typeof Object.freeze === "function" ? Object.freeze(this) : void 0;
                    };

                    return Application;

                })();

            });;
            loader.register('chaplin/mediator', function(e, r, module) {
                'use strict';

                var Backbone, handlers, mediator, support, utils, _,
                __slice = [].slice;

                Backbone = loader('backbone');

                _ = loader('underscore');

                support = loader('chaplin/lib/support');

                utils = loader('chaplin/lib/utils');

                mediator = {};

                mediator.subscribe = Backbone.Events.on;

                mediator.unsubscribe = Backbone.Events.off;

                mediator.publish = Backbone.Events.trigger;

                mediator._callbacks = null;

                handlers = mediator._handlers = {};

                mediator.setHandler = function(name, method, instance) {
                    return handlers[name] = {
                        instance: instance,
                        method: method
                    };
                };

                mediator.execute = function() {
                    var args, handler, name, nameOrObj, silent;
                    nameOrObj = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
                    silent = false;
                    if (typeof nameOrObj === 'object') {
                        silent = nameOrObj.silent;
                        name = nameOrObj.name;
                    } else {
                        name = nameOrObj;
                    }
                    handler = handlers[name];
                    if (handler) {
                        return handler.method.apply(handler.instance, args);
                    } else if (!silent) {
                        throw new Error("mediator.execute: " + name + " handler is not defined");
                    }
                };

                mediator.removeHandlers = function(instanceOrNames) {
                    var handler, name, _i, _len;
                    if (!instanceOrNames) {
                        mediator._handlers = {};
                    }
                    if (utils.isArray(instanceOrNames)) {
                        for (_i = 0, _len = instanceOrNames.length; _i < _len; _i++) {
                            name = instanceOrNames[_i];
                            delete handlers[name];
                        }
                    } else {
                        for (name in handlers) {
                            handler = handlers[name];
                            if (handler.instance === instanceOrNames) {
                                delete handlers[name];
                            }
                        }
                    }
                };

                utils.readonly(mediator, 'subscribe', 'unsubscribe', 'publish', 'setHandler', 'execute', 'removeHandlers');

                mediator.seal = function() {
                    if (support.propertyDescriptors && Object.seal) {
                        return Object.seal(mediator);
                    }
                };

                utils.readonly(mediator, 'seal');

                module.exports = mediator;

            });;
            loader.register('chaplin/dispatcher', function(e, r, module) {
                'use strict';

                var Backbone, Dispatcher, EventBroker, mediator, utils, _;

                _ = loader('underscore');

                Backbone = loader('backbone');

                mediator = loader('chaplin/mediator');

                utils = loader('chaplin/lib/utils');

                EventBroker = loader('chaplin/lib/event_broker');

                module.exports = Dispatcher = (function() {

                    Dispatcher.extend = Backbone.Model.extend;

                    _.extend(Dispatcher.prototype, EventBroker);

                    Dispatcher.prototype.previousRoute = null;

                    Dispatcher.prototype.currentController = null;

                    Dispatcher.prototype.currentRoute = null;

                    Dispatcher.prototype.currentParams = null;

                    Dispatcher.prototype.currentQuery = null;

                    function Dispatcher() {
                        this.initialize.apply(this, arguments);
                    }

                    Dispatcher.prototype.initialize = function(options) {
                        if (options == null) {
                            options = {};
                        }
                        this.settings = _.defaults(options, {
                            controllerPath: 'controllers/',
                            controllerSuffix: '_controller'
                        });
                        return this.subscribeEvent('router:match', this.dispatch);
                    };

                    Dispatcher.prototype.dispatch = function(route, params, options) {
                        var _ref, _ref1,
                        _this = this;
                        params = params ? _.extend({}, params) : {};
                        options = options ? _.extend({}, options) : {};
                        if (!(options.query != null)) {
                            options.query = {};
                        }
                        if (options.forceStartup !== true) {
                            options.forceStartup = false;
                        }
                        if (!options.forceStartup && ((_ref = this.currentRoute) != null ? _ref.controller : void 0) === route.controller && ((_ref1 = this.currentRoute) != null ? _ref1.action : void 0) === route.action && _.isEqual(this.currentParams, params) && _.isEqual(this.currentQuery, options.query)) {
                            return;
                        }
                        return this.loadController(route.controller, function(Controller) {
                            return _this.controllerLoaded(route, params, options, Controller);
                        });
                    };

                    Dispatcher.prototype.loadController = function(name, handler) {
                        var fileName, moduleName,
                        _this = this;
                        fileName = name + this.settings.controllerSuffix;
                        moduleName = this.settings.controllerPath + fileName;
                        if (typeof define !== "undefined" && define !== null ? define.amd : void 0) {
                            return require([moduleName], handler);
                        } else {
                            return setTimeout(function() {
                                return handler(require(moduleName));
                            }, 0);
                        }
                    };

                    Dispatcher.prototype.controllerLoaded = function(route, params, options, Controller) {
                        var controller, prev, previous;
                        if (this.nextPreviousRoute = this.currentRoute) {
                            previous = _.extend({}, this.nextPreviousRoute);
                            if (this.currentParams != null) {
                                previous.params = this.currentParams;
                            }
                            if (previous.previous) {
                                delete previous.previous;
                            }
                            prev = {
                                previous: previous
                            };
                        }
                        this.nextCurrentRoute = _.extend({}, route, prev);
                        controller = new Controller(params, this.nextCurrentRoute, options);
                        return this.executeBeforeAction(controller, this.nextCurrentRoute, params, options);
                    };

                    Dispatcher.prototype.executeAction = function(controller, route, params, options) {
                        if (this.currentController) {
                            this.publishEvent('beforeControllerDispose', this.currentController);
                            this.currentController.dispose(params, route, options);
                        }
                        this.currentController = controller;
                        this.currentParams = params;
                        this.currentQuery = options.query;
                        controller[route.action](params, route, options);
                        if (controller.redirected) {
                            return;
                        }
                        return this.publishEvent('dispatcher:dispatch', this.currentController, params, route, options);
                    };

                    Dispatcher.prototype.executeBeforeAction = function(controller, route, params, options) {
                        var before, executeAction, promise,
                        _this = this;
                        before = controller.beforeAction;
                        executeAction = function() {
                            if (controller.redirected || _this.currentRoute && route === _this.currentRoute) {
                                _this.nextPreviousRoute = _this.nextCurrentRoute = null;
                                controller.dispose();
                                return;
                            }
                            _this.previousRoute = _this.nextPreviousRoute;
                            _this.currentRoute = _this.nextCurrentRoute;
                            _this.nextPreviousRoute = _this.nextCurrentRoute = null;
                            return _this.executeAction(controller, route, params, options);
                        };
                        if (!before) {
                            executeAction();
                            return;
                        }
                        if (typeof before !== 'function') {
                            throw new TypeError('Controller#beforeAction: function expected. ' + 'Old object-like form is not supported.');
                        }
                        promise = controller.beforeAction(params, route, options);
                        if (promise && promise.then) {
                            return promise.then(executeAction);
                        } else {
                            return executeAction();
                        }
                    };

                    Dispatcher.prototype.disposed = false;

                    Dispatcher.prototype.dispose = function() {
                        if (this.disposed) {
                            return;
                        }
                        this.unsubscribeAllEvents();
                        this.disposed = true;
                        return typeof Object.freeze === "function" ? Object.freeze(this) : void 0;
                    };

                    return Dispatcher;

                })();

            });;
            loader.register('chaplin/composer', function(e, r, module) {
                'use strict';

                var Backbone, Composer, Composition, EventBroker, mediator, utils, _;

                _ = loader('underscore');

                Backbone = loader('backbone');

                mediator = loader('chaplin/mediator');

                utils = loader('chaplin/lib/utils');

                Composition = loader('chaplin/lib/composition');

                EventBroker = loader('chaplin/lib/event_broker');

                module.exports = Composer = (function() {

                    Composer.extend = Backbone.Model.extend;

                    _.extend(Composer.prototype, EventBroker);

                    Composer.prototype.compositions = null;

                    function Composer() {
                        this.initialize.apply(this, arguments);
                    }

                    Composer.prototype.initialize = function(options) {
                        if (options == null) {
                            options = {};
                        }
                        this.compositions = {};
                        mediator.setHandler('composer:compose', this.compose, this);
                        mediator.setHandler('composer:retrieve', this.retrieve, this);
                        return this.subscribeEvent('dispatcher:dispatch', this.cleanup);
                    };

                    Composer.prototype.compose = function(name, second, third) {
                        if (typeof second === 'function') {
                            if (third || second.prototype.dispose) {
                                if (second.prototype instanceof Composition) {
                                    return this._compose(name, {
                                        composition: second,
                                        options: third
                                    });
                                } else {
                                    return this._compose(name, {
                                        options: third,
                                        compose: function() {
                                            var autoRender, disabledAutoRender;
                                            this.item = new second(this.options);
                                            autoRender = this.item.autoRender;
                                            disabledAutoRender = autoRender === void 0 || !autoRender;
                                            if (disabledAutoRender && typeof this.item.render === 'function') {
                                                return this.item.render();
                                            }
                                        }
                                    });
                                }
                            }
                            return this._compose(name, {
                                compose: second
                            });
                        }
                        if (typeof third === 'function') {
                            return this._compose(name, {
                                compose: third,
                                options: second
                            });
                        }
                        return this._compose(name, second);
                    };

                    Composer.prototype._compose = function(name, options) {
                        var composition, current, isPromise, returned;
                        if (typeof options.compose !== 'function' && !(options.composition != null)) {
                            throw new Error('Composer#compose was used incorrectly');
                        }
                        if (options.composition != null) {
                            composition = new options.composition(options.options);
                        } else {
                            composition = new Composition(options.options);
                            composition.compose = options.compose;
                            if (options.check) {
                                composition.check = options.check;
                            }
                        }
                        current = this.compositions[name];
                        isPromise = false;
                        if (current && current.check(composition.options)) {
                            current.stale(false);
                        } else {
                            if (current) {
                                current.dispose();
                            }
                            returned = composition.compose(composition.options);
                            isPromise = typeof (returned != null ? returned.then : void 0) === 'function';
                            composition.stale(false);
                            this.compositions[name] = composition;
                        }
                        if (isPromise) {
                            return returned;
                        } else {
                            return this.compositions[name].item;
                        }
                    };

                    Composer.prototype.retrieve = function(name) {
                        var active;
                        active = this.compositions[name];
                        if (active && !active.stale()) {
                            return active.item;
                        } else {
                            return void 0;
                        }
                    };

                    Composer.prototype.cleanup = function() {
                        var composition, name, _ref;
                        _ref = this.compositions;
                        for (name in _ref) {
                            composition = _ref[name];
                            if (composition.stale()) {
                                composition.dispose();
                                delete this.compositions[name];
                            } else {
                                composition.stale(true);
                            }
                        }
                    };

                    Composer.prototype.dispose = function() {
                        var composition, name, _ref;
                        if (this.disposed) {
                            return;
                        }
                        this.unsubscribeAllEvents();
                        mediator.removeHandlers(this);
                        _ref = this.compositions;
                        for (name in _ref) {
                            composition = _ref[name];
                            composition.dispose();
                        }
                        delete this.compositions;
                        this.disposed = true;
                        return typeof Object.freeze === "function" ? Object.freeze(this) : void 0;
                    };

                    return Composer;

                })();

            });;
            loader.register('chaplin/controllers/controller', function(e, r, module) {
                'use strict';

                var Backbone, Controller, EventBroker, mediator, utils, _,
                __slice = [].slice,
                __hasProp = {}.hasOwnProperty;

                _ = loader('underscore');

                Backbone = loader('backbone');

                EventBroker = loader('chaplin/lib/event_broker');

                utils = loader('chaplin/lib/utils');

                mediator = loader('chaplin/mediator');

                module.exports = Controller = (function() {

                    Controller.extend = Backbone.Model.extend;

                    _.extend(Controller.prototype, Backbone.Events);

                    _.extend(Controller.prototype, EventBroker);

                    Controller.prototype.view = null;

                    Controller.prototype.redirected = false;

                    function Controller() {
                        this.initialize.apply(this, arguments);
                    }

                    Controller.prototype.initialize = function() {};

                    Controller.prototype.beforeAction = function() {};

                    Controller.prototype.adjustTitle = function(subtitle) {
                        return mediator.execute('adjustTitle', subtitle);
                    };

                    Controller.prototype.reuse = function(name) {
                        var method;
                        method = arguments.length === 1 ? 'retrieve' : 'compose';
                        return mediator.execute.apply(mediator, ["composer:" + method].concat(__slice.call(arguments)));
                    };

                    Controller.prototype.compose = function() {
                        throw new Error('Controller#compose was moved to Controller#reuse');
                    };

                    Controller.prototype.redirectTo = function(pathDesc, params, options) {
                        this.redirected = true;
                        return utils.redirectTo(pathDesc, params, options);
                    };

                    Controller.prototype.disposed = false;

                    Controller.prototype.dispose = function() {
                        var obj, prop;
                        if (this.disposed) {
                            return;
                        }
                        for (prop in this) {
                            if (!__hasProp.call(this, prop)) 
                                continue;
                            obj = this[prop];
                            if (!(obj && typeof obj.dispose === 'function')) {
                                continue;
                            }
                            obj.dispose();
                            delete this[prop];
                        }
                        this.unsubscribeAllEvents();
                        this.stopListening();
                        this.disposed = true;
                        return typeof Object.freeze === "function" ? Object.freeze(this) : void 0;
                    };

                    return Controller;

                })();

            });;
            loader.register('chaplin/models/collection', function(e, r, module) {
                'use strict';

                var Backbone, Collection, EventBroker, Model, utils, _,
                __hasProp = {}.hasOwnProperty,
                __extends = function(child, parent) {
                    for (var key in parent) {
                        if (__hasProp.call(parent, key)) 
                            child[key] = parent[key];
                    }
                    function ctor() {
                        this.constructor = child;
                    }
                    ctor.prototype = parent.prototype;
                    child.prototype = new ctor();
                    child.__super__ = parent.prototype;
                    return child;
                };

                _ = loader('underscore');

                Backbone = loader('backbone');

                EventBroker = loader('chaplin/lib/event_broker');

                Model = loader('chaplin/models/model');

                utils = loader('chaplin/lib/utils');

                module.exports = Collection = (function(_super) {

                    __extends(Collection, _super);

                    function Collection() {
                        return Collection.__super__.constructor.apply(this, arguments);
                    }

                    _.extend(Collection.prototype, EventBroker);

                    Collection.prototype.model = Model;

                    Collection.prototype.serialize = function() {
                        return this.map(utils.serialize);
                    };

                    Collection.prototype.disposed = false;

                    Collection.prototype.dispose = function() {
                        var prop, properties, _i, _len;
                        if (this.disposed) {
                            return;
                        }
                        this.trigger('dispose', this);
                        this.reset([], {
                            silent: true
                        });
                        this.unsubscribeAllEvents();
                        this.stopListening();
                        this.off();
                        properties = ['model', 'models', '_byId', '_byCid', '_callbacks'];
                        for (_i = 0, _len = properties.length; _i < _len; _i++) {
                            prop = properties[_i];
                            delete this[prop];
                        }
                        this.disposed = true;
                        return typeof Object.freeze === "function" ? Object.freeze(this) : void 0;
                    };

                    return Collection;

                })(Backbone.Collection);

            });;
            loader.register('chaplin/models/model', function(e, r, module) {
                'use strict';

                var Backbone, EventBroker, Model, serializeAttributes, serializeModelAttributes, utils, _,
                __hasProp = {}.hasOwnProperty,
                __extends = function(child, parent) {
                    for (var key in parent) {
                        if (__hasProp.call(parent, key)) 
                            child[key] = parent[key];
                    }
                    function ctor() {
                        this.constructor = child;
                    }
                    ctor.prototype = parent.prototype;
                    child.prototype = new ctor();
                    child.__super__ = parent.prototype;
                    return child;
                };

                _ = loader('underscore');

                Backbone = loader('backbone');

                utils = loader('chaplin/lib/utils');

                EventBroker = loader('chaplin/lib/event_broker');

                serializeAttributes = function(model, attributes, modelStack) {
                    var delegator, key, otherModel, serializedModels, value, _i, _len, _ref;
                    delegator = utils.beget(attributes);
                    if (modelStack == null) {
                        modelStack = {};
                    }
                    modelStack[model.cid] = true;
                    for (key in attributes) {
                        value = attributes[key];
                        if (value instanceof Backbone.Model) {
                            delegator[key] = serializeModelAttributes(value, model, modelStack);
                        } else if (value instanceof Backbone.Collection) {
                            serializedModels = [];
                            _ref = value.models;
                            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                                otherModel = _ref[_i];
                                serializedModels.push(serializeModelAttributes(otherModel, model, modelStack));
                            }
                            delegator[key] = serializedModels;
                        }
                    }
                    delete modelStack[model.cid];
                    return delegator;
                };

                serializeModelAttributes = function(model, currentModel, modelStack) {
                    var attributes;
                    if (model === currentModel || model.cid in modelStack) {
                        return null;
                    }
                    attributes = typeof model.getAttributes === 'function' ? model.getAttributes() : model.attributes;
                    return serializeAttributes(model, attributes, modelStack);
                };

                module.exports = Model = (function(_super) {

                    __extends(Model, _super);

                    function Model() {
                        return Model.__super__.constructor.apply(this, arguments);
                    }

                    _.extend(Model.prototype, EventBroker);

                    Model.prototype.getAttributes = function() {
                        return this.attributes;
                    };

                    Model.prototype.serialize = function() {
                        return serializeAttributes(this, this.getAttributes());
                    };

                    Model.prototype.disposed = false;

                    Model.prototype.dispose = function() {
                        var prop, properties, _i, _len;
                        if (this.disposed) {
                            return;
                        }
                        this.trigger('dispose', this);
                        this.unsubscribeAllEvents();
                        this.stopListening();
                        this.off();
                        properties = ['collection', 'attributes', 'changed', '_escapedAttributes', '_previousAttributes', '_silent', '_pending', '_callbacks'];
                        for (_i = 0, _len = properties.length; _i < _len; _i++) {
                            prop = properties[_i];
                            delete this[prop];
                        }
                        this.disposed = true;
                        return typeof Object.freeze === "function" ? Object.freeze(this) : void 0;
                    };

                    return Model;

                })(Backbone.Model);

            });;
            loader.register('chaplin/views/layout', function(e, r, module) {
                'use strict';

                var $, Backbone, EventBroker, Layout, View, mediator, utils, _,
                __bind = function(fn, me) {
                    return function() {
                        return fn.apply(me, arguments);
                    };
                },
                __hasProp = {}.hasOwnProperty,
                __extends = function(child, parent) {
                    for (var key in parent) {
                        if (__hasProp.call(parent, key)) 
                            child[key] = parent[key];
                    }
                    function ctor() {
                        this.constructor = child;
                    }
                    ctor.prototype = parent.prototype;
                    child.prototype = new ctor();
                    child.__super__ = parent.prototype;
                    return child;
                };

                _ = loader('underscore');

                Backbone = loader('backbone');

                mediator = loader('chaplin/mediator');

                utils = loader('chaplin/lib/utils');

                EventBroker = loader('chaplin/lib/event_broker');

                View = loader('chaplin/views/view');

                $ = Backbone.$;

                module.exports = Layout = (function(_super) {

                    __extends(Layout, _super);

                    Layout.prototype.el = 'body';

                    Layout.prototype.keepElement = true;

                    Layout.prototype.title = '';

                    Layout.prototype.globalRegions = null;

                    Layout.prototype.listen = {
                        'beforeControllerDispose mediator': 'scroll'
                    };

                    function Layout(options) {
                        if (options == null) {
                            options = {};
                        }
                        this.openLink = __bind(this.openLink, this);

                        this.globalRegions = [];
                        this.title = options.title;
                        if (options.regions) {
                            this.regions = options.regions;
                        }
                        this.settings = _.defaults(options, {
                            titleTemplate: function(data) {
                                var st;
                                st = data.subtitle ? "" + data.subtitle + " \u2013 " : '';
                                return st + data.title;
                            },
                            openExternalToBlank: false,
                            routeLinks: 'a, .go-to',
                            skipRouting: '.noscript',
                            scrollTo: [0, 0]
                        });
                        mediator.setHandler('region:show', this.showRegion, this);
                        mediator.setHandler('region:register', this.registerRegionHandler, this);
                        mediator.setHandler('region:unregister', this.unregisterRegionHandler, this);
                        mediator.setHandler('region:find', this.regionByName, this);
                        mediator.setHandler('adjustTitle', this.adjustTitle, this);
                        Layout.__super__.constructor.apply(this, arguments);
                        if (this.settings.routeLinks) {
                            this.startLinkRouting();
                        }
                    }

                    Layout.prototype.scroll = function() {
                        var position;
                        position = this.settings.scrollTo;
                        if (position) {
                            return window.scrollTo(position[0], position[1]);
                        }
                    };

                    Layout.prototype.adjustTitle = function(subtitle) {
                        var title,
                        _this = this;
                        if (subtitle == null) {
                            subtitle = '';
                        }
                        title = this.settings.titleTemplate({
                            title: this.title,
                            subtitle: subtitle
                        });
                        setTimeout(function() {
                            document.title = title;
                            return _this.publishEvent('adjustTitle', subtitle, title);
                        }, 50);
                        return title;
                    };

                    Layout.prototype.startLinkRouting = function() {
                        var route;
                        route = this.settings.routeLinks;
                        if (!route) {
                            return;
                        }
                        if ($) {
                            return this.$el.on('click', route, this.openLink);
                        } else {
                            return this.delegate('click', route, this.openLink);
                        }
                    };

                    Layout.prototype.stopLinkRouting = function() {
                        var route;
                        route = this.settings.routeLinks;
                        if ($) {
                            if (route) {
                                return this.$el.off('click', route);
                            }
                        } else {
                            return this.undelegate('click', route, this.openLink);
                        }
                    };

                    Layout.prototype.isExternalLink = function(link) {
                        var _ref, _ref1;
                        return link.target === '_blank' || link.rel === 'external' || ((_ref = link.protocol) !== 'http:' && _ref !== 'https:' && _ref !== 'file:') || ((_ref1 = link.hostname) !== location.hostname && _ref1 !== '');
                    };

                    Layout.prototype.openLink = function(event) {
                        var el, external, href, isAnchor, skipRouting, type;
                        if (utils.modifierKeyPressed(event)) {
                            return;
                        }
                        el = $ ? event.currentTarget : event.delegateTarget;
                        isAnchor = el.nodeName === 'A';
                        href = el.getAttribute('href') || el.getAttribute('data-href') || null;
                        if (!(href != null) || href === '' || href.charAt(0) === '#') {
                            return;
                        }
                        skipRouting = this.settings.skipRouting;
                        type = typeof skipRouting;
                        if (type === 'function' && !skipRouting(href, el) || type === 'string' && ($ ? $(el).is(skipRouting) : Backbone.utils.matchesSelector(el, skipRouting))) {
                            return;
                        }
                        external = isAnchor && this.isExternalLink(el);
                        if (external) {
                            if (this.settings.openExternalToBlank) {
                                event.preventDefault();
                                window.open(href);
                            }
                            return;
                        }
                        utils.redirectTo({
                            url: href
                        });
                        event.preventDefault();
                    };

                    Layout.prototype.registerRegionHandler = function(instance, name, selector) {
                        if (name != null) {
                            return this.registerGlobalRegion(instance, name, selector);
                        } else {
                            return this.registerGlobalRegions(instance);
                        }
                    };

                    Layout.prototype.registerGlobalRegion = function(instance, name, selector) {
                        this.unregisterGlobalRegion(instance, name);
                        return this.globalRegions.unshift({
                            instance: instance,
                            name: name,
                            selector: selector
                        });
                    };

                    Layout.prototype.registerGlobalRegions = function(instance) {
                        var name, selector, version, _i, _len, _ref;
                        _ref = utils.getAllPropertyVersions(instance, 'regions');
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                            version = _ref[_i];
                            for (name in version) {
                                selector = version[name];
                                this.registerGlobalRegion(instance, name, selector);
                            }
                        }
                    };

                    Layout.prototype.unregisterRegionHandler = function(instance, name) {
                        if (name != null) {
                            return this.unregisterGlobalRegion(instance, name);
                        } else {
                            return this.unregisterGlobalRegions(instance);
                        }
                    };

                    Layout.prototype.unregisterGlobalRegion = function(instance, name) {
                        var cid, region;
                        cid = instance.cid;
                        return this.globalRegions = (function() {
                            var _i, _len, _ref, _results;
                            _ref = this.globalRegions;
                            _results = [];
                            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                                region = _ref[_i];
                                if (region.instance.cid !== cid || region.name !== name) {
                                    _results.push(region);
                                }
                            }
                            return _results;
                        }).call(this);
                    };

                    Layout.prototype.unregisterGlobalRegions = function(instance) {
                        var region;
                        return this.globalRegions = (function() {
                            var _i, _len, _ref, _results;
                            _ref = this.globalRegions;
                            _results = [];
                            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                                region = _ref[_i];
                                if (region.instance.cid !== instance.cid) {
                                    _results.push(region);
                                }
                            }
                            return _results;
                        }).call(this);
                    };

                    Layout.prototype.regionByName = function(name) {
                        var reg, _i, _len, _ref;
                        _ref = this.globalRegions;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                            reg = _ref[_i];
                            if (reg.name === name && !reg.instance.stale) {
                                return reg;
                            }
                        }
                    };

                    Layout.prototype.showRegion = function(name, instance) {
                        var region;
                        region = this.regionByName(name);
                        if (!region) {
                            throw new Error("No region registered under " + name);
                        }
                        return instance.container = region.selector === '' ? $ ? region.instance.$el : region.instance.el : region.instance.noWrap ? $ ? $(region.instance.container).find(region.selector) : region.instance.container.querySelector(region.selector) : region.instance[$ ? '$' : 'find'](region.selector);
                    };

                    Layout.prototype.dispose = function() {
                        var prop, _i, _len, _ref;
                        if (this.disposed) {
                            return;
                        }
                        this.stopLinkRouting();
                        _ref = ['globalRegions', 'title', 'route'];
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                            prop = _ref[_i];
                            delete this[prop];
                        }
                        mediator.removeHandlers(this);
                        return Layout.__super__.dispose.apply(this, arguments);
                    };

                    return Layout;

                })(View);

            });;
            loader.register('chaplin/views/view', function(e, r, module) {
                'use strict';

                var $, Backbone, EventBroker, View, attach, bind, mediator, setHTML, utils, _,
                __hasProp = {}.hasOwnProperty,
                __extends = function(child, parent) {
                    for (var key in parent) {
                        if (__hasProp.call(parent, key)) 
                            child[key] = parent[key];
                    }
                    function ctor() {
                        this.constructor = child;
                    }
                    ctor.prototype = parent.prototype;
                    child.prototype = new ctor();
                    child.__super__ = parent.prototype;
                    return child;
                },
                __indexOf = [].indexOf || function(item) {
                    for (var i = 0, l = this.length; i < l; i++) {
                        if (i in this && this[i] === item) 
                            return i;
                    }
                    return - 1;
                };

                _ = loader('underscore');

                Backbone = loader('backbone');

                mediator = loader('chaplin/mediator');

                EventBroker = loader('chaplin/lib/event_broker');

                utils = loader('chaplin/lib/utils');

                $ = Backbone.$;

                bind = (function() {
                    if (Function.prototype.bind) {
                        return function(item, ctx) {
                            return item.bind(ctx);
                        };
                    } else if (_.bind) {
                        return _.bind;
                    }
                })();

                setHTML = (function() {
                    if ($) {
                        return function(elem, html) {
                            return elem.html(html);
                        };
                    } else {
                        return function(elem, html) {
                            return elem.innerHTML = html;
                        };
                    }
                })();

                attach = (function() {
                    if ($) {
                        return function(view) {
                            var actual;
                            actual = $(view.container);
                            if (typeof view.containerMethod === 'function') {
                                return view.containerMethod(actual, view.el);
                            } else {
                                return actual[view.containerMethod](view.el);
                            }
                        };
                    } else {
                        return function(view) {
                            var actual;
                            actual = typeof view.container === 'string' ? document.querySelector(view.container) : view.container;
                            if (typeof view.containerMethod === 'function') {
                                return view.containerMethod(actual, view.el);
                            } else {
                                return actual[view.containerMethod](view.el);
                            }
                        };
                    }
                })();

                module.exports = View = (function(_super) {

                    __extends(View, _super);

                    _.extend(View.prototype, EventBroker);

                    View.prototype.autoRender = false;

                    View.prototype.autoAttach = true;

                    View.prototype.container = null;

                    View.prototype.containerMethod = $ ? 'append' : 'appendChild';

                    View.prototype.regions = null;

                    View.prototype.region = null;

                    View.prototype.stale = false;

                    View.prototype.noWrap = false;

                    View.prototype.keepElement = false;

                    View.prototype.subviews = null;

                    View.prototype.subviewsByName = null;

                    View.prototype.optionNames = ['autoAttach', 'autoRender', 'container', 'containerMethod', 'region', 'regions', 'noWrap'];

                    function View(options) {
                        var optName, optValue, region, render,
                        _this = this;
                        if (options) {
                            for (optName in options) {
                                optValue = options[optName];
                                if (__indexOf.call(this.optionNames, optName) >= 0) {
                                    this[optName] = optValue;
                                }
                            }
                        }
                        render = this.render;
                        this.render = function() {
                            if (_this.disposed) {
                                return false;
                            }
                            render.apply(_this, arguments);
                            if (_this.autoAttach) {
                                _this.attach.apply(_this, arguments);
                            }
                            return _this;
                        };
                        this.subviews = [];
                        this.subviewsByName = {};
                        if (this.noWrap) {
                            if (this.region) {
                                region = mediator.execute('region:find', this.region);
                                if (region != null) {
                                    this.el = region.instance.container != null ? region.instance.region != null ? $(region.instance.container).find(region.selector) : region.instance.container : region.instance.$(region.selector);
                                }
                            }
                            if (this.container) {
                                this.el = this.container;
                            }
                        }
                        View.__super__.constructor.apply(this, arguments);
                        this.delegateListeners();
                        if (this.model) {
                            this.listenTo(this.model, 'dispose', this.dispose);
                        }
                        if (this.collection) {
                            this.listenTo(this.collection, 'dispose', function(subject) {
                                if (!subject || subject === _this.collection) {
                                    return _this.dispose();
                                }
                            });
                        }
                        if (this.regions != null) {
                            mediator.execute('region:register', this);
                        }
                        if (this.autoRender) {
                            this.render();
                        }
                    }

                    View.prototype.delegate = function(eventName, second, third) {
                        var bound, event, events, handler, list, selector;
                        if (Backbone.utils) {
                            return Backbone.utils.delegate(this, eventName, second, third);
                        }
                        if (typeof eventName !== 'string') {
                            throw new TypeError('View#delegate: first argument must be a string');
                        }
                        if (arguments.length === 2) {
                            handler = second;
                        } else if (arguments.length === 3) {
                            selector = second;
                            if (typeof selector !== 'string') {
                                throw new TypeError('View#delegate: ' + 'second argument must be a string');
                            }
                            handler = third;
                        } else {
                            throw new TypeError('View#delegate: ' + 'only two or three arguments are allowed');
                        }
                        if (typeof handler !== 'function') {
                            throw new TypeError('View#delegate: ' + 'handler argument must be function');
                        }
                        list = (function() {
                            var _i, _len, _ref, _results;
                            _ref = eventName.split(' ');
                            _results = [];
                            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                                event = _ref[_i];
                                _results.push("" + event + ".delegate" + this.cid);
                            }
                            return _results;
                        }).call(this);
                        events = list.join(' ');
                        bound = bind(handler, this);
                        this.$el.on(events, selector || null, bound);
                        return bound;
                    };

                    View.prototype._delegateEvents = function(events) {
                        var bound, eventName, handler, key, match, selector, value;
                        if (Backbone.View.prototype.delegateEvents.length === 2) {
                            return Backbone.View.prototype.delegateEvents.call(this, events, true);
                        }
                        for (key in events) {
                            value = events[key];
                            handler = typeof value === 'function' ? value : this[value];
                            if (!handler) {
                                throw new Error("Method '" + value + "' does not exist");
                            }
                            match = key.match(/^(\S+)\s*(.*)$/);
                            eventName = "" + match[1] + ".delegateEvents" + this.cid;
                            selector = match[2];
                            bound = bind(handler, this);
                            this.$el.on(eventName, selector || null, bound);
                        }
                    };

                    View.prototype.delegateEvents = function(events, keepOld) {
                        var classEvents, _i, _len, _ref;
                        if (!keepOld) {
                            this.undelegateEvents();
                        }
                        if (events) {
                            return this._delegateEvents(events);
                        }
                        _ref = utils.getAllPropertyVersions(this, 'events');
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                            classEvents = _ref[_i];
                            if (typeof classEvents === 'function') {
                                throw new TypeError('View#delegateEvents: functions are not supported');
                            }
                            this._delegateEvents(classEvents);
                        }
                    };

                    View.prototype.undelegate = function(eventName, second, third) {
                        var event, events, handler, list, selector;
                        if (Backbone.utils) {
                            return Backbone.utils.undelegate(this, eventName, second, third);
                        }
                        if (eventName) {
                            if (typeof eventName !== 'string') {
                                throw new TypeError('View#undelegate: first argument must be a string');
                            }
                            if (arguments.length === 2) {
                                if (typeof second === 'string') {
                                    selector = second;
                                } else {
                                    handler = second;
                                }
                            } else if (arguments.length === 3) {
                                selector = second;
                                if (typeof selector !== 'string') {
                                    throw new TypeError('View#undelegate: ' + 'second argument must be a string');
                                }
                                handler = third;
                            }
                            list = (function() {
                                var _i, _len, _ref, _results;
                                _ref = eventName.split(' ');
                                _results = [];
                                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                                    event = _ref[_i];
                                    _results.push("" + event + ".delegate" + this.cid);
                                }
                                return _results;
                            }).call(this);
                            events = list.join(' ');
                            return this.$el.off(events, selector || null);
                        } else {
                            return this.$el.off(".delegate" + this.cid);
                        }
                    };

                    View.prototype.delegateListeners = function() {
                        var eventName, key, method, target, version, _i, _len, _ref, _ref1;
                        if (!this.listen) {
                            return;
                        }
                        _ref = utils.getAllPropertyVersions(this, 'listen');
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                            version = _ref[_i];
                            for (key in version) {
                                method = version[key];
                                if (typeof method !== 'function') {
                                    method = this[method];
                                }
                                if (typeof method !== 'function') {
                                    throw new Error('View#delegateListeners: ' + ("" + method + " must be function"));
                                }
                                _ref1 = key.split(' '), eventName = _ref1[0], target = _ref1[1];
                                this.delegateListener(eventName, target, method);
                            }
                        }
                    };

                    View.prototype.delegateListener = function(eventName, target, callback) {
                        var prop;
                        if (target === 'model' || target === 'collection') {
                            prop = this[target];
                            if (prop) {
                                this.listenTo(prop, eventName, callback);
                            }
                        } else if (target === 'mediator') {
                            this.subscribeEvent(eventName, callback);
                        } else if (!target) {
                            this.on(eventName, callback, this);
                        }
                    };

                    View.prototype.registerRegion = function(name, selector) {
                        return mediator.execute('region:register', this, name, selector);
                    };

                    View.prototype.unregisterRegion = function(name) {
                        return mediator.execute('region:unregister', this, name);
                    };

                    View.prototype.unregisterAllRegions = function() {
                        return mediator.execute({
                            name: 'region:unregister',
                            silent: true
                        }, this);
                    };

                    View.prototype.subview = function(name, view) {
                        var byName, subviews;
                        subviews = this.subviews;
                        byName = this.subviewsByName;
                        if (name && view) {
                            this.removeSubview(name);
                            subviews.push(view);
                            byName[name] = view;
                            return view;
                        } else if (name) {
                            return byName[name];
                        }
                    };

                    View.prototype.removeSubview = function(nameOrView) {
                        var byName, index, name, otherName, otherView, subviews, view;
                        if (!nameOrView) {
                            return;
                        }
                        subviews = this.subviews;
                        byName = this.subviewsByName;
                        if (typeof nameOrView === 'string') {
                            name = nameOrView;
                            view = byName[name];
                        } else {
                            view = nameOrView;
                            for (otherName in byName) {
                                otherView = byName[otherName];
                                if (!(otherView === view)) {
                                    continue;
                                }
                                name = otherName;
                                break;
                            }
                        }
                        if (!(name && view && view.dispose)) {
                            return;
                        }
                        view.dispose();
                        index = utils.indexOf(subviews, view);
                        if (index !== - 1) {
                            subviews.splice(index, 1);
                        }
                        return delete byName[name];
                    };

                    View.prototype.getTemplateData = function() {
                        var data, source;
                        data = this.model ? utils.serialize(this.model) : this.collection ? {
                            items: utils.serialize(this.collection),
                            length: this.collection.length
                        } : {};
                        source = this.model || this.collection;
                        if (source) {
                            if (typeof source.isSynced === 'function' && !('synced' in data)) {
                                data.synced = source.isSynced();
                            }
                        }
                        return data;
                    };

                    View.prototype.getTemplateFunction = function() {
                        throw new Error('View#getTemplateFunction must be overridden');
                    };

                    View.prototype.render = function() {
                        var el, html, templateFunc;
                        if (this.disposed) {
                            return false;
                        }
                        templateFunc = this.getTemplateFunction();
                        if (typeof templateFunc === 'function') {
                            html = templateFunc(this.getTemplateData());
                            if (this.noWrap) {
                                el = document.createElement('div');
                                el.innerHTML = html;
                                if (el.children.length > 1) {
                                    throw new Error('There must be a single top-level element when ' + 'using `noWrap`.');
                                }
                                this.undelegateEvents();
                                this.setElement(el.firstChild, true);
                            } else {
                                setHTML(($ ? this.$el : this.el), html);
                            }
                        }
                        return this;
                    };

                    View.prototype.attach = function() {
                        if (this.region != null) {
                            mediator.execute('region:show', this.region, this);
                        }
                        if (this.container && !document.body.contains(this.el)) {
                            attach(this);
                            return this.trigger('addedToDOM');
                        }
                    };

                    View.prototype.disposed = false;

                    View.prototype.dispose = function() {
                        var prop, properties, subview, _i, _j, _len, _len1, _ref;
                        if (this.disposed) {
                            return;
                        }
                        this.unregisterAllRegions();
                        _ref = this.subviews;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                            subview = _ref[_i];
                            subview.dispose();
                        }
                        this.unsubscribeAllEvents();
                        this.off();
                        if (this.keepElement) {
                            this.undelegateEvents();
                            this.undelegate();
                            this.stopListening();
                        } else {
                            this.remove();
                        }
                        properties = ['el', '$el', 'options', 'model', 'collection', 'subviews', 'subviewsByName', '_callbacks'];
                        for (_j = 0, _len1 = properties.length; _j < _len1; _j++) {
                            prop = properties[_j];
                            delete this[prop];
                        }
                        this.disposed = true;
                        return typeof Object.freeze === "function" ? Object.freeze(this) : void 0;
                    };

                    return View;

                })(Backbone.View);

            });;
            loader.register('chaplin/views/collection_view', function(e, r, module) {
                'use strict';

                var $, Backbone, CollectionView, View, addClass, endAnimation, filterChildren, insertView, startAnimation, toggleElement, utils, _,
                __bind = function(fn, me) {
                    return function() {
                        return fn.apply(me, arguments);
                    };
                },
                __hasProp = {}.hasOwnProperty,
                __extends = function(child, parent) {
                    for (var key in parent) {
                        if (__hasProp.call(parent, key)) 
                            child[key] = parent[key];
                    }
                    function ctor() {
                        this.constructor = child;
                    }
                    ctor.prototype = parent.prototype;
                    child.prototype = new ctor();
                    child.__super__ = parent.prototype;
                    return child;
                };

                _ = loader('underscore');

                Backbone = loader('backbone');

                View = loader('chaplin/views/view');

                utils = loader('chaplin/lib/utils');

                $ = Backbone.$;

                filterChildren = function(nodeList, selector) {
                    var node, _i, _len, _results;
                    if (!selector) {
                        return nodeList;
                    }
                    _results = [];
                    for (_i = 0, _len = nodeList.length; _i < _len; _i++) {
                        node = nodeList[_i];
                        if (Backbone.utils.matchesSelector(node, selector)) {
                            _results.push(node);
                        }
                    }
                    return _results;
                };

                toggleElement = (function() {
                    if ($) {
                        return function(elem, visible) {
                            return elem.toggle(visible);
                        };
                    } else {
                        return function(elem, visible) {
                            return elem.style.display = (visible ? '' : 'none');
                        };
                    }
                })();

                addClass = (function() {
                    if ($) {
                        return function(elem, cls) {
                            return elem.addClass(cls);
                        };
                    } else {
                        return function(elem, cls) {
                            return elem.classList.add(cls);
                        };
                    }
                })();

                startAnimation = (function() {
                    if ($) {
                        return function(elem, useCssAnimation, cls) {
                            if (useCssAnimation) {
                                return addClass(elem, cls);
                            } else {
                                return elem.css('opacity', 0);
                            }
                        };
                    } else {
                        return function(elem, useCssAnimation, cls) {
                            if (useCssAnimation) {
                                return addClass(elem, cls);
                            } else {
                                return elem.style.opacity = 0;
                            }
                        };
                    }
                })();

                endAnimation = (function() {
                    if ($) {
                        return function(elem, duration) {
                            return elem.animate({
                                opacity: 1
                            }, duration);
                        };
                    } else {
                        return function(elem, duration) {
                            elem.style.transition = "opacity " + (duration / 1000) + "s";
                            return elem.opacity = 1;
                        };
                    }
                })();

                insertView = (function() {
                    if ($) {
                        return function(list, viewEl, position, length, itemSelector) {
                            var children, childrenLength, insertInMiddle, isEnd, method;
                            insertInMiddle = (0 < position && position < length);
                            isEnd = function(length) {
                                return length === 0 || position === length;
                            };
                            if (insertInMiddle || itemSelector) {
                                children = list.children(itemSelector);
                                childrenLength = children.length;
                                if (children[position] !== viewEl) {
                                    if (isEnd(childrenLength)) {
                                        return list.append(viewEl);
                                    } else {
                                        if (position === 0) {
                                            return children.eq(position).before(viewEl);
                                        } else {
                                            return children.eq(position - 1).after(viewEl);
                                        }
                                    }
                                }
                            } else {
                                method = isEnd(length) ? 'append' : 'prepend';
                                return list[method](viewEl);
                            }
                        };
                    } else {
                        return function(list, viewEl, position, length, itemSelector) {
                            var children, childrenLength, insertInMiddle, isEnd, last;
                            insertInMiddle = (0 < position && position < length);
                            isEnd = function(length) {
                                return length === 0 || position === length;
                            };
                            if (insertInMiddle || itemSelector) {
                                children = filterChildren(list.children, itemSelector);
                                childrenLength = children.length;
                                if (children[position] !== viewEl) {
                                    if (isEnd(childrenLength)) {
                                        return list.appendChild(viewEl);
                                    } else if (position === 0) {
                                        return list.insertBefore(viewEl, children[position]);
                                    } else {
                                        last = children[position - 1];
                                        if (list.lastChild === last) {
                                            return list.appendChild(viewEl);
                                        } else {
                                            return list.insertBefore(viewEl, last.nextElementSibling);
                                        }
                                    }
                                }
                            } else if (isEnd(length)) {
                                return list.appendChild(viewEl);
                            } else {
                                return list.insertBefore(viewEl, list.firstChild);
                            }
                        };
                    }
                })();

                module.exports = CollectionView = (function(_super) {

                    __extends(CollectionView, _super);

                    CollectionView.prototype.itemView = null;

                    CollectionView.prototype.autoRender = true;

                    CollectionView.prototype.renderItems = true;

                    CollectionView.prototype.animationDuration = 500;

                    CollectionView.prototype.useCssAnimation = false;

                    CollectionView.prototype.animationStartClass = 'animated-item-view';

                    CollectionView.prototype.animationEndClass = 'animated-item-view-end';

                    CollectionView.prototype.listSelector = null;

                    CollectionView.prototype.$list = null;

                    CollectionView.prototype.fallbackSelector = null;

                    CollectionView.prototype.$fallback = null;

                    CollectionView.prototype.loadingSelector = null;

                    CollectionView.prototype.$loading = null;

                    CollectionView.prototype.itemSelector = void 0;

                    CollectionView.prototype.filterer = null;

                    CollectionView.prototype.filterCallback = function(view, included) {
                        if ($) {
                            view.$el.stop(true, true);
                        }
                        return toggleElement(($ ? view.$el : view.el), included);
                    };

                    CollectionView.prototype.visibleItems = null;

                    CollectionView.prototype.optionNames = View.prototype.optionNames.concat(['renderItems', 'itemView']);

                    function CollectionView(options) {
                        this.renderAllItems = __bind(this.renderAllItems, this);

                        this.toggleFallback = __bind(this.toggleFallback, this);

                        this.itemsReset = __bind(this.itemsReset, this);

                        this.itemRemoved = __bind(this.itemRemoved, this);

                        this.itemAdded = __bind(this.itemAdded, this);
                        this.visibleItems = [];
                        CollectionView.__super__.constructor.apply(this, arguments);
                    }

                    CollectionView.prototype.initialize = function(options) {
                        if (options == null) {
                            options = {};
                        }
                        this.addCollectionListeners();
                        if (options.filterer != null) {
                            return this.filter(options.filterer);
                        }
                    };

                    CollectionView.prototype.addCollectionListeners = function() {
                        this.listenTo(this.collection, 'add', this.itemAdded);
                        this.listenTo(this.collection, 'remove', this.itemRemoved);
                        return this.listenTo(this.collection, 'reset sort', this.itemsReset);
                    };

                    CollectionView.prototype.getTemplateData = function() {
                        var templateData;
                        templateData = {
                            length: this.collection.length
                        };
                        if (typeof this.collection.isSynced === 'function') {
                            templateData.synced = this.collection.isSynced();
                        }
                        return templateData;
                    };

                    CollectionView.prototype.getTemplateFunction = function() {};

                    CollectionView.prototype.render = function() {
                        var listSelector;
                        CollectionView.__super__.render.apply(this, arguments);
                        listSelector = _.result(this, 'listSelector');
                        if ($) {
                            this.$list = listSelector ? this.$(listSelector) : this.$el;
                        } else {
                            this.list = listSelector ? this.find(this.listSelector) : this.el;
                        }
                        this.initFallback();
                        this.initLoadingIndicator();
                        if (this.renderItems) {
                            return this.renderAllItems();
                        }
                    };

                    CollectionView.prototype.itemAdded = function(item, collection, options) {
                        return this.insertView(item, this.renderItem(item), options.at);
                    };

                    CollectionView.prototype.itemRemoved = function(item) {
                        return this.removeViewForItem(item);
                    };

                    CollectionView.prototype.itemsReset = function() {
                        return this.renderAllItems();
                    };

                    CollectionView.prototype.initFallback = function() {
                        if (!this.fallbackSelector) {
                            return;
                        }
                        if ($) {
                            this.$fallback = this.$(this.fallbackSelector);
                        } else {
                            this.fallback = this.find(this.fallbackSelector);
                        }
                        this.on('visibilityChange', this.toggleFallback);
                        this.listenTo(this.collection, 'syncStateChange', this.toggleFallback);
                        return this.toggleFallback();
                    };

                    CollectionView.prototype.toggleFallback = function() {
                        var visible;
                        visible = this.visibleItems.length === 0 && (typeof this.collection.isSynced === 'function' ? this.collection.isSynced() : true);
                        return toggleElement(($ ? this.$fallback : this.fallback), visible);
                    };

                    CollectionView.prototype.initLoadingIndicator = function() {
                        if (!(this.loadingSelector && typeof this.collection.isSyncing === 'function')) {
                            return;
                        }
                        if ($) {
                            this.$loading = this.$(this.loadingSelector);
                        } else {
                            this.loading = this.find(this.loadingSelector);
                        }
                        this.listenTo(this.collection, 'syncStateChange', this.toggleLoadingIndicator);
                        return this.toggleLoadingIndicator();
                    };

                    CollectionView.prototype.toggleLoadingIndicator = function() {
                        var visible;
                        visible = this.collection.length === 0 && this.collection.isSyncing();
                        return toggleElement(($ ? this.$loading : this.loading), visible);
                    };

                    CollectionView.prototype.getItemViews = function() {
                        var itemViews, name, view, _ref;
                        itemViews = {};
                        if (this.subviews.length > 0) {
                            _ref = this.subviewsByName;
                            for (name in _ref) {
                                view = _ref[name];
                                if (name.slice(0, 9) === 'itemView:') {
                                    itemViews[name.slice(9)] = view;
                                }
                            }
                        }
                        return itemViews;
                    };

                    CollectionView.prototype.filter = function(filterer, filterCallback) {
                        var hasItemViews, included, index, item, view, _i, _len, _ref,
                        _this = this;
                        if (typeof filterer === 'function' || filterer === null) {
                            this.filterer = filterer;
                        }
                        if (typeof filterCallback === 'function' || filterCallback === null) {
                            this.filterCallback = filterCallback;
                        }
                        hasItemViews = (function() {
                            var name;
                            if (_this.subviews.length > 0) {
                                for (name in _this.subviewsByName) {
                                    if (name.slice(0, 9) === 'itemView:') {
                                        return true;
                                    }
                                }
                            }
                            return false;
                        })();
                        if (hasItemViews) {
                            _ref = this.collection.models;
                            for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
                                item = _ref[index];
                                included = typeof this.filterer === 'function' ? this.filterer(item, index) : true;
                                view = this.subview("itemView:" + item.cid);
                                if (!view) {
                                    throw new Error('CollectionView#filter: ' + ("no view found for " + item.cid));
                                }
                                this.filterCallback(view, included);
                                this.updateVisibleItems(view.model, included, false);
                            }
                        }
                        return this.trigger('visibilityChange', this.visibleItems);
                    };

                    CollectionView.prototype.renderAllItems = function() {
                        var cid, index, item, items, remainingViewsByCid, view, _i, _j, _len, _len1, _ref;
                        items = this.collection.models;
                        this.visibleItems = [];
                        remainingViewsByCid = {};
                        for (_i = 0, _len = items.length; _i < _len; _i++) {
                            item = items[_i];
                            view = this.subview("itemView:" + item.cid);
                            if (view) {
                                remainingViewsByCid[item.cid] = view;
                            }
                        }
                        _ref = this.getItemViews();
                        for (cid in _ref) {
                            if (!__hasProp.call(_ref, cid)) 
                                continue;
                            view = _ref[cid];
                            if (!(cid in remainingViewsByCid)) {
                                this.removeSubview("itemView:" + cid);
                            }
                        }
                        for (index = _j = 0, _len1 = items.length; _j < _len1; index = ++_j) {
                            item = items[index];
                            view = this.subview("itemView:" + item.cid);
                            if (view) {
                                this.insertView(item, view, index, false);
                            } else {
                                this.insertView(item, this.renderItem(item), index);
                            }
                        }
                        if (items.length === 0) {
                            return this.trigger('visibilityChange', this.visibleItems);
                        }
                    };

                    CollectionView.prototype.renderItem = function(item) {
                        var view;
                        view = this.subview("itemView:" + item.cid);
                        if (!view) {
                            view = this.initItemView(item);
                            this.subview("itemView:" + item.cid, view);
                        }
                        view.render();
                        return view;
                    };

                    CollectionView.prototype.initItemView = function(model) {
                        if (this.itemView) {
                            return new this.itemView({
                                autoRender: false,
                                model: model
                            });
                        } else {
                            throw new Error('The CollectionView#itemView property ' + 'must be defined or the initItemView() must be overridden.');
                        }
                    };

                    CollectionView.prototype.insertView = function(item, view, position, enableAnimation) {
                        var elem, included, length, list,
                        _this = this;
                        if (enableAnimation == null) {
                            enableAnimation = true;
                        }
                        if (this.animationDuration === 0) {
                            enableAnimation = false;
                        }
                        if (typeof position !== 'number') {
                            position = this.collection.indexOf(item);
                        }
                        included = typeof this.filterer === 'function' ? this.filterer(item, position) : true;
                        elem = $ ? view.$el : view.el;
                        if (included && enableAnimation) {
                            startAnimation(elem, this.useCssAnimation, this.animationStartClass);
                        }
                        if (this.filterer) {
                            this.filterCallback(view, included);
                        }
                        length = this.collection.length;
                        list = $ ? this.$list : this.list;
                        insertView(list, elem, position, length, this.itemSelector);
                        view.trigger('addedToParent');
                        this.updateVisibleItems(item, included);
                        if (included && enableAnimation) {
                            if (this.useCssAnimation) {
                                setTimeout((function() {
                                    return addClass(elem, _this.animationEndClass);
                                }), 0);
                            } else {
                                endAnimation(elem, this.animationDuration);
                            }
                        }
                        return view;
                    };

                    CollectionView.prototype.removeViewForItem = function(item) {
                        this.updateVisibleItems(item, false);
                        return this.removeSubview("itemView:" + item.cid);
                    };

                    CollectionView.prototype.updateVisibleItems = function(item, includedInFilter, triggerEvent) {
                        var includedInVisibleItems, visibilityChanged, visibleItemsIndex;
                        if (triggerEvent == null) {
                            triggerEvent = true;
                        }
                        visibilityChanged = false;
                        visibleItemsIndex = utils.indexOf(this.visibleItems, item);
                        includedInVisibleItems = visibleItemsIndex !== - 1;
                        if (includedInFilter && !includedInVisibleItems) {
                            this.visibleItems.push(item);
                            visibilityChanged = true;
                        } else if (!includedInFilter && includedInVisibleItems) {
                            this.visibleItems.splice(visibleItemsIndex, 1);
                            visibilityChanged = true;
                        }
                        if (visibilityChanged && triggerEvent) {
                            this.trigger('visibilityChange', this.visibleItems);
                        }
                        return visibilityChanged;
                    };

                    CollectionView.prototype.dispose = function() {
                        var prop, properties, _i, _len;
                        if (this.disposed) {
                            return;
                        }
                        properties = ['$list', '$fallback', '$loading', 'visibleItems'];
                        for (_i = 0, _len = properties.length; _i < _len; _i++) {
                            prop = properties[_i];
                            delete this[prop];
                        }
                        return CollectionView.__super__.dispose.apply(this, arguments);
                    };

                    return CollectionView;

                })(View);

            });;
            loader.register('chaplin/lib/route', function(e, r, module) {
                'use strict';

                var Backbone, Controller, EventBroker, Route, utils, _,
                __bind = function(fn, me) {
                    return function() {
                        return fn.apply(me, arguments);
                    };
                },
                __hasProp = {}.hasOwnProperty;

                _ = loader('underscore');

                Backbone = loader('backbone');

                EventBroker = loader('chaplin/lib/event_broker');

                Controller = loader('chaplin/controllers/controller');

                utils = loader('chaplin/lib/utils');

                module.exports = Route = (function() {
                    var escapeRegExp, optionalRegExp, paramRegExp, processTrailingSlash;

                    Route.extend = Backbone.Model.extend;

                    _.extend(Route.prototype, EventBroker);

                    escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g;

                    optionalRegExp = /\((.*?)\)/g;

                    paramRegExp = /(?::|\*)(\w+)/g;

                    processTrailingSlash = function(path, trailing) {
                        switch (trailing) {
                        case true:
                            if (path.slice( - 1) !== '/') {
                                path += '/';
                            }
                            break;
                        case false:
                            if (path.slice( - 1) === '/') {
                                path = path.slice(0, - 1);
                            }
                        }
                        return path;
                    };

                    function Route(pattern, controller, action, options) {
                        var _ref;
                        this.pattern = pattern;
                        this.controller = controller;
                        this.action = action;
                        this.handler = __bind(this.handler, this);

                        this.replaceParams = __bind(this.replaceParams, this);

                        this.parseOptionalPortion = __bind(this.parseOptionalPortion, this);

                        if (typeof this.pattern !== 'string') {
                            throw new Error('Route: RegExps are not supported.\
                            Use strings with :names and `constraints` option of route');
                        }
                        this.options = options ? _.extend({}, options) : {};
                        if (this.options.name != null) {
                            this.name = this.options.name;
                        }
                        if (this.name && this.name.indexOf('#') !== - 1) {
                            throw new Error('Route: "#" cannot be used in name');
                        }
                        if ((_ref = this.name) == null) {
                            this.name = this.controller + '#' + this.action;
                        }
                        this.allParams = [];
                        this.requiredParams = [];
                        this.optionalParams = [];
                        if (this.action in Controller.prototype) {
                            throw new Error('Route: You should not use existing controller ' + 'properties as action names');
                        }
                        this.createRegExp();
                        if (typeof Object.freeze === "function") {
                            Object.freeze(this);
                        }
                    }

                    Route.prototype.matches = function(criteria) {
                        var invalidParamsCount, name, propertiesCount, property, _i, _len, _ref;
                        if (typeof criteria === 'string') {
                            return criteria === this.name;
                        } else {
                            propertiesCount = 0;
                            _ref = ['name', 'action', 'controller'];
                            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                                name = _ref[_i];
                                propertiesCount++;
                                property = criteria[name];
                                if (property && property !== this[name]) {
                                    return false;
                                }
                            }
                            invalidParamsCount = propertiesCount === 1 && (name === 'action' || name === 'controller');
                            return !invalidParamsCount;
                        }
                    };

                    Route.prototype.reverse = function(params, query) {
                        var name, queryString, raw, url, value, _i, _j, _len, _len1, _ref, _ref1;
                        params = this.normalizeParams(params);
                        if (params === false) {
                            return false;
                        }
                        url = this.pattern;
                        _ref = this.requiredParams;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                            name = _ref[_i];
                            value = params[name];
                            url = url.replace(RegExp("[:*]" + name, "g"), value);
                        }
                        _ref1 = this.optionalParams;
                        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                            name = _ref1[_j];
                            if (value = params[name]) {
                                url = url.replace(RegExp("[:*]" + name, "g"), value);
                            }
                        }
                        raw = url.replace(optionalRegExp, function(match, portion) {
                            if (portion.match(/[:*]/g)) {
                                return "";
                            } else {
                                return portion;
                            }
                        });
                        url = processTrailingSlash(raw, this.options.trailing);
                        if (!query) {
                            return url;
                        }
                        if (typeof query === 'object') {
                            queryString = utils.queryParams.stringify(query);
                            return url += queryString ? '?' + queryString : '';
                        } else {
                            return url += (query[0] === '?' ? '' : '?') + query;
                        }
                    };

                    Route.prototype.normalizeParams = function(params) {
                        var paramIndex, paramName, paramsHash, _i, _len, _ref;
                        if (utils.isArray(params)) {
                            if (params.length < this.requiredParams.length) {
                                return false;
                            }
                            paramsHash = {};
                            _ref = this.requiredParams;
                            for (paramIndex = _i = 0, _len = _ref.length; _i < _len; paramIndex = ++_i) {
                                paramName = _ref[paramIndex];
                                paramsHash[paramName] = params[paramIndex];
                            }
                            if (!this.testConstraints(paramsHash)) {
                                return false;
                            }
                            params = paramsHash;
                        } else {
                            if (params == null) {
                                params = {};
                            }
                            if (!this.testParams(params)) {
                                return false;
                            }
                        }
                        return params;
                    };

                    Route.prototype.testConstraints = function(params) {
                        var constraint, constraints, name;
                        constraints = this.options.constraints;
                        if (constraints) {
                            for (name in constraints) {
                                if (!__hasProp.call(constraints, name)) 
                                    continue;
                                constraint = constraints[name];
                                if (!constraint.test(params[name])) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    };

                    Route.prototype.testParams = function(params) {
                        var paramName, _i, _len, _ref;
                        _ref = this.requiredParams;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                            paramName = _ref[_i];
                            if (params[paramName] === void 0) {
                                return false;
                            }
                        }
                        return this.testConstraints(params);
                    };

                    Route.prototype.createRegExp = function() {
                        var pattern,
                        _this = this;
                        pattern = this.pattern;
                        pattern = pattern.replace(escapeRegExp, '\\$&');
                        this.replaceParams(pattern, function(match, param) {
                            return _this.allParams.push(param);
                        });
                        pattern = pattern.replace(optionalRegExp, this.parseOptionalPortion);
                        pattern = this.replaceParams(pattern, function(match, param) {
                            _this.requiredParams.push(param);
                            return _this.paramCapturePattern(match);
                        });
                        return this.regExp = RegExp("^" + pattern + "(?=\\/?(?=\\?|$))");
                    };

                    Route.prototype.parseOptionalPortion = function(match, optionalPortion) {
                        var portion,
                        _this = this;
                        portion = this.replaceParams(optionalPortion, function(match, param) {
                            _this.optionalParams.push(param);
                            return _this.paramCapturePattern(match);
                        });
                        return "(?:" + portion + ")?";
                    };

                    Route.prototype.replaceParams = function(s, callback) {
                        return s.replace(paramRegExp, callback);
                    };

                    Route.prototype.paramCapturePattern = function(param) {
                        if (param.charAt(0) === ':') {
                            return '([^\/\?]+)';
                        } else {
                            return '(.*?)';
                        }
                    };

                    Route.prototype.test = function(path) {
                        var constraints, matched;
                        matched = this.regExp.test(path);
                        if (!matched) {
                            return false;
                        }
                        constraints = this.options.constraints;
                        if (constraints) {
                            return this.testConstraints(this.extractParams(path));
                        }
                        return true;
                    };

                    Route.prototype.handler = function(pathParams, options) {
                        var actionParams, params, path, query, route, _ref;
                        options = options ? _.extend({}, options) : {};
                        if (typeof pathParams === 'object') {
                            query = utils.queryParams.stringify(options.query);
                            params = pathParams;
                            path = this.reverse(params);
                        } else {
                            _ref = pathParams.split('?'), path = _ref[0], query = _ref[1];
                            if (!(query != null)) {
                                query = '';
                            } else {
                                options.query = utils.queryParams.parse(query);
                            }
                            params = this.extractParams(path);
                            path = processTrailingSlash(path, this.options.trailing);
                        }
                        actionParams = _.extend({}, params, this.options.params);
                        route = {
                            path: path,
                            action: this.action,
                            controller: this.controller,
                            name: this.name,
                            query: query
                        };
                        return this.publishEvent('router:match', route, actionParams, options);
                    };

                    Route.prototype.extractParams = function(path) {
                        var index, match, matches, paramName, params, _i, _len, _ref;
                        params = {};
                        matches = this.regExp.exec(path);
                        _ref = matches.slice(1);
                        for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
                            match = _ref[index];
                            paramName = this.allParams.length ? this.allParams[index] : index;
                            params[paramName] = match;
                        }
                        return params;
                    };

                    return Route;

                })();

            });;
            loader.register('chaplin/lib/router', function(e, r, module) {
                'use strict';

                var Backbone, EventBroker, History, Route, Router, mediator, utils, _,
                __bind = function(fn, me) {
                    return function() {
                        return fn.apply(me, arguments);
                    };
                };

                _ = loader('underscore');

                Backbone = loader('backbone');

                mediator = loader('chaplin/mediator');

                EventBroker = loader('chaplin/lib/event_broker');

                History = loader('chaplin/lib/history');

                Route = loader('chaplin/lib/route');

                utils = loader('chaplin/lib/utils');

                module.exports = Router = (function() {

                    Router.extend = Backbone.Model.extend;

                    _.extend(Router.prototype, EventBroker);

                    function Router(options) {
                        var isWebFile;
                        this.options = options != null ? options : {};
                        this.match = __bind(this.match, this);

                        isWebFile = window.location.protocol !== 'file:';
                        _.defaults(this.options, {
                            pushState: isWebFile,
                            root: '/',
                            trailing: false
                        });
                        this.removeRoot = new RegExp('^' + utils.escapeRegExp(this.options.root) + '(#)?');
                        this.subscribeEvent('!router:route', this.oldEventError);
                        this.subscribeEvent('!router:routeByName', this.oldEventError);
                        this.subscribeEvent('!router:changeURL', this.oldURLEventError);
                        this.subscribeEvent('dispatcher:dispatch', this.changeURL);
                        mediator.setHandler('router:route', this.route, this);
                        mediator.setHandler('router:reverse', this.reverse, this);
                        this.createHistory();
                    }

                    Router.prototype.oldEventError = function() {
                        throw new Error('!router:route and !router:routeByName events were removed.\
                        Use `Chaplin.utils.redirectTo`');
                    };

                    Router.prototype.oldURLEventError = function() {
                        throw new Error('!router:changeURL event was removed.');
                    };

                    Router.prototype.createHistory = function() {
                        return Backbone.history = new History();
                    };

                    Router.prototype.startHistory = function() {
                        return Backbone.history.start(this.options);
                    };

                    Router.prototype.stopHistory = function() {
                        if (Backbone.History.started) {
                            return Backbone.history.stop();
                        }
                    };

                    Router.prototype.findHandler = function(predicate) {
                        var handler, _i, _len, _ref;
                        _ref = Backbone.history.handlers;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                            handler = _ref[_i];
                            if (predicate(handler)) {
                                return handler;
                            }
                        }
                    };

                    Router.prototype.match = function(pattern, target, options) {
                        var action, controller, route, _ref;
                        if (options == null) {
                            options = {};
                        }
                        if (arguments.length === 2 && typeof target === 'object') {
                            options = target;
                            controller = options.controller, action = options.action;
                            if (!(controller && action)) {
                                throw new Error('Router#match must receive either target or ' + 'options.controller & options.action');
                            }
                        } else {
                            controller = options.controller, action = options.action;
                            if (controller || action) {
                                throw new Error('Router#match cannot use both target and ' + 'options.controller / options.action');
                            }
                            _ref = target.split('#'), controller = _ref[0], action = _ref[1];
                        }
                        _.defaults(options, {
                            trailing: this.options.trailing
                        });
                        route = new Route(pattern, controller, action, options);
                        Backbone.history.handlers.push({
                            route: route,
                            callback: route.handler
                        });
                        return route;
                    };

                    Router.prototype.route = function(pathDesc, params, options) {
                        var handler, path;
                        if (typeof pathDesc === 'object') {
                            path = pathDesc.url;
                            if (!params && pathDesc.params) {
                                params = pathDesc.params;
                            }
                        }
                        params = params ? utils.isArray(params) ? params.slice() : _.extend({}, params) : {};
                        if (path != null) {
                            path = path.replace(this.removeRoot, '');
                            handler = this.findHandler(function(handler) {
                                return handler.route.test(path);
                            });
                            options = params;
                            params = null;
                        } else {
                            options = options ? _.extend({}, options) : {};
                            handler = this.findHandler(function(handler) {
                                if (handler.route.matches(pathDesc)) {
                                    params = handler.route.normalizeParams(params);
                                    if (params) {
                                        return true;
                                    }
                                }
                                return false;
                            });
                        }
                        if (handler) {
                            _.defaults(options, {
                                changeURL: true
                            });
                            handler.callback(path || params, options);
                            return true;
                        } else {
                            throw new Error('Router#route: request was not routed');
                        }
                    };

                    Router.prototype.reverse = function(criteria, params, query) {
                        var handler, handlers, reversed, root, url, _i, _len;
                        root = this.options.root;
                        if ((params != null) && typeof params !== 'object') {
                            throw new TypeError('Router#reverse: params must be an array or an ' + 'object');
                        }
                        handlers = Backbone.history.handlers;
                        for (_i = 0, _len = handlers.length; _i < _len; _i++) {
                            handler = handlers[_i];
                            if (!(handler.route.matches(criteria))) {
                                continue;
                            }
                            reversed = handler.route.reverse(params, query);
                            if (reversed !== false) {
                                url = root ? root + reversed : reversed;
                                return url;
                            }
                        }
                        throw new Error('Router#reverse: invalid route specified');
                    };

                    Router.prototype.changeURL = function(controller, params, route, options) {
                        var navigateOptions, url;
                        if (!((route.path != null) && options.changeURL)) {
                            return;
                        }
                        url = route.path + (route.query ? "?" + route.query : "");
                        navigateOptions = {
                            trigger: options.trigger === true,
                            replace: options.replace === true
                        };
                        return Backbone.history.navigate(url, navigateOptions);
                    };

                    Router.prototype.disposed = false;

                    Router.prototype.dispose = function() {
                        if (this.disposed) {
                            return;
                        }
                        this.stopHistory();
                        delete Backbone.history;
                        this.unsubscribeAllEvents();
                        mediator.removeHandlers(this);
                        this.disposed = true;
                        return typeof Object.freeze === "function" ? Object.freeze(this) : void 0;
                    };

                    return Router;

                })();

            });;
            loader.register('chaplin/lib/history', function(e, r, module) {
                'use strict';

                var Backbone, History, isExplorer, rootStripper, routeStripper, trailingSlash, _,
                __hasProp = {}.hasOwnProperty,
                __extends = function(child, parent) {
                    for (var key in parent) {
                        if (__hasProp.call(parent, key)) 
                            child[key] = parent[key];
                    }
                    function ctor() {
                        this.constructor = child;
                    }
                    ctor.prototype = parent.prototype;
                    child.prototype = new ctor();
                    child.__super__ = parent.prototype;
                    return child;
                };

                _ = loader('underscore');

                Backbone = loader('backbone');

                routeStripper = /^[#\/]|\s+$/g;

                rootStripper = /^\/+|\/+$/g;

                isExplorer = /msie [\w.]+/;

                trailingSlash = /\/$/;

                History = (function(_super) {

                    __extends(History, _super);

                    function History() {
                        return History.__super__.constructor.apply(this, arguments);
                    }

                    History.prototype.getFragment = function(fragment, forcePushState) {
                        var root;
                        if (!(fragment != null)) {
                            if (this._hasPushState || !this._wantsHashChange || forcePushState) {
                                fragment = this.location.pathname + this.location.search;
                                root = this.root.replace(trailingSlash, '');
                                if (!fragment.indexOf(root)) {
                                    fragment = fragment.substr(root.length);
                                }
                            } else {
                                fragment = this.getHash();
                            }
                        }
                        return fragment.replace(routeStripper, '');
                    };

                    History.prototype.start = function(options) {
                        var atRoot, fragment, loc;
                        if (Backbone.History.started) {
                            throw new Error('Backbone.history has already been started');
                        }
                        Backbone.History.started = true;
                        this.options = _.extend({}, {
                            root: '/'
                        }, this.options, options);
                        this.root = this.options.root;
                        this._wantsHashChange = this.options.hashChange !== false;
                        this._wantsPushState = Boolean(this.options.pushState);
                        this._hasPushState = Boolean(this.options.pushState && this.history && this.history.pushState);
                        fragment = this.getFragment();
                        this.root = ('/' + this.root + '/').replace(rootStripper, '/');
                        if (this._hasPushState) {
                            Backbone.$(window).on('popstate', this.checkUrl);
                        } else if (this._wantsHashChange && 'onhashchange' in window) {
                            Backbone.$(window).on('hashchange', this.checkUrl);
                        } else if (this._wantsHashChange) {
                            this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
                        }
                        this.fragment = fragment;
                        loc = this.location;
                        atRoot = loc.pathname.replace(/[^\/]$/, '$&/') === this.root;
                        if (this._wantsHashChange && this._wantsPushState && !this._hasPushState && !atRoot) {
                            this.fragment = this.getFragment(null, true);
                            this.location.replace(this.root + '#' + this.fragment);
                            return true;
                        } else if (this._wantsPushState && this._hasPushState && atRoot && loc.hash) {
                            this.fragment = this.getHash().replace(routeStripper, '');
                            this.history.replaceState({}, document.title, this.root + this.fragment);
                        }
                        if (!this.options.silent) {
                            return this.loadUrl();
                        }
                    };

                    History.prototype.navigate = function(fragment, options) {
                        var historyMethod, isSameFragment, url;
                        if (fragment == null) {
                            fragment = '';
                        }
                        if (!Backbone.History.started) {
                            return false;
                        }
                        if (!options || options === true) {
                            options = {
                                trigger: options
                            };
                        }
                        fragment = this.getFragment(fragment);
                        url = this.root + fragment;
                        if (this.fragment === fragment) {
                            return false;
                        }
                        this.fragment = fragment;
                        if (fragment.length === 0 && url !== '/') {
                            url = url.slice(0, - 1);
                        }
                        if (this._hasPushState) {
                            historyMethod = options.replace ? 'replaceState' : 'pushState';
                            this.history[historyMethod]({}, document.title, url);
                        } else if (this._wantsHashChange) {
                            this._updateHash(this.location, fragment, options.replace);
                            isSameFragment = fragment !== this.getFragment(this.getHash(this.iframe));
                            if ((this.iframe != null) && isSameFragment) {
                                if (!options.replace) {
                                    this.iframe.document.open().close();
                                }
                                this._updateHash(this.iframe.location, fragment, options.replace);
                            }
                        } else {
                            return this.location.assign(url);
                        }
                        if (options.trigger) {
                            return this.loadUrl(fragment);
                        }
                    };

                    return History;

                })(Backbone.History);

                module.exports = Backbone.$ ? History : Backbone.History;

            });;
            loader.register('chaplin/lib/event_broker', function(e, r, module) {
                'use strict';

                var EventBroker, mediator,
                __slice = [].slice;

                mediator = loader('chaplin/mediator');

                EventBroker = {
                    subscribeEvent: function(type, handler) {
                        if (typeof type !== 'string') {
                            throw new TypeError('EventBroker#subscribeEvent: ' + 'type argument must be a string');
                        }
                        if (typeof handler !== 'function') {
                            throw new TypeError('EventBroker#subscribeEvent: ' + 'handler argument must be a function');
                        }
                        mediator.unsubscribe(type, handler, this);
                        return mediator.subscribe(type, handler, this);
                    },
                    unsubscribeEvent: function(type, handler) {
                        if (typeof type !== 'string') {
                            throw new TypeError('EventBroker#unsubscribeEvent: ' + 'type argument must be a string');
                        }
                        if (typeof handler !== 'function') {
                            throw new TypeError('EventBroker#unsubscribeEvent: ' + 'handler argument must be a function');
                        }
                        return mediator.unsubscribe(type, handler);
                    },
                    unsubscribeAllEvents: function() {
                        return mediator.unsubscribe(null, null, this);
                    },
                    publishEvent: function() {
                        var args, type;
                        type = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
                        if (typeof type !== 'string') {
                            throw new TypeError('EventBroker#publishEvent: ' + 'type argument must be a string');
                        }
                        return mediator.publish.apply(mediator, [type].concat(__slice.call(args)));
                    }
                };

                if (typeof Object.freeze === "function") {
                    Object.freeze(EventBroker);
                }

                module.exports = EventBroker;

            });;
            loader.register('chaplin/lib/support', function(e, r, module) {
                'use strict';

                var support;

                support = {
                    propertyDescriptors: (function() {
                        var o;
                        if (!(typeof Object.defineProperty === 'function' && typeof Object.defineProperties === 'function')) {
                            return false;
                        }
                        try {
                            o = {};
                            Object.defineProperty(o, 'foo', {
                                value: 'bar'
                            });
                            return o.foo === 'bar';
                        } catch (error) {
                            return false;
                        }
                    })()
                };

                module.exports = support;

            });;
            loader.register('chaplin/lib/composition', function(e, r, module) {
                'use strict';

                var Backbone, Composition, EventBroker, has, _,
                __hasProp = {}.hasOwnProperty;

                _ = loader('underscore');

                Backbone = loader('backbone');

                EventBroker = loader('chaplin/lib/event_broker');

                has = Object.prototype.hasOwnProperty;

                module.exports = Composition = (function() {

                    Composition.extend = Backbone.Model.extend;

                    _.extend(Composition.prototype, Backbone.Events);

                    _.extend(Composition.prototype, EventBroker);

                    Composition.prototype.item = null;

                    Composition.prototype.options = null;

                    Composition.prototype._stale = false;

                    function Composition(options) {
                        if (options != null) {
                            this.options = _.extend({}, options);
                        }
                        this.item = this;
                        this.initialize(this.options);
                    }

                    Composition.prototype.initialize = function() {};

                    Composition.prototype.compose = function() {};

                    Composition.prototype.check = function(options) {
                        return _.isEqual(this.options, options);
                    };

                    Composition.prototype.stale = function(value) {
                        var item, name;
                        if (value == null) {
                            return this._stale;
                        }
                        this._stale = value;
                        for (name in this) {
                            item = this[name];
                            if (item && item !== this && typeof item === 'object' && has.call(item, 'stale')) {
                                item.stale = value;
                            }
                        }
                    };

                    Composition.prototype.disposed = false;

                    Composition.prototype.dispose = function() {
                        var obj, prop, properties, _i, _len;
                        if (this.disposed) {
                            return;
                        }
                        for (prop in this) {
                            if (!__hasProp.call(this, prop)) 
                                continue;
                            obj = this[prop];
                            if (obj && typeof obj.dispose === 'function') {
                                if (obj !== this) {
                                    obj.dispose();
                                    delete this[prop];
                                }
                            }
                        }
                        this.unsubscribeAllEvents();
                        this.stopListening();
                        properties = ['redirected'];
                        for (_i = 0, _len = properties.length; _i < _len; _i++) {
                            prop = properties[_i];
                            delete this[prop];
                        }
                        this.disposed = true;
                        return typeof Object.freeze === "function" ? Object.freeze(this) : void 0;
                    };

                    return Composition;

                })();

            });;
            loader.register('chaplin/lib/sync_machine', function(e, r, module) {
                'use strict';

                var STATE_CHANGE, SYNCED, SYNCING, SyncMachine, UNSYNCED, event, _fn, _i, _len, _ref;

                UNSYNCED = 'unsynced';

                SYNCING = 'syncing';

                SYNCED = 'synced';

                STATE_CHANGE = 'syncStateChange';

                SyncMachine = {
                    _syncState: UNSYNCED,
                    _previousSyncState: null,
                    syncState: function() {
                        return this._syncState;
                    },
                    isUnsynced: function() {
                        return this._syncState === UNSYNCED;
                    },
                    isSynced: function() {
                        return this._syncState === SYNCED;
                    },
                    isSyncing: function() {
                        return this._syncState === SYNCING;
                    },
                    unsync: function() {
                        var _ref;
                        if ((_ref = this._syncState) === SYNCING || _ref === SYNCED) {
                            this._previousSync = this._syncState;
                            this._syncState = UNSYNCED;
                            this.trigger(this._syncState, this, this._syncState);
                            this.trigger(STATE_CHANGE, this, this._syncState);
                        }
                    },
                    beginSync: function() {
                        var _ref;
                        if ((_ref = this._syncState) === UNSYNCED || _ref === SYNCED) {
                            this._previousSync = this._syncState;
                            this._syncState = SYNCING;
                            this.trigger(this._syncState, this, this._syncState);
                            this.trigger(STATE_CHANGE, this, this._syncState);
                        }
                    },
                    finishSync: function() {
                        if (this._syncState === SYNCING) {
                            this._previousSync = this._syncState;
                            this._syncState = SYNCED;
                            this.trigger(this._syncState, this, this._syncState);
                            this.trigger(STATE_CHANGE, this, this._syncState);
                        }
                    },
                    abortSync: function() {
                        if (this._syncState === SYNCING) {
                            this._syncState = this._previousSync;
                            this._previousSync = this._syncState;
                            this.trigger(this._syncState, this, this._syncState);
                            this.trigger(STATE_CHANGE, this, this._syncState);
                        }
                    }
                };

                _ref = [UNSYNCED, SYNCING, SYNCED, STATE_CHANGE];
                _fn = function(event) {
                    return SyncMachine[event] = function(callback, context) {
                        if (context == null) {
                            context = this;
                        }
                        this.on(event, callback, context);
                        if (this._syncState === event) {
                            return callback.call(context);
                        }
                    };
                };
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    event = _ref[_i];
                    _fn(event);
                }

                if (typeof Object.freeze === "function") {
                    Object.freeze(SyncMachine);
                }

                module.exports = SyncMachine;

            });;
            loader.register('chaplin/lib/utils', function(e, r, module) {
                'use strict';

                var support, utils, _,
                __slice = [].slice,
                __indexOf = [].indexOf || function(item) {
                    for (var i = 0, l = this.length; i < l; i++) {
                        if (i in this && this[i] === item) 
                            return i;
                    }
                    return - 1;
                },
                __hasProp = {}.hasOwnProperty;

                _ = loader('underscore');

                support = loader('chaplin/lib/support');

                utils = {
                    beget: (function() {
                        var ctor;
                        if (typeof Object.create === 'function') {
                            return Object.create;
                        } else {
                            ctor = function() {};
                            return function(obj) {
                                ctor.prototype = obj;
                                return new ctor;
                            };
                        }
                    })(),
                    indexOf: (function() {
                        if (Array.prototype.indexOf) {
                            return function(list, index) {
                                return list.indexOf(index);
                            };
                        } else if (_.indexOf) {
                            return _.indexOf;
                        }
                    })(),
                    isArray: Array.isArray || _.isArray,
                    serialize: function(data) {
                        if (typeof data.serialize === 'function') {
                            return data.serialize();
                        } else if (typeof data.toJSON === 'function') {
                            return data.toJSON();
                        } else {
                            throw new TypeError('utils.serialize: Unknown data was passed');
                        }
                    },
                    readonly: (function() {
                        var readonlyDescriptor;
                        if (support.propertyDescriptors) {
                            readonlyDescriptor = {
                                writable: false,
                                enumerable: true,
                                configurable: false
                            };
                            return function() {
                                var obj, prop, properties, _i, _len;
                                obj = arguments[0], properties = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
                                for (_i = 0, _len = properties.length; _i < _len; _i++) {
                                    prop = properties[_i];
                                    readonlyDescriptor.value = obj[prop];
                                    Object.defineProperty(obj, prop, readonlyDescriptor);
                                }
                                return true;
                            };
                        } else {
                            return function() {
                                return false;
                            };
                        }
                    })(),
                    getPrototypeChain: function(object) {
                        var chain, _ref, _ref1, _ref2;
                        chain = [object.constructor.prototype];
                        while (object = (_ref = (_ref1 = object.constructor) != null ? _ref1.__super__ : void 0) != null ? _ref : (_ref2 = object.constructor) != null ? _ref2.superclass : void 0) {
                            chain.push(object);
                        }
                        return chain.reverse();
                    },
                    getAllPropertyVersions: function(object, property) {
                        var proto, result, value, _i, _len, _ref;
                        result = [];
                        _ref = utils.getPrototypeChain(object);
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                            proto = _ref[_i];
                            value = proto[property];
                            if (value && __indexOf.call(result, value) < 0) {
                                result.push(value);
                            }
                        }
                        return result;
                    },
                    upcase: function(str) {
                        return str.charAt(0).toUpperCase() + str.substring(1);
                    },
                    escapeRegExp: function(str) {
                        return String(str || '').replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
                    },
                    modifierKeyPressed: function(event) {
                        return event.shiftKey || event.altKey || event.ctrlKey || event.metaKey;
                    },
                    reverse: function(criteria, params, query) {
                        return loader('chaplin/mediator').execute('router:reverse', criteria, params, query);
                    },
                    redirectTo: function(pathDesc, params, options) {
                        return loader('chaplin/mediator').execute('router:route', pathDesc, params, options);
                    },
                    queryParams: {
                        stringify: function(queryParams) {
                            var arrParam, encodedKey, key, query, stringifyKeyValuePair, value, _i, _len;
                            query = '';
                            stringifyKeyValuePair = function(encodedKey, value) {
                                if (value != null) {
                                    return '&' + encodedKey + '=' + encodeURIComponent(value);
                                } else {
                                    return '';
                                }
                            };
                            for (key in queryParams) {
                                if (!__hasProp.call(queryParams, key)) 
                                    continue;
                                value = queryParams[key];
                                encodedKey = encodeURIComponent(key);
                                if (utils.isArray(value)) {
                                    for (_i = 0, _len = value.length; _i < _len; _i++) {
                                        arrParam = value[_i];
                                        query += stringifyKeyValuePair(encodedKey, arrParam);
                                    }
                                } else {
                                    query += stringifyKeyValuePair(encodedKey, value);
                                }
                            }
                            return query && query.substring(1);
                        },
                        parse: function(queryString) {
                            var current, field, pair, pairs, params, value, _i, _len, _ref;
                            params = {};
                            if (!queryString) {
                                return params;
                            }
                            pairs = queryString.split('&');
                            for (_i = 0, _len = pairs.length; _i < _len; _i++) {
                                pair = pairs[_i];
                                if (!pair.length) {
                                    continue;
                                }
                                _ref = pair.split('='), field = _ref[0], value = _ref[1];
                                if (!field.length) {
                                    continue;
                                }
                                field = decodeURIComponent(field);
                                value = decodeURIComponent(value);
                                current = params[field];
                                if (current) {
                                    if (current.push) {
                                        current.push(value);
                                    } else {
                                        params[field] = [current, value];
                                    }
                                } else {
                                    params[field] = value;
                                }
                            }
                            return params;
                        }
                    }
                };

                if (typeof Object.seal === "function") {
                    Object.seal(utils);
                }

                module.exports = utils;

            });;
            loader.register('chaplin', function(e, r, module) {

                module.exports = {
                    Application: loader('chaplin/application'),
                    mediator: loader('chaplin/mediator'),
                    Dispatcher: loader('chaplin/dispatcher'),
                    Controller: loader('chaplin/controllers/controller'),
                    Composer: loader('chaplin/composer'),
                    Composition: loader('chaplin/lib/composition'),
                    Collection: loader('chaplin/models/collection'),
                    Model: loader('chaplin/models/model'),
                    Layout: loader('chaplin/views/layout'),
                    View: loader('chaplin/views/view'),
                    CollectionView: loader('chaplin/views/collection_view'),
                    Route: loader('chaplin/lib/route'),
                    Router: loader('chaplin/lib/router'),
                    EventBroker: loader('chaplin/lib/event_broker'),
                    support: loader('chaplin/lib/support'),
                    SyncMachine: loader('chaplin/lib/sync_machine'),
                    utils: loader('chaplin/lib/utils')
                };

            });
            var regDeps = function(Backbone, _) {
                loader.register('backbone', function(exports, require, module) {
                    module.exports = Backbone;
                });
                loader.register('underscore', function(exports, require, module) {
                    module.exports = _;
                });
            };

            if (typeof define === 'function' && define.amd) {
                define(['backbone', 'underscore'], function(Backbone, _) {
                    regDeps(Backbone, _);
                    return loader('chaplin');
                });
            } else if (typeof module === 'object' && module && module.exports) {
                regDeps(require('backbone'), require('underscore'));
                module.exports = loader('chaplin');
            } else if (typeof require === 'function') {
                regDeps(window.Backbone, window._ || window.Backbone.utils);
                window.Chaplin = loader('chaplin');
            } else {
                throw new Error('Chaplin requires Common.js or AMD modules');
            }

        })();
    }, {
        "backbone": 267,
        "underscore": 276
    }
    ],
    269: [function(require, module, exports) {
        /*!
         * jQuery JavaScript Library v1.11.0
         * http://jquery.com/
         *
         * Includes Sizzle.js
         * http://sizzlejs.com/
         *
         * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
         * Released under the MIT license
         * http://jquery.org/license
         *
         * Date: 2014-01-23T21:02Z
         */

        (function( global, factory ) {

            if ( typeof module === "object" && typeof module.exports === "object" ) {
                // For CommonJS and CommonJS-like environments where a proper window is present,
                // execute the factory and get jQuery
                // For environments that do not inherently posses a window with a document
                // (such as Node.js), expose a jQuery-making factory as module.exports
                // This accentuates the need for the creation of a real window
                // e.g. var jQuery = require("jquery")(window);
                // See ticket #14549 for more info
                module.exports = global.document ?
                factory( global, true ) :
                function( w ) {
                    if ( !w.document ) {
                        throw new Error( "jQuery requires a window with a document" );
                    }
                    return factory( w );
                };
            } else {
                factory( global );
            }

            // Pass this if window is not defined yet
        }(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

            // Can't do this because several apps including ASP.NET trace
            // the stack via arguments.caller.callee and Firefox dies if
            // you try to trace through "use strict" call chains. (#13335)
            // Support: Firefox 18+
            //

            var deletedIds = [];

            var slice = deletedIds.slice;

            var concat = deletedIds.concat;

            var push = deletedIds.push;

            var indexOf = deletedIds.indexOf;

            var class2type = {};

            var toString = class2type.toString;

            var hasOwn = class2type.hasOwnProperty;

            var trim = "".trim;

            var support = {};



            var
            version = "1.11.0",
            // Define a local copy of jQuery
            jQuery = function( selector, context ) {
                // The jQuery object is actually just the init constructor 'enhanced'
                // Need init if jQuery is called (just allow error to be thrown if not included)
                return new jQuery.fn.init( selector, context );
            },
            // Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)
            rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
            // Matches dashed string for camelizing
            rmsPrefix = /^-ms-/,
            rdashAlpha = /-([\da-z])/gi,
            // Used by jQuery.camelCase as callback to replace()
            fcamelCase = function( all, letter ) {
                return letter.toUpperCase();
            };

            jQuery.fn = jQuery.prototype = {
                // The current version of jQuery being used
                jquery: version,

                constructor: jQuery,

                // Start with an empty selector
                selector: "",

                // The default length of a jQuery object is 0
                length: 0,

                toArray: function() {
                    return slice.call( this );
                },

                // Get the Nth element in the matched element set OR
                // Get the whole matched element set as a clean array
                get: function( num ) {
                    return num != null ?
                    // Return a 'clean' array
                    ( num < 0 ? this[ num + this.length ] : this[ num ] ) :
                    // Return just the object
                    slice.call( this );
                },

                // Take an array of elements and push it onto the stack
                // (returning the new matched element set)
                pushStack: function( elems ) {

                    // Build a new jQuery matched element set
                    var ret = jQuery.merge( this.constructor(), elems );

                    // Add the old object onto the stack (as a reference)
                    ret.prevObject = this;
                    ret.context = this.context;

                    // Return the newly-formed element set
                    return ret;
                },

                // Execute a callback for every element in the matched set.
                // (You can seed the arguments with an array of args, but this is
                // only used internally.)
                each: function( callback, args ) {
                    return jQuery.each( this, callback, args );
                },

                map: function( callback ) {
                    return this.pushStack( jQuery.map(this, function( elem, i ) {
                        return callback.call( elem, i, elem );
                    }));
                },

                slice: function() {
                    return this.pushStack( slice.apply( this, arguments ) );
                },

                first: function() {
                    return this.eq( 0 );
                },

                last: function() {
                    return this.eq( - 1 );
                },

                eq: function( i ) {
                    var len = this.length,
                    j = + i + ( i < 0 ? len : 0 );
                    return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
                },

                end: function() {
                    return this.prevObject || this.constructor(null);
                },

                // For internal use only.
                // Behaves like an Array's method, not like a jQuery method.
                push: push,
                sort: deletedIds.sort,
                splice: deletedIds.splice
            };

            jQuery.extend = jQuery.fn.extend = function() {
                var src, copyIsArray, copy, name, options, clone,
                target = arguments[0] || {},
                i = 1,
                length = arguments.length,
                deep = false;

                // Handle a deep copy situation
                if ( typeof target === "boolean" ) {
                    deep = target;

                    // skip the boolean and the target
                    target = arguments[ i ] || {};
                    i++;
                }

                // Handle case when target is a string or something (possible in deep copy)
                if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
                    target = {};
                }

                // extend jQuery itself if only one argument is passed
                if ( i === length ) {
                    target = this;
                    i--;
                }

                for ( ; i < length; i++ ) {
                    // Only deal with non-null/undefined values
                    if ( (options = arguments[ i ]) != null ) {
                        // Extend the base object
                        for ( name in options ) {
                            src = target[ name ];
                            copy = options[ name ];

                            // Prevent never-ending loop
                            if ( target === copy ) {
                                continue;
                            }

                            // Recurse if we're merging plain objects or arrays
                            if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
                                if ( copyIsArray ) {
                                    copyIsArray = false;
                                    clone = src && jQuery.isArray(src) ? src : [];

                                } else {
                                    clone = src && jQuery.isPlainObject(src) ? src : {};
                                }

                                // Never move original objects, clone them
                                target[ name ] = jQuery.extend( deep, clone, copy );

                                // Don't bring in undefined values
                            } else if ( copy !== undefined ) {
                                target[ name ] = copy;
                            }
                        }
                    }
                }

                // Return the modified object
                return target;
            };

            jQuery.extend({
                // Unique for each copy of jQuery on the page
                expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

                // Assume jQuery is ready without the ready module
                isReady: true,

                error: function( msg ) {
                    throw new Error( msg );
                },

                noop: function() {},

                // See test/unit/core.js for details concerning isFunction.
                // Since version 1.3, DOM methods and functions like alert
                // aren't supported. They return false on IE (#2968).
                isFunction: function( obj ) {
                    return jQuery.type(obj) === "function";
                },

                isArray: Array.isArray || function( obj ) {
                    return jQuery.type(obj) === "array";
                },

                isWindow: function( obj ) {
                    /* jshint eqeqeq: false */
                    return obj != null && obj == obj.window;
                },

                isNumeric: function( obj ) {
                    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
                    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
                    // subtraction forces infinities to NaN
                    return obj - parseFloat( obj ) >= 0;
                },

                isEmptyObject: function( obj ) {
                    var name;
                    for ( name in obj ) {
                        return false;
                    }
                    return true;
                },

                isPlainObject: function( obj ) {
                    var key;

                    // Must be an Object.
                    // Because of IE, we also have to check the presence of the constructor property.
                    // Make sure that DOM nodes and window objects don't pass through, as well
                    if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
                        return false;
                    }

                    try {
                        // Not own constructor property must be Object
                        if ( obj.constructor &&
                        !hasOwn.call(obj, "constructor") &&
                        !hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
                            return false;
                        }
                    } catch ( e ) {
                        // IE8,9 Will throw exceptions on certain host objects #9897
                        return false;
                    }

                    // Support: IE<9
                    // Handle iteration over inherited properties before own properties.
                    if ( support.ownLast ) {
                        for ( key in obj ) {
                            return hasOwn.call( obj, key );
                        }
                    }

                    // Own properties are enumerated firstly, so to speed up,
                    // if last one is own, then all properties are own.
                    for ( key in obj ) {}

                    return key === undefined || hasOwn.call( obj, key );
                },

                type: function( obj ) {
                    if ( obj == null ) {
                        return obj + "";
                    }
                    return typeof obj === "object" || typeof obj === "function" ?
                    class2type[ toString.call(obj) ] || "object" :
                    typeof obj;
                },

                // Evaluates a script in a global context
                // Workarounds based on findings by Jim Driscoll
                // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
                globalEval: function( data ) {
                    if ( data && jQuery.trim( data ) ) {
                        // We use execScript on Internet Explorer
                        // We use an anonymous function so that context is window
                        // rather than jQuery in Firefox
                        ( window.execScript || function( data ) {
                            window[ "eval" ].call( window, data );
                        })( data );
                    }
                },

                // Convert dashed to camelCase; used by the css and data modules
                // Microsoft forgot to hump their vendor prefix (#9572)
                camelCase: function( string ) {
                    return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
                },

                nodeName: function( elem, name ) {
                    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
                },

                // args is for internal usage only
                each: function( obj, callback, args ) {
                    var value,
                    i = 0,
                    length = obj.length,
                    isArray = isArraylike( obj );

                    if ( args ) {
                        if ( isArray ) {
                            for ( ; i < length; i++ ) {
                                value = callback.apply( obj[ i ], args );

                                if ( value === false ) {
                                    break;
                                }
                            }
                        } else {
                            for ( i in obj ) {
                                value = callback.apply( obj[ i ], args );

                                if ( value === false ) {
                                    break;
                                }
                            }
                        }

                        // A special, fast, case for the most common use of each
                    } else {
                        if ( isArray ) {
                            for ( ; i < length; i++ ) {
                                value = callback.call( obj[ i ], i, obj[ i ] );

                                if ( value === false ) {
                                    break;
                                }
                            }
                        } else {
                            for ( i in obj ) {
                                value = callback.call( obj[ i ], i, obj[ i ] );

                                if ( value === false ) {
                                    break;
                                }
                            }
                        }
                    }

                    return obj;
                },

                // Use native String.trim function wherever possible
                trim: trim && !trim.call("\uFEFF\xA0") ?
                function( text ) {
                    return text == null ?
                    "" :
                    trim.call( text );
                }
                :
                // Otherwise use our own trimming functionality
                function( text ) {
                    return text == null ?
                    "" :
                    ( text + "" ).replace( rtrim, "" );
                },

                // results is for internal usage only
                makeArray: function( arr, results ) {
                    var ret = results || [];

                    if ( arr != null ) {
                        if ( isArraylike( Object(arr) ) ) {
                            jQuery.merge( ret,
                            typeof arr === "string" ?
                            [ arr ] : arr
                            );
                        } else {
                            push.call( ret, arr );
                        }
                    }

                    return ret;
                },

                inArray: function( elem, arr, i ) {
                    var len;

                    if ( arr ) {
                        if ( indexOf ) {
                            return indexOf.call( arr, elem, i );
                        }

                        len = arr.length;
                        i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

                        for ( ; i < len; i++ ) {
                            // Skip accessing in sparse arrays
                            if ( i in arr && arr[ i ] === elem ) {
                                return i;
                            }
                        }
                    }

                    return - 1;
                },

                merge: function( first, second ) {
                    var len = + second.length,
                    j = 0,
                    i = first.length;

                    while ( j < len ) {
                        first[ i++ ] = second[ j++ ];
                    }

                    // Support: IE<9
                    // Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)
                    if ( len !== len ) {
                        while ( second[j] !== undefined ) {
                            first[ i++ ] = second[ j++ ];
                        }
                    }

                    first.length = i;

                    return first;
                },

                grep: function( elems, callback, invert ) {
                    var callbackInverse,
                    matches = [],
                    i = 0,
                    length = elems.length,
                    callbackExpect = !invert;

                    // Go through the array, only saving the items
                    // that pass the validator function
                    for ( ; i < length; i++ ) {
                        callbackInverse = !callback( elems[ i ], i );
                        if ( callbackInverse !== callbackExpect ) {
                            matches.push( elems[ i ] );
                        }
                    }

                    return matches;
                },

                // arg is for internal usage only
                map: function( elems, callback, arg ) {
                    var value,
                    i = 0,
                    length = elems.length,
                    isArray = isArraylike( elems ),
                    ret = [];

                    // Go through the array, translating each of the items to their new values
                    if ( isArray ) {
                        for ( ; i < length; i++ ) {
                            value = callback( elems[ i ], i, arg );

                            if ( value != null ) {
                                ret.push( value );
                            }
                        }

                        // Go through every key on the object,
                    } else {
                        for ( i in elems ) {
                            value = callback( elems[ i ], i, arg );

                            if ( value != null ) {
                                ret.push( value );
                            }
                        }
                    }

                    // Flatten any nested arrays
                    return concat.apply( [], ret );
                },

                // A global GUID counter for objects
                guid: 1,

                // Bind a function to a context, optionally partially applying any
                // arguments.
                proxy: function( fn, context ) {
                    var args, proxy, tmp;

                    if ( typeof context === "string" ) {
                        tmp = fn[ context ];
                        context = fn;
                        fn = tmp;
                    }

                    // Quick check to determine if target is callable, in the spec
                    // this throws a TypeError, but we will just return undefined.
                    if ( !jQuery.isFunction( fn ) ) {
                        return undefined;
                    }

                    // Simulated bind
                    args = slice.call( arguments, 2 );
                    proxy = function() {
                        return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
                    };

                    // Set the guid of unique handler to the same of original handler, so it can be removed
                    proxy.guid = fn.guid = fn.guid || jQuery.guid++;

                    return proxy;
                },

                now: function() {
                    return + ( new Date() );
                },

                // jQuery.support is not used in Core but other projects attach their
                // properties to it so it needs to exist.
                support: support
            });

            // Populate the class2type map
            jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
                class2type[ "[object " + name + "]" ] = name.toLowerCase();
            });

            function isArraylike( obj ) {
                var length = obj.length,
                type = jQuery.type( obj );

                if ( type === "function" || jQuery.isWindow( obj ) ) {
                    return false;
                }

                if ( obj.nodeType === 1 && length ) {
                    return true;
                }

                return type === "array" || length === 0 ||
                typeof length === "number" && length > 0 && ( length - 1 ) in obj;
            }
            var Sizzle =
            /*!
             * Sizzle CSS Selector Engine v1.10.16
             * http://sizzlejs.com/
             *
             * Copyright 2013 jQuery Foundation, Inc. and other contributors
             * Released under the MIT license
             * http://jquery.org/license
             *
             * Date: 2014-01-13
             */
            (function( window ) {

                var i,
                support,
                Expr,
                getText,
                isXML,
                compile,
                outermostContext,
                sortInput,
                hasDuplicate,
                // Local document vars
                setDocument,
                document,
                docElem,
                documentIsHTML,
                rbuggyQSA,
                rbuggyMatches,
                matches,
                contains,
                // Instance-specific data
                expando = "sizzle" + - (new Date()),
                preferredDoc = window.document,
                dirruns = 0,
                done = 0,
                classCache = createCache(),
                tokenCache = createCache(),
                compilerCache = createCache(),
                sortOrder = function( a, b ) {
                    if ( a === b ) {
                        hasDuplicate = true;
                    }
                    return 0;
                },
                // General-purpose constants
                strundefined = typeof undefined,
                MAX_NEGATIVE = 1 << 31,
                // Instance methods
                hasOwn = ({}).hasOwnProperty,
                arr = [],
                pop = arr.pop,
                push_native = arr.push,
                push = arr.push,
                slice = arr.slice,
                // Use a stripped-down indexOf if we can't use a native one
                indexOf = arr.indexOf || function( elem ) {
                    var i = 0,
                    len = this.length;
                    for ( ; i < len; i++ ) {
                        if ( this[i] === elem ) {
                            return i;
                        }
                    }
                    return - 1;
                },
                booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
                // Regular expressions

                // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
                whitespace = "[\\x20\\t\\r\\n\\f]",
                // http://www.w3.org/TR/css3-syntax/#characters
                characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
                // Loosely modeled on CSS identifier characters
                // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
                // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
                identifier = characterEncoding.replace( "w", "w#" ),
                // Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
                attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
                "*(?:([*^$|!~]?=)" + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",
                // Prefer arguments quoted,
                //   then not containing pseudos/brackets,
                //   then attribute selectors/non-parenthetical expressions,
                //   then anything else
                // These preferences are here to reduce the number of selectors
                //   needing tokenize in the PSEUDO preFilter
                pseudos = ":(" + characterEncoding + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + attributes.replace( 3, 8 ) + ")*)|.*)\\)|)",
                // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
                rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),
                rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
                rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
                rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),
                rpseudo = new RegExp( pseudos ),
                ridentifier = new RegExp( "^" + identifier + "$" ),
                matchExpr = {
                    "ID": new RegExp( "^#(" + characterEncoding + ")" ),
                    "CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
                    "TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
                    "ATTR": new RegExp( "^" + attributes ),
                    "PSEUDO": new RegExp( "^" + pseudos ),
                    "CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
                    "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
                    "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
                    "bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
                    // For use in libraries implementing .is()
                    // We use this for POS matching in `select`
                    "needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
                    whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
                },
                rinputs = /^(?:input|select|textarea|button)$/i,
                rheader = /^h\d$/i,
                rnative = /^[^{]+\{\s*\[native \w/,
                // Easily-parseable/retrievable ID or TAG or CLASS selectors
                rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
                rsibling = /[+~]/,
                rescape = /'|\\/g,
                // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
                runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
                funescape = function( _, escaped, escapedWhitespace ) {
                    var high = "0x" + escaped - 0x10000;
                    // NaN means non-codepoint
                    // Support: Firefox
                    // Workaround erroneous numeric interpretation of +"0x"
                    return high !== high || escapedWhitespace ?
                    escaped :
                    high < 0 ?
                    // BMP codepoint
                    String.fromCharCode( high + 0x10000 ) :
                    // Supplemental Plane codepoint (surrogate pair)
                    String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
                };

                // Optimize for push.apply( _, NodeList )
                try {
                    push.apply(
                    (arr = slice.call( preferredDoc.childNodes )),
                    preferredDoc.childNodes
                    );
                    // Support: Android<4.0
                    // Detect silently failing push.apply
                    arr[ preferredDoc.childNodes.length ].nodeType;
                } catch ( e ) {
                    push = {
                        apply: arr.length ?
                        // Leverage slice if possible
                        function( target, els ) {
                            push_native.apply( target, slice.call(els) );
                        }
                        :
                        // Support: IE<9
                        // Otherwise append directly
                        function( target, els ) {
                            var j = target.length,
                            i = 0;
                            // Can't trust NodeList.length
                            while ( (target[j++] = els[i++]) ) {}
                            target.length = j - 1;
                        }
                    };
                }

                function Sizzle( selector, context, results, seed ) {
                    var match, elem, m, nodeType,
                    // QSA vars
                    i, groups, old, nid, newContext, newSelector;

                    if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
                        setDocument( context );
                    }

                    context = context || document;
                    results = results || [];

                    if ( !selector || typeof selector !== "string" ) {
                        return results;
                    }

                    if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {
                        return [];
                    }

                    if ( documentIsHTML && !seed ) {

                        // Shortcuts
                        if ( (match = rquickExpr.exec( selector )) ) {
                            // Speed-up: Sizzle("#ID")
                            if ( (m = match[1]) ) {
                                if ( nodeType === 9 ) {
                                    elem = context.getElementById( m );
                                    // Check parentNode to catch when Blackberry 4.6 returns
                                    // nodes that are no longer in the document (jQuery #6963)
                                    if ( elem && elem.parentNode ) {
                                        // Handle the case where IE, Opera, and Webkit return items
                                        // by name instead of ID
                                        if ( elem.id === m ) {
                                            results.push( elem );
                                            return results;
                                        }
                                    } else {
                                        return results;
                                    }
                                } else {
                                    // Context is not a document
                                    if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
                                    contains( context, elem ) && elem.id === m ) {
                                        results.push( elem );
                                        return results;
                                    }
                                }

                                // Speed-up: Sizzle("TAG")
                            } else if ( match[2] ) {
                                push.apply( results, context.getElementsByTagName( selector ) );
                                return results;

                                // Speed-up: Sizzle(".CLASS")
                            } else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {
                                push.apply( results, context.getElementsByClassName( m ) );
                                return results;
                            }
                        }

                        // QSA path
                        if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
                            nid = old = expando;
                            newContext = context;
                            newSelector = nodeType === 9 && selector;

                            // qSA works strangely on Element-rooted queries
                            // We can work around this by specifying an extra ID on the root
                            // and working up from there (Thanks to Andrew Dupont for the technique)
                            // IE 8 doesn't work on object elements
                            if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
                                groups = tokenize( selector );

                                if ( (old = context.getAttribute("id")) ) {
                                    nid = old.replace( rescape, "\\$&" );
                                } else {
                                    context.setAttribute( "id", nid );
                                }
                                nid = "[id='" + nid + "'] ";

                                i = groups.length;
                                while ( i-- ) {
                                    groups[i] = nid + toSelector( groups[i] );
                                }
                                newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
                                newSelector = groups.join(",");
                            }

                            if ( newSelector ) {
                                try {
                                    push.apply( results,
                                    newContext.querySelectorAll( newSelector )
                                    );
                                    return results;
                                } catch (qsaError) {} finally {
                                    if ( !old ) {
                                        context.removeAttribute("id");
                                    }
                                }
                            }
                        }
                    }

                    // All others
                    return select( selector.replace( rtrim, "$1" ), context, results, seed );
                }

                /**
                 * Create key-value caches of limited size
                 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
                 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
                 *	deleting the oldest entry
                 */
                function createCache() {
                    var keys = [];

                    function cache( key, value ) {
                        // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                        if ( keys.push( key + " " ) > Expr.cacheLength ) {
                            // Only keep the most recent entries
                            delete cache[ keys.shift() ];
                        }
                        return (cache[ key + " " ] = value);
                    }
                    return cache;
                }

                /**
                 * Mark a function for special use by Sizzle
                 * @param {Function} fn The function to mark
                 */
                function markFunction( fn ) {
                    fn[ expando ] = true;
                    return fn;
                }

                /**
                 * Support testing using an element
                 * @param {Function} fn Passed the created div and expects a boolean result
                 */
                function assert( fn ) {
                    var div = document.createElement("div");

                    try {
                        return !!fn( div );
                    } catch (e) {
                        return false;
                    } finally {
                        // Remove from its parent by default
                        if ( div.parentNode ) {
                            div.parentNode.removeChild( div );
                        }
                        // release memory in IE
                        div = null;
                    }
                }

                /**
                 * Adds the same handler for all of the specified attrs
                 * @param {String} attrs Pipe-separated list of attributes
                 * @param {Function} handler The method that will be applied
                 */
                function addHandle( attrs, handler ) {
                    var arr = attrs.split("|"),
                    i = attrs.length;

                    while ( i-- ) {
                        Expr.attrHandle[ arr[i] ] = handler;
                    }
                }

                /**
                 * Checks document order of two siblings
                 * @param {Element} a
                 * @param {Element} b
                 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
                 */
                function siblingCheck( a, b ) {
                    var cur = b && a,
                    diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
                    ( ~b.sourceIndex || MAX_NEGATIVE ) -
                    ( ~a.sourceIndex || MAX_NEGATIVE );

                    // Use IE sourceIndex if available on both nodes
                    if ( diff ) {
                        return diff;
                    }

                    // Check if b follows a
                    if ( cur ) {
                        while ( (cur = cur.nextSibling) ) {
                            if ( cur === b ) {
                                return - 1;
                            }
                        }
                    }

                    return a ? 1 : - 1;
                }

                /**
                 * Returns a function to use in pseudos for input types
                 * @param {String} type
                 */
                function createInputPseudo( type ) {
                    return function( elem ) {
                        var name = elem.nodeName.toLowerCase();
                        return name === "input" && elem.type === type;
                    };
                }

                /**
                 * Returns a function to use in pseudos for buttons
                 * @param {String} type
                 */
                function createButtonPseudo( type ) {
                    return function( elem ) {
                        var name = elem.nodeName.toLowerCase();
                        return (name === "input" || name === "button") && elem.type === type;
                    };
                }

                /**
                 * Returns a function to use in pseudos for positionals
                 * @param {Function} fn
                 */
                function createPositionalPseudo( fn ) {
                    return markFunction(function( argument ) {
                        argument = + argument;
                        return markFunction(function( seed, matches ) {
                            var j,
                            matchIndexes = fn( [], seed.length, argument ),
                            i = matchIndexes.length;

                            // Match elements found at the specified indexes
                            while ( i-- ) {
                                if ( seed[ (j = matchIndexes[i]) ] ) {
                                    seed[j] = !(matches[j] = seed[j]);
                                }
                            }
                        });
                    });
                }

                /**
                 * Checks a node for validity as a Sizzle context
                 * @param {Element|Object=} context
                 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
                 */
                function testContext( context ) {
                    return context && typeof context.getElementsByTagName !== strundefined && context;
                }

                // Expose support vars for convenience
                support = Sizzle.support = {};

                /**
                 * Detects XML nodes
                 * @param {Element|Object} elem An element or a document
                 * @returns {Boolean} True iff elem is a non-HTML XML node
                 */
                isXML = Sizzle.isXML = function( elem ) {
                    // documentElement is verified for cases where it doesn't yet exist
                    // (such as loading iframes in IE - #4833)
                    var documentElement = elem && (elem.ownerDocument || elem).documentElement;
                    return documentElement ? documentElement.nodeName !== "HTML" : false;
                };

                /**
                 * Sets document-related variables once based on the current document
                 * @param {Element|Object} [doc] An element or document object to use to set the document
                 * @returns {Object} Returns the current document
                 */
                setDocument = Sizzle.setDocument = function( node ) {
                    var hasCompare,
                    doc = node ? node.ownerDocument || node : preferredDoc,
                    parent = doc.defaultView;

                    // If no document and documentElement is available, return
                    if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
                        return document;
                    }

                    // Set our document
                    document = doc;
                    docElem = doc.documentElement;

                    // Support tests
                    documentIsHTML = !isXML( doc );

                    // Support: IE>8
                    // If iframe document is assigned to "document" variable and if iframe has been reloaded,
                    // IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
                    // IE6-8 do not support the defaultView property so parent will be undefined
                    if ( parent && parent !== parent.top ) {
                        // IE11 does not have attachEvent, so all must suffer
                        if ( parent.addEventListener ) {
                            parent.addEventListener( "unload", function() {
                                setDocument();
                            }, false );
                        } else if ( parent.attachEvent ) {
                            parent.attachEvent( "onunload", function() {
                                setDocument();
                            });
                        }
                    }

                    /* Attributes
                    	---------------------------------------------------------------------- */

                    // Support: IE<8
                    // Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
                    support.attributes = assert(function( div ) {
                        div.className = "i";
                        return !div.getAttribute("className");
                    });

                    /* getElement(s)By*
                    	---------------------------------------------------------------------- */

                    // Check if getElementsByTagName("*") returns only elements
                    support.getElementsByTagName = assert(function( div ) {
                        div.appendChild( doc.createComment("") );
                        return !div.getElementsByTagName("*").length;
                    });

                    // Check if getElementsByClassName can be trusted
                    support.getElementsByClassName = rnative.test( doc.getElementsByClassName ) && assert(function( div ) {
                        div.innerHTML = "<div class='a'></div><div class='a i'></div>";

                        // Support: Safari<4
                        // Catch class over-caching
                        div.firstChild.className = "i";
                        // Support: Opera<10
                        // Catch gEBCN failure to find non-leading classes
                        return div.getElementsByClassName("i").length === 2;
                    });

                    // Support: IE<10
                    // Check if getElementById returns elements by name
                    // The broken getElementById methods don't pick up programatically-set names,
                    // so use a roundabout getElementsByName test
                    support.getById = assert(function( div ) {
                        docElem.appendChild( div ).id = expando;
                        return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
                    });

                    // ID find and filter
                    if ( support.getById ) {
                        Expr.find["ID"] = function( id, context ) {
                            if ( typeof context.getElementById !== strundefined && documentIsHTML ) {
                                var m = context.getElementById( id );
                                // Check parentNode to catch when Blackberry 4.6 returns
                                // nodes that are no longer in the document #6963
                                return m && m.parentNode ? [m] : [];
                            }
                        };
                        Expr.filter["ID"] = function( id ) {
                            var attrId = id.replace( runescape, funescape );
                            return function( elem ) {
                                return elem.getAttribute("id") === attrId;
                            };
                        };
                    } else {
                        // Support: IE6/7
                        // getElementById is not reliable as a find shortcut
                        delete Expr.find["ID"];

                        Expr.filter["ID"] = function( id ) {
                            var attrId = id.replace( runescape, funescape );
                            return function( elem ) {
                                var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
                                return node && node.value === attrId;
                            };
                        };
                    }

                    // Tag
                    Expr.find["TAG"] = support.getElementsByTagName ?
                    function( tag, context ) {
                        if ( typeof context.getElementsByTagName !== strundefined ) {
                            return context.getElementsByTagName( tag );
                        }
                    } :
                    function( tag, context ) {
                        var elem,
                        tmp = [],
                        i = 0,
                        results = context.getElementsByTagName( tag );

                        // Filter out possible comments
                        if ( tag === "*" ) {
                            while ( (elem = results[i++]) ) {
                                if ( elem.nodeType === 1 ) {
                                    tmp.push( elem );
                                }
                            }

                            return tmp;
                        }
                        return results;
                    };

                    // Class
                    Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
                        if ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {
                            return context.getElementsByClassName( className );
                        }
                    };

                    /* QSA/matchesSelector
                    	---------------------------------------------------------------------- */

                    // QSA and matchesSelector support

                    // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
                    rbuggyMatches = [];

                    // qSa(:focus) reports false when true (Chrome 21)
                    // We allow this because of a bug in IE8/9 that throws an error
                    // whenever `document.activeElement` is accessed on an iframe
                    // So, we allow :focus to pass through QSA all the time to avoid the IE error
                    // See http://bugs.jquery.com/ticket/13378
                    rbuggyQSA = [];

                    if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
                        // Build QSA regex
                        // Regex strategy adopted from Diego Perini
                        assert(function( div ) {
                            // Select is set to empty string on purpose
                            // This is to test IE's treatment of not explicitly
                            // setting a boolean content attribute,
                            // since its presence should be enough
                            // http://bugs.jquery.com/ticket/12359
                            div.innerHTML = "<select t=''><option selected=''></option></select>";

                            // Support: IE8, Opera 10-12
                            // Nothing should be selected when empty strings follow ^= or $= or *=
                            if ( div.querySelectorAll("[t^='']").length ) {
                                rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
                            }

                            // Support: IE8
                            // Boolean attributes and "value" are not treated correctly
                            if ( !div.querySelectorAll("[selected]").length ) {
                                rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
                            }

                            // Webkit/Opera - :checked should return selected option elements
                            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                            // IE8 throws error here and will not see later tests
                            if ( !div.querySelectorAll(":checked").length ) {
                                rbuggyQSA.push(":checked");
                            }
                        });

                        assert(function( div ) {
                            // Support: Windows 8 Native Apps
                            // The type and name attributes are restricted during .innerHTML assignment
                            var input = doc.createElement("input");
                            input.setAttribute( "type", "hidden" );
                            div.appendChild( input ).setAttribute( "name", "D" );

                            // Support: IE8
                            // Enforce case-sensitivity of name attribute
                            if ( div.querySelectorAll("[name=d]").length ) {
                                rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
                            }

                            // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                            // IE8 throws error here and will not see later tests
                            if ( !div.querySelectorAll(":enabled").length ) {
                                rbuggyQSA.push( ":enabled", ":disabled" );
                            }

                            // Opera 10-11 does not throw on post-comma invalid pseudos
                            div.querySelectorAll("*,:x");
                            rbuggyQSA.push(",.*:");
                        });
                    }

                    if ( (support.matchesSelector = rnative.test( (matches = docElem.webkitMatchesSelector ||
                    docElem.mozMatchesSelector ||
                    docElem.oMatchesSelector ||
                    docElem.msMatchesSelector) )) ) {

                        assert(function( div ) {
                            // Check to see if it's possible to do matchesSelector
                            // on a disconnected node (IE 9)
                            support.disconnectedMatch = matches.call( div, "div" );

                            // This should fail with an exception
                            // Gecko does not error, returns false instead
                            matches.call( div, "[s!='']:x" );
                            rbuggyMatches.push( "!=", pseudos );
                        });
                    }

                    rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
                    rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

                    /* Contains
                    	---------------------------------------------------------------------- */
                    hasCompare = rnative.test( docElem.compareDocumentPosition );

                    // Element contains another
                    // Purposefully does not implement inclusive descendent
                    // As in, an element does not contain itself
                    contains = hasCompare || rnative.test( docElem.contains ) ?
                    function( a, b ) {
                        var adown = a.nodeType === 9 ? a.documentElement : a,
                        bup = b && b.parentNode;
                        return a === bup || !!( bup && bup.nodeType === 1 && (
                        adown.contains ?
                        adown.contains( bup ) :
                        a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
                        ));
                    } :
                    function( a, b ) {
                        if ( b ) {
                            while ( (b = b.parentNode) ) {
                                if ( b === a ) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    };

                    /* Sorting
                    	---------------------------------------------------------------------- */

                    // Document order sorting
                    sortOrder = hasCompare ?
                    function( a, b ) {

                        // Flag for duplicate removal
                        if ( a === b ) {
                            hasDuplicate = true;
                            return 0;
                        }

                        // Sort on method existence if only one input has compareDocumentPosition
                        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                        if ( compare ) {
                            return compare;
                        }

                        // Calculate position if both inputs belong to the same document
                        compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
                        a.compareDocumentPosition( b ) :
                        // Otherwise we know they are disconnected
                        1;

                        // Disconnected nodes
                        if ( compare & 1 ||
                        (!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

                            // Choose the first element that is related to our preferred document
                            if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
                                return - 1;
                            }
                            if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
                                return 1;
                            }

                            // Maintain original order
                            return sortInput ?
                            ( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
                            0;
                        }

                        return compare & 4 ? - 1 : 1;
                    } :
                    function( a, b ) {
                        // Exit early if the nodes are identical
                        if ( a === b ) {
                            hasDuplicate = true;
                            return 0;
                        }

                        var cur,
                        i = 0,
                        aup = a.parentNode,
                        bup = b.parentNode,
                        ap = [ a ],
                        bp = [ b ];

                        // Parentless nodes are either documents or disconnected
                        if ( !aup || !bup ) {
                            return a === doc ? - 1 :
                            b === doc ? 1 :
                            aup ? - 1 :
                            bup ? 1 :
                            sortInput ?
                            ( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
                            0;

                            // If the nodes are siblings, we can do a quick check
                        } else if ( aup === bup ) {
                            return siblingCheck( a, b );
                        }

                        // Otherwise we need full lists of their ancestors for comparison
                        cur = a;
                        while ( (cur = cur.parentNode) ) {
                            ap.unshift( cur );
                        }
                        cur = b;
                        while ( (cur = cur.parentNode) ) {
                            bp.unshift( cur );
                        }

                        // Walk down the tree looking for a discrepancy
                        while ( ap[i] === bp[i] ) {
                            i++;
                        }

                        return i ?
                        // Do a sibling check if the nodes have a common ancestor
                        siblingCheck( ap[i], bp[i] ) :
                        // Otherwise nodes in our document sort first
                        ap[i] === preferredDoc ? - 1 :
                        bp[i] === preferredDoc ? 1 :
                        0;
                    };

                    return doc;
                };

                Sizzle.matches = function( expr, elements ) {
                    return Sizzle( expr, null, null, elements );
                };

                Sizzle.matchesSelector = function( elem, expr ) {
                    // Set document vars if needed
                    if ( ( elem.ownerDocument || elem ) !== document ) {
                        setDocument( elem );
                    }

                    // Make sure that attribute selectors are quoted
                    expr = expr.replace( rattributeQuotes, "='$1']" );

                    if ( support.matchesSelector && documentIsHTML &&
                    ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
                    ( !rbuggyQSA || !rbuggyQSA.test( expr ) ) ) {

                        try {
                            var ret = matches.call( elem, expr );

                            // IE 9's matchesSelector returns false on disconnected nodes
                            if ( ret || support.disconnectedMatch ||
                            // As well, disconnected nodes are said to be in a document
                            // fragment in IE 9
                            elem.document && elem.document.nodeType !== 11 ) {
                                return ret;
                            }
                        } catch (e) {}
                    }

                    return Sizzle( expr, document, null, [elem] ).length > 0;
                };

                Sizzle.contains = function( context, elem ) {
                    // Set document vars if needed
                    if ( ( context.ownerDocument || context ) !== document ) {
                        setDocument( context );
                    }
                    return contains( context, elem );
                };

                Sizzle.attr = function( elem, name ) {
                    // Set document vars if needed
                    if ( ( elem.ownerDocument || elem ) !== document ) {
                        setDocument( elem );
                    }

                    var fn = Expr.attrHandle[ name.toLowerCase() ],
                    // Don't get fooled by Object.prototype properties (jQuery #13807)
                    val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
                    fn( elem, name, !documentIsHTML ) :
                    undefined;

                    return val !== undefined ?
                    val :
                    support.attributes || !documentIsHTML ?
                    elem.getAttribute( name ) :
                    (val = elem.getAttributeNode(name)) && val.specified ?
                    val.value :
                    null;
                };

                Sizzle.error = function( msg ) {
                    throw new Error( "Syntax error, unrecognized expression: " + msg );
                };

                /**
                 * Document sorting and removing duplicates
                 * @param {ArrayLike} results
                 */
                Sizzle.uniqueSort = function( results ) {
                    var elem,
                    duplicates = [],
                    j = 0,
                    i = 0;

                    // Unless we *know* we can detect duplicates, assume their presence
                    hasDuplicate = !support.detectDuplicates;
                    sortInput = !support.sortStable && results.slice( 0 );
                    results.sort( sortOrder );

                    if ( hasDuplicate ) {
                        while ( (elem = results[i++]) ) {
                            if ( elem === results[ i ] ) {
                                j = duplicates.push( i );
                            }
                        }
                        while ( j-- ) {
                            results.splice( duplicates[ j ], 1 );
                        }
                    }

                    // Clear input after sorting to release objects
                    // See https://github.com/jquery/sizzle/pull/225
                    sortInput = null;

                    return results;
                };

                /**
                 * Utility function for retrieving the text value of an array of DOM nodes
                 * @param {Array|Element} elem
                 */
                getText = Sizzle.getText = function( elem ) {
                    var node,
                    ret = "",
                    i = 0,
                    nodeType = elem.nodeType;

                    if ( !nodeType ) {
                        // If no nodeType, this is expected to be an array
                        while ( (node = elem[i++]) ) {
                            // Do not traverse comment nodes
                            ret += getText( node );
                        }
                    } else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
                        // Use textContent for elements
                        // innerText usage removed for consistency of new lines (jQuery #11153)
                        if ( typeof elem.textContent === "string" ) {
                            return elem.textContent;
                        } else {
                            // Traverse its children
                            for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                                ret += getText( elem );
                            }
                        }
                    } else if ( nodeType === 3 || nodeType === 4 ) {
                        return elem.nodeValue;
                    }
                    // Do not include comment or processing instruction nodes

                    return ret;
                };

                Expr = Sizzle.selectors = {

                    // Can be adjusted by the user
                    cacheLength: 50,

                    createPseudo: markFunction,

                    match: matchExpr,

                    attrHandle: {},

                    find: {},

                    relative: {
                        ">": {
                            dir: "parentNode",
                            first: true 
                        },
                        " ": {
                            dir: "parentNode" 
                        },
                        "+": {
                            dir: "previousSibling",
                            first: true 
                        },
                        "~": {
                            dir: "previousSibling" 
                        }
                    },

                    preFilter: {
                        "ATTR": function( match ) {
                            match[1] = match[1].replace( runescape, funescape );

                            // Move the given value to match[3] whether quoted or unquoted
                            match[3] = ( match[4] || match[5] || "" ).replace( runescape, funescape );

                            if ( match[2] === "~=" ) {
                                match[3] = " " + match[3] + " ";
                            }

                            return match.slice( 0, 4 );
                        },

                        "CHILD": function( match ) {
                            /* matches from matchExpr["CHILD"]
                            				1 type (only|nth|...)
                            				2 what (child|of-type)
                            				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
                            				4 xn-component of xn+y argument ([+-]?\d*n|)
                            				5 sign of xn-component
                            				6 x of xn-component
                            				7 sign of y-component
                            				8 y of y-component
                            			*/
                            match[1] = match[1].toLowerCase();

                            if ( match[1].slice( 0, 3 ) === "nth" ) {
                                // nth-* requires argument
                                if ( !match[3] ) {
                                    Sizzle.error( match[0] );
                                }

                                // numeric x and y parameters for Expr.filter.CHILD
                                // remember that false/true cast respectively to 0/1
                                match[4] = + ( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
                                match[5] = + ( ( match[7] + match[8] ) || match[3] === "odd" );

                                // other types prohibit arguments
                            } else if ( match[3] ) {
                                Sizzle.error( match[0] );
                            }

                            return match;
                        },

                        "PSEUDO": function( match ) {
                            var excess,
                            unquoted = !match[5] && match[2];

                            if ( matchExpr["CHILD"].test( match[0] ) ) {
                                return null;
                            }

                            // Accept quoted arguments as-is
                            if ( match[3] && match[4] !== undefined ) {
                                match[2] = match[4];

                                // Strip excess characters from unquoted arguments
                            } else if ( unquoted && rpseudo.test( unquoted ) &&
                            // Get excess from tokenize (recursively)
                            (excess = tokenize( unquoted, true )) &&
                            // advance to the next closing parenthesis
                            (excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

                                // excess is a negative index
                                match[0] = match[0].slice( 0, excess );
                                match[2] = unquoted.slice( 0, excess );
                            }

                            // Return only captures needed by the pseudo filter method (type and argument)
                            return match.slice( 0, 3 );
                        }
                    },

                    filter: {

                        "TAG": function( nodeNameSelector ) {
                            var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
                            return nodeNameSelector === "*" ?
                            function() {
                                return true;
                            } :
                            function( elem ) {
                                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                            };
                        },

                        "CLASS": function( className ) {
                            var pattern = classCache[ className + " " ];

                            return pattern ||
                            (pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
                            classCache( className, function( elem ) {
                                return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "" );
                            });
                        },

                        "ATTR": function( name, operator, check ) {
                            return function( elem ) {
                                var result = Sizzle.attr( elem, name );

                                if ( result == null ) {
                                    return operator === "!=";
                                }
                                if ( !operator ) {
                                    return true;
                                }

                                result += "";

                                return operator === "=" ? result === check :
                                operator === "!=" ? result !== check :
                                operator === "^=" ? check && result.indexOf( check ) === 0 :
                                operator === "*=" ? check && result.indexOf( check ) > - 1 :
                                operator === "$=" ? check && result.slice( - check.length ) === check :
                                operator === "~=" ? ( " " + result + " " ).indexOf( check ) > - 1 :
                                operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
                                false;
                            };
                        },

                        "CHILD": function( type, what, argument, first, last ) {
                            var simple = type.slice( 0, 3 ) !== "nth",
                            forward = type.slice( - 4 ) !== "last",
                            ofType = what === "of-type";

                            return first === 1 && last === 0 ?
                            // Shortcut for :nth-*(n)
                            function( elem ) {
                                return !!elem.parentNode;
                            } :
                            function( elem, context, xml ) {
                                var cache, outerCache, node, diff, nodeIndex, start,
                                dir = simple !== forward ? "nextSibling" : "previousSibling",
                                parent = elem.parentNode,
                                name = ofType && elem.nodeName.toLowerCase(),
                                useCache = !xml && !ofType;

                                if ( parent ) {

                                    // :(first|last|only)-(child|of-type)
                                    if ( simple ) {
                                        while ( dir ) {
                                            node = elem;
                                            while ( (node = node[ dir ]) ) {
                                                if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
                                                    return false;
                                                }
                                            }
                                            // Reverse direction for :only-* (if we haven't yet done so)
                                            start = dir = type === "only" && !start && "nextSibling";
                                        }
                                        return true;
                                    }

                                    start = [ forward ? parent.firstChild : parent.lastChild ];

                                    // non-xml :nth-child(...) stores cache data on `parent`
                                    if ( forward && useCache ) {
                                        // Seek `elem` from a previously-cached index
                                        outerCache = parent[ expando ] || (parent[ expando ] = {});
                                        cache = outerCache[ type ] || [];
                                        nodeIndex = cache[0] === dirruns && cache[1];
                                        diff = cache[0] === dirruns && cache[2];
                                        node = nodeIndex && parent.childNodes[ nodeIndex ];

                                        while ( (node = ++nodeIndex && node && node[ dir ] ||
                                        // Fallback to seeking `elem` from the start
                                        (diff = nodeIndex = 0) || start.pop()) ) {

                                            // When found, cache indexes on `parent` and break
                                            if ( node.nodeType === 1 && ++diff && node === elem ) {
                                                outerCache[ type ] = [ dirruns, nodeIndex, diff ];
                                                break;
                                            }
                                        }

                                        // Use previously-cached element index if available
                                    } else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
                                        diff = cache[1];

                                        // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                    } else {
                                        // Use the same loop as above to seek `elem` from the start
                                        while ( (node = ++nodeIndex && node && node[ dir ] ||
                                        (diff = nodeIndex = 0) || start.pop()) ) {

                                            if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
                                                // Cache the index of each encountered element
                                                if ( useCache ) {
                                                    (node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
                                                }

                                                if ( node === elem ) {
                                                    break;
                                                }
                                            }
                                        }
                                    }

                                    // Incorporate the offset, then check against cycle size
                                    diff -= last;
                                    return diff === first || ( diff % first === 0 && diff / first >= 0 );
                                }
                            };
                        },

                        "PSEUDO": function( pseudo, argument ) {
                            // pseudo-class names are case-insensitive
                            // http://www.w3.org/TR/selectors/#pseudo-classes
                            // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                            // Remember that setFilters inherits from pseudos
                            var args,
                            fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
                            Sizzle.error( "unsupported pseudo: " + pseudo );

                            // The user may use createPseudo to indicate that
                            // arguments are needed to create the filter function
                            // just as Sizzle does
                            if ( fn[ expando ] ) {
                                return fn( argument );
                            }

                            // But maintain support for old signatures
                            if ( fn.length > 1 ) {
                                args = [ pseudo, pseudo, "", argument ];
                                return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
                                markFunction(function( seed, matches ) {
                                    var idx,
                                    matched = fn( seed, argument ),
                                    i = matched.length;
                                    while ( i-- ) {
                                        idx = indexOf.call( seed, matched[i] );
                                        seed[ idx ] = !( matches[ idx ] = matched[i] );
                                    }
                                }) :
                                function( elem ) {
                                    return fn( elem, 0, args );
                                };
                            }

                            return fn;
                        }
                    },

                    pseudos: {
                        // Potentially complex pseudos
                        "not": markFunction(function( selector ) {
                            // Trim the selector passed to compile
                            // to avoid treating leading and trailing
                            // spaces as combinators
                            var input = [],
                            results = [],
                            matcher = compile( selector.replace( rtrim, "$1" ) );

                            return matcher[ expando ] ?
                            markFunction(function( seed, matches, context, xml ) {
                                var elem,
                                unmatched = matcher( seed, null, xml, [] ),
                                i = seed.length;

                                // Match elements unmatched by `matcher`
                                while ( i-- ) {
                                    if ( (elem = unmatched[i]) ) {
                                        seed[i] = !(matches[i] = elem);
                                    }
                                }
                            }) :
                            function( elem, context, xml ) {
                                input[0] = elem;
                                matcher( input, null, xml, results );
                                return !results.pop();
                            };
                        }),

                        "has": markFunction(function( selector ) {
                            return function( elem ) {
                                return Sizzle( selector, elem ).length > 0;
                            };
                        }),

                        "contains": markFunction(function( text ) {
                            return function( elem ) {
                                return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > - 1;
                            };
                        }),

                        // "Whether an element is represented by a :lang() selector
                        // is based solely on the element's language value
                        // being equal to the identifier C,
                        // or beginning with the identifier C immediately followed by "-".
                        // The matching of C against the element's language value is performed case-insensitively.
                        // The identifier C does not have to be a valid language name."
                        // http://www.w3.org/TR/selectors/#lang-pseudo
                        "lang": markFunction( function( lang ) {
                            // lang value must be a valid identifier
                            if ( !ridentifier.test(lang || "") ) {
                                Sizzle.error( "unsupported lang: " + lang );
                            }
                            lang = lang.replace( runescape, funescape ).toLowerCase();
                            return function( elem ) {
                                var elemLang;
                                do {
                                    if ( (elemLang = documentIsHTML ?
                                    elem.lang :
                                    elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

                                        elemLang = elemLang.toLowerCase();
                                        return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
                                    }
                                }
                                while ( (elem = elem.parentNode) && elem.nodeType === 1 );
                                return false;
                            };
                        }),

                        // Miscellaneous
                        "target": function( elem ) {
                            var hash = window.location && window.location.hash;
                            return hash && hash.slice( 1 ) === elem.id;
                        },

                        "root": function( elem ) {
                            return elem === docElem;
                        },

                        "focus": function( elem ) {
                            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                        },

                        // Boolean properties
                        "enabled": function( elem ) {
                            return elem.disabled === false;
                        },

                        "disabled": function( elem ) {
                            return elem.disabled === true;
                        },

                        "checked": function( elem ) {
                            // In CSS3, :checked should return both checked and selected elements
                            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                            var nodeName = elem.nodeName.toLowerCase();
                            return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
                        },

                        "selected": function( elem ) {
                            // Accessing this property makes selected-by-default
                            // options in Safari work properly
                            if ( elem.parentNode ) {
                                elem.parentNode.selectedIndex;
                            }

                            return elem.selected === true;
                        },

                        // Contents
                        "empty": function( elem ) {
                            // http://www.w3.org/TR/selectors/#empty-pseudo
                            // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                            //   but not by others (comment: 8; processing instruction: 7; etc.)
                            // nodeType < 6 works because attributes (2) do not appear as children
                            for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                                if ( elem.nodeType < 6 ) {
                                    return false;
                                }
                            }
                            return true;
                        },

                        "parent": function( elem ) {
                            return !Expr.pseudos["empty"]( elem );
                        },

                        // Element/input types
                        "header": function( elem ) {
                            return rheader.test( elem.nodeName );
                        },

                        "input": function( elem ) {
                            return rinputs.test( elem.nodeName );
                        },

                        "button": function( elem ) {
                            var name = elem.nodeName.toLowerCase();
                            return name === "input" && elem.type === "button" || name === "button";
                        },

                        "text": function( elem ) {
                            var attr;
                            return elem.nodeName.toLowerCase() === "input" &&
                            elem.type === "text" &&
                            // Support: IE<8
                            // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                            ( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
                        },

                        // Position-in-collection
                        "first": createPositionalPseudo(function() {
                            return [ 0 ];
                        }),

                        "last": createPositionalPseudo(function( matchIndexes, length ) {
                            return [ length - 1 ];
                        }),

                        "eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
                            return [ argument < 0 ? argument + length : argument ];
                        }),

                        "even": createPositionalPseudo(function( matchIndexes, length ) {
                            var i = 0;
                            for ( ; i < length; i += 2 ) {
                                matchIndexes.push( i );
                            }
                            return matchIndexes;
                        }),

                        "odd": createPositionalPseudo(function( matchIndexes, length ) {
                            var i = 1;
                            for ( ; i < length; i += 2 ) {
                                matchIndexes.push( i );
                            }
                            return matchIndexes;
                        }),

                        "lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
                            var i = argument < 0 ? argument + length : argument;
                            for ( ; --i >= 0; ) {
                                matchIndexes.push( i );
                            }
                            return matchIndexes;
                        }),

                        "gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
                            var i = argument < 0 ? argument + length : argument;
                            for ( ; ++i < length; ) {
                                matchIndexes.push( i );
                            }
                            return matchIndexes;
                        })
                    }
                };

                Expr.pseudos["nth"] = Expr.pseudos["eq"];

                // Add button/input type pseudos
                for ( i in {
                    radio: true,
                    checkbox: true,
                    file: true,
                    password: true,
                    image: true 
                }) {
                    Expr.pseudos[ i ] = createInputPseudo( i );
                }
                for ( i in {
                    submit: true,
                    reset: true 
                }) {
                    Expr.pseudos[ i ] = createButtonPseudo( i );
                }

                // Easy API for creating new setFilters
                function setFilters() {}
                setFilters.prototype = Expr.filters = Expr.pseudos;
                Expr.setFilters = new setFilters();

                function tokenize( selector, parseOnly ) {
                    var matched, match, tokens, type,
                    soFar, groups, preFilters,
                    cached = tokenCache[ selector + " " ];

                    if ( cached ) {
                        return parseOnly ? 0 : cached.slice( 0 );
                    }

                    soFar = selector;
                    groups = [];
                    preFilters = Expr.preFilter;

                    while ( soFar ) {

                        // Comma and first run
                        if ( !matched || (match = rcomma.exec( soFar )) ) {
                            if ( match ) {
                                // Don't consume trailing commas as valid
                                soFar = soFar.slice( match[0].length ) || soFar;
                            }
                            groups.push( (tokens = []) );
                        }

                        matched = false;

                        // Combinators
                        if ( (match = rcombinators.exec( soFar )) ) {
                            matched = match.shift();
                            tokens.push({
                                value: matched,
                                // Cast descendant combinators to space
                                type: match[0].replace( rtrim, " " )
                            });
                            soFar = soFar.slice( matched.length );
                        }

                        // Filters
                        for ( type in Expr.filter ) {
                            if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
                            (match = preFilters[ type ]( match ))) ) {
                                matched = match.shift();
                                tokens.push({
                                    value: matched,
                                    type: type,
                                    matches: match
                                });
                                soFar = soFar.slice( matched.length );
                            }
                        }

                        if ( !matched ) {
                            break;
                        }
                    }

                    // Return the length of the invalid excess
                    // if we're just parsing
                    // Otherwise, throw an error or return tokens
                    return parseOnly ?
                    soFar.length :
                    soFar ?
                    Sizzle.error( selector ) :
                    // Cache the tokens
                    tokenCache( selector, groups ).slice( 0 );
                }

                function toSelector( tokens ) {
                    var i = 0,
                    len = tokens.length,
                    selector = "";
                    for ( ; i < len; i++ ) {
                        selector += tokens[i].value;
                    }
                    return selector;
                }

                function addCombinator( matcher, combinator, base ) {
                    var dir = combinator.dir,
                    checkNonElements = base && dir === "parentNode",
                    doneName = done++;

                    return combinator.first ?
                    // Check against closest ancestor/preceding element
                    function( elem, context, xml ) {
                        while ( (elem = elem[ dir ]) ) {
                            if ( elem.nodeType === 1 || checkNonElements ) {
                                return matcher( elem, context, xml );
                            }
                        }
                    } :
                    // Check against all ancestor/preceding elements
                    function( elem, context, xml ) {
                        var oldCache, outerCache,
                        newCache = [ dirruns, doneName ];

                        // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
                        if ( xml ) {
                            while ( (elem = elem[ dir ]) ) {
                                if ( elem.nodeType === 1 || checkNonElements ) {
                                    if ( matcher( elem, context, xml ) ) {
                                        return true;
                                    }
                                }
                            }
                        } else {
                            while ( (elem = elem[ dir ]) ) {
                                if ( elem.nodeType === 1 || checkNonElements ) {
                                    outerCache = elem[ expando ] || (elem[ expando ] = {});
                                    if ( (oldCache = outerCache[ dir ]) &&
                                    oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

                                        // Assign to newCache so results back-propagate to previous elements
                                        return (newCache[ 2 ] = oldCache[ 2 ]);
                                    } else {
                                        // Reuse newcache so results back-propagate to previous elements
                                        outerCache[ dir ] = newCache;

                                        // A match means we're done; a fail means we have to keep checking
                                        if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
                                            return true;
                                        }
                                    }
                                }
                            }
                        }
                    };
                }

                function elementMatcher( matchers ) {
                    return matchers.length > 1 ?
                    function( elem, context, xml ) {
                        var i = matchers.length;
                        while ( i-- ) {
                            if ( !matchers[i]( elem, context, xml ) ) {
                                return false;
                            }
                        }
                        return true;
                    } :
                    matchers[0];
                }

                function condense( unmatched, map, filter, context, xml ) {
                    var elem,
                    newUnmatched = [],
                    i = 0,
                    len = unmatched.length,
                    mapped = map != null;

                    for ( ; i < len; i++ ) {
                        if ( (elem = unmatched[i]) ) {
                            if ( !filter || filter( elem, context, xml ) ) {
                                newUnmatched.push( elem );
                                if ( mapped ) {
                                    map.push( i );
                                }
                            }
                        }
                    }

                    return newUnmatched;
                }

                function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
                    if ( postFilter && !postFilter[ expando ] ) {
                        postFilter = setMatcher( postFilter );
                    }
                    if ( postFinder && !postFinder[ expando ] ) {
                        postFinder = setMatcher( postFinder, postSelector );
                    }
                    return markFunction(function( seed, results, context, xml ) {
                        var temp, i, elem,
                        preMap = [],
                        postMap = [],
                        preexisting = results.length,
                        // Get initial elements from seed or context
                        elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),
                        // Prefilter to get matcher input, preserving a map for seed-results synchronization
                        matcherIn = preFilter && ( seed || !selector ) ?
                        condense( elems, preMap, preFilter, context, xml ) :
                        elems,
                        matcherOut = matcher ?
                        // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                        postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
                        // ...intermediate processing is necessary
                        [] :
                        // ...otherwise use results directly
                        results :
                        matcherIn;

                        // Find primary matches
                        if ( matcher ) {
                            matcher( matcherIn, matcherOut, context, xml );
                        }

                        // Apply postFilter
                        if ( postFilter ) {
                            temp = condense( matcherOut, postMap );
                            postFilter( temp, [], context, xml );

                            // Un-match failing elements by moving them back to matcherIn
                            i = temp.length;
                            while ( i-- ) {
                                if ( (elem = temp[i]) ) {
                                    matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
                                }
                            }
                        }

                        if ( seed ) {
                            if ( postFinder || preFilter ) {
                                if ( postFinder ) {
                                    // Get the final matcherOut by condensing this intermediate into postFinder contexts
                                    temp = [];
                                    i = matcherOut.length;
                                    while ( i-- ) {
                                        if ( (elem = matcherOut[i]) ) {
                                            // Restore matcherIn since elem is not yet a final match
                                            temp.push( (matcherIn[i] = elem) );
                                        }
                                    }
                                    postFinder( null, (matcherOut = []), temp, xml );
                                }

                                // Move matched elements from seed to results to keep them synchronized
                                i = matcherOut.length;
                                while ( i-- ) {
                                    if ( (elem = matcherOut[i]) &&
                                    (temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > - 1 ) {

                                        seed[temp] = !(results[temp] = elem);
                                    }
                                }
                            }

                            // Add elements to results, through postFinder if defined
                        } else {
                            matcherOut = condense(
                            matcherOut === results ?
                            matcherOut.splice( preexisting, matcherOut.length ) :
                            matcherOut
                            );
                            if ( postFinder ) {
                                postFinder( null, results, matcherOut, xml );
                            } else {
                                push.apply( results, matcherOut );
                            }
                        }
                    });
                }

                function matcherFromTokens( tokens ) {
                    var checkContext, matcher, j,
                    len = tokens.length,
                    leadingRelative = Expr.relative[ tokens[0].type ],
                    implicitRelative = leadingRelative || Expr.relative[" "],
                    i = leadingRelative ? 1 : 0,
                    // The foundational matcher ensures that elements are reachable from top-level context(s)
                    matchContext = addCombinator( function( elem ) {
                        return elem === checkContext;
                    }, implicitRelative, true ),
                    matchAnyContext = addCombinator( function( elem ) {
                        return indexOf.call( checkContext, elem ) > - 1;
                    }, implicitRelative, true ),
                    matchers = [ function( elem, context, xml ) {
                        return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
                        (checkContext = context).nodeType ?
                        matchContext( elem, context, xml ) :
                        matchAnyContext( elem, context, xml ) );
                    }
                    ];

                    for ( ; i < len; i++ ) {
                        if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
                            matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
                        } else {
                            matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

                            // Return special upon seeing a positional matcher
                            if ( matcher[ expando ] ) {
                                // Find the next relative operator (if any) for proper handling
                                j = ++i;
                                for ( ; j < len; j++ ) {
                                    if ( Expr.relative[ tokens[j].type ] ) {
                                        break;
                                    }
                                }
                                return setMatcher(
                                i > 1 && elementMatcher( matchers ),
                                i > 1 && toSelector(
                                // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                                tokens.slice( 0, i - 1 ).concat({
                                    value: tokens[ i - 2 ].type === " " ? "*" : "" 
                                })
                                ).replace( rtrim, "$1" ),
                                matcher,
                                i < j && matcherFromTokens( tokens.slice( i, j ) ),
                                j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
                                j < len && toSelector( tokens )
                                );
                            }
                            matchers.push( matcher );
                        }
                    }

                    return elementMatcher( matchers );
                }

                function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
                    var bySet = setMatchers.length > 0,
                    byElement = elementMatchers.length > 0,
                    superMatcher = function( seed, context, xml, results, outermost ) {
                        var elem, j, matcher,
                        matchedCount = 0,
                        i = "0",
                        unmatched = seed && [],
                        setMatched = [],
                        contextBackup = outermostContext,
                        // We must always have either seed elements or outermost context
                        elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
                        // Use integer dirruns iff this is the outermost matcher
                        dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                        len = elems.length;

                        if ( outermost ) {
                            outermostContext = context !== document && context;
                        }

                        // Add elements passing elementMatchers directly to results
                        // Keep `i` a string if there are no elements so `matchedCount` will be "00" below
                        // Support: IE<9, Safari
                        // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                        for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
                            if ( byElement && elem ) {
                                j = 0;
                                while ( (matcher = elementMatchers[j++]) ) {
                                    if ( matcher( elem, context, xml ) ) {
                                        results.push( elem );
                                        break;
                                    }
                                }
                                if ( outermost ) {
                                    dirruns = dirrunsUnique;
                                }
                            }

                            // Track unmatched elements for set filters
                            if ( bySet ) {
                                // They will have gone through all possible matchers
                                if ( (elem = !matcher && elem) ) {
                                    matchedCount--;
                                }

                                // Lengthen the array for every element, matched or not
                                if ( seed ) {
                                    unmatched.push( elem );
                                }
                            }
                        }

                        // Apply set filters to unmatched elements
                        matchedCount += i;
                        if ( bySet && i !== matchedCount ) {
                            j = 0;
                            while ( (matcher = setMatchers[j++]) ) {
                                matcher( unmatched, setMatched, context, xml );
                            }

                            if ( seed ) {
                                // Reintegrate element matches to eliminate the need for sorting
                                if ( matchedCount > 0 ) {
                                    while ( i-- ) {
                                        if ( !(unmatched[i] || setMatched[i]) ) {
                                            setMatched[i] = pop.call( results );
                                        }
                                    }
                                }

                                // Discard index placeholder values to get only actual matches
                                setMatched = condense( setMatched );
                            }

                            // Add matches to results
                            push.apply( results, setMatched );

                            // Seedless set matches succeeding multiple successful matchers stipulate sorting
                            if ( outermost && !seed && setMatched.length > 0 &&
                            ( matchedCount + setMatchers.length ) > 1 ) {

                                Sizzle.uniqueSort( results );
                            }
                        }

                        // Override manipulation of globals by nested matchers
                        if ( outermost ) {
                            dirruns = dirrunsUnique;
                            outermostContext = contextBackup;
                        }

                        return unmatched;
                    };

                    return bySet ?
                    markFunction( superMatcher ) :
                    superMatcher;
                }

                compile = Sizzle.compile = function( selector, group /* Internal Use Only */
                ) {
                    var i,
                    setMatchers = [],
                    elementMatchers = [],
                    cached = compilerCache[ selector + " " ];

                    if ( !cached ) {
                        // Generate a function of recursive functions that can be used to check each element
                        if ( !group ) {
                            group = tokenize( selector );
                        }
                        i = group.length;
                        while ( i-- ) {
                            cached = matcherFromTokens( group[i] );
                            if ( cached[ expando ] ) {
                                setMatchers.push( cached );
                            } else {
                                elementMatchers.push( cached );
                            }
                        }

                        // Cache the compiled function
                        cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
                    }
                    return cached;
                };

                function multipleContexts( selector, contexts, results ) {
                    var i = 0,
                    len = contexts.length;
                    for ( ; i < len; i++ ) {
                        Sizzle( selector, contexts[i], results );
                    }
                    return results;
                }

                function select( selector, context, results, seed ) {
                    var i, tokens, token, type, find,
                    match = tokenize( selector );

                    if ( !seed ) {
                        // Try to minimize operations if there is only one group
                        if ( match.length === 1 ) {

                            // Take a shortcut and set the context if the root selector is an ID
                            tokens = match[0] = match[0].slice( 0 );
                            if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
                            support.getById && context.nodeType === 9 && documentIsHTML &&
                            Expr.relative[ tokens[1].type ] ) {

                                context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
                                if ( !context ) {
                                    return results;
                                }
                                selector = selector.slice( tokens.shift().value.length );
                            }

                            // Fetch a seed set for right-to-left matching
                            i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
                            while ( i-- ) {
                                token = tokens[i];

                                // Abort if we hit a combinator
                                if ( Expr.relative[ (type = token.type) ] ) {
                                    break;
                                }
                                if ( (find = Expr.find[ type ]) ) {
                                    // Search, expanding context for leading sibling combinators
                                    if ( (seed = find(
                                    token.matches[0].replace( runescape, funescape ),
                                    rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
                                    )) ) {

                                        // If seed is empty or no tokens remain, we can return early
                                        tokens.splice( i, 1 );
                                        selector = seed.length && toSelector( tokens );
                                        if ( !selector ) {
                                            push.apply( results, seed );
                                            return results;
                                        }

                                        break;
                                    }
                                }
                            }
                        }
                    }

                    // Compile and execute a filtering function
                    // Provide `match` to avoid retokenization if we modified the selector above
                    compile( selector, match )(
                    seed,
                    context,
                    !documentIsHTML,
                    results,
                    rsibling.test( selector ) && testContext( context.parentNode ) || context
                    );
                    return results;
                }

                // One-time assignments

                // Sort stability
                support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

                // Support: Chrome<14
                // Always assume duplicates if they aren't passed to the comparison function
                support.detectDuplicates = !!hasDuplicate;

                // Initialize against the default document
                setDocument();

                // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
                // Detached nodes confoundingly follow *each other*
                support.sortDetached = assert(function( div1 ) {
                    // Should return 1, but returns 4 (following)
                    return div1.compareDocumentPosition( document.createElement("div") ) & 1;
                });

                // Support: IE<8
                // Prevent attribute/property "interpolation"
                // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
                if ( !assert(function( div ) {
                    div.innerHTML = "<a href='#'></a>";
                    return div.firstChild.getAttribute("href") === "#" ;
                }) ) {
                    addHandle( "type|href|height|width", function( elem, name, isXML ) {
                        if ( !isXML ) {
                            return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
                        }
                    });
                }

                // Support: IE<9
                // Use defaultValue in place of getAttribute("value")
                if ( !support.attributes || !assert(function( div ) {
                    div.innerHTML = "<input/>";
                    div.firstChild.setAttribute( "value", "" );
                    return div.firstChild.getAttribute( "value" ) === "";
                }) ) {
                    addHandle( "value", function( elem, name, isXML ) {
                        if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
                            return elem.defaultValue;
                        }
                    });
                }

                // Support: IE<9
                // Use getAttributeNode to fetch booleans when getAttribute lies
                if ( !assert(function( div ) {
                    return div.getAttribute("disabled") == null;
                }) ) {
                    addHandle( booleans, function( elem, name, isXML ) {
                        var val;
                        if ( !isXML ) {
                            return elem[ name ] === true ? name.toLowerCase() :
                            (val = elem.getAttributeNode( name )) && val.specified ?
                            val.value :
                            null;
                        }
                    });
                }

                return Sizzle;

            })( window );



            jQuery.find = Sizzle;
            jQuery.expr = Sizzle.selectors;
            jQuery.expr[":"] = jQuery.expr.pseudos;
            jQuery.unique = Sizzle.uniqueSort;
            jQuery.text = Sizzle.getText;
            jQuery.isXMLDoc = Sizzle.isXML;
            jQuery.contains = Sizzle.contains;



            var rneedsContext = jQuery.expr.match.needsContext;

            var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



            var risSimple = /^.[^:#\[\.,]*$/;

            // Implement the identical functionality for filter and not
            function winnow( elements, qualifier, not ) {
                if ( jQuery.isFunction( qualifier ) ) {
                    return jQuery.grep( elements, function( elem, i ) {
                        /* jshint -W018 */
                        return !!qualifier.call( elem, i, elem ) !== not;
                    });

                }

                if ( qualifier.nodeType ) {
                    return jQuery.grep( elements, function( elem ) {
                        return ( elem === qualifier ) !== not;
                    });

                }

                if ( typeof qualifier === "string" ) {
                    if ( risSimple.test( qualifier ) ) {
                        return jQuery.filter( qualifier, elements, not );
                    }

                    qualifier = jQuery.filter( qualifier, elements );
                }

                return jQuery.grep( elements, function( elem ) {
                    return ( jQuery.inArray( elem, qualifier ) >= 0 ) !== not;
                });
            }

            jQuery.filter = function( expr, elems, not ) {
                var elem = elems[ 0 ];

                if ( not ) {
                    expr = ":not(" + expr + ")";
                }

                return elems.length === 1 && elem.nodeType === 1 ?
                jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
                jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
                    return elem.nodeType === 1;
                }));
            };

            jQuery.fn.extend({
                find: function( selector ) {
                    var i,
                    ret = [],
                    self = this,
                    len = self.length;

                    if ( typeof selector !== "string" ) {
                        return this.pushStack( jQuery( selector ).filter(function() {
                            for ( i = 0; i < len; i++ ) {
                                if ( jQuery.contains( self[ i ], this ) ) {
                                    return true;
                                }
                            }
                        }) );
                    }

                    for ( i = 0; i < len; i++ ) {
                        jQuery.find( selector, self[ i ], ret );
                    }

                    // Needed because $( selector, context ) becomes $( context ).find( selector )
                    ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
                    ret.selector = this.selector ? this.selector + " " + selector : selector;
                    return ret;
                },
                filter: function( selector ) {
                    return this.pushStack( winnow(this, selector || [], false) );
                },
                not: function( selector ) {
                    return this.pushStack( winnow(this, selector || [], true) );
                },
                is: function( selector ) {
                    return !!winnow(
                    this,
                    // If this is a positional/relative selector, check membership in the returned set
                    // so $("p:first").is("p:last") won't return true for a doc with two "p".
                    typeof selector === "string" && rneedsContext.test( selector ) ?
                    jQuery( selector ) :
                    selector || [],
                    false
                    ).length;
                }
            });


            // Initialize a jQuery object


            // A central reference to the root jQuery(document)
            var rootjQuery,
            // Use the correct document accordingly with window argument (sandbox)
            document = window.document,
            // A simple way to check for HTML strings
            // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
            // Strict HTML recognition (#11290: must start with <)
            rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
            init = jQuery.fn.init = function( selector, context ) {
                var match, elem;

                // HANDLE: $(""), $(null), $(undefined), $(false)
                if ( !selector ) {
                    return this;
                }

                // Handle HTML strings
                if ( typeof selector === "string" ) {
                    if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
                        // Assume that strings that start and end with <> are HTML and skip the regex check
                        match = [ null, selector, null ];

                    } else {
                        match = rquickExpr.exec( selector );
                    }

                    // Match html or make sure no context is specified for #id
                    if ( match && (match[1] || !context) ) {

                        // HANDLE: $(html) -> $(array)
                        if ( match[1] ) {
                            context = context instanceof jQuery ? context[0] : context;

                            // scripts is true for back-compat
                            // Intentionally let the error be thrown if parseHTML is not present
                            jQuery.merge( this, jQuery.parseHTML(
                            match[1],
                            context && context.nodeType ? context.ownerDocument || context : document,
                            true
                            ) );

                            // HANDLE: $(html, props)
                            if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
                                for ( match in context ) {
                                    // Properties of context are called as methods if possible
                                    if ( jQuery.isFunction( this[ match ] ) ) {
                                        this[ match ]( context[ match ] );

                                        // ...and otherwise set as attributes
                                    } else {
                                        this.attr( match, context[ match ] );
                                    }
                                }
                            }

                            return this;

                            // HANDLE: $(#id)
                        } else {
                            elem = document.getElementById( match[2] );

                            // Check parentNode to catch when Blackberry 4.6 returns
                            // nodes that are no longer in the document #6963
                            if ( elem && elem.parentNode ) {
                                // Handle the case where IE and Opera return items
                                // by name instead of ID
                                if ( elem.id !== match[2] ) {
                                    return rootjQuery.find( selector );
                                }

                                // Otherwise, we inject the element directly into the jQuery object
                                this.length = 1;
                                this[0] = elem;
                            }

                            this.context = document;
                            this.selector = selector;
                            return this;
                        }

                        // HANDLE: $(expr, $(...))
                    } else if ( !context || context.jquery ) {
                        return ( context || rootjQuery ).find( selector );

                        // HANDLE: $(expr, context)
                        // (which is just equivalent to: $(context).find(expr)
                    } else {
                        return this.constructor( context ).find( selector );
                    }

                    // HANDLE: $(DOMElement)
                } else if ( selector.nodeType ) {
                    this.context = this[0] = selector;
                    this.length = 1;
                    return this;

                    // HANDLE: $(function)
                    // Shortcut for document ready
                } else if ( jQuery.isFunction( selector ) ) {
                    return typeof rootjQuery.ready !== "undefined" ?
                    rootjQuery.ready( selector ) :
                    // Execute immediately if ready is not present
                    selector( jQuery );
                }

                if ( selector.selector !== undefined ) {
                    this.selector = selector.selector;
                    this.context = selector.context;
                }

                return jQuery.makeArray( selector, this );
            };

            // Give the init function the jQuery prototype for later instantiation
            init.prototype = jQuery.fn;

            // Initialize central reference
            rootjQuery = jQuery( document );


            var rparentsprev = /^(?:parents|prev(?:Until|All))/,
            // methods guaranteed to produce a unique set when starting from a unique set
            guaranteedUnique = {
                children: true,
                contents: true,
                next: true,
                prev: true
            };

            jQuery.extend({
                dir: function( elem, dir, until ) {
                    var matched = [],
                    cur = elem[ dir ];

                    while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
                        if ( cur.nodeType === 1 ) {
                            matched.push( cur );
                        }
                        cur = cur[dir];
                    }
                    return matched;
                },

                sibling: function( n, elem ) {
                    var r = [];

                    for ( ; n; n = n.nextSibling ) {
                        if ( n.nodeType === 1 && n !== elem ) {
                            r.push( n );
                        }
                    }

                    return r;
                }
            });

            jQuery.fn.extend({
                has: function( target ) {
                    var i,
                    targets = jQuery( target, this ),
                    len = targets.length;

                    return this.filter(function() {
                        for ( i = 0; i < len; i++ ) {
                            if ( jQuery.contains( this, targets[i] ) ) {
                                return true;
                            }
                        }
                    });
                },

                closest: function( selectors, context ) {
                    var cur,
                    i = 0,
                    l = this.length,
                    matched = [],
                    pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
                    jQuery( selectors, context || this.context ) :
                    0;

                    for ( ; i < l; i++ ) {
                        for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
                            // Always skip document fragments
                            if ( cur.nodeType < 11 && (pos ?
                            pos.index(cur) > - 1 :
                            // Don't pass non-elements to Sizzle
                            cur.nodeType === 1 &&
                            jQuery.find.matchesSelector(cur, selectors)) ) {

                                matched.push( cur );
                                break;
                            }
                        }
                    }

                    return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
                },

                // Determine the position of an element within
                // the matched set of elements
                index: function( elem ) {

                    // No argument, return index in parent
                    if ( !elem ) {
                        return ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : - 1;
                    }

                    // index in selector
                    if ( typeof elem === "string" ) {
                        return jQuery.inArray( this[0], jQuery( elem ) );
                    }

                    // Locate the position of the desired element
                    return jQuery.inArray(
                    // If it receives a jQuery object, the first element is used
                    elem.jquery ? elem[0] : elem, this );
                },

                add: function( selector, context ) {
                    return this.pushStack(
                    jQuery.unique(
                    jQuery.merge( this.get(), jQuery( selector, context ) )
                    )
                    );
                },

                addBack: function( selector ) {
                    return this.add( selector == null ?
                    this.prevObject : this.prevObject.filter(selector)
                    );
                }
            });

            function sibling( cur, dir ) {
                do {
                    cur = cur[ dir ];
                }
                while ( cur && cur.nodeType !== 1 );

                return cur;
            }

            jQuery.each({
                parent: function( elem ) {
                    var parent = elem.parentNode;
                    return parent && parent.nodeType !== 11 ? parent : null;
                },
                parents: function( elem ) {
                    return jQuery.dir( elem, "parentNode" );
                },
                parentsUntil: function( elem, i, until ) {
                    return jQuery.dir( elem, "parentNode", until );
                },
                next: function( elem ) {
                    return sibling( elem, "nextSibling" );
                },
                prev: function( elem ) {
                    return sibling( elem, "previousSibling" );
                },
                nextAll: function( elem ) {
                    return jQuery.dir( elem, "nextSibling" );
                },
                prevAll: function( elem ) {
                    return jQuery.dir( elem, "previousSibling" );
                },
                nextUntil: function( elem, i, until ) {
                    return jQuery.dir( elem, "nextSibling", until );
                },
                prevUntil: function( elem, i, until ) {
                    return jQuery.dir( elem, "previousSibling", until );
                },
                siblings: function( elem ) {
                    return jQuery.sibling( ( elem.parentNode || {}).firstChild, elem );
                },
                children: function( elem ) {
                    return jQuery.sibling( elem.firstChild );
                },
                contents: function( elem ) {
                    return jQuery.nodeName( elem, "iframe" ) ?
                    elem.contentDocument || elem.contentWindow.document :
                    jQuery.merge( [], elem.childNodes );
                }
            }, function( name, fn ) {
                jQuery.fn[ name ] = function( until, selector ) {
                    var ret = jQuery.map( this, fn, until );

                    if ( name.slice( - 5 ) !== "Until" ) {
                        selector = until;
                    }

                    if ( selector && typeof selector === "string" ) {
                        ret = jQuery.filter( selector, ret );
                    }

                    if ( this.length > 1 ) {
                        // Remove duplicates
                        if ( !guaranteedUnique[ name ] ) {
                            ret = jQuery.unique( ret );
                        }

                        // Reverse order for parents* and prev-derivatives
                        if ( rparentsprev.test( name ) ) {
                            ret = ret.reverse();
                        }
                    }

                    return this.pushStack( ret );
                };
            });
            var rnotwhite = (/\S+/g);



            // String to Object options format cache
            var optionsCache = {};

            // Convert String-formatted options into Object-formatted ones and store in cache
            function createOptions( options ) {
                var object = optionsCache[ options ] = {};
                jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
                    object[ flag ] = true;
                });
                return object;
            }

            /*
             * Create a callback list using the following parameters:
             *
             *	options: an optional list of space-separated options that will change how
             *			the callback list behaves or a more traditional option object
             *
             * By default a callback list will act like an event callback list and can be
             * "fired" multiple times.
             *
             * Possible options:
             *
             *	once:			will ensure the callback list can only be fired once (like a Deferred)
             *
             *	memory:			will keep track of previous values and will call any callback added
             *					after the list has been fired right away with the latest "memorized"
             *					values (like a Deferred)
             *
             *	unique:			will ensure a callback can only be added once (no duplicate in the list)
             *
             *	stopOnFalse:	interrupt callings when a callback returns false
             *
             */
            jQuery.Callbacks = function( options ) {

                // Convert options from String-formatted to Object-formatted if needed
                // (we check in cache first)
                options = typeof options === "string" ?
                ( optionsCache[ options ] || createOptions( options ) ) :
                jQuery.extend( {}, options );

                var // Flag to know if list is currently firing
                firing,
                // Last fire value (for non-forgettable lists)
                memory,
                // Flag to know if list was already fired
                fired,
                // End of the loop when firing
                firingLength,
                // Index of currently firing callback (modified by remove if needed)
                firingIndex,
                // First callback to fire (used internally by add and fireWith)
                firingStart,
                // Actual callback list
                list = [],
                // Stack of fire calls for repeatable lists
                stack = !options.once && [],
                // Fire callbacks
                fire = function( data ) {
                    memory = options.memory && data;
                    fired = true;
                    firingIndex = firingStart || 0;
                    firingStart = 0;
                    firingLength = list.length;
                    firing = true;
                    for ( ; list && firingIndex < firingLength; firingIndex++ ) {
                        if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
                            memory = false; // To prevent further calls using add
                            break;
                        }
                    }
                    firing = false;
                    if ( list ) {
                        if ( stack ) {
                            if ( stack.length ) {
                                fire( stack.shift() );
                            }
                        } else if ( memory ) {
                            list = [];
                        } else {
                            self.disable();
                        }
                    }
                },
                // Actual Callbacks object
                self = {
                    // Add a callback or a collection of callbacks to the list
                    add: function() {
                        if ( list ) {
                            // First, we save the current length
                            var start = list.length;
                            (function add( args ) {
                                jQuery.each( args, function( _, arg ) {
                                    var type = jQuery.type( arg );
                                    if ( type === "function" ) {
                                        if ( !options.unique || !self.has( arg ) ) {
                                            list.push( arg );
                                        }
                                    } else if ( arg && arg.length && type !== "string" ) {
                                        // Inspect recursively
                                        add( arg );
                                    }
                                });
                            })( arguments );
                            // Do we need to add the callbacks to the
                            // current firing batch?
                            if ( firing ) {
                                firingLength = list.length;
                                // With memory, if we're not firing then
                                // we should call right away
                            } else if ( memory ) {
                                firingStart = start;
                                fire( memory );
                            }
                        }
                        return this;
                    },
                    // Remove a callback from the list
                    remove: function() {
                        if ( list ) {
                            jQuery.each( arguments, function( _, arg ) {
                                var index;
                                while ( ( index = jQuery.inArray( arg, list, index ) ) > - 1 ) {
                                    list.splice( index, 1 );
                                    // Handle firing indexes
                                    if ( firing ) {
                                        if ( index <= firingLength ) {
                                            firingLength--;
                                        }
                                        if ( index <= firingIndex ) {
                                            firingIndex--;
                                        }
                                    }
                                }
                            });
                        }
                        return this;
                    },
                    // Check if a given callback is in the list.
                    // If no argument is given, return whether or not list has callbacks attached.
                    has: function( fn ) {
                        return fn ? jQuery.inArray( fn, list ) > - 1 : !!( list && list.length );
                    },
                    // Remove all callbacks from the list
                    empty: function() {
                        list = [];
                        firingLength = 0;
                        return this;
                    },
                    // Have the list do nothing anymore
                    disable: function() {
                        list = stack = memory = undefined;
                        return this;
                    },
                    // Is it disabled?
                    disabled: function() {
                        return !list;
                    },
                    // Lock the list in its current state
                    lock: function() {
                        stack = undefined;
                        if ( !memory ) {
                            self.disable();
                        }
                        return this;
                    },
                    // Is it locked?
                    locked: function() {
                        return !stack;
                    },
                    // Call all callbacks with the given context and arguments
                    fireWith: function( context, args ) {
                        if ( list && ( !fired || stack ) ) {
                            args = args || [];
                            args = [ context, args.slice ? args.slice() : args ];
                            if ( firing ) {
                                stack.push( args );
                            } else {
                                fire( args );
                            }
                        }
                        return this;
                    },
                    // Call all the callbacks with the given arguments
                    fire: function() {
                        self.fireWith( this, arguments );
                        return this;
                    },
                    // To know if the callbacks have already been called at least once
                    fired: function() {
                        return !!fired;
                    }
                };

                return self;
            };


            jQuery.extend({

                Deferred: function( func ) {
                    var tuples = [
                    // action, add listener, listener list, final state
                    [ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
                    [ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
                    [ "notify", "progress", jQuery.Callbacks("memory") ]
                    ],
                    state = "pending",
                    promise = {
                        state: function() {
                            return state;
                        },
                        always: function() {
                            deferred.done( arguments ).fail( arguments );
                            return this;
                        },
                        then: function( /* fnDone, fnFail, fnProgress */
                        ) {
                            var fns = arguments;
                            return jQuery.Deferred(function( newDefer ) {
                                jQuery.each( tuples, function( i, tuple ) {
                                    var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
                                    // deferred[ done | fail | progress ] for forwarding actions to newDefer
                                    deferred[ tuple[1] ](function() {
                                        var returned = fn && fn.apply( this, arguments );
                                        if ( returned && jQuery.isFunction( returned.promise ) ) {
                                            returned.promise()
                                            .done( newDefer.resolve )
                                            .fail( newDefer.reject )
                                            .progress( newDefer.notify );
                                        } else {
                                            newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
                                        }
                                    });
                                });
                                fns = null;
                            }).promise();
                        },
                        // Get a promise for this deferred
                        // If obj is provided, the promise aspect is added to the object
                        promise: function( obj ) {
                            return obj != null ? jQuery.extend( obj, promise ) : promise;
                        }
                    },
                    deferred = {};

                    // Keep pipe for back-compat
                    promise.pipe = promise.then;

                    // Add list-specific methods
                    jQuery.each( tuples, function( i, tuple ) {
                        var list = tuple[ 2 ],
                        stateString = tuple[ 3 ];

                        // promise[ done | fail | progress ] = list.add
                        promise[ tuple[1] ] = list.add;

                        // Handle state
                        if ( stateString ) {
                            list.add(function() {
                                // state = [ resolved | rejected ]
                                state = stateString;

                                // [ reject_list | resolve_list ].disable; progress_list.lock
                            }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
                        }

                        // deferred[ resolve | reject | notify ]
                        deferred[ tuple[0] ] = function() {
                            deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
                            return this;
                        };
                        deferred[ tuple[0] + "With" ] = list.fireWith;
                    });

                    // Make the deferred a promise
                    promise.promise( deferred );

                    // Call given func if any
                    if ( func ) {
                        func.call( deferred, deferred );
                    }

                    // All done!
                    return deferred;
                },

                // Deferred helper
                when: function( subordinate /* , ..., subordinateN */
                ) {
                    var i = 0,
                    resolveValues = slice.call( arguments ),
                    length = resolveValues.length,
                    // the count of uncompleted subordinates
                    remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,
                    // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
                    deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
                    // Update function for both resolve and progress values
                    updateFunc = function( i, contexts, values ) {
                        return function( value ) {
                            contexts[ i ] = this;
                            values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
                            if ( values === progressValues ) {
                                deferred.notifyWith( contexts, values );

                            } else if ( !(--remaining) ) {
                                deferred.resolveWith( contexts, values );
                            }
                        };
                    },
                    progressValues, progressContexts, resolveContexts;

                    // add listeners to Deferred subordinates; treat others as resolved
                    if ( length > 1 ) {
                        progressValues = new Array( length );
                        progressContexts = new Array( length );
                        resolveContexts = new Array( length );
                        for ( ; i < length; i++ ) {
                            if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
                                resolveValues[ i ].promise()
                                .done( updateFunc( i, resolveContexts, resolveValues ) )
                                .fail( deferred.reject )
                                .progress( updateFunc( i, progressContexts, progressValues ) );
                            } else {
                                --remaining;
                            }
                        }
                    }

                    // if we're not waiting on anything, resolve the master
                    if ( !remaining ) {
                        deferred.resolveWith( resolveContexts, resolveValues );
                    }

                    return deferred.promise();
                }
            });


            // The deferred used on DOM ready
            var readyList;

            jQuery.fn.ready = function( fn ) {
                // Add the callback
                jQuery.ready.promise().done( fn );

                return this;
            };

            jQuery.extend({
                // Is the DOM ready to be used? Set to true once it occurs.
                isReady: false,

                // A counter to track how many items to wait for before
                // the ready event fires. See #6781
                readyWait: 1,

                // Hold (or release) the ready event
                holdReady: function( hold ) {
                    if ( hold ) {
                        jQuery.readyWait++;
                    } else {
                        jQuery.ready( true );
                    }
                },

                // Handle when the DOM is ready
                ready: function( wait ) {

                    // Abort if there are pending holds or we're already ready
                    if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
                        return;
                    }

                    // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
                    if ( !document.body ) {
                        return setTimeout( jQuery.ready );
                    }

                    // Remember that the DOM is ready
                    jQuery.isReady = true;

                    // If a normal DOM Ready event fired, decrement, and wait if need be
                    if ( wait !== true && --jQuery.readyWait > 0 ) {
                        return;
                    }

                    // If there are functions bound, to execute
                    readyList.resolveWith( document, [ jQuery ] );

                    // Trigger any bound ready events
                    if ( jQuery.fn.trigger ) {
                        jQuery( document ).trigger("ready").off("ready");
                    }
                }
            });

            /**
             * Clean-up method for dom ready events
             */
            function detach() {
                if ( document.addEventListener ) {
                    document.removeEventListener( "DOMContentLoaded", completed, false );
                    window.removeEventListener( "load", completed, false );

                } else {
                    document.detachEvent( "onreadystatechange", completed );
                    window.detachEvent( "onload", completed );
                }
            }

            /**
             * The ready event handler and self cleanup method
             */
            function completed() {
                // readyState === "complete" is good enough for us to call the dom ready in oldIE
                if ( document.addEventListener || event.type === "load" || document.readyState === "complete" ) {
                    detach();
                    jQuery.ready();
                }
            }

            jQuery.ready.promise = function( obj ) {
                if ( !readyList ) {

                    readyList = jQuery.Deferred();

                    // Catch cases where $(document).ready() is called after the browser event has already occurred.
                    // we once tried to use readyState "interactive" here, but it caused issues like the one
                    // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
                    if ( document.readyState === "complete" ) {
                        // Handle it asynchronously to allow scripts the opportunity to delay ready
                        setTimeout( jQuery.ready );

                        // Standards-based browsers support DOMContentLoaded
                    } else if ( document.addEventListener ) {
                        // Use the handy event callback
                        document.addEventListener( "DOMContentLoaded", completed, false );

                        // A fallback to window.onload, that will always work
                        window.addEventListener( "load", completed, false );

                        // If IE event model is used
                    } else {
                        // Ensure firing before onload, maybe late but safe also for iframes
                        document.attachEvent( "onreadystatechange", completed );

                        // A fallback to window.onload, that will always work
                        window.attachEvent( "onload", completed );

                        // If IE and not a frame
                        // continually check to see if the document is ready
                        var top = false;

                        try {
                            top = window.frameElement == null && document.documentElement;
                        } catch (e) {}

                        if ( top && top.doScroll ) {
                            (function doScrollCheck() {
                                if ( !jQuery.isReady ) {

                                    try {
                                        // Use the trick by Diego Perini
                                        // http://javascript.nwbox.com/IEContentLoaded/
                                        top.doScroll("left");
                                    } catch (e) {
                                        return setTimeout( doScrollCheck, 50 );
                                    }

                                    // detach all dom ready events
                                    detach();

                                    // and execute any waiting functions
                                    jQuery.ready();
                                }
                            })();
                        }
                    }
                }
                return readyList.promise( obj );
            };


            var strundefined = typeof undefined;



            // Support: IE<9
            // Iteration over object's inherited properties before its own
            var i;
            for ( i in jQuery( support ) ) {
                break;
            }
            support.ownLast = i !== "0";

            // Note: most support tests are defined in their respective modules.
            // false until the test is run
            support.inlineBlockNeedsLayout = false;

            jQuery(function() {
                // We need to execute this one support test ASAP because we need to know
                // if body.style.zoom needs to be set.

                var container, div,
                body = document.getElementsByTagName("body")[0];

                if ( !body ) {
                    // Return for frameset docs that don't have a body
                    return;
                }

                // Setup
                container = document.createElement( "div" );
                container.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px";

                div = document.createElement( "div" );
                body.appendChild( container ).appendChild( div );

                if ( typeof div.style.zoom !== strundefined ) {
                    // Support: IE<8
                    // Check if natively block-level elements act like inline-block
                    // elements when setting their display to 'inline' and giving
                    // them layout
                    div.style.cssText = "border:0;margin:0;width:1px;padding:1px;display:inline;zoom:1";

                    if ( (support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 )) ) {
                        // Prevent IE 6 from affecting layout for positioned elements #11048
                        // Prevent IE from shrinking the body in IE 7 mode #12869
                        // Support: IE<8
                        body.style.zoom = 1;
                    }
                }

                body.removeChild( container );

                // Null elements to avoid leaks in IE
                container = div = null;
            });




            (function() {
                var div = document.createElement( "div" );

                // Execute the test only if not already executed in another module.
                if (support.deleteExpando == null) {
                    // Support: IE<9
                    support.deleteExpando = true;
                    try {
                        delete div.test;
                    } catch ( e ) {
                        support.deleteExpando = false;
                    }
                }

                // Null elements to avoid leaks in IE.
                div = null;
            })();


            /**
             * Determines whether an object can have data
             */
            jQuery.acceptData = function( elem ) {
                var noData = jQuery.noData[ (elem.nodeName + " ").toLowerCase() ],
                nodeType = + elem.nodeType || 1;

                // Do not set data on non-element DOM nodes because it will not be cleared (#8335).
                return nodeType !== 1 && nodeType !== 9 ?
                false :
                // Nodes accept data unless otherwise specified; rejection can be conditional
                !noData || noData !== true && elem.getAttribute("classid") === noData;
            };


            var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
            rmultiDash = /([A-Z])/g;

            function dataAttr( elem, key, data ) {
                // If nothing was found internally, try to fetch any
                // data from the HTML5 data-* attribute
                if ( data === undefined && elem.nodeType === 1 ) {

                    var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

                    data = elem.getAttribute( name );

                    if ( typeof data === "string" ) {
                        try {
                            data = data === "true" ? true :
                            data === "false" ? false :
                            data === "null" ? null :
                            // Only convert to a number if it doesn't change the string
                            + data + "" === data ? + data :
                            rbrace.test( data ) ? jQuery.parseJSON( data ) :
                            data;
                        } catch ( e ) {}

                        // Make sure we set the data so it isn't changed later
                        jQuery.data( elem, key, data );

                    } else {
                        data = undefined;
                    }
                }

                return data;
            }

            // checks a cache object for emptiness
            function isEmptyDataObject( obj ) {
                var name;
                for ( name in obj ) {

                    // if the public data object is empty, the private is still empty
                    if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
                        continue;
                    }
                    if ( name !== "toJSON" ) {
                        return false;
                    }
                }

                return true;
            }

            function internalData( elem, name, data, pvt /* Internal Use Only */
            ) {
                if ( !jQuery.acceptData( elem ) ) {
                    return;
                }

                var ret, thisCache,
                internalKey = jQuery.expando,
                // We have to handle DOM nodes and JS objects differently because IE6-7
                // can't GC object references properly across the DOM-JS boundary
                isNode = elem.nodeType,
                // Only DOM nodes need the global jQuery cache; JS object data is
                // attached directly to the object so GC can occur automatically
                cache = isNode ? jQuery.cache : elem,
                // Only defining an ID for JS objects if its cache already exists allows
                // the code to shortcut on the same path as a DOM node with no cache
                id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;

                // Avoid doing any more work than we need to when trying to get data on an
                // object that has no data at all
                if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && data === undefined && typeof name === "string" ) {
                    return;
                }

                if ( !id ) {
                    // Only DOM nodes need a new unique ID for each element since their data
                    // ends up in the global cache
                    if ( isNode ) {
                        id = elem[ internalKey ] = deletedIds.pop() || jQuery.guid++;
                    } else {
                        id = internalKey;
                    }
                }

                if ( !cache[ id ] ) {
                    // Avoid exposing jQuery metadata on plain JS objects when the object
                    // is serialized using JSON.stringify
                    cache[ id ] = isNode ? {} : {
                        toJSON: jQuery.noop 
                    };
                }

                // An object can be passed to jQuery.data instead of a key/value pair; this gets
                // shallow copied over onto the existing cache
                if ( typeof name === "object" || typeof name === "function" ) {
                    if ( pvt ) {
                        cache[ id ] = jQuery.extend( cache[ id ], name );
                    } else {
                        cache[ id ].data = jQuery.extend( cache[ id ].data, name );
                    }
                }

                thisCache = cache[ id ];

                // jQuery data() is stored in a separate object inside the object's internal data
                // cache in order to avoid key collisions between internal data and user-defined
                // data.
                if ( !pvt ) {
                    if ( !thisCache.data ) {
                        thisCache.data = {};
                    }

                    thisCache = thisCache.data;
                }

                if ( data !== undefined ) {
                    thisCache[ jQuery.camelCase( name ) ] = data;
                }

                // Check for both converted-to-camel and non-converted data property names
                // If a data property was specified
                if ( typeof name === "string" ) {

                    // First Try to find as-is property data
                    ret = thisCache[ name ];

                    // Test for null|undefined property data
                    if ( ret == null ) {

                        // Try to find the camelCased property
                        ret = thisCache[ jQuery.camelCase( name ) ];
                    }
                } else {
                    ret = thisCache;
                }

                return ret;
            }

            function internalRemoveData( elem, name, pvt ) {
                if ( !jQuery.acceptData( elem ) ) {
                    return;
                }

                var thisCache, i,
                isNode = elem.nodeType,
                // See jQuery.data for more information
                cache = isNode ? jQuery.cache : elem,
                id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

                // If there is already no cache entry for this object, there is no
                // purpose in continuing
                if ( !cache[ id ] ) {
                    return;
                }

                if ( name ) {

                    thisCache = pvt ? cache[ id ] : cache[ id ].data;

                    if ( thisCache ) {

                        // Support array or space separated string names for data keys
                        if ( !jQuery.isArray( name ) ) {

                            // try the string as a key before any manipulation
                            if ( name in thisCache ) {
                                name = [ name ];
                            } else {

                                // split the camel cased version by spaces unless a key with the spaces exists
                                name = jQuery.camelCase( name );
                                if ( name in thisCache ) {
                                    name = [ name ];
                                } else {
                                    name = name.split(" ");
                                }
                            }
                        } else {
                            // If "name" is an array of keys...
                            // When data is initially created, via ("key", "val") signature,
                            // keys will be converted to camelCase.
                            // Since there is no way to tell _how_ a key was added, remove
                            // both plain key and camelCase key. #12786
                            // This will only penalize the array argument path.
                            name = name.concat( jQuery.map( name, jQuery.camelCase ) );
                        }

                        i = name.length;
                        while ( i-- ) {
                            delete thisCache[ name[i] ];
                        }

                        // If there is no data left in the cache, we want to continue
                        // and let the cache object itself get destroyed
                        if ( pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache) ) {
                            return;
                        }
                    }
                }

                // See jQuery.data for more information
                if ( !pvt ) {
                    delete cache[ id ].data;

                    // Don't destroy the parent cache unless the internal data object
                    // had been the only thing left in it
                    if ( !isEmptyDataObject( cache[ id ] ) ) {
                        return;
                    }
                }

                // Destroy the cache
                if ( isNode ) {
                    jQuery.cleanData( [ elem ], true );

                    // Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
                    /* jshint eqeqeq: false */
                } else if ( support.deleteExpando || cache != cache.window ) {
                    /* jshint eqeqeq: true */
                    delete cache[ id ];

                    // When all else fails, null
                } else {
                    cache[ id ] = null;
                }
            }

            jQuery.extend({
                cache: {},

                // The following elements (space-suffixed to avoid Object.prototype collisions)
                // throw uncatchable exceptions if you attempt to set expando properties
                noData: {
                    "applet ": true,
                    "embed ": true,
                    // ...but Flash objects (which have this classid) *can* handle expandos
                    "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
                },

                hasData: function( elem ) {
                    elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
                    return !!elem && !isEmptyDataObject( elem );
                },

                data: function( elem, name, data ) {
                    return internalData( elem, name, data );
                },

                removeData: function( elem, name ) {
                    return internalRemoveData( elem, name );
                },

                // For internal use only.
                _data: function( elem, name, data ) {
                    return internalData( elem, name, data, true );
                },

                _removeData: function( elem, name ) {
                    return internalRemoveData( elem, name, true );
                }
            });

            jQuery.fn.extend({
                data: function( key, value ) {
                    var i, name, data,
                    elem = this[0],
                    attrs = elem && elem.attributes;

                    // Special expections of .data basically thwart jQuery.access,
                    // so implement the relevant behavior ourselves

                    // Gets all values
                    if ( key === undefined ) {
                        if ( this.length ) {
                            data = jQuery.data( elem );

                            if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
                                i = attrs.length;
                                while ( i-- ) {
                                    name = attrs[i].name;

                                    if ( name.indexOf("data-") === 0 ) {
                                        name = jQuery.camelCase( name.slice(5) );

                                        dataAttr( elem, name, data[ name ] );
                                    }
                                }
                                jQuery._data( elem, "parsedAttrs", true );
                            }
                        }

                        return data;
                    }

                    // Sets multiple values
                    if ( typeof key === "object" ) {
                        return this.each(function() {
                            jQuery.data( this, key );
                        });
                    }

                    return arguments.length > 1 ?
                    // Sets one value
                    this.each(function() {
                        jQuery.data( this, key, value );
                    }) :
                    // Gets one value
                    // Try to fetch any internally stored data first
                    elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : undefined;
                },

                removeData: function( key ) {
                    return this.each(function() {
                        jQuery.removeData( this, key );
                    });
                }
            });


            jQuery.extend({
                queue: function( elem, type, data ) {
                    var queue;

                    if ( elem ) {
                        type = ( type || "fx" ) + "queue";
                        queue = jQuery._data( elem, type );

                        // Speed up dequeue by getting out quickly if this is just a lookup
                        if ( data ) {
                            if ( !queue || jQuery.isArray(data) ) {
                                queue = jQuery._data( elem, type, jQuery.makeArray(data) );
                            } else {
                                queue.push( data );
                            }
                        }
                        return queue || [];
                    }
                },

                dequeue: function( elem, type ) {
                    type = type || "fx";

                    var queue = jQuery.queue( elem, type ),
                    startLength = queue.length,
                    fn = queue.shift(),
                    hooks = jQuery._queueHooks( elem, type ),
                    next = function() {
                        jQuery.dequeue( elem, type );
                    };

                    // If the fx queue is dequeued, always remove the progress sentinel
                    if ( fn === "inprogress" ) {
                        fn = queue.shift();
                        startLength--;
                    }

                    if ( fn ) {

                        // Add a progress sentinel to prevent the fx queue from being
                        // automatically dequeued
                        if ( type === "fx" ) {
                            queue.unshift( "inprogress" );
                        }

                        // clear up the last queue stop function
                        delete hooks.stop;
                        fn.call( elem, next, hooks );
                    }

                    if ( !startLength && hooks ) {
                        hooks.empty.fire();
                    }
                },

                // not intended for public consumption - generates a queueHooks object, or returns the current one
                _queueHooks: function( elem, type ) {
                    var key = type + "queueHooks";
                    return jQuery._data( elem, key ) || jQuery._data( elem, key, {
                        empty: jQuery.Callbacks("once memory").add(function() {
                            jQuery._removeData( elem, type + "queue" );
                            jQuery._removeData( elem, key );
                        })
                    });
                }
            });

            jQuery.fn.extend({
                queue: function( type, data ) {
                    var setter = 2;

                    if ( typeof type !== "string" ) {
                        data = type;
                        type = "fx";
                        setter--;
                    }

                    if ( arguments.length < setter ) {
                        return jQuery.queue( this[0], type );
                    }

                    return data === undefined ?
                    this :
                    this.each(function() {
                        var queue = jQuery.queue( this, type, data );

                        // ensure a hooks for this queue
                        jQuery._queueHooks( this, type );

                        if ( type === "fx" && queue[0] !== "inprogress" ) {
                            jQuery.dequeue( this, type );
                        }
                    });
                },
                dequeue: function( type ) {
                    return this.each(function() {
                        jQuery.dequeue( this, type );
                    });
                },
                clearQueue: function( type ) {
                    return this.queue( type || "fx", [] );
                },
                // Get a promise resolved when queues of a certain type
                // are emptied (fx is the type by default)
                promise: function( type, obj ) {
                    var tmp,
                    count = 1,
                    defer = jQuery.Deferred(),
                    elements = this,
                    i = this.length,
                    resolve = function() {
                        if ( !( --count ) ) {
                            defer.resolveWith( elements, [ elements ] );
                        }
                    };

                    if ( typeof type !== "string" ) {
                        obj = type;
                        type = undefined;
                    }
                    type = type || "fx";

                    while ( i-- ) {
                        tmp = jQuery._data( elements[ i ], type + "queueHooks" );
                        if ( tmp && tmp.empty ) {
                            count++;
                            tmp.empty.add( resolve );
                        }
                    }
                    resolve();
                    return defer.promise( obj );
                }
            });
            var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

            var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

            var isHidden = function( elem, el ) {
                // isHidden might be called from jQuery#filter function;
                // in that case, element will be second argument
                elem = el || elem;
                return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
            };



            // Multifunctional method to get and set values of a collection
            // The value/s can optionally be executed if it's a function
            var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
                var i = 0,
                length = elems.length,
                bulk = key == null;

                // Sets many values
                if ( jQuery.type( key ) === "object" ) {
                    chainable = true;
                    for ( i in key ) {
                        jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
                    }

                    // Sets one value
                } else if ( value !== undefined ) {
                    chainable = true;

                    if ( !jQuery.isFunction( value ) ) {
                        raw = true;
                    }

                    if ( bulk ) {
                        // Bulk operations run against the entire set
                        if ( raw ) {
                            fn.call( elems, value );
                            fn = null;

                            // ...except when executing function values
                        } else {
                            bulk = fn;
                            fn = function( elem, key, value ) {
                                return bulk.call( jQuery( elem ), value );
                            };
                        }
                    }

                    if ( fn ) {
                        for ( ; i < length; i++ ) {
                            fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
                        }
                    }
                }

                return chainable ?
                elems :
                // Gets
                bulk ?
                fn.call( elems ) :
                length ? fn( elems[0], key ) : emptyGet;
            };
            var rcheckableType = (/^(?:checkbox|radio)$/i);



            (function() {
                var fragment = document.createDocumentFragment(),
                div = document.createElement("div"),
                input = document.createElement("input");

                // Setup
                div.setAttribute( "className", "t" );
                div.innerHTML = "  <link/><table></table><a href='/a'>a</a>";

                // IE strips leading whitespace when .innerHTML is used
                support.leadingWhitespace = div.firstChild.nodeType === 3;

                // Make sure that tbody elements aren't automatically inserted
                // IE will insert them into empty tables
                support.tbody = !div.getElementsByTagName( "tbody" ).length;

                // Make sure that link elements get serialized correctly by innerHTML
                // This requires a wrapper element in IE
                support.htmlSerialize = !!div.getElementsByTagName( "link" ).length;

                // Makes sure cloning an html5 element does not cause problems
                // Where outerHTML is undefined, this still works
                support.html5Clone =
                document.createElement( "nav" ).cloneNode( true ).outerHTML !== "<:nav></:nav>";

                // Check if a disconnected checkbox will retain its checked
                // value of true after appended to the DOM (IE6/7)
                input.type = "checkbox";
                input.checked = true;
                fragment.appendChild( input );
                support.appendChecked = input.checked;

                // Make sure textarea (and checkbox) defaultValue is properly cloned
                // Support: IE6-IE11+
                div.innerHTML = "<textarea>x</textarea>";
                support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

                // #11217 - WebKit loses check when the name is after the checked attribute
                fragment.appendChild( div );
                div.innerHTML = "<input type='radio' checked='checked' name='t'/>";

                // Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
                // old WebKit doesn't clone checked state correctly in fragments
                support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

                // Support: IE<9
                // Opera does not clone events (and typeof div.attachEvent === undefined).
                // IE9-10 clones events bound via attachEvent, but they don't trigger with .click()
                support.noCloneEvent = true;
                if ( div.attachEvent ) {
                    div.attachEvent( "onclick", function() {
                        support.noCloneEvent = false;
                    });

                    div.cloneNode( true ).click();
                }

                // Execute the test only if not already executed in another module.
                if (support.deleteExpando == null) {
                    // Support: IE<9
                    support.deleteExpando = true;
                    try {
                        delete div.test;
                    } catch ( e ) {
                        support.deleteExpando = false;
                    }
                }

                // Null elements to avoid leaks in IE.
                fragment = div = input = null;
            })();


            (function() {
                var i, eventName,
                div = document.createElement( "div" );

                // Support: IE<9 (lack submit/change bubble), Firefox 23+ (lack focusin event)
                for ( i in {
                    submit: true,
                    change: true,
                    focusin: true 
                }) {
                    eventName = "on" + i;

                    if ( !(support[ i + "Bubbles" ] = eventName in window) ) {
                        // Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
                        div.setAttribute( eventName, "t" );
                        support[ i + "Bubbles" ] = div.attributes[ eventName ].expando === false;
                    }
                }

                // Null elements to avoid leaks in IE.
                div = null;
            })();


            var rformElems = /^(?:input|select|textarea)$/i,
            rkeyEvent = /^key/,
            rmouseEvent = /^(?:mouse|contextmenu)|click/,
            rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
            rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

            function returnTrue() {
                return true;
            }

            function returnFalse() {
                return false;
            }

            function safeActiveElement() {
                try {
                    return document.activeElement;
                } catch ( err ) {}
            }

            /*
             * Helper functions for managing events -- not part of the public interface.
             * Props to Dean Edwards' addEvent library for many of the ideas.
             */
            jQuery.event = {

                global: {},

                add: function( elem, types, handler, data, selector ) {
                    var tmp, events, t, handleObjIn,
                    special, eventHandle, handleObj,
                    handlers, type, namespaces, origType,
                    elemData = jQuery._data( elem );

                    // Don't attach events to noData or text/comment nodes (but allow plain objects)
                    if ( !elemData ) {
                        return;
                    }

                    // Caller can pass in an object of custom data in lieu of the handler
                    if ( handler.handler ) {
                        handleObjIn = handler;
                        handler = handleObjIn.handler;
                        selector = handleObjIn.selector;
                    }

                    // Make sure that the handler has a unique ID, used to find/remove it later
                    if ( !handler.guid ) {
                        handler.guid = jQuery.guid++;
                    }

                    // Init the element's event structure and main handler, if this is the first
                    if ( !(events = elemData.events) ) {
                        events = elemData.events = {};
                    }
                    if ( !(eventHandle = elemData.handle) ) {
                        eventHandle = elemData.handle = function( e ) {
                            // Discard the second event of a jQuery.event.trigger() and
                            // when an event is called after a page has unloaded
                            return typeof jQuery !== strundefined && (!e || jQuery.event.triggered !== e.type) ?
                            jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
                            undefined;
                        };
                        // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
                        eventHandle.elem = elem;
                    }

                    // Handle multiple events separated by a space
                    types = ( types || "" ).match( rnotwhite ) || [ "" ];
                    t = types.length;
                    while ( t-- ) {
                        tmp = rtypenamespace.exec( types[t] ) || [];
                        type = origType = tmp[1];
                        namespaces = ( tmp[2] || "" ).split( "." ).sort();

                        // There *must* be a type, no attaching namespace-only handlers
                        if ( !type ) {
                            continue;
                        }

                        // If event changes its type, use the special event handlers for the changed type
                        special = jQuery.event.special[ type ] || {};

                        // If selector defined, determine special event api type, otherwise given type
                        type = ( selector ? special.delegateType : special.bindType ) || type;

                        // Update special based on newly reset type
                        special = jQuery.event.special[ type ] || {};

                        // handleObj is passed to all event handlers
                        handleObj = jQuery.extend({
                            type: type,
                            origType: origType,
                            data: data,
                            handler: handler,
                            guid: handler.guid,
                            selector: selector,
                            needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
                            namespace: namespaces.join(".")
                        }, handleObjIn );

                        // Init the event handler queue if we're the first
                        if ( !(handlers = events[ type ]) ) {
                            handlers = events[ type ] = [];
                            handlers.delegateCount = 0;

                            // Only use addEventListener/attachEvent if the special events handler returns false
                            if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
                                // Bind the global event handler to the element
                                if ( elem.addEventListener ) {
                                    elem.addEventListener( type, eventHandle, false );

                                } else if ( elem.attachEvent ) {
                                    elem.attachEvent( "on" + type, eventHandle );
                                }
                            }
                        }

                        if ( special.add ) {
                            special.add.call( elem, handleObj );

                            if ( !handleObj.handler.guid ) {
                                handleObj.handler.guid = handler.guid;
                            }
                        }

                        // Add to the element's handler list, delegates in front
                        if ( selector ) {
                            handlers.splice( handlers.delegateCount++, 0, handleObj );
                        } else {
                            handlers.push( handleObj );
                        }

                        // Keep track of which events have ever been used, for event optimization
                        jQuery.event.global[ type ] = true;
                    }

                    // Nullify elem to prevent memory leaks in IE
                    elem = null;
                },

                // Detach an event or set of events from an element
                remove: function( elem, types, handler, selector, mappedTypes ) {
                    var j, handleObj, tmp,
                    origCount, t, events,
                    special, handlers, type,
                    namespaces, origType,
                    elemData = jQuery.hasData( elem ) && jQuery._data( elem );

                    if ( !elemData || !(events = elemData.events) ) {
                        return;
                    }

                    // Once for each type.namespace in types; type may be omitted
                    types = ( types || "" ).match( rnotwhite ) || [ "" ];
                    t = types.length;
                    while ( t-- ) {
                        tmp = rtypenamespace.exec( types[t] ) || [];
                        type = origType = tmp[1];
                        namespaces = ( tmp[2] || "" ).split( "." ).sort();

                        // Unbind all events (on this namespace, if provided) for the element
                        if ( !type ) {
                            for ( type in events ) {
                                jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
                            }
                            continue;
                        }

                        special = jQuery.event.special[ type ] || {};
                        type = ( selector ? special.delegateType : special.bindType ) || type;
                        handlers = events[ type ] || [];
                        tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

                        // Remove matching events
                        origCount = j = handlers.length;
                        while ( j-- ) {
                            handleObj = handlers[ j ];

                            if ( ( mappedTypes || origType === handleObj.origType ) &&
                            ( !handler || handler.guid === handleObj.guid ) &&
                            ( !tmp || tmp.test( handleObj.namespace ) ) &&
                            ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
                                handlers.splice( j, 1 );

                                if ( handleObj.selector ) {
                                    handlers.delegateCount--;
                                }
                                if ( special.remove ) {
                                    special.remove.call( elem, handleObj );
                                }
                            }
                        }

                        // Remove generic event handler if we removed something and no more handlers exist
                        // (avoids potential for endless recursion during removal of special event handlers)
                        if ( origCount && !handlers.length ) {
                            if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
                                jQuery.removeEvent( elem, type, elemData.handle );
                            }

                            delete events[ type ];
                        }
                    }

                    // Remove the expando if it's no longer used
                    if ( jQuery.isEmptyObject( events ) ) {
                        delete elemData.handle;

                        // removeData also checks for emptiness and clears the expando if empty
                        // so use it instead of delete
                        jQuery._removeData( elem, "events" );
                    }
                },

                trigger: function( event, data, elem, onlyHandlers ) {
                    var handle, ontype, cur,
                    bubbleType, special, tmp, i,
                    eventPath = [ elem || document ],
                    type = hasOwn.call( event, "type" ) ? event.type : event,
                    namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

                    cur = tmp = elem = elem || document;

                    // Don't do events on text and comment nodes
                    if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
                        return;
                    }

                    // focus/blur morphs to focusin/out; ensure we're not firing them right now
                    if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
                        return;
                    }

                    if ( type.indexOf(".") >= 0 ) {
                        // Namespaced trigger; create a regexp to match event type in handle()
                        namespaces = type.split(".");
                        type = namespaces.shift();
                        namespaces.sort();
                    }
                    ontype = type.indexOf(":") < 0 && "on" + type;

                    // Caller can pass in a jQuery.Event object, Object, or just an event type string
                    event = event[ jQuery.expando ] ?
                    event :
                    new jQuery.Event( type, typeof event === "object" && event );

                    // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
                    event.isTrigger = onlyHandlers ? 2 : 3;
                    event.namespace = namespaces.join(".");
                    event.namespace_re = event.namespace ?
                    new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
                    null;

                    // Clean up the event in case it is being reused
                    event.result = undefined;
                    if ( !event.target ) {
                        event.target = elem;
                    }

                    // Clone any incoming data and prepend the event, creating the handler arg list
                    data = data == null ?
                    [ event ] :
                    jQuery.makeArray( data, [ event ] );

                    // Allow special events to draw outside the lines
                    special = jQuery.event.special[ type ] || {};
                    if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
                        return;
                    }

                    // Determine event propagation path in advance, per W3C events spec (#9951)
                    // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
                    if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

                        bubbleType = special.delegateType || type;
                        if ( !rfocusMorph.test( bubbleType + type ) ) {
                            cur = cur.parentNode;
                        }
                        for ( ; cur; cur = cur.parentNode ) {
                            eventPath.push( cur );
                            tmp = cur;
                        }

                        // Only add window if we got to document (e.g., not plain obj or detached DOM)
                        if ( tmp === (elem.ownerDocument || document) ) {
                            eventPath.push( tmp.defaultView || tmp.parentWindow || window );
                        }
                    }

                    // Fire handlers on the event path
                    i = 0;
                    while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

                        event.type = i > 1 ?
                        bubbleType :
                        special.bindType || type;

                        // jQuery handler
                        handle = ( jQuery._data( cur, "events" ) || {})[ event.type ] && jQuery._data( cur, "handle" );
                        if ( handle ) {
                            handle.apply( cur, data );
                        }

                        // Native handler
                        handle = ontype && cur[ ontype ];
                        if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
                            event.result = handle.apply( cur, data );
                            if ( event.result === false ) {
                                event.preventDefault();
                            }
                        }
                    }
                    event.type = type;

                    // If nobody prevented the default action, do it now
                    if ( !onlyHandlers && !event.isDefaultPrevented() ) {

                        if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
                        jQuery.acceptData( elem ) ) {

                            // Call a native DOM method on the target with the same name name as the event.
                            // Can't use an .isFunction() check here because IE6/7 fails that test.
                            // Don't do default actions on window, that's where global variables be (#6170)
                            if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {

                                // Don't re-trigger an onFOO event when we call its FOO() method
                                tmp = elem[ ontype ];

                                if ( tmp ) {
                                    elem[ ontype ] = null;
                                }

                                // Prevent re-triggering of the same event, since we already bubbled it above
                                jQuery.event.triggered = type;
                                try {
                                    elem[ type ]();
                                } catch ( e ) {
                                    // IE<9 dies on focus/blur to hidden element (#1486,#12518)
                                    // only reproducible on winXP IE8 native, not IE9 in IE8 mode
                                }
                                jQuery.event.triggered = undefined;

                                if ( tmp ) {
                                    elem[ ontype ] = tmp;
                                }
                            }
                        }
                    }

                    return event.result;
                },

                dispatch: function( event ) {

                    // Make a writable jQuery.Event from the native event object
                    event = jQuery.event.fix( event );

                    var i, ret, handleObj, matched, j,
                    handlerQueue = [],
                    args = slice.call( arguments ),
                    handlers = ( jQuery._data( this, "events" ) || {})[ event.type ] || [],
                    special = jQuery.event.special[ event.type ] || {};

                    // Use the fix-ed jQuery.Event rather than the (read-only) native event
                    args[0] = event;
                    event.delegateTarget = this;

                    // Call the preDispatch hook for the mapped type, and let it bail if desired
                    if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
                        return;
                    }

                    // Determine handlers
                    handlerQueue = jQuery.event.handlers.call( this, event, handlers );

                    // Run delegates first; they may want to stop propagation beneath us
                    i = 0;
                    while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
                        event.currentTarget = matched.elem;

                        j = 0;
                        while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

                            // Triggered event must either 1) have no namespace, or
                            // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
                            if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

                                event.handleObj = handleObj;
                                event.data = handleObj.data;

                                ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
                                .apply( matched.elem, args );

                                if ( ret !== undefined ) {
                                    if ( (event.result = ret) === false ) {
                                        event.preventDefault();
                                        event.stopPropagation();
                                    }
                                }
                            }
                        }
                    }

                    // Call the postDispatch hook for the mapped type
                    if ( special.postDispatch ) {
                        special.postDispatch.call( this, event );
                    }

                    return event.result;
                },

                handlers: function( event, handlers ) {
                    var sel, handleObj, matches, i,
                    handlerQueue = [],
                    delegateCount = handlers.delegateCount,
                    cur = event.target;

                    // Find delegate handlers
                    // Black-hole SVG <use> instance trees (#13180)
                    // Avoid non-left-click bubbling in Firefox (#3861)
                    if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

                        /* jshint eqeqeq: false */
                        for ( ; cur != this; cur = cur.parentNode || this ) {
                            /* jshint eqeqeq: true */

                            // Don't check non-elements (#13208)
                            // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                            if ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click") ) {
                                matches = [];
                                for ( i = 0; i < delegateCount; i++ ) {
                                    handleObj = handlers[ i ];

                                    // Don't conflict with Object.prototype properties (#13203)
                                    sel = handleObj.selector + " ";

                                    if ( matches[ sel ] === undefined ) {
                                        matches[ sel ] = handleObj.needsContext ?
                                        jQuery( sel, this ).index( cur ) >= 0 :
                                        jQuery.find( sel, this, null, [ cur ] ).length;
                                    }
                                    if ( matches[ sel ] ) {
                                        matches.push( handleObj );
                                    }
                                }
                                if ( matches.length ) {
                                    handlerQueue.push({
                                        elem: cur,
                                        handlers: matches 
                                    });
                                }
                            }
                        }
                    }

                    // Add the remaining (directly-bound) handlers
                    if ( delegateCount < handlers.length ) {
                        handlerQueue.push({
                            elem: this,
                            handlers: handlers.slice( delegateCount ) 
                        });
                    }

                    return handlerQueue;
                },

                fix: function( event ) {
                    if ( event[ jQuery.expando ] ) {
                        return event;
                    }

                    // Create a writable copy of the event object and normalize some properties
                    var i, prop, copy,
                    type = event.type,
                    originalEvent = event,
                    fixHook = this.fixHooks[ type ];

                    if ( !fixHook ) {
                        this.fixHooks[ type ] = fixHook =
                        rmouseEvent.test( type ) ? this.mouseHooks :
                        rkeyEvent.test( type ) ? this.keyHooks :
                        {};
                    }
                    copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

                    event = new jQuery.Event( originalEvent );

                    i = copy.length;
                    while ( i-- ) {
                        prop = copy[ i ];
                        event[ prop ] = originalEvent[ prop ];
                    }

                    // Support: IE<9
                    // Fix target property (#1925)
                    if ( !event.target ) {
                        event.target = originalEvent.srcElement || document;
                    }

                    // Support: Chrome 23+, Safari?
                    // Target should not be a text node (#504, #13143)
                    if ( event.target.nodeType === 3 ) {
                        event.target = event.target.parentNode;
                    }

                    // Support: IE<9
                    // For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
                    event.metaKey = !!event.metaKey;

                    return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
                },

                // Includes some event props shared by KeyEvent and MouseEvent
                props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

                fixHooks: {},

                keyHooks: {
                    props: "char charCode key keyCode".split(" "),
                    filter: function( event, original ) {

                        // Add which for key events
                        if ( event.which == null ) {
                            event.which = original.charCode != null ? original.charCode : original.keyCode;
                        }

                        return event;
                    }
                },

                mouseHooks: {
                    props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
                    filter: function( event, original ) {
                        var body, eventDoc, doc,
                        button = original.button,
                        fromElement = original.fromElement;

                        // Calculate pageX/Y if missing and clientX/Y available
                        if ( event.pageX == null && original.clientX != null ) {
                            eventDoc = event.target.ownerDocument || document;
                            doc = eventDoc.documentElement;
                            body = eventDoc.body;

                            event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
                            event.pageY = original.clientY + ( doc && doc.scrollTop || body && body.scrollTop || 0 ) - ( doc && doc.clientTop || body && body.clientTop || 0 );
                        }

                        // Add relatedTarget, if necessary
                        if ( !event.relatedTarget && fromElement ) {
                            event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
                        }

                        // Add which for click: 1 === left; 2 === middle; 3 === right
                        // Note: button is not normalized, so don't use it
                        if ( !event.which && button !== undefined ) {
                            event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
                        }

                        return event;
                    }
                },

                special: {
                    load: {
                        // Prevent triggered image.load events from bubbling to window.load
                        noBubble: true
                    },
                    focus: {
                        // Fire native event if possible so blur/focus sequence is correct
                        trigger: function() {
                            if ( this !== safeActiveElement() && this.focus ) {
                                try {
                                    this.focus();
                                    return false;
                                } catch ( e ) {
                                    // Support: IE<9
                                    // If we error on focus to hidden element (#1486, #12518),
                                    // let .trigger() run the handlers
                                }
                            }
                        },
                        delegateType: "focusin"
                    },
                    blur: {
                        trigger: function() {
                            if ( this === safeActiveElement() && this.blur ) {
                                this.blur();
                                return false;
                            }
                        },
                        delegateType: "focusout"
                    },
                    click: {
                        // For checkbox, fire native event so checked state will be right
                        trigger: function() {
                            if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {
                                this.click();
                                return false;
                            }
                        },

                        // For cross-browser consistency, don't fire native .click() on links
                        _default: function( event ) {
                            return jQuery.nodeName( event.target, "a" );
                        }
                    },

                    beforeunload: {
                        postDispatch: function( event ) {

                            // Even when returnValue equals to undefined Firefox will still show alert
                            if ( event.result !== undefined ) {
                                event.originalEvent.returnValue = event.result;
                            }
                        }
                    }
                },

                simulate: function( type, elem, event, bubble ) {
                    // Piggyback on a donor event to simulate a different one.
                    // Fake originalEvent to avoid donor's stopPropagation, but if the
                    // simulated event prevents default then we do the same on the donor.
                    var e = jQuery.extend(
                    new jQuery.Event(),
                    event,
                    {
                        type: type,
                        isSimulated: true,
                        originalEvent: {}
                    });
                    if ( bubble ) {
                        jQuery.event.trigger( e, null, elem );
                    } else {
                        jQuery.event.dispatch.call( elem, e );
                    }
                    if ( e.isDefaultPrevented() ) {
                        event.preventDefault();
                    }
                }
            };

            jQuery.removeEvent = document.removeEventListener ?
            function( elem, type, handle ) {
                if ( elem.removeEventListener ) {
                    elem.removeEventListener( type, handle, false );
                }
            } :
            function( elem, type, handle ) {
                var name = "on" + type;

                if ( elem.detachEvent ) {

                    // #8545, #7054, preventing memory leaks for custom events in IE6-8
                    // detachEvent needed property on element, by name of that event, to properly expose it to GC
                    if ( typeof elem[ name ] === strundefined ) {
                        elem[ name ] = null;
                    }

                    elem.detachEvent( name, handle );
                }
            };

            jQuery.Event = function( src, props ) {
                // Allow instantiation without the 'new' keyword
                if ( !(this instanceof jQuery.Event) ) {
                    return new jQuery.Event( src, props );
                }

                // Event object
                if ( src && src.type ) {
                    this.originalEvent = src;
                    this.type = src.type;

                    // Events bubbling up the document may have been marked as prevented
                    // by a handler lower down the tree; reflect the correct value.
                    this.isDefaultPrevented = src.defaultPrevented ||
                    src.defaultPrevented === undefined && (
                    // Support: IE < 9
                    src.returnValue === false ||
                    // Support: Android < 4.0
                    src.getPreventDefault && src.getPreventDefault() ) ?
                    returnTrue :
                    returnFalse;

                    // Event type
                } else {
                    this.type = src;
                }

                // Put explicitly provided properties onto the event object
                if ( props ) {
                    jQuery.extend( this, props );
                }

                // Create a timestamp if incoming event doesn't have one
                this.timeStamp = src && src.timeStamp || jQuery.now();

                // Mark it as fixed
                this[ jQuery.expando ] = true;
            };

            // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
            // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
            jQuery.Event.prototype = {
                isDefaultPrevented: returnFalse,
                isPropagationStopped: returnFalse,
                isImmediatePropagationStopped: returnFalse,

                preventDefault: function() {
                    var e = this.originalEvent;

                    this.isDefaultPrevented = returnTrue;
                    if ( !e ) {
                        return;
                    }

                    // If preventDefault exists, run it on the original event
                    if ( e.preventDefault ) {
                        e.preventDefault();

                        // Support: IE
                        // Otherwise set the returnValue property of the original event to false
                    } else {
                        e.returnValue = false;
                    }
                },
                stopPropagation: function() {
                    var e = this.originalEvent;

                    this.isPropagationStopped = returnTrue;
                    if ( !e ) {
                        return;
                    }
                    // If stopPropagation exists, run it on the original event
                    if ( e.stopPropagation ) {
                        e.stopPropagation();
                    }

                    // Support: IE
                    // Set the cancelBubble property of the original event to true
                    e.cancelBubble = true;
                },
                stopImmediatePropagation: function() {
                    this.isImmediatePropagationStopped = returnTrue;
                    this.stopPropagation();
                }
            };

            // Create mouseenter/leave events using mouseover/out and event-time checks
            jQuery.each({
                mouseenter: "mouseover",
                mouseleave: "mouseout"
            }, function( orig, fix ) {
                jQuery.event.special[ orig ] = {
                    delegateType: fix,
                    bindType: fix,

                    handle: function( event ) {
                        var ret,
                        target = this,
                        related = event.relatedTarget,
                        handleObj = event.handleObj;

                        // For mousenter/leave call the handler if related is outside the target.
                        // NB: No relatedTarget if the mouse left/entered the browser window
                        if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
                            event.type = handleObj.origType;
                            ret = handleObj.handler.apply( this, arguments );
                            event.type = fix;
                        }
                        return ret;
                    }
                };
            });

            // IE submit delegation
            if ( !support.submitBubbles ) {

                jQuery.event.special.submit = {
                    setup: function() {
                        // Only need this for delegated form submit events
                        if ( jQuery.nodeName( this, "form" ) ) {
                            return false;
                        }

                        // Lazy-add a submit handler when a descendant form may potentially be submitted
                        jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
                            // Node name check avoids a VML-related crash in IE (#9807)
                            var elem = e.target,
                            form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
                            if ( form && !jQuery._data( form, "submitBubbles" ) ) {
                                jQuery.event.add( form, "submit._submit", function( event ) {
                                    event._submit_bubble = true;
                                });
                                jQuery._data( form, "submitBubbles", true );
                            }
                        });
                        // return undefined since we don't need an event listener
                    },

                    postDispatch: function( event ) {
                        // If form was submitted by the user, bubble the event up the tree
                        if ( event._submit_bubble ) {
                            delete event._submit_bubble;
                            if ( this.parentNode && !event.isTrigger ) {
                                jQuery.event.simulate( "submit", this.parentNode, event, true );
                            }
                        }
                    },

                    teardown: function() {
                        // Only need this for delegated form submit events
                        if ( jQuery.nodeName( this, "form" ) ) {
                            return false;
                        }

                        // Remove delegated handlers; cleanData eventually reaps submit handlers attached above
                        jQuery.event.remove( this, "._submit" );
                    }
                };
            }

            // IE change delegation and checkbox/radio fix
            if ( !support.changeBubbles ) {

                jQuery.event.special.change = {

                    setup: function() {

                        if ( rformElems.test( this.nodeName ) ) {
                            // IE doesn't fire change on a check/radio until blur; trigger it on click
                            // after a propertychange. Eat the blur-change in special.change.handle.
                            // This still fires onchange a second time for check/radio after blur.
                            if ( this.type === "checkbox" || this.type === "radio" ) {
                                jQuery.event.add( this, "propertychange._change", function( event ) {
                                    if ( event.originalEvent.propertyName === "checked" ) {
                                        this._just_changed = true;
                                    }
                                });
                                jQuery.event.add( this, "click._change", function( event ) {
                                    if ( this._just_changed && !event.isTrigger ) {
                                        this._just_changed = false;
                                    }
                                    // Allow triggered, simulated change events (#11500)
                                    jQuery.event.simulate( "change", this, event, true );
                                });
                            }
                            return false;
                        }
                        // Delegated event; lazy-add a change handler on descendant inputs
                        jQuery.event.add( this, "beforeactivate._change", function( e ) {
                            var elem = e.target;

                            if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "changeBubbles" ) ) {
                                jQuery.event.add( elem, "change._change", function( event ) {
                                    if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
                                        jQuery.event.simulate( "change", this.parentNode, event, true );
                                    }
                                });
                                jQuery._data( elem, "changeBubbles", true );
                            }
                        });
                    },

                    handle: function( event ) {
                        var elem = event.target;

                        // Swallow native change events from checkbox/radio, we already triggered them above
                        if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
                            return event.handleObj.handler.apply( this, arguments );
                        }
                    },

                    teardown: function() {
                        jQuery.event.remove( this, "._change" );

                        return !rformElems.test( this.nodeName );
                    }
                };
            }

            // Create "bubbling" focus and blur events
            if ( !support.focusinBubbles ) {
                jQuery.each({
                    focus: "focusin",
                    blur: "focusout" 
                }, function( orig, fix ) {

                    // Attach a single capturing handler on the document while someone wants focusin/focusout
                    var handler = function( event ) {
                        jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
                    };

                    jQuery.event.special[ fix ] = {
                        setup: function() {
                            var doc = this.ownerDocument || this,
                            attaches = jQuery._data( doc, fix );

                            if ( !attaches ) {
                                doc.addEventListener( orig, handler, true );
                            }
                            jQuery._data( doc, fix, ( attaches || 0 ) + 1 );
                        },
                        teardown: function() {
                            var doc = this.ownerDocument || this,
                            attaches = jQuery._data( doc, fix ) - 1;

                            if ( !attaches ) {
                                doc.removeEventListener( orig, handler, true );
                                jQuery._removeData( doc, fix );
                            } else {
                                jQuery._data( doc, fix, attaches );
                            }
                        }
                    };
                });
            }

            jQuery.fn.extend({

                on: function( types, selector, data, fn, /*INTERNAL*/
                one ) {
                    var type, origFn;

                    // Types can be a map of types/handlers
                    if ( typeof types === "object" ) {
                        // ( types-Object, selector, data )
                        if ( typeof selector !== "string" ) {
                            // ( types-Object, data )
                            data = data || selector;
                            selector = undefined;
                        }
                        for ( type in types ) {
                            this.on( type, selector, data, types[ type ], one );
                        }
                        return this;
                    }

                    if ( data == null && fn == null ) {
                        // ( types, fn )
                        fn = selector;
                        data = selector = undefined;
                    } else if ( fn == null ) {
                        if ( typeof selector === "string" ) {
                            // ( types, selector, fn )
                            fn = data;
                            data = undefined;
                        } else {
                            // ( types, data, fn )
                            fn = data;
                            data = selector;
                            selector = undefined;
                        }
                    }
                    if ( fn === false ) {
                        fn = returnFalse;
                    } else if ( !fn ) {
                        return this;
                    }

                    if ( one === 1 ) {
                        origFn = fn;
                        fn = function( event ) {
                            // Can use an empty set, since event contains the info
                            jQuery().off( event );
                            return origFn.apply( this, arguments );
                        };
                        // Use same guid so caller can remove using origFn
                        fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
                    }
                    return this.each( function() {
                        jQuery.event.add( this, types, fn, data, selector );
                    });
                },
                one: function( types, selector, data, fn ) {
                    return this.on( types, selector, data, fn, 1 );
                },
                off: function( types, selector, fn ) {
                    var handleObj, type;
                    if ( types && types.preventDefault && types.handleObj ) {
                        // ( event )  dispatched jQuery.Event
                        handleObj = types.handleObj;
                        jQuery( types.delegateTarget ).off(
                        handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
                        handleObj.selector,
                        handleObj.handler
                        );
                        return this;
                    }
                    if ( typeof types === "object" ) {
                        // ( types-object [, selector] )
                        for ( type in types ) {
                            this.off( type, selector, types[ type ] );
                        }
                        return this;
                    }
                    if ( selector === false || typeof selector === "function" ) {
                        // ( types [, fn] )
                        fn = selector;
                        selector = undefined;
                    }
                    if ( fn === false ) {
                        fn = returnFalse;
                    }
                    return this.each(function() {
                        jQuery.event.remove( this, types, fn, selector );
                    });
                },

                trigger: function( type, data ) {
                    return this.each(function() {
                        jQuery.event.trigger( type, data, this );
                    });
                },
                triggerHandler: function( type, data ) {
                    var elem = this[0];
                    if ( elem ) {
                        return jQuery.event.trigger( type, data, elem, true );
                    }
                }
            });


            function createSafeFragment( document ) {
                var list = nodeNames.split( "|" ),
                safeFrag = document.createDocumentFragment();

                if ( safeFrag.createElement ) {
                    while ( list.length ) {
                        safeFrag.createElement(
                        list.pop()
                        );
                    }
                }
                return safeFrag;
            }

            var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
            "header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
            rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
            rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
            rleadingWhitespace = /^\s+/,
            rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
            rtagName = /<([\w:]+)/,
            rtbody = /<tbody/i,
            rhtml = /<|&#?\w+;/,
            rnoInnerhtml = /<(?:script|style|link)/i,
            // checked="checked" or checked
            rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
            rscriptType = /^$|\/(?:java|ecma)script/i,
            rscriptTypeMasked = /^true\/(.*)/,
            rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
            // We have to close these tags to support XHTML (#13200)
            wrapMap = {
                option: [ 1, "<select multiple='multiple'>", "</select>" ],
                legend: [ 1, "<fieldset>", "</fieldset>" ],
                area: [ 1, "<map>", "</map>" ],
                param: [ 1, "<object>", "</object>" ],
                thead: [ 1, "<table>", "</table>" ],
                tr: [ 2, "<table><tbody>", "</tbody></table>" ],
                col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
                td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

                // IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
                // unless wrapped in a div with non-breaking characters in front of it.
                _default: support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>" ]
            },
            safeFragment = createSafeFragment( document ),
            fragmentDiv = safeFragment.appendChild( document.createElement("div") );

            wrapMap.optgroup = wrapMap.option;
            wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
            wrapMap.th = wrapMap.td;

            function getAll( context, tag ) {
                var elems, elem,
                i = 0,
                found = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName( tag || "*" ) :
                typeof context.querySelectorAll !== strundefined ? context.querySelectorAll( tag || "*" ) :
                undefined;

                if ( !found ) {
                    for ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {
                        if ( !tag || jQuery.nodeName( elem, tag ) ) {
                            found.push( elem );
                        } else {
                            jQuery.merge( found, getAll( elem, tag ) );
                        }
                    }
                }

                return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
                jQuery.merge( [ context ], found ) :
                found;
            }

            // Used in buildFragment, fixes the defaultChecked property
            function fixDefaultChecked( elem ) {
                if ( rcheckableType.test( elem.type ) ) {
                    elem.defaultChecked = elem.checked;
                }
            }

            // Support: IE<8
            // Manipulating tables requires a tbody
            function manipulationTarget( elem, content ) {
                return jQuery.nodeName( elem, "table" ) &&
                jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?
                elem.getElementsByTagName("tbody")[0] ||
                elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
                elem;
            }

            // Replace/restore the type attribute of script elements for safe DOM manipulation
            function disableScript( elem ) {
                elem.type = (jQuery.find.attr( elem, "type" ) !== null) + "/" + elem.type;
                return elem;
            }
            function restoreScript( elem ) {
                var match = rscriptTypeMasked.exec( elem.type );
                if ( match ) {
                    elem.type = match[1];
                } else {
                    elem.removeAttribute("type");
                }
                return elem;
            }

            // Mark scripts as having already been evaluated
            function setGlobalEval( elems, refElements ) {
                var elem,
                i = 0;
                for ( ; (elem = elems[i]) != null; i++ ) {
                    jQuery._data( elem, "globalEval", !refElements || jQuery._data( refElements[i], "globalEval" ) );
                }
            }

            function cloneCopyEvent( src, dest ) {

                if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
                    return;
                }

                var type, i, l,
                oldData = jQuery._data( src ),
                curData = jQuery._data( dest, oldData ),
                events = oldData.events;

                if ( events ) {
                    delete curData.handle;
                    curData.events = {};

                    for ( type in events ) {
                        for ( i = 0, l = events[ type ].length; i < l; i++ ) {
                            jQuery.event.add( dest, type, events[ type ][ i ] );
                        }
                    }
                }

                // make the cloned public data object a copy from the original
                if ( curData.data ) {
                    curData.data = jQuery.extend( {}, curData.data );
                }
            }

            function fixCloneNodeIssues( src, dest ) {
                var nodeName, e, data;

                // We do not need to do anything for non-Elements
                if ( dest.nodeType !== 1 ) {
                    return;
                }

                nodeName = dest.nodeName.toLowerCase();

                // IE6-8 copies events bound via attachEvent when using cloneNode.
                if ( !support.noCloneEvent && dest[ jQuery.expando ] ) {
                    data = jQuery._data( dest );

                    for ( e in data.events ) {
                        jQuery.removeEvent( dest, e, data.handle );
                    }

                    // Event data gets referenced instead of copied if the expando gets copied too
                    dest.removeAttribute( jQuery.expando );
                }

                // IE blanks contents when cloning scripts, and tries to evaluate newly-set text
                if ( nodeName === "script" && dest.text !== src.text ) {
                    disableScript( dest ).text = src.text;
                    restoreScript( dest );

                    // IE6-10 improperly clones children of object elements using classid.
                    // IE10 throws NoModificationAllowedError if parent is null, #12132.
                } else if ( nodeName === "object" ) {
                    if ( dest.parentNode ) {
                        dest.outerHTML = src.outerHTML;
                    }

                    // This path appears unavoidable for IE9. When cloning an object
                    // element in IE9, the outerHTML strategy above is not sufficient.
                    // If the src has innerHTML and the destination does not,
                    // copy the src.innerHTML into the dest.innerHTML. #10324
                    if ( support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {
                        dest.innerHTML = src.innerHTML;
                    }

                } else if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
                    // IE6-8 fails to persist the checked state of a cloned checkbox
                    // or radio button. Worse, IE6-7 fail to give the cloned element
                    // a checked appearance if the defaultChecked value isn't also set

                    dest.defaultChecked = dest.checked = src.checked;

                    // IE6-7 get confused and end up setting the value of a cloned
                    // checkbox/radio button to an empty string instead of "on"
                    if ( dest.value !== src.value ) {
                        dest.value = src.value;
                    }

                    // IE6-8 fails to return the selected option to the default selected
                    // state when cloning options
                } else if ( nodeName === "option" ) {
                    dest.defaultSelected = dest.selected = src.defaultSelected;

                    // IE6-8 fails to set the defaultValue to the correct value when
                    // cloning other types of input fields
                } else if ( nodeName === "input" || nodeName === "textarea" ) {
                    dest.defaultValue = src.defaultValue;
                }
            }

            jQuery.extend({
                clone: function( elem, dataAndEvents, deepDataAndEvents ) {
                    var destElements, node, clone, i, srcElements,
                    inPage = jQuery.contains( elem.ownerDocument, elem );

                    if ( support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
                        clone = elem.cloneNode( true );

                        // IE<=8 does not properly clone detached, unknown element nodes
                    } else {
                        fragmentDiv.innerHTML = elem.outerHTML;
                        fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
                    }

                    if ( (!support.noCloneEvent || !support.noCloneChecked) &&
                    (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {

                        // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
                        destElements = getAll( clone );
                        srcElements = getAll( elem );

                        // Fix all IE cloning issues
                        for ( i = 0; (node = srcElements[i]) != null; ++i ) {
                            // Ensure that the destination node is not null; Fixes #9587
                            if ( destElements[i] ) {
                                fixCloneNodeIssues( node, destElements[i] );
                            }
                        }
                    }

                    // Copy the events from the original to the clone
                    if ( dataAndEvents ) {
                        if ( deepDataAndEvents ) {
                            srcElements = srcElements || getAll( elem );
                            destElements = destElements || getAll( clone );

                            for ( i = 0; (node = srcElements[i]) != null; i++ ) {
                                cloneCopyEvent( node, destElements[i] );
                            }
                        } else {
                            cloneCopyEvent( elem, clone );
                        }
                    }

                    // Preserve script evaluation history
                    destElements = getAll( clone, "script" );
                    if ( destElements.length > 0 ) {
                        setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
                    }

                    destElements = srcElements = node = null;

                    // Return the cloned set
                    return clone;
                },

                buildFragment: function( elems, context, scripts, selection ) {
                    var j, elem, contains,
                    tmp, tag, tbody, wrap,
                    l = elems.length,
                    // Ensure a safe fragment
                    safe = createSafeFragment( context ),
                    nodes = [],
                    i = 0;

                    for ( ; i < l; i++ ) {
                        elem = elems[ i ];

                        if ( elem || elem === 0 ) {

                            // Add nodes directly
                            if ( jQuery.type( elem ) === "object" ) {
                                jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

                                // Convert non-html into a text node
                            } else if ( !rhtml.test( elem ) ) {
                                nodes.push( context.createTextNode( elem ) );

                                // Convert html into DOM nodes
                            } else {
                                tmp = tmp || safe.appendChild( context.createElement("div") );

                                // Deserialize a standard representation
                                tag = (rtagName.exec( elem ) || [ "", "" ])[ 1 ].toLowerCase();
                                wrap = wrapMap[ tag ] || wrapMap._default;

                                tmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[2];

                                // Descend through wrappers to the right content
                                j = wrap[0];
                                while ( j-- ) {
                                    tmp = tmp.lastChild;
                                }

                                // Manually add leading whitespace removed by IE
                                if ( !support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
                                    nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );
                                }

                                // Remove IE's autoinserted <tbody> from table fragments
                                if ( !support.tbody ) {

                                    // String was a <table>, *may* have spurious <tbody>
                                    elem = tag === "table" && !rtbody.test( elem ) ?
                                    tmp.firstChild :
                                    // String was a bare <thead> or <tfoot>
                                    wrap[1] === "<table>" && !rtbody.test( elem ) ?
                                    tmp :
                                    0;

                                    j = elem && elem.childNodes.length;
                                    while ( j-- ) {
                                        if ( jQuery.nodeName( (tbody = elem.childNodes[j]), "tbody" ) && !tbody.childNodes.length ) {
                                            elem.removeChild( tbody );
                                        }
                                    }
                                }

                                jQuery.merge( nodes, tmp.childNodes );

                                // Fix #12392 for WebKit and IE > 9
                                tmp.textContent = "";

                                // Fix #12392 for oldIE
                                while ( tmp.firstChild ) {
                                    tmp.removeChild( tmp.firstChild );
                                }

                                // Remember the top-level container for proper cleanup
                                tmp = safe.lastChild;
                            }
                        }
                    }

                    // Fix #11356: Clear elements from fragment
                    if ( tmp ) {
                        safe.removeChild( tmp );
                    }

                    // Reset defaultChecked for any radios and checkboxes
                    // about to be appended to the DOM in IE 6/7 (#8060)
                    if ( !support.appendChecked ) {
                        jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );
                    }

                    i = 0;
                    while ( (elem = nodes[ i++ ]) ) {

                        // #4087 - If origin and destination elements are the same, and this is
                        // that element, do not do anything
                        if ( selection && jQuery.inArray( elem, selection ) !== - 1 ) {
                            continue;
                        }

                        contains = jQuery.contains( elem.ownerDocument, elem );

                        // Append to fragment
                        tmp = getAll( safe.appendChild( elem ), "script" );

                        // Preserve script evaluation history
                        if ( contains ) {
                            setGlobalEval( tmp );
                        }

                        // Capture executables
                        if ( scripts ) {
                            j = 0;
                            while ( (elem = tmp[ j++ ]) ) {
                                if ( rscriptType.test( elem.type || "" ) ) {
                                    scripts.push( elem );
                                }
                            }
                        }
                    }

                    tmp = null;

                    return safe;
                },

                cleanData: function( elems, /* internal */
                acceptData ) {
                    var elem, type, id, data,
                    i = 0,
                    internalKey = jQuery.expando,
                    cache = jQuery.cache,
                    deleteExpando = support.deleteExpando,
                    special = jQuery.event.special;

                    for ( ; (elem = elems[i]) != null; i++ ) {
                        if ( acceptData || jQuery.acceptData( elem ) ) {

                            id = elem[ internalKey ];
                            data = id && cache[ id ];

                            if ( data ) {
                                if ( data.events ) {
                                    for ( type in data.events ) {
                                        if ( special[ type ] ) {
                                            jQuery.event.remove( elem, type );

                                            // This is a shortcut to avoid jQuery.event.remove's overhead
                                        } else {
                                            jQuery.removeEvent( elem, type, data.handle );
                                        }
                                    }
                                }

                                // Remove cache only if it was not already removed by jQuery.event.remove
                                if ( cache[ id ] ) {

                                    delete cache[ id ];

                                    // IE does not allow us to delete expando properties from nodes,
                                    // nor does it have a removeAttribute function on Document nodes;
                                    // we must handle all of these cases
                                    if ( deleteExpando ) {
                                        delete elem[ internalKey ];

                                    } else if ( typeof elem.removeAttribute !== strundefined ) {
                                        elem.removeAttribute( internalKey );

                                    } else {
                                        elem[ internalKey ] = null;
                                    }

                                    deletedIds.push( id );
                                }
                            }
                        }
                    }
                }
            });

            jQuery.fn.extend({
                text: function( value ) {
                    return access( this, function( value ) {
                        return value === undefined ?
                        jQuery.text( this ) :
                        this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
                    }, null, value, arguments.length );
                },

                append: function() {
                    return this.domManip( arguments, function( elem ) {
                        if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                            var target = manipulationTarget( this, elem );
                            target.appendChild( elem );
                        }
                    });
                },

                prepend: function() {
                    return this.domManip( arguments, function( elem ) {
                        if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                            var target = manipulationTarget( this, elem );
                            target.insertBefore( elem, target.firstChild );
                        }
                    });
                },

                before: function() {
                    return this.domManip( arguments, function( elem ) {
                        if ( this.parentNode ) {
                            this.parentNode.insertBefore( elem, this );
                        }
                    });
                },

                after: function() {
                    return this.domManip( arguments, function( elem ) {
                        if ( this.parentNode ) {
                            this.parentNode.insertBefore( elem, this.nextSibling );
                        }
                    });
                },

                remove: function( selector, keepData /* Internal Use Only */
                ) {
                    var elem,
                    elems = selector ? jQuery.filter( selector, this ) : this,
                    i = 0;

                    for ( ; (elem = elems[i]) != null; i++ ) {

                        if ( !keepData && elem.nodeType === 1 ) {
                            jQuery.cleanData( getAll( elem ) );
                        }

                        if ( elem.parentNode ) {
                            if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
                                setGlobalEval( getAll( elem, "script" ) );
                            }
                            elem.parentNode.removeChild( elem );
                        }
                    }

                    return this;
                },

                empty: function() {
                    var elem,
                    i = 0;

                    for ( ; (elem = this[i]) != null; i++ ) {
                        // Remove element nodes and prevent memory leaks
                        if ( elem.nodeType === 1 ) {
                            jQuery.cleanData( getAll( elem, false ) );
                        }

                        // Remove any remaining nodes
                        while ( elem.firstChild ) {
                            elem.removeChild( elem.firstChild );
                        }

                        // If this is a select, ensure that it displays empty (#12336)
                        // Support: IE<9
                        if ( elem.options && jQuery.nodeName( elem, "select" ) ) {
                            elem.options.length = 0;
                        }
                    }

                    return this;
                },

                clone: function( dataAndEvents, deepDataAndEvents ) {
                    dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
                    deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

                    return this.map(function() {
                        return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
                    });
                },

                html: function( value ) {
                    return access( this, function( value ) {
                        var elem = this[ 0 ] || {},
                        i = 0,
                        l = this.length;

                        if ( value === undefined ) {
                            return elem.nodeType === 1 ?
                            elem.innerHTML.replace( rinlinejQuery, "" ) :
                            undefined;
                        }

                        // See if we can take a shortcut and just use innerHTML
                        if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
                        ( support.htmlSerialize || !rnoshimcache.test( value ) ) &&
                        ( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
                        !wrapMap[ (rtagName.exec( value ) || [ "", "" ])[ 1 ].toLowerCase() ] ) {

                            value = value.replace( rxhtmlTag, "<$1></$2>" );

                            try {
                                for (; i < l; i++ ) {
                                    // Remove element nodes and prevent memory leaks
                                    elem = this[i] || {};
                                    if ( elem.nodeType === 1 ) {
                                        jQuery.cleanData( getAll( elem, false ) );
                                        elem.innerHTML = value;
                                    }
                                }

                                elem = 0;

                                // If using innerHTML throws an exception, use the fallback method
                            } catch (e) {}
                        }

                        if ( elem ) {
                            this.empty().append( value );
                        }
                    }, null, value, arguments.length );
                },

                replaceWith: function() {
                    var arg = arguments[ 0 ];

                    // Make the changes, replacing each context element with the new content
                    this.domManip( arguments, function( elem ) {
                        arg = this.parentNode;

                        jQuery.cleanData( getAll( this ) );

                        if ( arg ) {
                            arg.replaceChild( elem, this );
                        }
                    });

                    // Force removal if there was no new content (e.g., from empty arguments)
                    return arg && (arg.length || arg.nodeType) ? this : this.remove();
                },

                detach: function( selector ) {
                    return this.remove( selector, true );
                },

                domManip: function( args, callback ) {

                    // Flatten any nested arrays
                    args = concat.apply( [], args );

                    var first, node, hasScripts,
                    scripts, doc, fragment,
                    i = 0,
                    l = this.length,
                    set = this,
                    iNoClone = l - 1,
                    value = args[0],
                    isFunction = jQuery.isFunction( value );

                    // We can't cloneNode fragments that contain checked, in WebKit
                    if ( isFunction ||
                    ( l > 1 && typeof value === "string" &&
                    !support.checkClone && rchecked.test( value ) ) ) {
                        return this.each(function( index ) {
                            var self = set.eq( index );
                            if ( isFunction ) {
                                args[0] = value.call( this, index, self.html() );
                            }
                            self.domManip( args, callback );
                        });
                    }

                    if ( l ) {
                        fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
                        first = fragment.firstChild;

                        if ( fragment.childNodes.length === 1 ) {
                            fragment = first;
                        }

                        if ( first ) {
                            scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
                            hasScripts = scripts.length;

                            // Use the original fragment for the last item instead of the first because it can end up
                            // being emptied incorrectly in certain situations (#8070).
                            for ( ; i < l; i++ ) {
                                node = fragment;

                                if ( i !== iNoClone ) {
                                    node = jQuery.clone( node, true, true );

                                    // Keep references to cloned scripts for later restoration
                                    if ( hasScripts ) {
                                        jQuery.merge( scripts, getAll( node, "script" ) );
                                    }
                                }

                                callback.call( this[i], node, i );
                            }

                            if ( hasScripts ) {
                                doc = scripts[ scripts.length - 1 ].ownerDocument;

                                // Reenable scripts
                                jQuery.map( scripts, restoreScript );

                                // Evaluate executable scripts on first document insertion
                                for ( i = 0; i < hasScripts; i++ ) {
                                    node = scripts[ i ];
                                    if ( rscriptType.test( node.type || "" ) &&
                                    !jQuery._data( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

                                        if ( node.src ) {
                                            // Optional AJAX dependency, but won't run scripts if not present
                                            if ( jQuery._evalUrl ) {
                                                jQuery._evalUrl( node.src );
                                            }
                                        } else {
                                            jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || "" ).replace( rcleanScript, "" ) );
                                        }
                                    }
                                }
                            }

                            // Fix #11809: Avoid leaking memory
                            fragment = first = null;
                        }
                    }

                    return this;
                }
            });

            jQuery.each({
                appendTo: "append",
                prependTo: "prepend",
                insertBefore: "before",
                insertAfter: "after",
                replaceAll: "replaceWith"
            }, function( name, original ) {
                jQuery.fn[ name ] = function( selector ) {
                    var elems,
                    i = 0,
                    ret = [],
                    insert = jQuery( selector ),
                    last = insert.length - 1;

                    for ( ; i <= last; i++ ) {
                        elems = i === last ? this : this.clone(true);
                        jQuery( insert[i] )[ original ]( elems );

                        // Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
                        push.apply( ret, elems.get() );
                    }

                    return this.pushStack( ret );
                };
            });


            var iframe,
            elemdisplay = {};

            /**
             * Retrieve the actual display of a element
             * @param {String} name nodeName of the element
             * @param {Object} doc Document object
             */
            // Called only from within defaultDisplay
            function actualDisplay( name, doc ) {
                var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),
                // getDefaultComputedStyle might be reliably used only on attached element
                display = window.getDefaultComputedStyle ?
                // Use of this method is a temporary fix (more like optmization) until something better comes along,
                // since it was removed from specification and supported only in FF
                window.getDefaultComputedStyle( elem[ 0 ] ).display : jQuery.css( elem[ 0 ], "display" );

                // We don't have any data stored on the element,
                // so use "detach" method as fast way to get rid of the element
                elem.detach();

                return display;
            }

            /**
             * Try to determine the default display value of an element
             * @param {String} nodeName
             */
            function defaultDisplay( nodeName ) {
                var doc = document,
                display = elemdisplay[ nodeName ];

                if ( !display ) {
                    display = actualDisplay( nodeName, doc );

                    // If the simple way fails, read from inside an iframe
                    if ( display === "none" || !display ) {

                        // Use the already-created iframe if possible
                        iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

                        // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
                        doc = ( iframe[ 0 ].contentWindow || iframe[ 0 ].contentDocument ).document;

                        // Support: IE
                        doc.write();
                        doc.close();

                        display = actualDisplay( nodeName, doc );
                        iframe.detach();
                    }

                    // Store the correct default display
                    elemdisplay[ nodeName ] = display;
                }

                return display;
            }

(function() {
                var a, shrinkWrapBlocksVal,
                div = document.createElement( "div" ),
                divReset =
                "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;" +
                "display:block;padding:0;margin:0;border:0";

                // Setup
                div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
                a = div.getElementsByTagName( "a" )[ 0 ];

                a.style.cssText = "float:left;opacity:.5";

                // Make sure that element opacity exists
                // (IE uses filter instead)
                // Use a regex to work around a WebKit issue. See #5145
                support.opacity = /^0.5/.test( a.style.opacity );

                // Verify style float existence
                // (IE uses styleFloat instead of cssFloat)
                support.cssFloat = !!a.style.cssFloat;

                div.style.backgroundClip = "content-box";
                div.cloneNode( true ).style.backgroundClip = "";
                support.clearCloneStyle = div.style.backgroundClip === "content-box";

                // Null elements to avoid leaks in IE.
                a = div = null;

                support.shrinkWrapBlocks = function() {
                    var body, container, div, containerStyles;

                    if ( shrinkWrapBlocksVal == null ) {
                        body = document.getElementsByTagName( "body" )[ 0 ];
                        if ( !body ) {
                            // Test fired too early or in an unsupported environment, exit.
                            return;
                        }

                        containerStyles = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px";
                        container = document.createElement( "div" );
                        div = document.createElement( "div" );

                        body.appendChild( container ).appendChild( div );

                        // Will be changed later if needed.
                        shrinkWrapBlocksVal = false;

                        if ( typeof div.style.zoom !== strundefined ) {
                            // Support: IE6
                            // Check if elements with layout shrink-wrap their children
                            div.style.cssText = divReset + ";width:1px;padding:1px;zoom:1";
                            div.innerHTML = "<div></div>";
                            div.firstChild.style.width = "5px";
                            shrinkWrapBlocksVal = div.offsetWidth !== 3;
                        }

                        body.removeChild( container );

                        // Null elements to avoid leaks in IE.
                        body = container = div = null;
                    }

                    return shrinkWrapBlocksVal;
                };

            })();
            var rmargin = (/^margin/);

            var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );



            var getStyles, curCSS,
            rposition = /^(top|right|bottom|left)$/;

            if ( window.getComputedStyle ) {
                getStyles = function( elem ) {
                    return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
                };

                curCSS = function( elem, name, computed ) {
                    var width, minWidth, maxWidth, ret,
                    style = elem.style;

                    computed = computed || getStyles( elem );

                    // getPropertyValue is only needed for .css('filter') in IE9, see #12537
                    ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;

                    if ( computed ) {

                        if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
                            ret = jQuery.style( elem, name );
                        }

                        // A tribute to the "awesome hack by Dean Edwards"
                        // Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
                        // Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
                        // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
                        if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

                            // Remember the original values
                            width = style.width;
                            minWidth = style.minWidth;
                            maxWidth = style.maxWidth;

                            // Put in the new values to get a computed value out
                            style.minWidth = style.maxWidth = style.width = ret;
                            ret = computed.width;

                            // Revert the changed values
                            style.width = width;
                            style.minWidth = minWidth;
                            style.maxWidth = maxWidth;
                        }
                    }

                    // Support: IE
                    // IE returns zIndex value as an integer.
                    return ret === undefined ?
                    ret :
                    ret + "";
                };
            } else if ( document.documentElement.currentStyle ) {
                getStyles = function( elem ) {
                    return elem.currentStyle;
                };

                curCSS = function( elem, name, computed ) {
                    var left, rs, rsLeft, ret,
                    style = elem.style;

                    computed = computed || getStyles( elem );
                    ret = computed ? computed[ name ] : undefined;

                    // Avoid setting ret to empty string here
                    // so we don't default to auto
                    if ( ret == null && style && style[ name ] ) {
                        ret = style[ name ];
                    }

                    // From the awesome hack by Dean Edwards
                    // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

                    // If we're not dealing with a regular pixel number
                    // but a number that has a weird ending, we need to convert it to pixels
                    // but not position css attributes, as those are proportional to the parent element instead
                    // and we can't measure the parent instead because it might trigger a "stacking dolls" problem
                    if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {

                        // Remember the original values
                        left = style.left;
                        rs = elem.runtimeStyle;
                        rsLeft = rs && rs.left;

                        // Put in the new values to get a computed value out
                        if ( rsLeft ) {
                            rs.left = elem.currentStyle.left;
                        }
                        style.left = name === "fontSize" ? "1em" : ret;
                        ret = style.pixelLeft + "px";

                        // Revert the changed values
                        style.left = left;
                        if ( rsLeft ) {
                            rs.left = rsLeft;
                        }
                    }

                    // Support: IE
                    // IE returns zIndex value as an integer.
                    return ret === undefined ?
                    ret :
                    ret + "" || "auto";
                };
            }




            function addGetHookIf( conditionFn, hookFn ) {
                // Define the hook, we'll check on the first run if it's really needed.
                return {
                    get: function() {
                        var condition = conditionFn();

                        if ( condition == null ) {
                            // The test was not ready at this point; screw the hook this time
                            // but check again when needed next time.
                            return;
                        }

                        if ( condition ) {
                            // Hook not needed (or it's not possible to use it due to missing dependency),
                            // remove it.
                            // Since there are no other hooks for marginRight, remove the whole object.
                            delete this.get;
                            return;
                        }

                        // Hook needed; redefine it so that the support test is not executed again.

                        return (this.get = hookFn).apply( this, arguments );
                    }
                };
            }

(function() {
                var a, reliableHiddenOffsetsVal, boxSizingVal, boxSizingReliableVal,
                pixelPositionVal, reliableMarginRightVal,
                div = document.createElement( "div" ),
                containerStyles = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px",
                divReset =
                "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;" +
                "display:block;padding:0;margin:0;border:0";

                // Setup
                div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
                a = div.getElementsByTagName( "a" )[ 0 ];

                a.style.cssText = "float:left;opacity:.5";

                // Make sure that element opacity exists
                // (IE uses filter instead)
                // Use a regex to work around a WebKit issue. See #5145
                support.opacity = /^0.5/.test( a.style.opacity );

                // Verify style float existence
                // (IE uses styleFloat instead of cssFloat)
                support.cssFloat = !!a.style.cssFloat;

                div.style.backgroundClip = "content-box";
                div.cloneNode( true ).style.backgroundClip = "";
                support.clearCloneStyle = div.style.backgroundClip === "content-box";

                // Null elements to avoid leaks in IE.
                a = div = null;

                jQuery.extend(support, {
                    reliableHiddenOffsets: function() {
                        if ( reliableHiddenOffsetsVal != null ) {
                            return reliableHiddenOffsetsVal;
                        }

                        var container, tds, isSupported,
                        div = document.createElement( "div" ),
                        body = document.getElementsByTagName( "body" )[ 0 ];

                        if ( !body ) {
                            // Return for frameset docs that don't have a body
                            return;
                        }

                        // Setup
                        div.setAttribute( "className", "t" );
                        div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

                        container = document.createElement( "div" );
                        container.style.cssText = containerStyles;

                        body.appendChild( container ).appendChild( div );

                        // Support: IE8
                        // Check if table cells still have offsetWidth/Height when they are set
                        // to display:none and there are still other visible table cells in a
                        // table row; if so, offsetWidth/Height are not reliable for use when
                        // determining if an element has been hidden directly using
                        // display:none (it is still safe to use offsets if a parent element is
                        // hidden; don safety goggles and see bug #4512 for more information).
                        div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
                        tds = div.getElementsByTagName( "td" );
                        tds[ 0 ].style.cssText = "padding:0;margin:0;border:0;display:none";
                        isSupported = ( tds[ 0 ].offsetHeight === 0 );

                        tds[ 0 ].style.display = "";
                        tds[ 1 ].style.display = "none";

                        // Support: IE8
                        // Check if empty table cells still have offsetWidth/Height
                        reliableHiddenOffsetsVal = isSupported && ( tds[ 0 ].offsetHeight === 0 );

                        body.removeChild( container );

                        // Null elements to avoid leaks in IE.
                        div = body = null;

                        return reliableHiddenOffsetsVal;
                    },

                    boxSizing: function() {
                        if ( boxSizingVal == null ) {
                            computeStyleTests();
                        }
                        return boxSizingVal;
                    },

                    boxSizingReliable: function() {
                        if ( boxSizingReliableVal == null ) {
                            computeStyleTests();
                        }
                        return boxSizingReliableVal;
                    },

                    pixelPosition: function() {
                        if ( pixelPositionVal == null ) {
                            computeStyleTests();
                        }
                        return pixelPositionVal;
                    },

                    reliableMarginRight: function() {
                        var body, container, div, marginDiv;

                        // Use window.getComputedStyle because jsdom on node.js will break without it.
                        if ( reliableMarginRightVal == null && window.getComputedStyle ) {
                            body = document.getElementsByTagName( "body" )[ 0 ];
                            if ( !body ) {
                                // Test fired too early or in an unsupported environment, exit.
                                return;
                            }

                            container = document.createElement( "div" );
                            div = document.createElement( "div" );
                            container.style.cssText = containerStyles;

                            body.appendChild( container ).appendChild( div );

                            // Check if div with explicit width and no margin-right incorrectly
                            // gets computed margin-right based on width of container. (#3333)
                            // Fails in WebKit before Feb 2011 nightlies
                            // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                            marginDiv = div.appendChild( document.createElement( "div" ) );
                            marginDiv.style.cssText = div.style.cssText = divReset;
                            marginDiv.style.marginRight = marginDiv.style.width = "0";
                            div.style.width = "1px";

                            reliableMarginRightVal =
                            !parseFloat( ( window.getComputedStyle( marginDiv, null ) || {}).marginRight );

                            body.removeChild( container );
                        }

                        return reliableMarginRightVal;
                    }
                });

                function computeStyleTests() {
                    var container, div,
                    body = document.getElementsByTagName( "body" )[ 0 ];

                    if ( !body ) {
                        // Test fired too early or in an unsupported environment, exit.
                        return;
                    }

                    container = document.createElement( "div" );
                    div = document.createElement( "div" );
                    container.style.cssText = containerStyles;

                    body.appendChild( container ).appendChild( div );

                    div.style.cssText =
                    "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" +
                    "position:absolute;display:block;padding:1px;border:1px;width:4px;" +
                    "margin-top:1%;top:1%";

                    // Workaround failing boxSizing test due to offsetWidth returning wrong value
                    // with some non-1 values of body zoom, ticket #13543
                    jQuery.swap( body, body.style.zoom != null ? {
                        zoom: 1 
                    } : {}, function() {
                        boxSizingVal = div.offsetWidth === 4;
                    });

                    // Will be changed later if needed.
                    boxSizingReliableVal = true;
                    pixelPositionVal = false;
                    reliableMarginRightVal = true;

                    // Use window.getComputedStyle because jsdom on node.js will break without it.
                    if ( window.getComputedStyle ) {
                        pixelPositionVal = ( window.getComputedStyle( div, null ) || {}).top !== "1%";
                        boxSizingReliableVal =
                        ( window.getComputedStyle( div, null ) || {
                            width: "4px" 
                        }).width === "4px";
                    }

                    body.removeChild( container );

                    // Null elements to avoid leaks in IE.
                    div = body = null;
                }

            })();


            // A method for quickly swapping in/out CSS properties to get correct calculations.
            jQuery.swap = function( elem, options, callback, args ) {
                var ret, name,
                old = {};

                // Remember the old values, and insert the new ones
                for ( name in options ) {
                    old[ name ] = elem.style[ name ];
                    elem.style[ name ] = options[ name ];
                }

                ret = callback.apply( elem, args || [] );

                // Revert the old values
                for ( name in options ) {
                    elem.style[ name ] = old[ name ];
                }

                return ret;
            };


            var
            ralpha = /alpha\([^)]*\)/i,
            ropacity = /opacity\s*=\s*([^)]*)/,
            // swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
            // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
            rdisplayswap = /^(none|table(?!-c[ea]).+)/,
            rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
            rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),
            cssShow = {
                position: "absolute",
                visibility: "hidden",
                display: "block" 
            },
            cssNormalTransform = {
                letterSpacing: 0,
                fontWeight: 400
            },
            cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];


            // return a css property mapped to a potentially vendor prefixed property
            function vendorPropName( style, name ) {

                // shortcut for names that are not vendor prefixed
                if ( name in style ) {
                    return name;
                }

                // check for vendor prefixed names
                var capName = name.charAt(0).toUpperCase() + name.slice(1),
                origName = name,
                i = cssPrefixes.length;

                while ( i-- ) {
                    name = cssPrefixes[ i ] + capName;
                    if ( name in style ) {
                        return name;
                    }
                }

                return origName;
            }

            function showHide( elements, show ) {
                var display, elem, hidden,
                values = [],
                index = 0,
                length = elements.length;

                for ( ; index < length; index++ ) {
                    elem = elements[ index ];
                    if ( !elem.style ) {
                        continue;
                    }

                    values[ index ] = jQuery._data( elem, "olddisplay" );
                    display = elem.style.display;
                    if ( show ) {
                        // Reset the inline display of this element to learn if it is
                        // being hidden by cascaded rules or not
                        if ( !values[ index ] && display === "none" ) {
                            elem.style.display = "";
                        }

                        // Set elements which have been overridden with display: none
                        // in a stylesheet to whatever the default browser style is
                        // for such an element
                        if ( elem.style.display === "" && isHidden( elem ) ) {
                            values[ index ] = jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
                        }
                    } else {

                        if ( !values[ index ] ) {
                            hidden = isHidden( elem );

                            if ( display && display !== "none" || !hidden ) {
                                jQuery._data( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
                            }
                        }
                    }
                }

                // Set the display of most of the elements in a second loop
                // to avoid the constant reflow
                for ( index = 0; index < length; index++ ) {
                    elem = elements[ index ];
                    if ( !elem.style ) {
                        continue;
                    }
                    if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
                        elem.style.display = show ? values[ index ] || "" : "none";
                    }
                }

                return elements;
            }

            function setPositiveNumber( elem, value, subtract ) {
                var matches = rnumsplit.exec( value );
                return matches ?
                // Guard against undefined "subtract", e.g., when used as in cssHooks
                Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
                value;
            }

            function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
                var i = extra === ( isBorderBox ? "border" : "content" ) ?
                // If we already have the right measurement, avoid augmentation
                4 :
                // Otherwise initialize for horizontal or vertical properties
                name === "width" ? 1 : 0,
                val = 0;

                for ( ; i < 4; i += 2 ) {
                    // both box models exclude margin, so add it if we want it
                    if ( extra === "margin" ) {
                        val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
                    }

                    if ( isBorderBox ) {
                        // border-box includes padding, so remove it if we want content
                        if ( extra === "content" ) {
                            val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
                        }

                        // at this point, extra isn't border nor margin, so remove border
                        if ( extra !== "margin" ) {
                            val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
                        }
                    } else {
                        // at this point, extra isn't content, so add padding
                        val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

                        // at this point, extra isn't content nor padding, so add border
                        if ( extra !== "padding" ) {
                            val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
                        }
                    }
                }

                return val;
            }

            function getWidthOrHeight( elem, name, extra ) {

                // Start with offset property, which is equivalent to the border-box value
                var valueIsBorderBox = true,
                val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
                styles = getStyles( elem ),
                isBorderBox = support.boxSizing() && jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

                // some non-html elements return undefined for offsetWidth, so check for null/undefined
                // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
                // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
                if ( val <= 0 || val == null ) {
                    // Fall back to computed then uncomputed css if necessary
                    val = curCSS( elem, name, styles );
                    if ( val < 0 || val == null ) {
                        val = elem.style[ name ];
                    }

                    // Computed unit is not pixels. Stop here and return.
                    if ( rnumnonpx.test(val) ) {
                        return val;
                    }

                    // we need the check for style in case a browser which returns unreliable values
                    // for getComputedStyle silently falls back to the reliable elem.style
                    valueIsBorderBox = isBorderBox && ( support.boxSizingReliable() || val === elem.style[ name ] );

                    // Normalize "", auto, and prepare for extra
                    val = parseFloat( val ) || 0;
                }

                // use the active box-sizing model to add/subtract irrelevant styles
                return ( val +
                augmentWidthOrHeight(
                elem,
                name,
                extra || ( isBorderBox ? "border" : "content" ),
                valueIsBorderBox,
                styles
                )
                ) + "px";
            }

            jQuery.extend({
                // Add in style property hooks for overriding the default
                // behavior of getting and setting a style property
                cssHooks: {
                    opacity: {
                        get: function( elem, computed ) {
                            if ( computed ) {
                                // We should always get a number back from opacity
                                var ret = curCSS( elem, "opacity" );
                                return ret === "" ? "1" : ret;
                            }
                        }
                    }
                },

                // Don't automatically add "px" to these possibly-unitless properties
                cssNumber: {
                    "columnCount": true,
                    "fillOpacity": true,
                    "fontWeight": true,
                    "lineHeight": true,
                    "opacity": true,
                    "order": true,
                    "orphans": true,
                    "widows": true,
                    "zIndex": true,
                    "zoom": true
                },

                // Add in properties whose names you wish to fix before
                // setting or getting the value
                cssProps: {
                    // normalize float css property
                    "float": support.cssFloat ? "cssFloat" : "styleFloat"
                },

                // Get and set the style property on a DOM Node
                style: function( elem, name, value, extra ) {
                    // Don't set styles on text and comment nodes
                    if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
                        return;
                    }

                    // Make sure that we're working with the right name
                    var ret, type, hooks,
                    origName = jQuery.camelCase( name ),
                    style = elem.style;

                    name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

                    // gets hook for the prefixed version
                    // followed by the unprefixed version
                    hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

                    // Check if we're setting a value
                    if ( value !== undefined ) {
                        type = typeof value;

                        // convert relative number strings (+= or -=) to relative numbers. #7345
                        if ( type === "string" && (ret = rrelNum.exec( value )) ) {
                            value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
                            // Fixes bug #9237
                            type = "number";
                        }

                        // Make sure that null and NaN values aren't set. See: #7116
                        if ( value == null || value !== value ) {
                            return;
                        }

                        // If a number was passed in, add 'px' to the (except for certain CSS properties)
                        if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
                            value += "px";
                        }

                        // Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
                        // but it would mean to define eight (for every problematic property) identical functions
                        if ( !support.clearCloneStyle && value === "" && name.indexOf("background") === 0 ) {
                            style[ name ] = "inherit";
                        }

                        // If a hook was provided, use that value, otherwise just set the specified value
                        if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {

                            // Support: IE
                            // Swallow errors from 'invalid' CSS values (#5509)
                            try {
                                // Support: Chrome, Safari
                                // Setting style to blank string required to delete "style: x !important;"
                                style[ name ] = "";
                                style[ name ] = value;
                            } catch (e) {}
                        }

                    } else {
                        // If a hook was provided get the non-computed value from there
                        if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
                            return ret;
                        }

                        // Otherwise just get the value from the style object
                        return style[ name ];
                    }
                },

                css: function( elem, name, extra, styles ) {
                    var num, val, hooks,
                    origName = jQuery.camelCase( name );

                    // Make sure that we're working with the right name
                    name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

                    // gets hook for the prefixed version
                    // followed by the unprefixed version
                    hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

                    // If a hook was provided get the computed value from there
                    if ( hooks && "get" in hooks ) {
                        val = hooks.get( elem, true, extra );
                    }

                    // Otherwise, if a way to get the computed value exists, use that
                    if ( val === undefined ) {
                        val = curCSS( elem, name, styles );
                    }

                    //convert "normal" to computed value
                    if ( val === "normal" && name in cssNormalTransform ) {
                        val = cssNormalTransform[ name ];
                    }

                    // Return, converting to number if forced or a qualifier was provided and val looks numeric
                    if ( extra === "" || extra ) {
                        num = parseFloat( val );
                        return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
                    }
                    return val;
                }
            });

            jQuery.each([ "height", "width" ], function( i, name ) {
                jQuery.cssHooks[ name ] = {
                    get: function( elem, computed, extra ) {
                        if ( computed ) {
                            // certain elements can have dimension info if we invisibly show them
                            // however, it must have a current display style that would benefit from this
                            return elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, "display" ) ) ?
                            jQuery.swap( elem, cssShow, function() {
                                return getWidthOrHeight( elem, name, extra );
                            }) :
                            getWidthOrHeight( elem, name, extra );
                        }
                    },

                    set: function( elem, value, extra ) {
                        var styles = extra && getStyles( elem );
                        return setPositiveNumber( elem, value, extra ?
                        augmentWidthOrHeight(
                        elem,
                        name,
                        extra,
                        support.boxSizing() && jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
                        styles
                        ) : 0
                        );
                    }
                };
            });

            if ( !support.opacity ) {
                jQuery.cssHooks.opacity = {
                    get: function( elem, computed ) {
                        // IE uses filters for opacity
                        return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
                        ( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
                        computed ? "1" : "";
                    },

                    set: function( elem, value ) {
                        var style = elem.style,
                        currentStyle = elem.currentStyle,
                        opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
                        filter = currentStyle && currentStyle.filter || style.filter || "";

                        // IE has trouble with opacity if it does not have layout
                        // Force it by setting the zoom level
                        style.zoom = 1;

                        // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
                        // if value === "", then remove inline opacity #12685
                        if ( ( value >= 1 || value === "" ) &&
                        jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
                        style.removeAttribute ) {

                            // Setting style.filter to null, "" & " " still leave "filter:" in the cssText
                            // if "filter:" is present at all, clearType is disabled, we want to avoid this
                            // style.removeAttribute is IE Only, but so apparently is this code path...
                            style.removeAttribute( "filter" );

                            // if there is no filter style applied in a css rule or unset inline opacity, we are done
                            if ( value === "" || currentStyle && !currentStyle.filter ) {
                                return;
                            }
                        }

                        // otherwise, set new filter values
                        style.filter = ralpha.test( filter ) ?
                        filter.replace( ralpha, opacity ) :
                        filter + " " + opacity;
                    }
                };
            }

            jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
            function( elem, computed ) {
                if ( computed ) {
                    // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                    // Work around by temporarily setting element display to inline-block
                    return jQuery.swap( elem, {
                        "display": "inline-block" 
                    },
                    curCSS, [ elem, "marginRight" ] );
                }
            });

            // These hooks are used by animate to expand properties
            jQuery.each({
                margin: "",
                padding: "",
                border: "Width"
            }, function( prefix, suffix ) {
                jQuery.cssHooks[ prefix + suffix ] = {
                    expand: function( value ) {
                        var i = 0,
                        expanded = {},
                        // assumes a single number if not a string
                        parts = typeof value === "string" ? value.split(" ") : [ value ];

                        for ( ; i < 4; i++ ) {
                            expanded[ prefix + cssExpand[ i ] + suffix ] =
                            parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
                        }

                        return expanded;
                    }
                };

                if ( !rmargin.test( prefix ) ) {
                    jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
                }
            });

            jQuery.fn.extend({
                css: function( name, value ) {
                    return access( this, function( elem, name, value ) {
                        var styles, len,
                        map = {},
                        i = 0;

                        if ( jQuery.isArray( name ) ) {
                            styles = getStyles( elem );
                            len = name.length;

                            for ( ; i < len; i++ ) {
                                map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
                            }

                            return map;
                        }

                        return value !== undefined ?
                        jQuery.style( elem, name, value ) :
                        jQuery.css( elem, name );
                    }, name, value, arguments.length > 1 );
                },
                show: function() {
                    return showHide( this, true );
                },
                hide: function() {
                    return showHide( this );
                },
                toggle: function( state ) {
                    if ( typeof state === "boolean" ) {
                        return state ? this.show() : this.hide();
                    }

                    return this.each(function() {
                        if ( isHidden( this ) ) {
                            jQuery( this ).show();
                        } else {
                            jQuery( this ).hide();
                        }
                    });
                }
            });


            function Tween( elem, options, prop, end, easing ) {
                return new Tween.prototype.init( elem, options, prop, end, easing );
            }
            jQuery.Tween = Tween;

            Tween.prototype = {
                constructor: Tween,
                init: function( elem, options, prop, end, easing, unit ) {
                    this.elem = elem;
                    this.prop = prop;
                    this.easing = easing || "swing";
                    this.options = options;
                    this.start = this.now = this.cur();
                    this.end = end;
                    this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
                },
                cur: function() {
                    var hooks = Tween.propHooks[ this.prop ];

                    return hooks && hooks.get ?
                    hooks.get( this ) :
                    Tween.propHooks._default.get( this );
                },
                run: function( percent ) {
                    var eased,
                    hooks = Tween.propHooks[ this.prop ];

                    if ( this.options.duration ) {
                        this.pos = eased = jQuery.easing[ this.easing ](
                        percent, this.options.duration * percent, 0, 1, this.options.duration
                        );
                    } else {
                        this.pos = eased = percent;
                    }
                    this.now = ( this.end - this.start ) * eased + this.start;

                    if ( this.options.step ) {
                        this.options.step.call( this.elem, this.now, this );
                    }

                    if ( hooks && hooks.set ) {
                        hooks.set( this );
                    } else {
                        Tween.propHooks._default.set( this );
                    }
                    return this;
                }
            };

            Tween.prototype.init.prototype = Tween.prototype;

            Tween.propHooks = {
                _default: {
                    get: function( tween ) {
                        var result;

                        if ( tween.elem[ tween.prop ] != null &&
                        (!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
                            return tween.elem[ tween.prop ];
                        }

                        // passing an empty string as a 3rd parameter to .css will automatically
                        // attempt a parseFloat and fallback to a string if the parse fails
                        // so, simple values such as "10px" are parsed to Float.
                        // complex values such as "rotate(1rad)" are returned as is.
                        result = jQuery.css( tween.elem, tween.prop, "" );
                        // Empty strings, null, undefined and "auto" are converted to 0.
                        return !result || result === "auto" ? 0 : result;
                    },
                    set: function( tween ) {
                        // use step hook for back compat - use cssHook if its there - use .style if its
                        // available and use plain properties where available
                        if ( jQuery.fx.step[ tween.prop ] ) {
                            jQuery.fx.step[ tween.prop ]( tween );
                        } else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
                            jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
                        } else {
                            tween.elem[ tween.prop ] = tween.now;
                        }
                    }
                }
            };

            // Support: IE <=9
            // Panic based approach to setting things on disconnected nodes

            Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
                set: function( tween ) {
                    if ( tween.elem.nodeType && tween.elem.parentNode ) {
                        tween.elem[ tween.prop ] = tween.now;
                    }
                }
            };

            jQuery.easing = {
                linear: function( p ) {
                    return p;
                },
                swing: function( p ) {
                    return 0.5 - Math.cos( p * Math.PI ) / 2;
                }
            };

            jQuery.fx = Tween.prototype.init;

            // Back Compat <1.8 extension point
            jQuery.fx.step = {};




            var
            fxNow, timerId,
            rfxtypes = /^(?:toggle|show|hide)$/,
            rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
            rrun = /queueHooks$/,
            animationPrefilters = [ defaultPrefilter ],
            tweeners = {
                "*": [ function( prop, value ) {
                    var tween = this.createTween( prop, value ),
                    target = tween.cur(),
                    parts = rfxnum.exec( value ),
                    unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),
                    // Starting value computation is required for potential unit mismatches
                    start = ( jQuery.cssNumber[ prop ] || unit !== "px" && + target ) &&
                    rfxnum.exec( jQuery.css( tween.elem, prop ) ),
                    scale = 1,
                    maxIterations = 20;

                    if ( start && start[ 3 ] !== unit ) {
                        // Trust units reported by jQuery.css
                        unit = unit || start[ 3 ];

                        // Make sure we update the tween properties later on
                        parts = parts || [];

                        // Iteratively approximate from a nonzero starting point
                        start = + target || 1;

                        do {
                            // If previous iteration zeroed out, double until we get *something*
                            // Use a string for doubling factor so we don't accidentally see scale as unchanged below
                            scale = scale || ".5";

                            // Adjust and apply
                            start = start / scale;
                            jQuery.style( tween.elem, prop, start + unit );

                            // Update scale, tolerating zero or NaN from tween.cur()
                            // And breaking the loop if scale is unchanged or perfect, or if we've just had enough
                        }
                        while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
                    }

                    // Update tween properties
                    if ( parts ) {
                        start = tween.start = + start || + target || 0;
                        tween.unit = unit;
                        // If a +=/-= token was provided, we're doing a relative animation
                        tween.end = parts[ 1 ] ?
                        start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
                        + parts[ 2 ];
                    }

                    return tween;
                }
                ]
            };

            // Animations created synchronously will run synchronously
            function createFxNow() {
                setTimeout(function() {
                    fxNow = undefined;
                });
                return ( fxNow = jQuery.now() );
            }

            // Generate parameters to create a standard animation
            function genFx( type, includeWidth ) {
                var which,
                attrs = {
                    height: type 
                },
                i = 0;

                // if we include width, step value is 1 to do all cssExpand values,
                // if we don't include width, step value is 2 to skip over Left and Right
                includeWidth = includeWidth ? 1 : 0;
                for ( ; i < 4 ; i += 2 - includeWidth ) {
                    which = cssExpand[ i ];
                    attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
                }

                if ( includeWidth ) {
                    attrs.opacity = attrs.width = type;
                }

                return attrs;
            }

            function createTween( value, prop, animation ) {
                var tween,
                collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
                index = 0,
                length = collection.length;
                for ( ; index < length; index++ ) {
                    if ( (tween = collection[ index ].call( animation, prop, value )) ) {

                        // we're done with this property
                        return tween;
                    }
                }
            }

            function defaultPrefilter( elem, props, opts ) {
                /* jshint validthis: true */
                var prop, value, toggle, tween, hooks, oldfire, display, dDisplay,
                anim = this,
                orig = {},
                style = elem.style,
                hidden = elem.nodeType && isHidden( elem ),
                dataShow = jQuery._data( elem, "fxshow" );

                // handle queue: false promises
                if ( !opts.queue ) {
                    hooks = jQuery._queueHooks( elem, "fx" );
                    if ( hooks.unqueued == null ) {
                        hooks.unqueued = 0;
                        oldfire = hooks.empty.fire;
                        hooks.empty.fire = function() {
                            if ( !hooks.unqueued ) {
                                oldfire();
                            }
                        };
                    }
                    hooks.unqueued++;

                    anim.always(function() {
                        // doing this makes sure that the complete handler will be called
                        // before this completes
                        anim.always(function() {
                            hooks.unqueued--;
                            if ( !jQuery.queue( elem, "fx" ).length ) {
                                hooks.empty.fire();
                            }
                        });
                    });
                }

                // height/width overflow pass
                if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
                    // Make sure that nothing sneaks out
                    // Record all 3 overflow attributes because IE does not
                    // change the overflow attribute when overflowX and
                    // overflowY are set to the same value
                    opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

                    // Set display property to inline-block for height/width
                    // animations on inline elements that are having width/height animated
                    display = jQuery.css( elem, "display" );
                    dDisplay = defaultDisplay( elem.nodeName );
                    if ( display === "none" ) {
                        display = dDisplay;
                    }
                    if ( display === "inline" &&
                    jQuery.css( elem, "float" ) === "none" ) {

                        // inline-level elements accept inline-block;
                        // block-level elements need to be inline with layout
                        if ( !support.inlineBlockNeedsLayout || dDisplay === "inline" ) {
                            style.display = "inline-block";
                        } else {
                            style.zoom = 1;
                        }
                    }
                }

                if ( opts.overflow ) {
                    style.overflow = "hidden";
                    if ( !support.shrinkWrapBlocks() ) {
                        anim.always(function() {
                            style.overflow = opts.overflow[ 0 ];
                            style.overflowX = opts.overflow[ 1 ];
                            style.overflowY = opts.overflow[ 2 ];
                        });
                    }
                }

                // show/hide pass
                for ( prop in props ) {
                    value = props[ prop ];
                    if ( rfxtypes.exec( value ) ) {
                        delete props[ prop ];
                        toggle = toggle || value === "toggle";
                        if ( value === ( hidden ? "hide" : "show" ) ) {

                            // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
                            if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
                                hidden = true;
                            } else {
                                continue;
                            }
                        }
                        orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
                    }
                }

                if ( !jQuery.isEmptyObject( orig ) ) {
                    if ( dataShow ) {
                        if ( "hidden" in dataShow ) {
                            hidden = dataShow.hidden;
                        }
                    } else {
                        dataShow = jQuery._data( elem, "fxshow", {});
                    }

                    // store state if its toggle - enables .stop().toggle() to "reverse"
                    if ( toggle ) {
                        dataShow.hidden = !hidden;
                    }
                    if ( hidden ) {
                        jQuery( elem ).show();
                    } else {
                        anim.done(function() {
                            jQuery( elem ).hide();
                        });
                    }
                    anim.done(function() {
                        var prop;
                        jQuery._removeData( elem, "fxshow" );
                        for ( prop in orig ) {
                            jQuery.style( elem, prop, orig[ prop ] );
                        }
                    });
                    for ( prop in orig ) {
                        tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

                        if ( !( prop in dataShow ) ) {
                            dataShow[ prop ] = tween.start;
                            if ( hidden ) {
                                tween.end = tween.start;
                                tween.start = prop === "width" || prop === "height" ? 1 : 0;
                            }
                        }
                    }
                }
            }

            function propFilter( props, specialEasing ) {
                var index, name, easing, value, hooks;

                // camelCase, specialEasing and expand cssHook pass
                for ( index in props ) {
                    name = jQuery.camelCase( index );
                    easing = specialEasing[ name ];
                    value = props[ index ];
                    if ( jQuery.isArray( value ) ) {
                        easing = value[ 1 ];
                        value = props[ index ] = value[ 0 ];
                    }

                    if ( index !== name ) {
                        props[ name ] = value;
                        delete props[ index ];
                    }

                    hooks = jQuery.cssHooks[ name ];
                    if ( hooks && "expand" in hooks ) {
                        value = hooks.expand( value );
                        delete props[ name ];

                        // not quite $.extend, this wont overwrite keys already present.
                        // also - reusing 'index' from above because we have the correct "name"
                        for ( index in value ) {
                            if ( !( index in props ) ) {
                                props[ index ] = value[ index ];
                                specialEasing[ index ] = easing;
                            }
                        }
                    } else {
                        specialEasing[ name ] = easing;
                    }
                }
            }

            function Animation( elem, properties, options ) {
                var result,
                stopped,
                index = 0,
                length = animationPrefilters.length,
                deferred = jQuery.Deferred().always( function() {
                    // don't match elem in the :animated selector
                    delete tick.elem;
                }),
                tick = function() {
                    if ( stopped ) {
                        return false;
                    }
                    var currentTime = fxNow || createFxNow(),
                    remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
                    // archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
                    temp = remaining / animation.duration || 0,
                    percent = 1 - temp,
                    index = 0,
                    length = animation.tweens.length;

                    for ( ; index < length ; index++ ) {
                        animation.tweens[ index ].run( percent );
                    }

                    deferred.notifyWith( elem, [ animation, percent, remaining ]);

                    if ( percent < 1 && length ) {
                        return remaining;
                    } else {
                        deferred.resolveWith( elem, [ animation ] );
                        return false;
                    }
                },
                animation = deferred.promise({
                    elem: elem,
                    props: jQuery.extend( {}, properties ),
                    opts: jQuery.extend( true, {
                        specialEasing: {}
                    }, options ),
                    originalProperties: properties,
                    originalOptions: options,
                    startTime: fxNow || createFxNow(),
                    duration: options.duration,
                    tweens: [],
                    createTween: function( prop, end ) {
                        var tween = jQuery.Tween( elem, animation.opts, prop, end,
                        animation.opts.specialEasing[ prop ] || animation.opts.easing );
                        animation.tweens.push( tween );
                        return tween;
                    },
                    stop: function( gotoEnd ) {
                        var index = 0,
                        // if we are going to the end, we want to run all the tweens
                        // otherwise we skip this part
                        length = gotoEnd ? animation.tweens.length : 0;
                        if ( stopped ) {
                            return this;
                        }
                        stopped = true;
                        for ( ; index < length ; index++ ) {
                            animation.tweens[ index ].run( 1 );
                        }

                        // resolve when we played the last frame
                        // otherwise, reject
                        if ( gotoEnd ) {
                            deferred.resolveWith( elem, [ animation, gotoEnd ] );
                        } else {
                            deferred.rejectWith( elem, [ animation, gotoEnd ] );
                        }
                        return this;
                    }
                }),
                props = animation.props;

                propFilter( props, animation.opts.specialEasing );

                for ( ; index < length ; index++ ) {
                    result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
                    if ( result ) {
                        return result;
                    }
                }

                jQuery.map( props, createTween, animation );

                if ( jQuery.isFunction( animation.opts.start ) ) {
                    animation.opts.start.call( elem, animation );
                }

                jQuery.fx.timer(
                jQuery.extend( tick, {
                    elem: elem,
                    anim: animation,
                    queue: animation.opts.queue
                })
                );

                // attach callbacks from options
                return animation.progress( animation.opts.progress )
                .done( animation.opts.done, animation.opts.complete )
                .fail( animation.opts.fail )
                .always( animation.opts.always );
            }

            jQuery.Animation = jQuery.extend( Animation, {
                tweener: function( props, callback ) {
                    if ( jQuery.isFunction( props ) ) {
                        callback = props;
                        props = [ "*" ];
                    } else {
                        props = props.split(" ");
                    }

                    var prop,
                    index = 0,
                    length = props.length;

                    for ( ; index < length ; index++ ) {
                        prop = props[ index ];
                        tweeners[ prop ] = tweeners[ prop ] || [];
                        tweeners[ prop ].unshift( callback );
                    }
                },

                prefilter: function( callback, prepend ) {
                    if ( prepend ) {
                        animationPrefilters.unshift( callback );
                    } else {
                        animationPrefilters.push( callback );
                    }
                }
            });

            jQuery.speed = function( speed, easing, fn ) {
                var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
                    complete: fn || !fn && easing ||
                    jQuery.isFunction( speed ) && speed,
                    duration: speed,
                    easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
                };

                opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
                opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

                // normalize opt.queue - true/undefined/null -> "fx"
                if ( opt.queue == null || opt.queue === true ) {
                    opt.queue = "fx";
                }

                // Queueing
                opt.old = opt.complete;

                opt.complete = function() {
                    if ( jQuery.isFunction( opt.old ) ) {
                        opt.old.call( this );
                    }

                    if ( opt.queue ) {
                        jQuery.dequeue( this, opt.queue );
                    }
                };

                return opt;
            };

            jQuery.fn.extend({
                fadeTo: function( speed, to, easing, callback ) {

                    // show any hidden elements after setting opacity to 0
                    return this.filter( isHidden ).css( "opacity", 0 ).show()
                    // animate to the value specified
                    .end().animate({
                        opacity: to 
                    }, speed, easing, callback );
                },
                animate: function( prop, speed, easing, callback ) {
                    var empty = jQuery.isEmptyObject( prop ),
                    optall = jQuery.speed( speed, easing, callback ),
                    doAnimation = function() {
                        // Operate on a copy of prop so per-property easing won't be lost
                        var anim = Animation( this, jQuery.extend( {}, prop ), optall );

                        // Empty animations, or finishing resolves immediately
                        if ( empty || jQuery._data( this, "finish" ) ) {
                            anim.stop( true );
                        }
                    };
                    doAnimation.finish = doAnimation;

                    return empty || optall.queue === false ?
                    this.each( doAnimation ) :
                    this.queue( optall.queue, doAnimation );
                },
                stop: function( type, clearQueue, gotoEnd ) {
                    var stopQueue = function( hooks ) {
                        var stop = hooks.stop;
                        delete hooks.stop;
                        stop( gotoEnd );
                    };

                    if ( typeof type !== "string" ) {
                        gotoEnd = clearQueue;
                        clearQueue = type;
                        type = undefined;
                    }
                    if ( clearQueue && type !== false ) {
                        this.queue( type || "fx", [] );
                    }

                    return this.each(function() {
                        var dequeue = true,
                        index = type != null && type + "queueHooks",
                        timers = jQuery.timers,
                        data = jQuery._data( this );

                        if ( index ) {
                            if ( data[ index ] && data[ index ].stop ) {
                                stopQueue( data[ index ] );
                            }
                        } else {
                            for ( index in data ) {
                                if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
                                    stopQueue( data[ index ] );
                                }
                            }
                        }

                        for ( index = timers.length; index--; ) {
                            if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
                                timers[ index ].anim.stop( gotoEnd );
                                dequeue = false;
                                timers.splice( index, 1 );
                            }
                        }

                        // start the next in the queue if the last step wasn't forced
                        // timers currently will call their complete callbacks, which will dequeue
                        // but only if they were gotoEnd
                        if ( dequeue || !gotoEnd ) {
                            jQuery.dequeue( this, type );
                        }
                    });
                },
                finish: function( type ) {
                    if ( type !== false ) {
                        type = type || "fx";
                    }
                    return this.each(function() {
                        var index,
                        data = jQuery._data( this ),
                        queue = data[ type + "queue" ],
                        hooks = data[ type + "queueHooks" ],
                        timers = jQuery.timers,
                        length = queue ? queue.length : 0;

                        // enable finishing flag on private data
                        data.finish = true;

                        // empty the queue first
                        jQuery.queue( this, type, [] );

                        if ( hooks && hooks.stop ) {
                            hooks.stop.call( this, true );
                        }

                        // look for any active animations, and finish them
                        for ( index = timers.length; index--; ) {
                            if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
                                timers[ index ].anim.stop( true );
                                timers.splice( index, 1 );
                            }
                        }

                        // look for any animations in the old queue and finish them
                        for ( index = 0; index < length; index++ ) {
                            if ( queue[ index ] && queue[ index ].finish ) {
                                queue[ index ].finish.call( this );
                            }
                        }

                        // turn off finishing flag
                        delete data.finish;
                    });
                }
            });

            jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
                var cssFn = jQuery.fn[ name ];
                jQuery.fn[ name ] = function( speed, easing, callback ) {
                    return speed == null || typeof speed === "boolean" ?
                    cssFn.apply( this, arguments ) :
                    this.animate( genFx( name, true ), speed, easing, callback );
                };
            });

            // Generate shortcuts for custom animations
            jQuery.each({
                slideDown: genFx("show"),
                slideUp: genFx("hide"),
                slideToggle: genFx("toggle"),
                fadeIn: {
                    opacity: "show" 
                },
                fadeOut: {
                    opacity: "hide" 
                },
                fadeToggle: {
                    opacity: "toggle" 
                }
            }, function( name, props ) {
                jQuery.fn[ name ] = function( speed, easing, callback ) {
                    return this.animate( props, speed, easing, callback );
                };
            });

            jQuery.timers = [];
            jQuery.fx.tick = function() {
                var timer,
                timers = jQuery.timers,
                i = 0;

                fxNow = jQuery.now();

                for ( ; i < timers.length; i++ ) {
                    timer = timers[ i ];
                    // Checks the timer has not already been removed
                    if ( !timer() && timers[ i ] === timer ) {
                        timers.splice( i--, 1 );
                    }
                }

                if ( !timers.length ) {
                    jQuery.fx.stop();
                }
                fxNow = undefined;
            };

            jQuery.fx.timer = function( timer ) {
                jQuery.timers.push( timer );
                if ( timer() ) {
                    jQuery.fx.start();
                } else {
                    jQuery.timers.pop();
                }
            };

            jQuery.fx.interval = 13;

            jQuery.fx.start = function() {
                if ( !timerId ) {
                    timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
                }
            };

            jQuery.fx.stop = function() {
                clearInterval( timerId );
                timerId = null;
            };

            jQuery.fx.speeds = {
                slow: 600,
                fast: 200,
                // Default speed
                _default: 400
            };


            // Based off of the plugin by Clint Helfers, with permission.
            // http://blindsignals.com/index.php/2009/07/jquery-delay/
            jQuery.fn.delay = function( time, type ) {
                time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
                type = type || "fx";

                return this.queue( type, function( next, hooks ) {
                    var timeout = setTimeout( next, time );
                    hooks.stop = function() {
                        clearTimeout( timeout );
                    };
                });
            };


            (function() {
                var a, input, select, opt,
                div = document.createElement("div" );

                // Setup
                div.setAttribute( "className", "t" );
                div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
                a = div.getElementsByTagName("a")[ 0 ];

                // First batch of tests.
                select = document.createElement("select");
                opt = select.appendChild( document.createElement("option") );
                input = div.getElementsByTagName("input")[ 0 ];

                a.style.cssText = "top:1px";

                // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
                support.getSetAttribute = div.className !== "t";

                // Get the style information from getAttribute
                // (IE uses .cssText instead)
                support.style = /top/.test( a.getAttribute("style") );

                // Make sure that URLs aren't manipulated
                // (IE normalizes it by default)
                support.hrefNormalized = a.getAttribute("href") === "/a";

                // Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
                support.checkOn = !!input.value;

                // Make sure that a selected-by-default option has a working selected property.
                // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
                support.optSelected = opt.selected;

                // Tests for enctype support on a form (#6743)
                support.enctype = !!document.createElement("form").enctype;

                // Make sure that the options inside disabled selects aren't marked as disabled
                // (WebKit marks them as disabled)
                select.disabled = true;
                support.optDisabled = !opt.disabled;

                // Support: IE8 only
                // Check if we can trust getAttribute("value")
                input = document.createElement( "input" );
                input.setAttribute( "value", "" );
                support.input = input.getAttribute( "value" ) === "";

                // Check if an input maintains its value after becoming a radio
                input.value = "t";
                input.setAttribute( "type", "radio" );
                support.radioValue = input.value === "t";

                // Null elements to avoid leaks in IE.
                a = input = select = opt = div = null;
            })();


            var rreturn = /\r/g;

            jQuery.fn.extend({
                val: function( value ) {
                    var hooks, ret, isFunction,
                    elem = this[0];

                    if ( !arguments.length ) {
                        if ( elem ) {
                            hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

                            if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
                                return ret;
                            }

                            ret = elem.value;

                            return typeof ret === "string" ?
                            // handle most common string cases
                            ret.replace(rreturn, "") :
                            // handle cases where value is null/undef or number
                            ret == null ? "" : ret;
                        }

                        return;
                    }

                    isFunction = jQuery.isFunction( value );

                    return this.each(function( i ) {
                        var val;

                        if ( this.nodeType !== 1 ) {
                            return;
                        }

                        if ( isFunction ) {
                            val = value.call( this, i, jQuery( this ).val() );
                        } else {
                            val = value;
                        }

                        // Treat null/undefined as ""; convert numbers to string
                        if ( val == null ) {
                            val = "";
                        } else if ( typeof val === "number" ) {
                            val += "";
                        } else if ( jQuery.isArray( val ) ) {
                            val = jQuery.map( val, function( value ) {
                                return value == null ? "" : value + "";
                            });
                        }

                        hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

                        // If set returns undefined, fall back to normal setting
                        if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
                            this.value = val;
                        }
                    });
                }
            });

            jQuery.extend({
                valHooks: {
                    option: {
                        get: function( elem ) {
                            var val = jQuery.find.attr( elem, "value" );
                            return val != null ?
                            val :
                            jQuery.text( elem );
                        }
                    },
                    select: {
                        get: function( elem ) {
                            var value, option,
                            options = elem.options,
                            index = elem.selectedIndex,
                            one = elem.type === "select-one" || index < 0,
                            values = one ? null : [],
                            max = one ? index + 1 : options.length,
                            i = index < 0 ?
                            max :
                            one ? index : 0;

                            // Loop through all the selected options
                            for ( ; i < max; i++ ) {
                                option = options[ i ];

                                // oldIE doesn't update selected after form reset (#2551)
                                if ( ( option.selected || i === index ) &&
                                // Don't return options that are disabled or in a disabled optgroup
                                ( support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
                                ( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

                                    // Get the specific value for the option
                                    value = jQuery( option ).val();

                                    // We don't need an array for one selects
                                    if ( one ) {
                                        return value;
                                    }

                                    // Multi-Selects return an array
                                    values.push( value );
                                }
                            }

                            return values;
                        },

                        set: function( elem, value ) {
                            var optionSet, option,
                            options = elem.options,
                            values = jQuery.makeArray( value ),
                            i = options.length;

                            while ( i-- ) {
                                option = options[ i ];

                                if ( jQuery.inArray( jQuery.valHooks.option.get( option ), values ) >= 0 ) {

                                    // Support: IE6
                                    // When new option element is added to select box we need to
                                    // force reflow of newly added node in order to workaround delay
                                    // of initialization properties
                                    try {
                                        option.selected = optionSet = true;

                                    } catch ( _ ) {

                                        // Will be executed only in IE6
                                        option.scrollHeight;
                                    }

                                } else {
                                    option.selected = false;
                                }
                            }

                            // Force browsers to behave consistently when non-matching value is set
                            if ( !optionSet ) {
                                elem.selectedIndex = - 1;
                            }

                            return options;
                        }
                    }
                }
            });

            // Radios and checkboxes getter/setter
            jQuery.each([ "radio", "checkbox" ], function() {
                jQuery.valHooks[ this ] = {
                    set: function( elem, value ) {
                        if ( jQuery.isArray( value ) ) {
                            return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
                        }
                    }
                };
                if ( !support.checkOn ) {
                    jQuery.valHooks[ this ].get = function( elem ) {
                        // Support: Webkit
                        // "" is returned instead of "on" if a value isn't specified
                        return elem.getAttribute("value") === null ? "on" : elem.value;
                    };
                }
            });




            var nodeHook, boolHook,
            attrHandle = jQuery.expr.attrHandle,
            ruseDefault = /^(?:checked|selected)$/i,
            getSetAttribute = support.getSetAttribute,
            getSetInput = support.input;

            jQuery.fn.extend({
                attr: function( name, value ) {
                    return access( this, jQuery.attr, name, value, arguments.length > 1 );
                },

                removeAttr: function( name ) {
                    return this.each(function() {
                        jQuery.removeAttr( this, name );
                    });
                }
            });

            jQuery.extend({
                attr: function( elem, name, value ) {
                    var hooks, ret,
                    nType = elem.nodeType;

                    // don't get/set attributes on text, comment and attribute nodes
                    if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
                        return;
                    }

                    // Fallback to prop when attributes are not supported
                    if ( typeof elem.getAttribute === strundefined ) {
                        return jQuery.prop( elem, name, value );
                    }

                    // All attributes are lowercase
                    // Grab necessary hook if one is defined
                    if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
                        name = name.toLowerCase();
                        hooks = jQuery.attrHooks[ name ] ||
                        ( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
                    }

                    if ( value !== undefined ) {

                        if ( value === null ) {
                            jQuery.removeAttr( elem, name );

                        } else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
                            return ret;

                        } else {
                            elem.setAttribute( name, value + "" );
                            return value;
                        }

                    } else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
                        return ret;

                    } else {
                        ret = jQuery.find.attr( elem, name );

                        // Non-existent attributes return null, we normalize to undefined
                        return ret == null ?
                        undefined :
                        ret;
                    }
                },

                removeAttr: function( elem, value ) {
                    var name, propName,
                    i = 0,
                    attrNames = value && value.match( rnotwhite );

                    if ( attrNames && elem.nodeType === 1 ) {
                        while ( (name = attrNames[i++]) ) {
                            propName = jQuery.propFix[ name ] || name;

                            // Boolean attributes get special treatment (#10870)
                            if ( jQuery.expr.match.bool.test( name ) ) {
                                // Set corresponding property to false
                                if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
                                    elem[ propName ] = false;
                                    // Support: IE<9
                                    // Also clear defaultChecked/defaultSelected (if appropriate)
                                } else {
                                    elem[ jQuery.camelCase( "default-" + name ) ] =
                                    elem[ propName ] = false;
                                }

                                // See #9699 for explanation of this approach (setting first, then removal)
                            } else {
                                jQuery.attr( elem, name, "" );
                            }

                            elem.removeAttribute( getSetAttribute ? name : propName );
                        }
                    }
                },

                attrHooks: {
                    type: {
                        set: function( elem, value ) {
                            if ( !support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
                                // Setting the type on a radio button after the value resets the value in IE6-9
                                // Reset value to default in case type is set after value during creation
                                var val = elem.value;
                                elem.setAttribute( "type", value );
                                if ( val ) {
                                    elem.value = val;
                                }
                                return value;
                            }
                        }
                    }
                }
            });

            // Hook for boolean attributes
            boolHook = {
                set: function( elem, value, name ) {
                    if ( value === false ) {
                        // Remove boolean attributes when set to false
                        jQuery.removeAttr( elem, name );
                    } else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
                        // IE<8 needs the *property* name
                        elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );

                        // Use defaultChecked and defaultSelected for oldIE
                    } else {
                        elem[ jQuery.camelCase( "default-" + name ) ] = elem[ name ] = true;
                    }

                    return name;
                }
            };

            // Retrieve booleans specially
            jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {

                var getter = attrHandle[ name ] || jQuery.find.attr;

                attrHandle[ name ] = getSetInput && getSetAttribute || !ruseDefault.test( name ) ?
                function( elem, name, isXML ) {
                    var ret, handle;
                    if ( !isXML ) {
                        // Avoid an infinite loop by temporarily removing this function from the getter
                        handle = attrHandle[ name ];
                        attrHandle[ name ] = ret;
                        ret = getter( elem, name, isXML ) != null ?
                        name.toLowerCase() :
                        null;
                        attrHandle[ name ] = handle;
                    }
                    return ret;
                } :
                function( elem, name, isXML ) {
                    if ( !isXML ) {
                        return elem[ jQuery.camelCase( "default-" + name ) ] ?
                        name.toLowerCase() :
                        null;
                    }
                };
            });

            // fix oldIE attroperties
            if ( !getSetInput || !getSetAttribute ) {
                jQuery.attrHooks.value = {
                    set: function( elem, value, name ) {
                        if ( jQuery.nodeName( elem, "input" ) ) {
                            // Does not return so that setAttribute is also used
                            elem.defaultValue = value;
                        } else {
                            // Use nodeHook if defined (#1954); otherwise setAttribute is fine
                            return nodeHook && nodeHook.set( elem, value, name );
                        }
                    }
                };
            }

            // IE6/7 do not support getting/setting some attributes with get/setAttribute
            if ( !getSetAttribute ) {

                // Use this for any attribute in IE6/7
                // This fixes almost every IE6/7 issue
                nodeHook = {
                    set: function( elem, value, name ) {
                        // Set the existing or create a new attribute node
                        var ret = elem.getAttributeNode( name );
                        if ( !ret ) {
                            elem.setAttributeNode(
                            (ret = elem.ownerDocument.createAttribute( name ))
                            );
                        }

                        ret.value = value += "";

                        // Break association with cloned elements by also using setAttribute (#9646)
                        if ( name === "value" || value === elem.getAttribute( name ) ) {
                            return value;
                        }
                    }
                };

                // Some attributes are constructed with empty-string values when not defined
                attrHandle.id = attrHandle.name = attrHandle.coords =
                function( elem, name, isXML ) {
                    var ret;
                    if ( !isXML ) {
                        return (ret = elem.getAttributeNode( name )) && ret.value !== "" ?
                        ret.value :
                        null;
                    }
                };

                // Fixing value retrieval on a button requires this module
                jQuery.valHooks.button = {
                    get: function( elem, name ) {
                        var ret = elem.getAttributeNode( name );
                        if ( ret && ret.specified ) {
                            return ret.value;
                        }
                    },
                    set: nodeHook.set
                };

                // Set contenteditable to false on removals(#10429)
                // Setting to empty string throws an error as an invalid value
                jQuery.attrHooks.contenteditable = {
                    set: function( elem, value, name ) {
                        nodeHook.set( elem, value === "" ? false : value, name );
                    }
                };

                // Set width and height to auto instead of 0 on empty string( Bug #8150 )
                // This is for removals
                jQuery.each([ "width", "height" ], function( i, name ) {
                    jQuery.attrHooks[ name ] = {
                        set: function( elem, value ) {
                            if ( value === "" ) {
                                elem.setAttribute( name, "auto" );
                                return value;
                            }
                        }
                    };
                });
            }

            if ( !support.style ) {
                jQuery.attrHooks.style = {
                    get: function( elem ) {
                        // Return undefined in the case of empty string
                        // Note: IE uppercases css property names, but if we were to .toLowerCase()
                        // .cssText, that would destroy case senstitivity in URL's, like in "background"
                        return elem.style.cssText || undefined;
                    },
                    set: function( elem, value ) {
                        return ( elem.style.cssText = value + "" );
                    }
                };
            }




            var rfocusable = /^(?:input|select|textarea|button|object)$/i,
            rclickable = /^(?:a|area)$/i;

            jQuery.fn.extend({
                prop: function( name, value ) {
                    return access( this, jQuery.prop, name, value, arguments.length > 1 );
                },

                removeProp: function( name ) {
                    name = jQuery.propFix[ name ] || name;
                    return this.each(function() {
                        // try/catch handles cases where IE balks (such as removing a property on window)
                        try {
                            this[ name ] = undefined;
                            delete this[ name ];
                        } catch ( e ) {}
                    });
                }
            });

            jQuery.extend({
                propFix: {
                    "for": "htmlFor",
                    "class": "className"
                },

                prop: function( elem, name, value ) {
                    var ret, hooks, notxml,
                    nType = elem.nodeType;

                    // don't get/set properties on text, comment and attribute nodes
                    if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
                        return;
                    }

                    notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

                    if ( notxml ) {
                        // Fix name and attach hooks
                        name = jQuery.propFix[ name ] || name;
                        hooks = jQuery.propHooks[ name ];
                    }

                    if ( value !== undefined ) {
                        return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
                        ret :
                        ( elem[ name ] = value );

                    } else {
                        return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
                        ret :
                        elem[ name ];
                    }
                },

                propHooks: {
                    tabIndex: {
                        get: function( elem ) {
                            // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
                            // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                            // Use proper attribute retrieval(#12072)
                            var tabindex = jQuery.find.attr( elem, "tabindex" );

                            return tabindex ?
                            parseInt( tabindex, 10 ) :
                            rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
                            0 :
                            - 1;
                        }
                    }
                }
            });

            // Some attributes require a special call on IE
            // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
            if ( !support.hrefNormalized ) {
                // href/src property should get the full normalized URL (#10299/#12915)
                jQuery.each([ "href", "src" ], function( i, name ) {
                    jQuery.propHooks[ name ] = {
                        get: function( elem ) {
                            return elem.getAttribute( name, 4 );
                        }
                    };
                });
            }

            // Support: Safari, IE9+
            // mis-reports the default selected property of an option
            // Accessing the parent's selectedIndex property fixes it
            if ( !support.optSelected ) {
                jQuery.propHooks.selected = {
                    get: function( elem ) {
                        var parent = elem.parentNode;

                        if ( parent ) {
                            parent.selectedIndex;

                            // Make sure that it also works with optgroups, see #5701
                            if ( parent.parentNode ) {
                                parent.parentNode.selectedIndex;
                            }
                        }
                        return null;
                    }
                };
            }

            jQuery.each([
            "tabIndex",
            "readOnly",
            "maxLength",
            "cellSpacing",
            "cellPadding",
            "rowSpan",
            "colSpan",
            "useMap",
            "frameBorder",
            "contentEditable"
            ], function() {
                jQuery.propFix[ this.toLowerCase() ] = this;
            });

            // IE6/7 call enctype encoding
            if ( !support.enctype ) {
                jQuery.propFix.enctype = "encoding";
            }




            var rclass = /[\t\r\n\f]/g;

            jQuery.fn.extend({
                addClass: function( value ) {
                    var classes, elem, cur, clazz, j, finalValue,
                    i = 0,
                    len = this.length,
                    proceed = typeof value === "string" && value;

                    if ( jQuery.isFunction( value ) ) {
                        return this.each(function( j ) {
                            jQuery( this ).addClass( value.call( this, j, this.className ) );
                        });
                    }

                    if ( proceed ) {
                        // The disjunction here is for better compressibility (see removeClass)
                        classes = ( value || "" ).match( rnotwhite ) || [];

                        for ( ; i < len; i++ ) {
                            elem = this[ i ];
                            cur = elem.nodeType === 1 && ( elem.className ?
                            ( " " + elem.className + " " ).replace( rclass, " " ) :
                            " "
                            );

                            if ( cur ) {
                                j = 0;
                                while ( (clazz = classes[j++]) ) {
                                    if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
                                        cur += clazz + " ";
                                    }
                                }

                                // only assign if different to avoid unneeded rendering.
                                finalValue = jQuery.trim( cur );
                                if ( elem.className !== finalValue ) {
                                    elem.className = finalValue;
                                }
                            }
                        }
                    }

                    return this;
                },

                removeClass: function( value ) {
                    var classes, elem, cur, clazz, j, finalValue,
                    i = 0,
                    len = this.length,
                    proceed = arguments.length === 0 || typeof value === "string" && value;

                    if ( jQuery.isFunction( value ) ) {
                        return this.each(function( j ) {
                            jQuery( this ).removeClass( value.call( this, j, this.className ) );
                        });
                    }
                    if ( proceed ) {
                        classes = ( value || "" ).match( rnotwhite ) || [];

                        for ( ; i < len; i++ ) {
                            elem = this[ i ];
                            // This expression is here for better compressibility (see addClass)
                            cur = elem.nodeType === 1 && ( elem.className ?
                            ( " " + elem.className + " " ).replace( rclass, " " ) :
                            ""
                            );

                            if ( cur ) {
                                j = 0;
                                while ( (clazz = classes[j++]) ) {
                                    // Remove *all* instances
                                    while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
                                        cur = cur.replace( " " + clazz + " ", " " );
                                    }
                                }

                                // only assign if different to avoid unneeded rendering.
                                finalValue = value ? jQuery.trim( cur ) : "";
                                if ( elem.className !== finalValue ) {
                                    elem.className = finalValue;
                                }
                            }
                        }
                    }

                    return this;
                },

                toggleClass: function( value, stateVal ) {
                    var type = typeof value;

                    if ( typeof stateVal === "boolean" && type === "string" ) {
                        return stateVal ? this.addClass( value ) : this.removeClass( value );
                    }

                    if ( jQuery.isFunction( value ) ) {
                        return this.each(function( i ) {
                            jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
                        });
                    }

                    return this.each(function() {
                        if ( type === "string" ) {
                            // toggle individual class names
                            var className,
                            i = 0,
                            self = jQuery( this ),
                            classNames = value.match( rnotwhite ) || [];

                            while ( (className = classNames[ i++ ]) ) {
                                // check each className given, space separated list
                                if ( self.hasClass( className ) ) {
                                    self.removeClass( className );
                                } else {
                                    self.addClass( className );
                                }
                            }

                            // Toggle whole class name
                        } else if ( type === strundefined || type === "boolean" ) {
                            if ( this.className ) {
                                // store className if set
                                jQuery._data( this, "__className__", this.className );
                            }

                            // If the element has a class name or if we're passed "false",
                            // then remove the whole classname (if there was one, the above saved it).
                            // Otherwise bring back whatever was previously saved (if anything),
                            // falling back to the empty string if nothing was stored.
                            this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
                        }
                    });
                },

                hasClass: function( selector ) {
                    var className = " " + selector + " ",
                    i = 0,
                    l = this.length;
                    for ( ; i < l; i++ ) {
                        if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
                            return true;
                        }
                    }

                    return false;
                }
            });




            // Return jQuery for attributes-only inclusion


            jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
            "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
            "change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

                // Handle event binding
                jQuery.fn[ name ] = function( data, fn ) {
                    return arguments.length > 0 ?
                    this.on( name, null, data, fn ) :
                    this.trigger( name );
                };
            });

            jQuery.fn.extend({
                hover: function( fnOver, fnOut ) {
                    return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
                },

                bind: function( types, data, fn ) {
                    return this.on( types, null, data, fn );
                },
                unbind: function( types, fn ) {
                    return this.off( types, null, fn );
                },

                delegate: function( selector, types, data, fn ) {
                    return this.on( types, selector, data, fn );
                },
                undelegate: function( selector, types, fn ) {
                    // ( namespace ) or ( selector, types [, fn] )
                    return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
                }
            });


            var nonce = jQuery.now();

            var rquery = (/\?/);



            var rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;

            jQuery.parseJSON = function( data ) {
                // Attempt to parse using the native JSON parser first
                if ( window.JSON && window.JSON.parse ) {
                    // Support: Android 2.3
                    // Workaround failure to string-cast null input
                    return window.JSON.parse( data + "" );
                }

                var requireNonComma,
                depth = null,
                str = jQuery.trim( data + "" );

                // Guard against invalid (and possibly dangerous) input by ensuring that nothing remains
                // after removing valid tokens
                return str && !jQuery.trim( str.replace( rvalidtokens, function( token, comma, open, close ) {

                    // Force termination if we see a misplaced comma
                    if ( requireNonComma && comma ) {
                        depth = 0;
                    }

                    // Perform no more replacements after returning to outermost depth
                    if ( depth === 0 ) {
                        return token;
                    }

                    // Commas must not follow "[", "{", or ","
                    requireNonComma = open || comma;

                    // Determine new depth
                    // array/object open ("[" or "{"): depth += true - false (increment)
                    // array/object close ("]" or "}"): depth += false - true (decrement)
                    // other cases ("," or primitive): depth += true - true (numeric cast)
                    depth += !close - !open;

                    // Remove this token
                    return "";
                }) ) ?
                ( Function( "return " + str ) )() :
                jQuery.error( "Invalid JSON: " + data );
            };


            // Cross-browser xml parsing
            jQuery.parseXML = function( data ) {
                var xml, tmp;
                if ( !data || typeof data !== "string" ) {
                    return null;
                }
                try {
                    if ( window.DOMParser ) {
                        // Standard
                        tmp = new DOMParser();
                        xml = tmp.parseFromString( data, "text/xml" );
                    } else {
                        // IE
                        xml = new ActiveXObject( "Microsoft.XMLDOM" );
                        xml.async = "false";
                        xml.loadXML( data );
                    }
                } catch ( e ) {
                    xml = undefined;
                }
                if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
                    jQuery.error( "Invalid XML: " + data );
                }
                return xml;
            };


            var
            // Document location
            ajaxLocParts,
            ajaxLocation,
            rhash = /#.*$/,
            rts = /([?&])_=[^&]*/,
            rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
            // #7653, #8125, #8152: local protocol detection
            rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
            rnoContent = /^(?:GET|HEAD)$/,
            rprotocol = /^\/\//,
            rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
            /* Prefilters
            	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
            	 * 2) These are called:
            	 *    - BEFORE asking for a transport
            	 *    - AFTER param serialization (s.data is a string if s.processData is true)
            	 * 3) key is the dataType
            	 * 4) the catchall symbol "*" can be used
            	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
            	 */
            prefilters = {},
            /* Transports bindings
            	 * 1) key is the dataType
            	 * 2) the catchall symbol "*" can be used
            	 * 3) selection will start with transport dataType and THEN go to "*" if needed
            	 */
            transports = {},
            // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
            allTypes = "*/".concat("*");

            // #8138, IE may throw an exception when accessing
            // a field from window.location if document.domain has been set
            try {
                ajaxLocation = location.href;
            } catch ( e ) {
                // Use the href attribute of an A element
                // since IE will modify it given document.location
                ajaxLocation = document.createElement( "a" );
                ajaxLocation.href = "";
                ajaxLocation = ajaxLocation.href;
            }

            // Segment location into parts
            ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

            // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
            function addToPrefiltersOrTransports( structure ) {

                // dataTypeExpression is optional and defaults to "*"
                return function( dataTypeExpression, func ) {

                    if ( typeof dataTypeExpression !== "string" ) {
                        func = dataTypeExpression;
                        dataTypeExpression = "*";
                    }

                    var dataType,
                    i = 0,
                    dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

                    if ( jQuery.isFunction( func ) ) {
                        // For each dataType in the dataTypeExpression
                        while ( (dataType = dataTypes[i++]) ) {
                            // Prepend if requested
                            if ( dataType.charAt( 0 ) === "+" ) {
                                dataType = dataType.slice( 1 ) || "*";
                                (structure[ dataType ] = structure[ dataType ] || []).unshift( func );

                                // Otherwise append
                            } else {
                                (structure[ dataType ] = structure[ dataType ] || []).push( func );
                            }
                        }
                    }
                };
            }

            // Base inspection function for prefilters and transports
            function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

                var inspected = {},
                seekingTransport = ( structure === transports );

                function inspect( dataType ) {
                    var selected;
                    inspected[ dataType ] = true;
                    jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
                        var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
                        if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
                            options.dataTypes.unshift( dataTypeOrTransport );
                            inspect( dataTypeOrTransport );
                            return false;
                        } else if ( seekingTransport ) {
                            return !( selected = dataTypeOrTransport );
                        }
                    });
                    return selected;
                }

                return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
            }

            // A special extend for ajax options
            // that takes "flat" options (not to be deep extended)
            // Fixes #9887
            function ajaxExtend( target, src ) {
                var deep, key,
                flatOptions = jQuery.ajaxSettings.flatOptions || {};

                for ( key in src ) {
                    if ( src[ key ] !== undefined ) {
                        ( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
                    }
                }
                if ( deep ) {
                    jQuery.extend( true, target, deep );
                }

                return target;
            }

            /* Handles responses to an ajax request:
             * - finds the right dataType (mediates between content-type and expected dataType)
             * - returns the corresponding response
             */
            function ajaxHandleResponses( s, jqXHR, responses ) {
                var firstDataType, ct, finalDataType, type,
                contents = s.contents,
                dataTypes = s.dataTypes;

                // Remove auto dataType and get content-type in the process
                while ( dataTypes[ 0 ] === "*" ) {
                    dataTypes.shift();
                    if ( ct === undefined ) {
                        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
                    }
                }

                // Check if we're dealing with a known content-type
                if ( ct ) {
                    for ( type in contents ) {
                        if ( contents[ type ] && contents[ type ].test( ct ) ) {
                            dataTypes.unshift( type );
                            break;
                        }
                    }
                }

                // Check to see if we have a response for the expected dataType
                if ( dataTypes[ 0 ] in responses ) {
                    finalDataType = dataTypes[ 0 ];
                } else {
                    // Try convertible dataTypes
                    for ( type in responses ) {
                        if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
                            finalDataType = type;
                            break;
                        }
                        if ( !firstDataType ) {
                            firstDataType = type;
                        }
                    }
                    // Or just use first one
                    finalDataType = finalDataType || firstDataType;
                }

                // If we found a dataType
                // We add the dataType to the list if needed
                // and return the corresponding response
                if ( finalDataType ) {
                    if ( finalDataType !== dataTypes[ 0 ] ) {
                        dataTypes.unshift( finalDataType );
                    }
                    return responses[ finalDataType ];
                }
            }

            /* Chain conversions given the request and the original response
             * Also sets the responseXXX fields on the jqXHR instance
             */
            function ajaxConvert( s, response, jqXHR, isSuccess ) {
                var conv2, current, conv, tmp, prev,
                converters = {},
                // Work with a copy of dataTypes in case we need to modify it for conversion
                dataTypes = s.dataTypes.slice();

                // Create converters map with lowercased keys
                if ( dataTypes[ 1 ] ) {
                    for ( conv in s.converters ) {
                        converters[ conv.toLowerCase() ] = s.converters[ conv ];
                    }
                }

                current = dataTypes.shift();

                // Convert to each sequential dataType
                while ( current ) {

                    if ( s.responseFields[ current ] ) {
                        jqXHR[ s.responseFields[ current ] ] = response;
                    }

                    // Apply the dataFilter if provided
                    if ( !prev && isSuccess && s.dataFilter ) {
                        response = s.dataFilter( response, s.dataType );
                    }

                    prev = current;
                    current = dataTypes.shift();

                    if ( current ) {

                        // There's only work to do if current dataType is non-auto
                        if ( current === "*" ) {

                            current = prev;

                            // Convert response if prev dataType is non-auto and differs from current
                        } else if ( prev !== "*" && prev !== current ) {

                            // Seek a direct converter
                            conv = converters[ prev + " " + current ] || converters[ "* " + current ];

                            // If none found, seek a pair
                            if ( !conv ) {
                                for ( conv2 in converters ) {

                                    // If conv2 outputs current
                                    tmp = conv2.split( " " );
                                    if ( tmp[ 1 ] === current ) {

                                        // If prev can be converted to accepted input
                                        conv = converters[ prev + " " + tmp[ 0 ] ] ||
                                        converters[ "* " + tmp[ 0 ] ];
                                        if ( conv ) {
                                            // Condense equivalence converters
                                            if ( conv === true ) {
                                                conv = converters[ conv2 ];

                                                // Otherwise, insert the intermediate dataType
                                            } else if ( converters[ conv2 ] !== true ) {
                                                current = tmp[ 0 ];
                                                dataTypes.unshift( tmp[ 1 ] );
                                            }
                                            break;
                                        }
                                    }
                                }
                            }

                            // Apply converter (if not an equivalence)
                            if ( conv !== true ) {

                                // Unless errors are allowed to bubble, catch and return them
                                if ( conv && s[ "throws" ] ) {
                                    response = conv( response );
                                } else {
                                    try {
                                        response = conv( response );
                                    } catch ( e ) {
                                        return {
                                            state: "parsererror",
                                            error: conv ? e : "No conversion from " + prev + " to " + current 
                                        };
                                    }
                                }
                            }
                        }
                    }
                }

                return {
                    state: "success",
                    data: response 
                };
            }

            jQuery.extend({

                // Counter for holding the number of active queries
                active: 0,

                // Last-Modified header cache for next request
                lastModified: {},
                etag: {},

                ajaxSettings: {
                    url: ajaxLocation,
                    type: "GET",
                    isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
                    global: true,
                    processData: true,
                    async: true,
                    contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                    /*
                    		timeout: 0,
                    		data: null,
                    		dataType: null,
                    		username: null,
                    		password: null,
                    		cache: null,
                    		throws: false,
                    		traditional: false,
                    		headers: {},
                    		*/

                    accepts: {
                        "*": allTypes,
                        text: "text/plain",
                        html: "text/html",
                        xml: "application/xml, text/xml",
                        json: "application/json, text/javascript"
                    },

                    contents: {
                        xml: /xml/,
                        html: /html/,
                        json: /json/
                    },

                    responseFields: {
                        xml: "responseXML",
                        text: "responseText",
                        json: "responseJSON"
                    },

                    // Data converters
                    // Keys separate source (or catchall "*") and destination types with a single space
                    converters: {

                        // Convert anything to text
                        "* text": String,

                        // Text to html (true = no transformation)
                        "text html": true,

                        // Evaluate text as a json expression
                        "text json": jQuery.parseJSON,

                        // Parse text as xml
                        "text xml": jQuery.parseXML
                    },

                    // For options that shouldn't be deep extended:
                    // you can add your own custom options here if
                    // and when you create one that shouldn't be
                    // deep extended (see ajaxExtend)
                    flatOptions: {
                        url: true,
                        context: true
                    }
                },

                // Creates a full fledged settings object into target
                // with both ajaxSettings and settings fields.
                // If target is omitted, writes into ajaxSettings.
                ajaxSetup: function( target, settings ) {
                    return settings ?
                    // Building a settings object
                    ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
                    // Extending ajaxSettings
                    ajaxExtend( jQuery.ajaxSettings, target );
                },

                ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
                ajaxTransport: addToPrefiltersOrTransports( transports ),

                // Main method
                ajax: function( url, options ) {

                    // If url is an object, simulate pre-1.5 signature
                    if ( typeof url === "object" ) {
                        options = url;
                        url = undefined;
                    }

                    // Force options to be an object
                    options = options || {};

                    var // Cross-domain detection vars
                    parts,
                    // Loop variable
                    i,
                    // URL without anti-cache param
                    cacheURL,
                    // Response headers as string
                    responseHeadersString,
                    // timeout handle
                    timeoutTimer,
                    // To know if global events are to be dispatched
                    fireGlobals,
                    transport,
                    // Response headers
                    responseHeaders,
                    // Create the final options object
                    s = jQuery.ajaxSetup( {}, options ),
                    // Callbacks context
                    callbackContext = s.context || s,
                    // Context for global events is callbackContext if it is a DOM node or jQuery collection
                    globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
                    jQuery( callbackContext ) :
                    jQuery.event,
                    // Deferreds
                    deferred = jQuery.Deferred(),
                    completeDeferred = jQuery.Callbacks("once memory"),
                    // Status-dependent callbacks
                    statusCode = s.statusCode || {},
                    // Headers (they are sent all at once)
                    requestHeaders = {},
                    requestHeadersNames = {},
                    // The jqXHR state
                    state = 0,
                    // Default abort message
                    strAbort = "canceled",
                    // Fake xhr
                    jqXHR = {
                        readyState: 0,

                        // Builds headers hashtable if needed
                        getResponseHeader: function( key ) {
                            var match;
                            if ( state === 2 ) {
                                if ( !responseHeaders ) {
                                    responseHeaders = {};
                                    while ( (match = rheaders.exec( responseHeadersString )) ) {
                                        responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
                                    }
                                }
                                match = responseHeaders[ key.toLowerCase() ];
                            }
                            return match == null ? null : match;
                        },

                        // Raw string
                        getAllResponseHeaders: function() {
                            return state === 2 ? responseHeadersString : null;
                        },

                        // Caches the header
                        setRequestHeader: function( name, value ) {
                            var lname = name.toLowerCase();
                            if ( !state ) {
                                name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
                                requestHeaders[ name ] = value;
                            }
                            return this;
                        },

                        // Overrides response content-type header
                        overrideMimeType: function( type ) {
                            if ( !state ) {
                                s.mimeType = type;
                            }
                            return this;
                        },

                        // Status-dependent callbacks
                        statusCode: function( map ) {
                            var code;
                            if ( map ) {
                                if ( state < 2 ) {
                                    for ( code in map ) {
                                        // Lazy-add the new callback in a way that preserves old ones
                                        statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
                                    }
                                } else {
                                    // Execute the appropriate callbacks
                                    jqXHR.always( map[ jqXHR.status ] );
                                }
                            }
                            return this;
                        },

                        // Cancel the request
                        abort: function( statusText ) {
                            var finalText = statusText || strAbort;
                            if ( transport ) {
                                transport.abort( finalText );
                            }
                            done( 0, finalText );
                            return this;
                        }
                    };

                    // Attach deferreds
                    deferred.promise( jqXHR ).complete = completeDeferred.add;
                    jqXHR.success = jqXHR.done;
                    jqXHR.error = jqXHR.fail;

                    // Remove hash character (#7531: and string promotion)
                    // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
                    // Handle falsy url in the settings object (#10093: consistency with old signature)
                    // We also use the url parameter if available
                    s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

                    // Alias method option to type as per ticket #12004
                    s.type = options.method || options.type || s.method || s.type;

                    // Extract dataTypes list
                    s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

                    // A cross-domain request is in order when we have a protocol:host:port mismatch
                    if ( s.crossDomain == null ) {
                        parts = rurl.exec( s.url.toLowerCase() );
                        s.crossDomain = !!( parts &&
                        ( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
                        ( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
                        ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
                        );
                    }

                    // Convert data if not already a string
                    if ( s.data && s.processData && typeof s.data !== "string" ) {
                        s.data = jQuery.param( s.data, s.traditional );
                    }

                    // Apply prefilters
                    inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

                    // If request was aborted inside a prefilter, stop there
                    if ( state === 2 ) {
                        return jqXHR;
                    }

                    // We can fire global events as of now if asked to
                    fireGlobals = s.global;

                    // Watch for a new set of requests
                    if ( fireGlobals && jQuery.active++ === 0 ) {
                        jQuery.event.trigger("ajaxStart");
                    }

                    // Uppercase the type
                    s.type = s.type.toUpperCase();

                    // Determine if request has content
                    s.hasContent = !rnoContent.test( s.type );

                    // Save the URL in case we're toying with the If-Modified-Since
                    // and/or If-None-Match header later on
                    cacheURL = s.url;

                    // More options handling for requests with no content
                    if ( !s.hasContent ) {

                        // If data is available, append data to url
                        if ( s.data ) {
                            cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
                            // #9682: remove data so that it's not used in an eventual retry
                            delete s.data;
                        }

                        // Add anti-cache in url if needed
                        if ( s.cache === false ) {
                            s.url = rts.test( cacheURL ) ?
                            // If there is already a '_' parameter, set its value
                            cacheURL.replace( rts, "$1_=" + nonce++ ) :
                            // Otherwise add one to the end
                            cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
                        }
                    }

                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if ( s.ifModified ) {
                        if ( jQuery.lastModified[ cacheURL ] ) {
                            jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
                        }
                        if ( jQuery.etag[ cacheURL ] ) {
                            jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
                        }
                    }

                    // Set the correct header, if data is being sent
                    if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
                        jqXHR.setRequestHeader( "Content-Type", s.contentType );
                    }

                    // Set the Accepts header for the server, depending on the dataType
                    jqXHR.setRequestHeader(
                    "Accept",
                    s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
                    s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
                    s.accepts[ "*" ]
                    );

                    // Check for headers option
                    for ( i in s.headers ) {
                        jqXHR.setRequestHeader( i, s.headers[ i ] );
                    }

                    // Allow custom headers/mimetypes and early abort
                    if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
                        // Abort if not done already and return
                        return jqXHR.abort();
                    }

                    // aborting is no longer a cancellation
                    strAbort = "abort";

                    // Install callbacks on deferreds
                    for ( i in {
                        success: 1,
                        error: 1,
                        complete: 1 
                    }) {
                        jqXHR[ i ]( s[ i ] );
                    }

                    // Get transport
                    transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

                    // If no transport, we auto-abort
                    if ( !transport ) {
                        done( - 1, "No Transport" );
                    } else {
                        jqXHR.readyState = 1;

                        // Send global event
                        if ( fireGlobals ) {
                            globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
                        }
                        // Timeout
                        if ( s.async && s.timeout > 0 ) {
                            timeoutTimer = setTimeout(function() {
                                jqXHR.abort("timeout");
                            }, s.timeout );
                        }

                        try {
                            state = 1;
                            transport.send( requestHeaders, done );
                        } catch ( e ) {
                            // Propagate exception as error if not done
                            if ( state < 2 ) {
                                done( - 1, e );
                                // Simply rethrow otherwise
                            } else {
                                throw e;
                            }
                        }
                    }

                    // Callback for when everything is done
                    function done( status, nativeStatusText, responses, headers ) {
                        var isSuccess, success, error, response, modified,
                        statusText = nativeStatusText;

                        // Called once
                        if ( state === 2 ) {
                            return;
                        }

                        // State is "done" now
                        state = 2;

                        // Clear timeout if it exists
                        if ( timeoutTimer ) {
                            clearTimeout( timeoutTimer );
                        }

                        // Dereference transport for early garbage collection
                        // (no matter how long the jqXHR object will be used)
                        transport = undefined;

                        // Cache response headers
                        responseHeadersString = headers || "";

                        // Set readyState
                        jqXHR.readyState = status > 0 ? 4 : 0;

                        // Determine if successful
                        isSuccess = status >= 200 && status < 300 || status === 304;

                        // Get response data
                        if ( responses ) {
                            response = ajaxHandleResponses( s, jqXHR, responses );
                        }

                        // Convert no matter what (that way responseXXX fields are always set)
                        response = ajaxConvert( s, response, jqXHR, isSuccess );

                        // If successful, handle type chaining
                        if ( isSuccess ) {

                            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                            if ( s.ifModified ) {
                                modified = jqXHR.getResponseHeader("Last-Modified");
                                if ( modified ) {
                                    jQuery.lastModified[ cacheURL ] = modified;
                                }
                                modified = jqXHR.getResponseHeader("etag");
                                if ( modified ) {
                                    jQuery.etag[ cacheURL ] = modified;
                                }
                            }

                            // if no content
                            if ( status === 204 || s.type === "HEAD" ) {
                                statusText = "nocontent";

                                // if not modified
                            } else if ( status === 304 ) {
                                statusText = "notmodified";

                                // If we have data, let's convert it
                            } else {
                                statusText = response.state;
                                success = response.data;
                                error = response.error;
                                isSuccess = !error;
                            }
                        } else {
                            // We extract error from statusText
                            // then normalize statusText and status for non-aborts
                            error = statusText;
                            if ( status || !statusText ) {
                                statusText = "error";
                                if ( status < 0 ) {
                                    status = 0;
                                }
                            }
                        }

                        // Set data for the fake xhr object
                        jqXHR.status = status;
                        jqXHR.statusText = ( nativeStatusText || statusText ) + "";

                        // Success/Error
                        if ( isSuccess ) {
                            deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
                        } else {
                            deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
                        }

                        // Status-dependent callbacks
                        jqXHR.statusCode( statusCode );
                        statusCode = undefined;

                        if ( fireGlobals ) {
                            globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
                            [ jqXHR, s, isSuccess ? success : error ] );
                        }

                        // Complete
                        completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

                        if ( fireGlobals ) {
                            globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
                            // Handle the global AJAX counter
                            if ( !( --jQuery.active ) ) {
                                jQuery.event.trigger("ajaxStop");
                            }
                        }
                    }

                    return jqXHR;
                },

                getJSON: function( url, data, callback ) {
                    return jQuery.get( url, data, callback, "json" );
                },

                getScript: function( url, callback ) {
                    return jQuery.get( url, undefined, callback, "script" );
                }
            });

            jQuery.each( [ "get", "post" ], function( i, method ) {
                jQuery[ method ] = function( url, data, callback, type ) {
                    // shift arguments if data argument was omitted
                    if ( jQuery.isFunction( data ) ) {
                        type = type || callback;
                        callback = data;
                        data = undefined;
                    }

                    return jQuery.ajax({
                        url: url,
                        type: method,
                        dataType: type,
                        data: data,
                        success: callback
                    });
                };
            });

            // Attach a bunch of functions for handling common AJAX events
            jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
                jQuery.fn[ type ] = function( fn ) {
                    return this.on( type, fn );
                };
            });


            jQuery._evalUrl = function( url ) {
                return jQuery.ajax({
                    url: url,
                    type: "GET",
                    dataType: "script",
                    async: false,
                    global: false,
                    "throws": true
                });
            };


            jQuery.fn.extend({
                wrapAll: function( html ) {
                    if ( jQuery.isFunction( html ) ) {
                        return this.each(function(i) {
                            jQuery(this).wrapAll( html.call(this, i) );
                        });
                    }

                    if ( this[0] ) {
                        // The elements to wrap the target around
                        var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

                        if ( this[0].parentNode ) {
                            wrap.insertBefore( this[0] );
                        }

                        wrap.map(function() {
                            var elem = this;

                            while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
                                elem = elem.firstChild;
                            }

                            return elem;
                        }).append( this );
                    }

                    return this;
                },

                wrapInner: function( html ) {
                    if ( jQuery.isFunction( html ) ) {
                        return this.each(function(i) {
                            jQuery(this).wrapInner( html.call(this, i) );
                        });
                    }

                    return this.each(function() {
                        var self = jQuery( this ),
                        contents = self.contents();

                        if ( contents.length ) {
                            contents.wrapAll( html );

                        } else {
                            self.append( html );
                        }
                    });
                },

                wrap: function( html ) {
                    var isFunction = jQuery.isFunction( html );

                    return this.each(function(i) {
                        jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
                    });
                },

                unwrap: function() {
                    return this.parent().each(function() {
                        if ( !jQuery.nodeName( this, "body" ) ) {
                            jQuery( this ).replaceWith( this.childNodes );
                        }
                    }).end();
                }
            });


            jQuery.expr.filters.hidden = function( elem ) {
                // Support: Opera <= 12.12
                // Opera reports offsetWidths and offsetHeights less than zero on some elements
                return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||
                (!support.reliableHiddenOffsets() &&
                ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
            };

            jQuery.expr.filters.visible = function( elem ) {
                return !jQuery.expr.filters.hidden( elem );
            };




            var r20 = /%20/g,
            rbracket = /\[\]$/,
            rCRLF = /\r?\n/g,
            rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
            rsubmittable = /^(?:input|select|textarea|keygen)/i;

            function buildParams( prefix, obj, traditional, add ) {
                var name;

                if ( jQuery.isArray( obj ) ) {
                    // Serialize array item.
                    jQuery.each( obj, function( i, v ) {
                        if ( traditional || rbracket.test( prefix ) ) {
                            // Treat each array item as a scalar.
                            add( prefix, v );

                        } else {
                            // Item is non-scalar (array or object), encode its numeric index.
                            buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
                        }
                    });

                } else if ( !traditional && jQuery.type( obj ) === "object" ) {
                    // Serialize object item.
                    for ( name in obj ) {
                        buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
                    }

                } else {
                    // Serialize scalar item.
                    add( prefix, obj );
                }
            }

            // Serialize an array of form elements or a set of
            // key/values into a query string
            jQuery.param = function( a, traditional ) {
                var prefix,
                s = [],
                add = function( key, value ) {
                    // If value is a function, invoke it and return its value
                    value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
                    s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
                };

                // Set traditional to true for jQuery <= 1.3.2 behavior.
                if ( traditional === undefined ) {
                    traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
                }

                // If an array was passed in, assume that it is an array of form elements.
                if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
                    // Serialize the form elements
                    jQuery.each( a, function() {
                        add( this.name, this.value );
                    });

                } else {
                    // If traditional, encode the "old" way (the way 1.3.2 or older
                    // did it), otherwise encode params recursively.
                    for ( prefix in a ) {
                        buildParams( prefix, a[ prefix ], traditional, add );
                    }
                }

                // Return the resulting serialization
                return s.join( "&" ).replace( r20, "+" );
            };

            jQuery.fn.extend({
                serialize: function() {
                    return jQuery.param( this.serializeArray() );
                },
                serializeArray: function() {
                    return this.map(function() {
                        // Can add propHook for "elements" to filter or add form elements
                        var elements = jQuery.prop( this, "elements" );
                        return elements ? jQuery.makeArray( elements ) : this;
                    })
                    .filter(function() {
                        var type = this.type;
                        // Use .is(":disabled") so that fieldset[disabled] works
                        return this.name && !jQuery( this ).is( ":disabled" ) &&
                        rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
                        ( this.checked || !rcheckableType.test( type ) );
                    })
                    .map(function( i, elem ) {
                        var val = jQuery( this ).val();

                        return val == null ?
                        null :
                        jQuery.isArray( val ) ?
                        jQuery.map( val, function( val ) {
                            return {
                                name: elem.name,
                                value: val.replace( rCRLF, "\r\n" ) 
                            };
                        }) :
                        {
                            name: elem.name,
                            value: val.replace( rCRLF, "\r\n" ) 
                        };
                    }).get();
                }
            });


            // Create the request object
            // (This is still attached to ajaxSettings for backward compatibility)
            jQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ?
            // Support: IE6+
            function() {

                // XHR cannot access local files, always use ActiveX for that case
                return !this.isLocal &&
                // Support: IE7-8
                // oldIE XHR does not support non-RFC2616 methods (#13240)
                // See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx
                // and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9
                // Although this check for six methods instead of eight
                // since IE also does not support "trace" and "connect"
                /^(get|post|head|put|delete|options)$/i.test( this.type ) &&
                createStandardXHR() || createActiveXHR();
            } :
            // For all other browsers, use the standard XMLHttpRequest object
            createStandardXHR;

            var xhrId = 0,
            xhrCallbacks = {},
            xhrSupported = jQuery.ajaxSettings.xhr();

            // Support: IE<10
            // Open requests must be manually aborted on unload (#5280)
            if ( window.ActiveXObject ) {
                jQuery( window ).on( "unload", function() {
                    for ( var key in xhrCallbacks ) {
                        xhrCallbacks[ key ]( undefined, true );
                    }
                });
            }

            // Determine support properties
            support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
            xhrSupported = support.ajax = !!xhrSupported;

            // Create transport if the browser can provide an xhr
            if ( xhrSupported ) {

                jQuery.ajaxTransport(function( options ) {
                    // Cross domain only allowed if supported through XMLHttpRequest
                    if ( !options.crossDomain || support.cors ) {

                        var callback;

                        return {
                            send: function( headers, complete ) {
                                var i,
                                xhr = options.xhr(),
                                id = ++xhrId;

                                // Open the socket
                                xhr.open( options.type, options.url, options.async, options.username, options.password );

                                // Apply custom fields if provided
                                if ( options.xhrFields ) {
                                    for ( i in options.xhrFields ) {
                                        xhr[ i ] = options.xhrFields[ i ];
                                    }
                                }

                                // Override mime type if needed
                                if ( options.mimeType && xhr.overrideMimeType ) {
                                    xhr.overrideMimeType( options.mimeType );
                                }

                                // X-Requested-With header
                                // For cross-domain requests, seeing as conditions for a preflight are
                                // akin to a jigsaw puzzle, we simply never set it to be sure.
                                // (it can always be set on a per-request basis or even using ajaxSetup)
                                // For same-domain requests, won't change header if already provided.
                                if ( !options.crossDomain && !headers["X-Requested-With"] ) {
                                    headers["X-Requested-With"] = "XMLHttpRequest";
                                }

                                // Set headers
                                for ( i in headers ) {
                                    // Support: IE<9
                                    // IE's ActiveXObject throws a 'Type Mismatch' exception when setting
                                    // request header to a null-value.
                                    //
                                    // To keep consistent with other XHR implementations, cast the value
                                    // to string and ignore `undefined`.
                                    if ( headers[ i ] !== undefined ) {
                                        xhr.setRequestHeader( i, headers[ i ] + "" );
                                    }
                                }

                                // Do send the request
                                // This may raise an exception which is actually
                                // handled in jQuery.ajax (so no try/catch here)
                                xhr.send( ( options.hasContent && options.data ) || null );

                                // Listener
                                callback = function( _, isAbort ) {
                                    var status, statusText, responses;

                                    // Was never called and is aborted or complete
                                    if ( callback && ( isAbort || xhr.readyState === 4 ) ) {
                                        // Clean up
                                        delete xhrCallbacks[ id ];
                                        callback = undefined;
                                        xhr.onreadystatechange = jQuery.noop;

                                        // Abort manually if needed
                                        if ( isAbort ) {
                                            if ( xhr.readyState !== 4 ) {
                                                xhr.abort();
                                            }
                                        } else {
                                            responses = {};
                                            status = xhr.status;

                                            // Support: IE<10
                                            // Accessing binary-data responseText throws an exception
                                            // (#11426)
                                            if ( typeof xhr.responseText === "string" ) {
                                                responses.text = xhr.responseText;
                                            }

                                            // Firefox throws an exception when accessing
                                            // statusText for faulty cross-domain requests
                                            try {
                                                statusText = xhr.statusText;
                                            } catch ( e ) {
                                                // We normalize with Webkit giving an empty statusText
                                                statusText = "";
                                            }

                                            // Filter status for non standard behaviors

                                            // If the request is local and we have data: assume a success
                                            // (success with no data won't get notified, that's the best we
                                            // can do given current implementations)
                                            if ( !status && options.isLocal && !options.crossDomain ) {
                                                status = responses.text ? 200 : 404;
                                                // IE - #1450: sometimes returns 1223 when it should be 204
                                            } else if ( status === 1223 ) {
                                                status = 204;
                                            }
                                        }
                                    }

                                    // Call complete if needed
                                    if ( responses ) {
                                        complete( status, statusText, responses, xhr.getAllResponseHeaders() );
                                    }
                                };

                                if ( !options.async ) {
                                    // if we're in sync mode we fire the callback
                                    callback();
                                } else if ( xhr.readyState === 4 ) {
                                    // (IE6 & IE7) if it's in cache and has been
                                    // retrieved directly we need to fire the callback
                                    setTimeout( callback );
                                } else {
                                    // Add to the list of active xhr callbacks
                                    xhr.onreadystatechange = xhrCallbacks[ id ] = callback;
                                }
                            },

                            abort: function() {
                                if ( callback ) {
                                    callback( undefined, true );
                                }
                            }
                        };
                    }
                });
            }

            // Functions to create xhrs
            function createStandardXHR() {
                try {
                    return new window.XMLHttpRequest();
                } catch ( e ) {}
            }

            function createActiveXHR() {
                try {
                    return new window.ActiveXObject( "Microsoft.XMLHTTP" );
                } catch ( e ) {}
            }




            // Install script dataType
            jQuery.ajaxSetup({
                accepts: {
                    script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
                },
                contents: {
                    script: /(?:java|ecma)script/
                },
                converters: {
                    "text script": function( text ) {
                        jQuery.globalEval( text );
                        return text;
                    }
                }
            });

            // Handle cache's special case and global
            jQuery.ajaxPrefilter( "script", function( s ) {
                if ( s.cache === undefined ) {
                    s.cache = false;
                }
                if ( s.crossDomain ) {
                    s.type = "GET";
                    s.global = false;
                }
            });

            // Bind script tag hack transport
            jQuery.ajaxTransport( "script", function(s) {

                // This transport only deals with cross domain requests
                if ( s.crossDomain ) {

                    var script,
                    head = document.head || jQuery("head")[0] || document.documentElement;

                    return {

                        send: function( _, callback ) {

                            script = document.createElement("script");

                            script.async = true;

                            if ( s.scriptCharset ) {
                                script.charset = s.scriptCharset;
                            }

                            script.src = s.url;

                            // Attach handlers for all browsers
                            script.onload = script.onreadystatechange = function( _, isAbort ) {

                                if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

                                    // Handle memory leak in IE
                                    script.onload = script.onreadystatechange = null;

                                    // Remove the script
                                    if ( script.parentNode ) {
                                        script.parentNode.removeChild( script );
                                    }

                                    // Dereference the script
                                    script = null;

                                    // Callback if not abort
                                    if ( !isAbort ) {
                                        callback( 200, "success" );
                                    }
                                }
                            };

                            // Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
                            // Use native DOM manipulation to avoid our domManip AJAX trickery
                            head.insertBefore( script, head.firstChild );
                        },

                        abort: function() {
                            if ( script ) {
                                script.onload( undefined, true );
                            }
                        }
                    };
                }
            });




            var oldCallbacks = [],
            rjsonp = /(=)\?(?=&|$)|\?\?/;

            // Default jsonp settings
            jQuery.ajaxSetup({
                jsonp: "callback",
                jsonpCallback: function() {
                    var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
                    this[ callback ] = true;
                    return callback;
                }
            });

            // Detect, normalize options and install callbacks for jsonp requests
            jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

                var callbackName, overwritten, responseContainer,
                jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
                "url" :
                typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
                );

                // Handle iff the expected data type is "jsonp" or we have a parameter to set
                if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

                    // Get callback name, remembering preexisting value associated with it
                    callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
                    s.jsonpCallback() :
                    s.jsonpCallback;

                    // Insert callback into url or form data
                    if ( jsonProp ) {
                        s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
                    } else if ( s.jsonp !== false ) {
                        s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
                    }

                    // Use data converter to retrieve json after script execution
                    s.converters["script json"] = function() {
                        if ( !responseContainer ) {
                            jQuery.error( callbackName + " was not called" );
                        }
                        return responseContainer[ 0 ];
                    };

                    // force json dataType
                    s.dataTypes[ 0 ] = "json";

                    // Install callback
                    overwritten = window[ callbackName ];
                    window[ callbackName ] = function() {
                        responseContainer = arguments;
                    };

                    // Clean-up function (fires after converters)
                    jqXHR.always(function() {
                        // Restore preexisting value
                        window[ callbackName ] = overwritten;

                        // Save back as free
                        if ( s[ callbackName ] ) {
                            // make sure that re-using the options doesn't screw things around
                            s.jsonpCallback = originalSettings.jsonpCallback;

                            // save the callback name for future use
                            oldCallbacks.push( callbackName );
                        }

                        // Call if it was a function and we have a response
                        if ( responseContainer && jQuery.isFunction( overwritten ) ) {
                            overwritten( responseContainer[ 0 ] );
                        }

                        responseContainer = overwritten = undefined;
                    });

                    // Delegate to script
                    return "script";
                }
            });




            // data: string of html
            // context (optional): If specified, the fragment will be created in this context, defaults to document
            // keepScripts (optional): If true, will include scripts passed in the html string
            jQuery.parseHTML = function( data, context, keepScripts ) {
                if ( !data || typeof data !== "string" ) {
                    return null;
                }
                if ( typeof context === "boolean" ) {
                    keepScripts = context;
                    context = false;
                }
                context = context || document;

                var parsed = rsingleTag.exec( data ),
                scripts = !keepScripts && [];

                // Single tag
                if ( parsed ) {
                    return [ context.createElement( parsed[1] ) ];
                }

                parsed = jQuery.buildFragment( [ data ], context, scripts );

                if ( scripts && scripts.length ) {
                    jQuery( scripts ).remove();
                }

                return jQuery.merge( [], parsed.childNodes );
            };


            // Keep a copy of the old load method
            var _load = jQuery.fn.load;

            /**
             * Load a url into a page
             */
            jQuery.fn.load = function( url, params, callback ) {
                if ( typeof url !== "string" && _load ) {
                    return _load.apply( this, arguments );
                }

                var selector, response, type,
                self = this,
                off = url.indexOf(" ");

                if ( off >= 0 ) {
                    selector = url.slice( off, url.length );
                    url = url.slice( 0, off );
                }

                // If it's a function
                if ( jQuery.isFunction( params ) ) {

                    // We assume that it's the callback
                    callback = params;
                    params = undefined;

                    // Otherwise, build a param string
                } else if ( params && typeof params === "object" ) {
                    type = "POST";
                }

                // If we have elements to modify, make the request
                if ( self.length > 0 ) {
                    jQuery.ajax({
                        url: url,

                        // if "type" variable is undefined, then "GET" method will be used
                        type: type,
                        dataType: "html",
                        data: params
                    }).done(function( responseText ) {

                        // Save response for use in complete callback
                        response = arguments;

                        self.html( selector ?
                        // If a selector was specified, locate the right elements in a dummy div
                        // Exclude scripts to avoid IE 'Permission Denied' errors
                        jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :
                        // Otherwise use the full result
                        responseText );

                    }).complete( callback && function( jqXHR, status ) {
                        self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
                    });
                }

                return this;
            };




            jQuery.expr.filters.animated = function( elem ) {
                return jQuery.grep(jQuery.timers, function( fn ) {
                    return elem === fn.elem;
                }).length;
            };





            var docElem = window.document.documentElement;

            /**
             * Gets a window from an element
             */
            function getWindow( elem ) {
                return jQuery.isWindow( elem ) ?
                elem :
                elem.nodeType === 9 ?
                elem.defaultView || elem.parentWindow :
                false;
            }

            jQuery.offset = {
                setOffset: function( elem, options, i ) {
                    var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
                    position = jQuery.css( elem, "position" ),
                    curElem = jQuery( elem ),
                    props = {};

                    // set position first, in-case top/left are set even on static elem
                    if ( position === "static" ) {
                        elem.style.position = "relative";
                    }

                    curOffset = curElem.offset();
                    curCSSTop = jQuery.css( elem, "top" );
                    curCSSLeft = jQuery.css( elem, "left" );
                    calculatePosition = ( position === "absolute" || position === "fixed" ) &&
                    jQuery.inArray("auto", [ curCSSTop, curCSSLeft ] ) > - 1;

                    // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
                    if ( calculatePosition ) {
                        curPosition = curElem.position();
                        curTop = curPosition.top;
                        curLeft = curPosition.left;
                    } else {
                        curTop = parseFloat( curCSSTop ) || 0;
                        curLeft = parseFloat( curCSSLeft ) || 0;
                    }

                    if ( jQuery.isFunction( options ) ) {
                        options = options.call( elem, i, curOffset );
                    }

                    if ( options.top != null ) {
                        props.top = ( options.top - curOffset.top ) + curTop;
                    }
                    if ( options.left != null ) {
                        props.left = ( options.left - curOffset.left ) + curLeft;
                    }

                    if ( "using" in options ) {
                        options.using.call( elem, props );
                    } else {
                        curElem.css( props );
                    }
                }
            };

            jQuery.fn.extend({
                offset: function( options ) {
                    if ( arguments.length ) {
                        return options === undefined ?
                        this :
                        this.each(function( i ) {
                            jQuery.offset.setOffset( this, options, i );
                        });
                    }

                    var docElem, win,
                    box = {
                        top: 0,
                        left: 0 
                    },
                    elem = this[ 0 ],
                    doc = elem && elem.ownerDocument;

                    if ( !doc ) {
                        return;
                    }

                    docElem = doc.documentElement;

                    // Make sure it's not a disconnected DOM node
                    if ( !jQuery.contains( docElem, elem ) ) {
                        return box;
                    }

                    // If we don't have gBCR, just use 0,0 rather than error
                    // BlackBerry 5, iOS 3 (original iPhone)
                    if ( typeof elem.getBoundingClientRect !== strundefined ) {
                        box = elem.getBoundingClientRect();
                    }
                    win = getWindow( doc );
                    return {
                        top: box.top + ( win.pageYOffset || docElem.scrollTop ) - ( docElem.clientTop || 0 ),
                        left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )
                    };
                },

                position: function() {
                    if ( !this[ 0 ] ) {
                        return;
                    }

                    var offsetParent, offset,
                    parentOffset = {
                        top: 0,
                        left: 0 
                    },
                    elem = this[ 0 ];

                    // fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
                    if ( jQuery.css( elem, "position" ) === "fixed" ) {
                        // we assume that getBoundingClientRect is available when computed position is fixed
                        offset = elem.getBoundingClientRect();
                    } else {
                        // Get *real* offsetParent
                        offsetParent = this.offsetParent();

                        // Get correct offsets
                        offset = this.offset();
                        if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
                            parentOffset = offsetParent.offset();
                        }

                        // Add offsetParent borders
                        parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
                        parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
                    }

                    // Subtract parent offsets and element margins
                    // note: when an element has margin: auto the offsetLeft and marginLeft
                    // are the same in Safari causing offset.left to incorrectly be 0
                    return {
                        top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
                        left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true)
                    };
                },

                offsetParent: function() {
                    return this.map(function() {
                        var offsetParent = this.offsetParent || docElem;

                        while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
                            offsetParent = offsetParent.offsetParent;
                        }
                        return offsetParent || docElem;
                    });
                }
            });

            // Create scrollLeft and scrollTop methods
            jQuery.each( {
                scrollLeft: "pageXOffset",
                scrollTop: "pageYOffset" 
            }, function( method, prop ) {
                var top = /Y/.test( prop );

                jQuery.fn[ method ] = function( val ) {
                    return access( this, function( elem, method, val ) {
                        var win = getWindow( elem );

                        if ( val === undefined ) {
                            return win ? (prop in win) ? win[ prop ] :
                            win.document.documentElement[ method ] :
                            elem[ method ];
                        }

                        if ( win ) {
                            win.scrollTo(
                            !top ? val : jQuery( win ).scrollLeft(),
                            top ? val : jQuery( win ).scrollTop()
                            );

                        } else {
                            elem[ method ] = val;
                        }
                    }, method, val, arguments.length, null );
                };
            });

            // Add the top/left cssHooks using jQuery.fn.position
            // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
            // getComputedStyle returns percent when specified for top/left/bottom/right
            // rather than make the css module depend on the offset module, we just check for it here
            jQuery.each( [ "top", "left" ], function( i, prop ) {
                jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
                function( elem, computed ) {
                    if ( computed ) {
                        computed = curCSS( elem, prop );
                        // if curCSS returns percentage, fallback to offset
                        return rnumnonpx.test( computed ) ?
                        jQuery( elem ).position()[ prop ] + "px" :
                        computed;
                    }
                });
            });


            // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
            jQuery.each( {
                Height: "height",
                Width: "width" 
            }, function( name, type ) {
                jQuery.each( {
                    padding: "inner" + name,
                    content: type,
                    "": "outer" + name 
                }, function( defaultExtra, funcName ) {
                    // margin is only for outerHeight, outerWidth
                    jQuery.fn[ funcName ] = function( margin, value ) {
                        var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
                        extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

                        return access( this, function( elem, type, value ) {
                            var doc;

                            if ( jQuery.isWindow( elem ) ) {
                                // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                                // isn't a whole lot we can do. See pull request at this URL for discussion:
                                // https://github.com/jquery/jquery/pull/764
                                return elem.document.documentElement[ "client" + name ];
                            }

                            // Get document width or height
                            if ( elem.nodeType === 9 ) {
                                doc = elem.documentElement;

                                // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
                                // unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
                                return Math.max(
                                elem.body[ "scroll" + name ], doc[ "scroll" + name ],
                                elem.body[ "offset" + name ], doc[ "offset" + name ],
                                doc[ "client" + name ]
                                );
                            }

                            return value === undefined ?
                            // Get width or height on the element, requesting but not forcing parseFloat
                            jQuery.css( elem, type, extra ) :
                            // Set width or height on the element
                            jQuery.style( elem, type, value, extra );
                        }, type, chainable ? margin : undefined, chainable, null );
                    };
                });
            });


            // The number of elements contained in the matched element set
            jQuery.fn.size = function() {
                return this.length;
            };

            jQuery.fn.andSelf = jQuery.fn.addBack;




            // Register as a named AMD module, since jQuery can be concatenated with other
            // files that may use define, but not via a proper concatenation script that
            // understands anonymous AMD modules. A named AMD is safest and most robust
            // way to register. Lowercase jquery is used because AMD module names are
            // derived from file names, and jQuery is normally delivered in a lowercase
            // file name. Do this after creating the global so that if an AMD module wants
            // to call noConflict to hide this version of jQuery, it will work.
            if ( typeof define === "function" && define.amd ) {
                define( "jquery", [], function() {
                    return jQuery;
                });
            }




            var
            // Map over jQuery in case of overwrite
            _jQuery = window.jQuery,
            // Map over the $ in case of overwrite
            _$ = window.$;

            jQuery.noConflict = function( deep ) {
                if ( window.$ === jQuery ) {
                    window.$ = _$;
                }

                if ( deep && window.jQuery === jQuery ) {
                    window.jQuery = _jQuery;
                }

                return jQuery;
            };

            // Expose jQuery and $ identifiers, even in
            // AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
            // and CommonJS for browser emulators (#13566)
            if ( typeof noGlobal === strundefined ) {
                window.jQuery = window.$ = jQuery;
            }




            return jQuery;

        }));

    }, {}
    ],
    270: [function(require, module, exports) {
        /*
         * jwerty - Awesome handling of keyboard events
         *
         * jwerty is a JS lib which allows you to bind, fire and assert key combination
         * strings against elements and events. It normalises the poor std api into
         * something easy to use and clear.
         *
         * This code is licensed under the MIT
         * For the full license see: http://keithamus.mit-license.org/
         * For more information see: http://keithamus.github.com/jwerty
         *
         * @author Keith Cirkel ('keithamus') <jwerty@keithcirkel.co.uk>
         * @license http://keithamus.mit-license.org/
         * @copyright Copyright Â© 2011, Keith Cirkel
         *
         */
        (function (global, exports) {

            // Helper methods & vars:
            var $d = global.document
            , $ = (global.jQuery || global.Zepto || global.ender || $d)
            , $$
            , $b
            , ke = 'keydown';

            function realTypeOf(v, s) {
                return (v === null) ? s === 'null'
                : (v === undefined) ? s === 'undefined'
                : (v.is && v instanceof $) ? s === 'element'
                : Object.prototype.toString.call(v).toLowerCase().indexOf(s) > 7;
            }

            if ($ === $d) {
                $$ = function (selector, context) {
                    return selector ? $.querySelector(selector, context || $) : $;
                };

                $b = function (e, fn) {
                    e.addEventListener(ke, fn, false);
                };
                $f = function (e, jwertyEv) {
                    var ret = document.createEvent('Event')
                    , i;

                    ret.initEvent(ke, true, true);

                    for (i in jwertyEv) 
                        ret[i] = jwertyEv[i];

                    return (e || $).dispatchEvent(ret);
                }
            } else {
                $$ = function (selector, context, fn) {
                    return $(selector || $d, context);
                };
                $b = function (e, fn) {
                    $(e).bind(ke + '.jwerty', fn);
                };
                $f = function (e, ob) {
                    $(e || $d).trigger($.Event(ke, ob));
                };
            }

            // Private
            var _modProps = {
                16: 'shiftKey',
                17: 'ctrlKey',
                18: 'altKey',
                91: 'metaKey' 
            };

            // Generate key mappings for common keys that are not printable.
            var _keys = {

                // MOD aka toggleable keys
                mods: {
                    // Shift key, â‡§
                    'â‡§': 16,
                    shift: 16,
                    // CTRL key, on Mac: âŒƒ
                    'âŒƒ': 17,
                    ctrl: 17,
                    // ALT key, on Mac: âŒ¥ (Alt)
                    'âŒ¥': 18,
                    alt: 18,
                    option: 18,
                    // META, on Mac: âŒ˜ (CMD), on Windows (Win), on Linux (Super)
                    'âŒ˜': 91,
                    meta: 91,
                    cmd: 91,
                    'super': 91,
                    win: 91
                },

                // Normal keys
                keys: {
                    // Backspace key, on Mac: âŒ« (Backspace)
                    'âŒ«': 8,
                    backspace: 8,
                    // Tab Key, on Mac: â‡¥ (Tab), on Windows â‡¥â‡¥
                    'â‡¥': 9,
                    'â‡†': 9,
                    tab: 9,
                    // Return key, â†©
                    'â†©': 13,
                    'return': 13,
                    enter: 13,
                    'âŒ…': 13,
                    // Pause/Break key
                    'pause': 19,
                    'pause-break': 19,
                    // Caps Lock key, â‡ª
                    'â‡ª': 20,
                    caps: 20,
                    'caps-lock': 20,
                    // Escape key, on Mac: âŽ‹, on Windows: Esc
                    'âŽ‹': 27,
                    escape: 27,
                    esc: 27,
                    // Space key
                    space: 32,
                    // Page-Up key, or pgup, on Mac: â†–
                    'â†–': 33,
                    pgup: 33,
                    'page-up': 33,
                    // Page-Down key, or pgdown, on Mac: â†˜
                    'â†˜': 34,
                    pgdown: 34,
                    'page-down': 34,
                    // END key, on Mac: â‡Ÿ
                    'â‡Ÿ': 35,
                    end: 35,
                    // HOME key, on Mac: â‡ž
                    'â‡ž': 36,
                    home: 36,
                    // Insert key, or ins
                    ins: 45,
                    insert: 45,
                    // Delete key, on Mac: âŒ« (Delete)
                    del: 46,
                    'delete': 46,

                    // Left Arrow Key, or â†
                    'â†': 37,
                    left: 37,
                    'arrow-left': 37,
                    // Up Arrow Key, or â†‘
                    'â†‘': 38,
                    up: 38,
                    'arrow-up': 38,
                    // Right Arrow Key, or â†’
                    'â†’': 39,
                    right: 39,
                    'arrow-right': 39,
                    // Up Arrow Key, or â†“
                    'â†“': 40,
                    down: 40,
                    'arrow-down': 40,

                    // odities, printing characters that come out wrong:
                    // Num-Multiply, or *
                    '*': 106,
                    star: 106,
                    asterisk: 106,
                    multiply: 106,
                    // Num-Plus or +
                    '+': 107,
                    'plus': 107,
                    // Num-Subtract, or -
                    '-': 109,
                    subtract: 109,
                    // Semicolon
                    ';': 186,
                    semicolon: 186,
                    // = or equals
                    '=': 187,
                    'equals': 187,
                    // Comma, or ,
                    ',': 188,
                    comma: 188,
                    //'-': 189, //???
                    // Period, or ., or full-stop
                    '.': 190,
                    period: 190,
                    'full-stop': 190,
                    // Slash, or /, or forward-slash
                    '/': 191,
                    slash: 191,
                    'forward-slash': 191,
                    // Tick, or `, or back-quote 
                    '`': 192,
                    tick: 192,
                    'back-quote': 192,
                    // Open bracket, or [
                    '[': 219,
                    'open-bracket': 219,
                    // Back slash, or \
                    '\\': 220,
                    'back-slash': 220,
                    // Close backet, or ]
                    ']': 221,
                    'close-bracket': 221,
                    // Apostraphe, or Quote, or '
                    '\'': 222,
                    quote: 222,
                    apostraphe: 222
                }

            };

            // To minimise code bloat, add all of the NUMPAD 0-9 keys in a loop
            i = 95, n = 0;
            while (++i < 106) {
                _keys.keys['num-' + n] = i;
                ++n;
            }

            // To minimise code bloat, add all of the top row 0-9 keys in a loop
            i = 47, n = 0;
            while (++i < 58) {
                _keys.keys[n] = i;
                ++n;
            }

            // To minimise code bloat, add all of the F1-F25 keys in a loop
            i = 111, n = 1;
            while (++i < 136) {
                _keys.keys['f' + n] = i;
                ++n;
            }

            // To minimise code bloat, add all of the letters of the alphabet in a loop
            var i = 64;
            while (++i < 91) {
                _keys.keys[String.fromCharCode(i).toLowerCase()] = i;
            }

            function JwertyCode(jwertyCode) {
                var i
                , c
                , n
                , z
                , keyCombo
                , optionals
                , jwertyCodeFragment
                , rangeMatches
                , rangeI;

                // In-case we get called with an instance of ourselves, just return that.
                if (jwertyCode instanceof JwertyCode) 
                    return jwertyCode;

                // If jwertyCode isn't an array, cast it as a string and split into array.
                if (!realTypeOf(jwertyCode, 'array')) {
                    jwertyCode = (String(jwertyCode)).replace(/\s/g, '').toLowerCase().
                    match(/(?:\+,|[^,])+/g);
                }

                // Loop through each key sequence in jwertyCode
                for (i = 0, c = jwertyCode.length; i < c; ++i) {

                    // If the key combo at this part of the sequence isn't an array,
                    // cast as a string and split into an array.
                    if (!realTypeOf(jwertyCode[i], 'array')) {
                        jwertyCode[i] = String(jwertyCode[i])
                        .match(/(?:\+\/|[^\/])+/g);
                    }

                    // Parse the key optionals in this sequence
                    optionals = [], n = jwertyCode[i].length;
                    while (n--) {

                        // Begin creating the object for this key combo
                        var jwertyCodeFragment = jwertyCode[i][n];

                        keyCombo = {
                            jwertyCombo: String(jwertyCodeFragment),
                            shiftKey: false,
                            ctrlKey: false,
                            altKey: false,
                            metaKey: false
                        }

                        // If jwertyCodeFragment isn't an array then cast as a string
                        // and split it into one.
                        if (!realTypeOf(jwertyCodeFragment, 'array')) {
                            jwertyCodeFragment = String(jwertyCodeFragment).toLowerCase()
                            .match(/(?:(?:[^\+])+|\+\+|^\+$)/g);
                        }

                        z = jwertyCodeFragment.length;
                        while (z--) {

                            // Normalise matching errors
                            if (jwertyCodeFragment[z] === '++') 
                                jwertyCodeFragment[z] = '+';

                            // Inject either keyCode or ctrl/meta/shift/altKey into keyCombo
                            if (jwertyCodeFragment[z] in _keys.mods) {
                                keyCombo[_modProps[_keys.mods[jwertyCodeFragment[z]]]] = true;
                            } else if (jwertyCodeFragment[z] in _keys.keys) {
                                keyCombo.keyCode = _keys.keys[jwertyCodeFragment[z]];
                            } else {
                                rangeMatches = jwertyCodeFragment[z].match(/^\[([^-]+\-?[^-]*)-([^-]+\-?[^-]*)\]$/);
                            }
                        }
                        if (realTypeOf(keyCombo.keyCode, 'undefined')) {
                            // If we picked up a range match earlier...
                            if (rangeMatches && (rangeMatches[1] in _keys.keys) && (rangeMatches[2] in _keys.keys)) {
                                rangeMatches[2] = _keys.keys[rangeMatches[2]];
                                rangeMatches[1] = _keys.keys[rangeMatches[1]];

                                // Go from match 1 and capture all key-comobs up to match 2
                                for (rangeI = rangeMatches[1]; rangeI < rangeMatches[2]; ++rangeI) {
                                    optionals.push({
                                        altKey: keyCombo.altKey,
                                        shiftKey: keyCombo.shiftKey,
                                        metaKey: keyCombo.metaKey,
                                        ctrlKey: keyCombo.ctrlKey,
                                        keyCode: rangeI,
                                        jwertyCombo: String(jwertyCodeFragment)
                                    });

                                }
                                keyCombo.keyCode = rangeI;
                                // Inject either keyCode or ctrl/meta/shift/altKey into keyCombo
                            } else {
                                keyCombo.keyCode = 0;
                            }
                        }
                        optionals.push(keyCombo);

                    }
                    this[i] = optionals;
                }
                this.length = i;
                return this;
            }

            var jwerty = exports.jwerty = {
                /**
                         * jwerty.event
                         *
                         * `jwerty.event` will return a function, which expects the first
                         *  argument to be a key event. When the key event matches `jwertyCode`,
                         *  `callbackFunction` is fired. `jwerty.event` is used by `jwerty.key`
                         *  to bind the function it returns. `jwerty.event` is useful for
                         *  attaching to your own event listeners. It can be used as a decorator
                         *  method to encapsulate functionality that you only want to fire after
                         *  a specific key combo. If `callbackContext` is specified then it will
                         *  be supplied as `callbackFunction`'s context - in other words, the
                         *  keyword `this` will be set to `callbackContext` inside the
                         *  `callbackFunction` function.
                         *
                         *   @param {Mixed} jwertyCode can be an array, or string of key
                         *      combinations, which includes optinals and or sequences
                         *   @param {Function} callbackFucntion is a function (or boolean) which
                         *      is fired when jwertyCode is matched. Return false to
                         *      preventDefault()
                         *   @param {Object} callbackContext (Optional) The context to call
                         *      `callback` with (i.e this)
                         *      
                         */
                event: function (jwertyCode, callbackFunction, callbackContext /*? this */
                ) {

                    // Construct a function out of callbackFunction, if it is a boolean.
                    if (realTypeOf(callbackFunction, 'boolean')) {
                        var bool = callbackFunction;
                        callbackFunction = function () {
                            return bool;
                        }
                    }

                    jwertyCode = new JwertyCode(jwertyCode);

                    // Initialise in-scope vars.
                    var i = 0
                    , c = jwertyCode.length - 1
                    , returnValue
                    , jwertyCodeIs;

                    // This is the event listener function that gets returned...
                    return function (event) {

                        // if jwertyCodeIs returns truthy (string)...
                        if ((jwertyCodeIs = jwerty.is(jwertyCode, event, i))) {
                            // ... and this isn't the last key in the sequence,
                            // incriment the key in sequence to check.
                            if (i < c) {
                                ++i;
                                return;
                                // ... and this is the last in the sequence (or the only
                                // one in sequence), then fire the callback
                            } else {
                                returnValue = callbackFunction.call(
                                callbackContext || this, event, jwertyCodeIs);

                                // If the callback returned false, then we should run
                                // preventDefault();
                                if (returnValue === false) 
                                    event.preventDefault();

                                // Reset i for the next sequence to fire.
                                i = 0;
                                return;
                            }
                        }

                        // If the event didn't hit this time, we should reset i to 0,
                        // that is, unless this combo was the first in the sequence,
                        // in which case we should reset i to 1.
                        i = jwerty.is(jwertyCode, event) ? 1 : 0;
                    }
                },

                /**
                         * jwerty.is
                         *
                         * `jwerty.is` will return a boolean value, based on if `event` matches
                         *  `jwertyCode`. `jwerty.is` is called by `jwerty.event` to check
                         *  whether or not to fire the callback. `event` can be a DOM event, or
                         *  a jQuery/Zepto/Ender manufactured event. The properties of
                         *  `jwertyCode` (speficially ctrlKey, altKey, metaKey, shiftKey and
                         *  keyCode) should match `jwertyCode`'s properties - if they do, then
                         *  `jwerty.is` will return `true`. If they don't, `jwerty.is` will
                         *  return `false`.
                         *
                         *   @param {Mixed} jwertyCode can be an array, or string of key
                         *      combinations, which includes optinals and or sequences
                         *   @param {KeyboardEvent} event is the KeyboardEvent to assert against
                         *   @param {Integer} i (Optional) checks the `i` key in jwertyCode
                         *      sequence
                         *      
                         */
                is: function (jwertyCode, event, i /*? 0*/
                ) {
                    jwertyCode = new JwertyCode(jwertyCode);
                    // Default `i` to 0
                    i = i || 0;
                    // We are only interesting in `i` of jwertyCode;
                    jwertyCode = jwertyCode[i];
                    // jQuery stores the *real* event in `originalEvent`, which we use
                    // because it does annoything stuff to `metaKey`
                    event = event.originalEvent || event;

                    // We'll look at each optional in this jwertyCode sequence...
                    var key
                    , n = jwertyCode.length
                    , returnValue = false;

                    // Loop through each fragment of jwertyCode
                    while (n--) {
                        returnValue = jwertyCode[n].jwertyCombo;
                        // For each property in the jwertyCode object, compare to `event`
                        for (var p in jwertyCode[n]) {
                            // ...except for jwertyCode.jwertyCombo...
                            if (p !== 'jwertyCombo' && event[p] != jwertyCode[n][p]) 
                                returnValue = false;
                        }
                        // If this jwertyCode optional wasn't falsey, then we can return early.
                        if (returnValue !== false) 
                            return returnValue;
                    }
                    return returnValue;
                },

                /**
                         * jwerty.key
                         *
                         *  `jwerty.key` will attach an event listener and fire
                         *   `callbackFunction` when `jwertyCode` matches. The event listener is
                         *   attached to `document`, meaning it will listen for any key events
                         *   on the page (a global shortcut listener). If `callbackContext` is
                         *   specified then it will be supplied as `callbackFunction`'s context
                         *   - in other words, the keyword `this` will be set to
                         *   `callbackContext` inside the `callbackFunction` function.
                         *
                         *   @param {Mixed} jwertyCode can be an array, or string of key
                         *      combinations, which includes optinals and or sequences
                         *   @param {Function} callbackFunction is a function (or boolean) which
                         *      is fired when jwertyCode is matched. Return false to
                         *      preventDefault()
                         *   @param {Object} callbackContext (Optional) The context to call
                         *      `callback` with (i.e this)
                         *   @param {Mixed} selector can be a string, jQuery/Zepto/Ender object,
                         *      or an HTML*Element on which to bind the eventListener
                         *   @param {Mixed} selectorContext can be a string, jQuery/Zepto/Ender
                         *      object, or an HTML*Element on which to scope the selector
                         *  
                         */
                key: function (jwertyCode, callbackFunction, callbackContext /*? this */
                , selector /*? document */
                , selectorContext /*? body */
                ) {
                    // Because callbackContext is optional, we should check if the
                    // `callbackContext` is a string or element, and if it is, then the
                    // function was called without a context, and `callbackContext` is
                    // actually `selector`
                    var realSelector = realTypeOf(callbackContext, 'element') || realTypeOf(callbackContext, 'string') ? callbackContext : selector
                    // If `callbackContext` is undefined, or if we skipped it (and
                    // therefore it is `realSelector`), set context to `global`.
                    , realcallbackContext = realSelector === callbackContext ? global : callbackContext
                    // Finally if we did skip `callbackContext`, then shift
                    // `selectorContext` to the left (take it from `selector`)
                    , realSelectorContext = realSelector === callbackContext ? selector : selectorContext;

                    // If `realSelector` is already a jQuery/Zepto/Ender/DOM element,
                    // then just use it neat, otherwise find it in DOM using $$()
                    $b(realTypeOf(realSelector, 'element') ?
                    realSelector : $$(realSelector, realSelectorContext)
                    , jwerty.event(jwertyCode, callbackFunction, realcallbackContext));
                },

                /**
                         * jwerty.fire
                         *
                         * `jwerty.fire` will construct a keyup event to fire, based on
                         *  `jwertyCode`. The event will be fired against `selector`.
                         *  `selectorContext` is used to search for `selector` within
                         *  `selectorContext`, similar to jQuery's
                         *  `$('selector', 'context')`.
                         *
                         *   @param {Mixed} jwertyCode can be an array, or string of key
                         *      combinations, which includes optinals and or sequences
                         *   @param {Mixed} selector can be a string, jQuery/Zepto/Ender object,
                         *      or an HTML*Element on which to bind the eventListener
                         *   @param {Mixed} selectorContext can be a string, jQuery/Zepto/Ender
                         *      object, or an HTML*Element on which to scope the selector
                         *  
                         */
                fire: function (jwertyCode, selector /*? document */
                , selectorContext /*? body */
                , i) {
                    jwertyCode = new JwertyCode(jwertyCode);
                    var realI = realTypeOf(selectorContext, 'number') ? selectorContext : i;

                    // If `realSelector` is already a jQuery/Zepto/Ender/DOM element,
                    // then just use it neat, otherwise find it in DOM using $$()
                    $f(realTypeOf(selector, 'element') ?
                    selector : $$(selector, selectorContext)
                    , jwertyCode[realI || 0][0]);
                },

                KEYS: _keys
            };

        }(this, (typeof module !== 'undefined' && module.exports ? module.exports : this)));
    }, {}
    ],
    271: [function(require, module, exports) {
        var global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}; /**
         * @license
         * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
         * Build: `lodash modern -o ./dist/lodash.js`
         * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
         * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
         * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
         * Available under MIT license <http://lodash.com/license>
         */
        ;
        (function() {

            /** Used as a safe reference for `undefined` in pre ES5 environments */
            var undefined;

            /** Used to pool arrays and objects used internally */
            var arrayPool = [],
            objectPool = [];

            /** Used to generate unique IDs */
            var idCounter = 0;

            /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
            var keyPrefix = + new Date + '';

            /** Used as the size when optimizations are enabled for large arrays */
            var largeArraySize = 75;

            /** Used as the max size of the `arrayPool` and `objectPool` */
            var maxPoolSize = 40;

            /** Used to detect and test whitespace */
            var whitespace = (
            // whitespace
            ' \t\x0B\f\xA0\ufeff' +
            // line terminators
            '\n\r\u2028\u2029' +
            // unicode category "Zs" space separators
            '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
            );

            /** Used to match empty string literals in compiled template source */
            var reEmptyStringLeading = /\b__p \+= '';/g,
            reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
            reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

            /**
               * Used to match ES6 template delimiters
               * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
               */
            var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

            /** Used to match regexp flags from their coerced string values */
            var reFlags = /\w*$/;

            /** Used to detected named functions */
            var reFuncName = /^\s*function[ \n\r\t]+\w/;

            /** Used to match "interpolate" template delimiters */
            var reInterpolate = /<%=([\s\S]+?)%>/g;

            /** Used to match leading whitespace and zeros to be removed */
            var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');

            /** Used to ensure capturing order of template delimiters */
            var reNoMatch = /($^)/;

            /** Used to detect functions containing a `this` reference */
            var reThis = /\bthis\b/;

            /** Used to match unescaped characters in compiled string literals */
            var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

            /** Used to assign default `context` object properties */
            var contextProps = [
            'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',
            'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
            'parseInt', 'setTimeout'
            ];

            /** Used to make template sourceURLs easier to identify */
            var templateCounter = 0;

            /** `Object#toString` result shortcuts */
            var argsClass = '[object Arguments]',
            arrayClass = '[object Array]',
            boolClass = '[object Boolean]',
            dateClass = '[object Date]',
            funcClass = '[object Function]',
            numberClass = '[object Number]',
            objectClass = '[object Object]',
            regexpClass = '[object RegExp]',
            stringClass = '[object String]';

            /** Used to identify object classifications that `_.clone` supports */
            var cloneableClasses = {};
            cloneableClasses[funcClass] = false;
            cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
            cloneableClasses[boolClass] = cloneableClasses[dateClass] =
            cloneableClasses[numberClass] = cloneableClasses[objectClass] =
            cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

            /** Used as an internal `_.debounce` options object */
            var debounceOptions = {
                'leading': false,
                'maxWait': 0,
                'trailing': false
            };

            /** Used as the property descriptor for `__bindData__` */
            var descriptor = {
                'configurable': false,
                'enumerable': false,
                'value': null,
                'writable': false
            };

            /** Used to determine if values are of the language type Object */
            var objectTypes = {
                'boolean': false,
                'function': true,
                'object': true,
                'number': false,
                'string': false,
                'undefined': false
            };

            /** Used to escape characters for inclusion in compiled string literals */
            var stringEscapes = {
                '\\': '\\',
                "'": "'",
                '\n': 'n',
                '\r': 'r',
                '\t': 't',
                '\u2028': 'u2028',
                '\u2029': 'u2029'
            };

            /** Used as a reference to the global object */
            var root = (objectTypes[typeof window] && window) || this;

            /** Detect free variable `exports` */
            var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

            /** Detect free variable `module` */
            var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

            /** Detect the popular CommonJS extension `module.exports` */
            var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

            /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
            var freeGlobal = objectTypes[typeof global] && global;
            if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
                root = freeGlobal;
            }

            /*--------------------------------------------------------------------------*/

            /**
               * The base implementation of `_.indexOf` without support for binary searches
               * or `fromIndex` constraints.
               *
               * @private
               * @param {Array} array The array to search.
               * @param {*} value The value to search for.
               * @param {number} [fromIndex=0] The index to search from.
               * @returns {number} Returns the index of the matched value or `-1`.
               */
            function baseIndexOf(array, value, fromIndex) {
                var index = (fromIndex || 0) - 1,
                length = array ? array.length : 0;

                while (++index < length) {
                    if (array[index] === value) {
                        return index;
                    }
                }
                return - 1;
            }

            /**
               * An implementation of `_.contains` for cache objects that mimics the return
               * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
               *
               * @private
               * @param {Object} cache The cache object to inspect.
               * @param {*} value The value to search for.
               * @returns {number} Returns `0` if `value` is found, else `-1`.
               */
            function cacheIndexOf(cache, value) {
                var type = typeof value;
                cache = cache.cache;

                if (type == 'boolean' || value == null) {
                    return cache[value] ? 0 : - 1;
                }
                if (type != 'number' && type != 'string') {
                    type = 'object';
                }
                var key = type == 'number' ? value : keyPrefix + value;
                cache = (cache = cache[type]) && cache[key];

                return type == 'object'
                ? (cache && baseIndexOf(cache, value) > - 1 ? 0 : - 1)
                : (cache ? 0 : - 1);
            }

            /**
               * Adds a given value to the corresponding cache object.
               *
               * @private
               * @param {*} value The value to add to the cache.
               */
            function cachePush(value) {
                var cache = this.cache,
                type = typeof value;

                if (type == 'boolean' || value == null) {
                    cache[value] = true;
                } else {
                    if (type != 'number' && type != 'string') {
                        type = 'object';
                    }
                    var key = type == 'number' ? value : keyPrefix + value,
                    typeCache = cache[type] || (cache[type] = {});

                    if (type == 'object') {
                        (typeCache[key] || (typeCache[key] = [])).push(value);
                    } else {
                        typeCache[key] = true;
                    }
                }
            }

            /**
               * Used by `_.max` and `_.min` as the default callback when a given
               * collection is a string value.
               *
               * @private
               * @param {string} value The character to inspect.
               * @returns {number} Returns the code unit of given character.
               */
            function charAtCallback(value) {
                return value.charCodeAt(0);
            }

            /**
               * Used by `sortBy` to compare transformed `collection` elements, stable sorting
               * them in ascending order.
               *
               * @private
               * @param {Object} a The object to compare to `b`.
               * @param {Object} b The object to compare to `a`.
               * @returns {number} Returns the sort order indicator of `1` or `-1`.
               */
            function compareAscending(a, b) {
                var ac = a.criteria,
                bc = b.criteria,
                index = - 1,
                length = ac.length;

                while (++index < length) {
                    var value = ac[index],
                    other = bc[index];

                    if (value !== other) {
                        if (value > other || typeof value == 'undefined') {
                            return 1;
                        }
                        if (value < other || typeof other == 'undefined') {
                            return - 1;
                        }
                    }
                }
                // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
                // that causes it, under certain circumstances, to return the same value for
                // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
                //
                // This also ensures a stable sort in V8 and other engines.
                // See http://code.google.com/p/v8/issues/detail?id=90
                return a.index - b.index;
            }

            /**
               * Creates a cache object to optimize linear searches of large arrays.
               *
               * @private
               * @param {Array} [array=[]] The array to search.
               * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
               */
            function createCache(array) {
                var index = - 1,
                length = array.length,
                first = array[0],
                mid = array[(length / 2) | 0],
                last = array[length - 1];

                if (first && typeof first == 'object' &&
                mid && typeof mid == 'object' && last && typeof last == 'object') {
                    return false;
                }
                var cache = getObject();
                cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

                var result = getObject();
                result.array = array;
                result.cache = cache;
                result.push = cachePush;

                while (++index < length) {
                    result.push(array[index]);
                }
                return result;
            }

            /**
               * Used by `template` to escape characters for inclusion in compiled
               * string literals.
               *
               * @private
               * @param {string} match The matched character to escape.
               * @returns {string} Returns the escaped character.
               */
            function escapeStringChar(match) {
                return '\\' + stringEscapes[match];
            }

            /**
               * Gets an array from the array pool or creates a new one if the pool is empty.
               *
               * @private
               * @returns {Array} The array from the pool.
               */
            function getArray() {
                return arrayPool.pop() || [];
            }

            /**
               * Gets an object from the object pool or creates a new one if the pool is empty.
               *
               * @private
               * @returns {Object} The object from the pool.
               */
            function getObject() {
                return objectPool.pop() || {
                    'array': null,
                    'cache': null,
                    'criteria': null,
                    'false': false,
                    'index': 0,
                    'null': false,
                    'number': null,
                    'object': null,
                    'push': null,
                    'string': null,
                    'true': false,
                    'undefined': false,
                    'value': null
                };
            }

            /**
               * Releases the given array back to the array pool.
               *
               * @private
               * @param {Array} [array] The array to release.
               */
            function releaseArray(array) {
                array.length = 0;
                if (arrayPool.length < maxPoolSize) {
                    arrayPool.push(array);
                }
            }

            /**
               * Releases the given object back to the object pool.
               *
               * @private
               * @param {Object} [object] The object to release.
               */
            function releaseObject(object) {
                var cache = object.cache;
                if (cache) {
                    releaseObject(cache);
                }
                object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
                if (objectPool.length < maxPoolSize) {
                    objectPool.push(object);
                }
            }

            /**
               * Slices the `collection` from the `start` index up to, but not including,
               * the `end` index.
               *
               * Note: This function is used instead of `Array#slice` to support node lists
               * in IE < 9 and to ensure dense arrays are returned.
               *
               * @private
               * @param {Array|Object|string} collection The collection to slice.
               * @param {number} start The start index.
               * @param {number} end The end index.
               * @returns {Array} Returns the new array.
               */
            function slice(array, start, end) {
                start || (start = 0);
                if (typeof end == 'undefined') {
                    end = array ? array.length : 0;
                }
                var index = - 1,
                length = end - start || 0,
                result = Array(length < 0 ? 0 : length);

                while (++index < length) {
                    result[index] = array[start + index];
                }
                return result;
            }

            /*--------------------------------------------------------------------------*/

            /**
               * Create a new `lodash` function using the given context object.
               *
               * @static
               * @memberOf _
               * @category Utilities
               * @param {Object} [context=root] The context object.
               * @returns {Function} Returns the `lodash` function.
               */
            function runInContext(context) {
                // Avoid issues with some ES3 environments that attempt to use values, named
                // after built-in constructors like `Object`, for the creation of literals.
                // ES5 clears this up by stating that literals must use built-in constructors.
                // See http://es5.github.io/#x11.1.5.
                context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

                /** Native constructor references */
                var Array = context.Array,
                Boolean = context.Boolean,
                Date = context.Date,
                Function = context.Function,
                Math = context.Math,
                Number = context.Number,
                Object = context.Object,
                RegExp = context.RegExp,
                String = context.String,
                TypeError = context.TypeError;

                /**
                     * Used for `Array` method references.
                     *
                     * Normally `Array.prototype` would suffice, however, using an array literal
                     * avoids issues in Narwhal.
                     */
                var arrayRef = [];

                /** Used for native method references */
                var objectProto = Object.prototype;

                /** Used to restore the original `_` reference in `noConflict` */
                var oldDash = context._;

                /** Used to resolve the internal [[Class]] of values */
                var toString = objectProto.toString;

                /** Used to detect if a method is native */
                var reNative = RegExp('^' +
                String(toString)
                .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
                .replace(/toString| for [^\]]+/g, '.*?') + '$'
                );

                /** Native method shortcuts */
                var ceil = Math.ceil,
                clearTimeout = context.clearTimeout,
                floor = Math.floor,
                fnToString = Function.prototype.toString,
                getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
                hasOwnProperty = objectProto.hasOwnProperty,
                push = arrayRef.push,
                setTimeout = context.setTimeout,
                splice = arrayRef.splice,
                unshift = arrayRef.unshift;

                /** Used to set meta data on functions */
                var defineProperty = (function() {
                    // IE 8 only accepts DOM elements
                    try {
                        var o = {},
                        func = isNative(func = Object.defineProperty) && func,
                        result = func(o, o, o) && func;
                    } catch (e) {}
                    return result;
                }());

                /* Native method shortcuts for methods with the same name as other `lodash` methods */
                var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
                nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
                nativeIsFinite = context.isFinite,
                nativeIsNaN = context.isNaN,
                nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
                nativeMax = Math.max,
                nativeMin = Math.min,
                nativeParseInt = context.parseInt,
                nativeRandom = Math.random;

                /** Used to lookup a built-in constructor by [[Class]] */
                var ctorByClass = {};
                ctorByClass[arrayClass] = Array;
                ctorByClass[boolClass] = Boolean;
                ctorByClass[dateClass] = Date;
                ctorByClass[funcClass] = Function;
                ctorByClass[objectClass] = Object;
                ctorByClass[numberClass] = Number;
                ctorByClass[regexpClass] = RegExp;
                ctorByClass[stringClass] = String;

                /*--------------------------------------------------------------------------*/

                /**
                     * Creates a `lodash` object which wraps the given value to enable intuitive
                     * method chaining.
                     *
                     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
                     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
                     * and `unshift`
                     *
                     * Chaining is supported in custom builds as long as the `value` method is
                     * implicitly or explicitly included in the build.
                     *
                     * The chainable wrapper functions are:
                     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
                     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
                     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
                     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
                     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
                     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
                     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
                     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
                     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
                     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
                     * and `zip`
                     *
                     * The non-chainable wrapper functions are:
                     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
                     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
                     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
                     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
                     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
                     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
                     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
                     * `template`, `unescape`, `uniqueId`, and `value`
                     *
                     * The wrapper functions `first` and `last` return wrapped values when `n` is
                     * provided, otherwise they return unwrapped values.
                     *
                     * Explicit chaining can be enabled by using the `_.chain` method.
                     *
                     * @name _
                     * @constructor
                     * @category Chaining
                     * @param {*} value The value to wrap in a `lodash` instance.
                     * @returns {Object} Returns a `lodash` instance.
                     * @example
                     *
                     * var wrapped = _([1, 2, 3]);
                     *
                     * // returns an unwrapped value
                     * wrapped.reduce(function(sum, num) {
                     *   return sum + num;
                     * });
                     * // => 6
                     *
                     * // returns a wrapped value
                     * var squares = wrapped.map(function(num) {
                     *   return num * num;
                     * });
                     *
                     * _.isArray(squares);
                     * // => false
                     *
                     * _.isArray(squares.value());
                     * // => true
                     */
                function lodash(value) {
                    // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
                    return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
                    ? value
                    : new lodashWrapper(value);
                }

                /**
                     * A fast path for creating `lodash` wrapper objects.
                     *
                     * @private
                     * @param {*} value The value to wrap in a `lodash` instance.
                     * @param {boolean} chainAll A flag to enable chaining for all methods
                     * @returns {Object} Returns a `lodash` instance.
                     */
                function lodashWrapper(value, chainAll) {
                    this.__chain__ = !!chainAll;
                    this.__wrapped__ = value;
                }
                // ensure `new lodashWrapper` is an instance of `lodash`
                lodashWrapper.prototype = lodash.prototype;

                /**
                     * An object used to flag environments features.
                     *
                     * @static
                     * @memberOf _
                     * @type Object
                     */
                var support = lodash.support = {};

                /**
                     * Detect if functions can be decompiled by `Function#toString`
                     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
                     *
                     * @memberOf _.support
                     * @type boolean
                     */
                support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

                /**
                     * Detect if `Function#name` is supported (all but IE).
                     *
                     * @memberOf _.support
                     * @type boolean
                     */
                support.funcNames = typeof Function.name == 'string';

                /**
                     * By default, the template delimiters used by Lo-Dash are similar to those in
                     * embedded Ruby (ERB). Change the following template settings to use alternative
                     * delimiters.
                     *
                     * @static
                     * @memberOf _
                     * @type Object
                     */
                lodash.templateSettings = {

                    /**
                           * Used to detect `data` property values to be HTML-escaped.
                           *
                           * @memberOf _.templateSettings
                           * @type RegExp
                           */
                    'escape': /<%-([\s\S]+?)%>/g,

                    /**
                           * Used to detect code to be evaluated.
                           *
                           * @memberOf _.templateSettings
                           * @type RegExp
                           */
                    'evaluate': /<%([\s\S]+?)%>/g,

                    /**
                           * Used to detect `data` property values to inject.
                           *
                           * @memberOf _.templateSettings
                           * @type RegExp
                           */
                    'interpolate': reInterpolate,

                    /**
                           * Used to reference the data object in the template text.
                           *
                           * @memberOf _.templateSettings
                           * @type string
                           */
                    'variable': '',

                    /**
                           * Used to import variables into the compiled template.
                           *
                           * @memberOf _.templateSettings
                           * @type Object
                           */
                    'imports': {

                        /**
                                 * A reference to the `lodash` function.
                                 *
                                 * @memberOf _.templateSettings.imports
                                 * @type Function
                                 */
                        '_': lodash
                    }
                };

                /*--------------------------------------------------------------------------*/

                /**
                     * The base implementation of `_.bind` that creates the bound function and
                     * sets its meta data.
                     *
                     * @private
                     * @param {Array} bindData The bind data array.
                     * @returns {Function} Returns the new bound function.
                     */
                function baseBind(bindData) {
                    var func = bindData[0],
                    partialArgs = bindData[2],
                    thisArg = bindData[4];

                    function bound() {
                        // `Function#bind` spec
                        // http://es5.github.io/#x15.3.4.5
                        if (partialArgs) {
                            // avoid `arguments` object deoptimizations by using `slice` instead
                            // of `Array.prototype.slice.call` and not assigning `arguments` to a
                            // variable as a ternary expression
                            var args = slice(partialArgs);
                            push.apply(args, arguments);
                        }
                        // mimic the constructor's `return` behavior
                        // http://es5.github.io/#x13.2.2
                        if (this instanceof bound) {
                            // ensure `new bound` is an instance of `func`
                            var thisBinding = baseCreate(func.prototype),
                            result = func.apply(thisBinding, args || arguments);
                            return isObject(result) ? result : thisBinding;
                        }
                        return func.apply(thisArg, args || arguments);
                    }
                    setBindData(bound, bindData);
                    return bound;
                }

                /**
                     * The base implementation of `_.clone` without argument juggling or support
                     * for `thisArg` binding.
                     *
                     * @private
                     * @param {*} value The value to clone.
                     * @param {boolean} [isDeep=false] Specify a deep clone.
                     * @param {Function} [callback] The function to customize cloning values.
                     * @param {Array} [stackA=[]] Tracks traversed source objects.
                     * @param {Array} [stackB=[]] Associates clones with source counterparts.
                     * @returns {*} Returns the cloned value.
                     */
                function baseClone(value, isDeep, callback, stackA, stackB) {
                    if (callback) {
                        var result = callback(value);
                        if (typeof result != 'undefined') {
                            return result;
                        }
                    }
                    // inspect [[Class]]
                    var isObj = isObject(value);
                    if (isObj) {
                        var className = toString.call(value);
                        if (!cloneableClasses[className]) {
                            return value;
                        }
                        var ctor = ctorByClass[className];
                        switch (className) {
                        case boolClass:
                        case dateClass:
                            return new ctor( + value);

                        case numberClass:
                        case stringClass:
                            return new ctor(value);

                        case regexpClass:
                            result = ctor(value.source, reFlags.exec(value));
                            result.lastIndex = value.lastIndex;
                            return result;
                        }
                    } else {
                        return value;
                    }
                    var isArr = isArray(value);
                    if (isDeep) {
                        // check for circular references and return corresponding clone
                        var initedStack = !stackA;
                        stackA || (stackA = getArray());
                        stackB || (stackB = getArray());

                        var length = stackA.length;
                        while (length--) {
                            if (stackA[length] == value) {
                                return stackB[length];
                            }
                        }
                        result = isArr ? ctor(value.length) : {};
                    } else {
                        result = isArr ? slice(value) : assign({}, value);
                    }
                    // add array properties assigned by `RegExp#exec`
                    if (isArr) {
                        if (hasOwnProperty.call(value, 'index')) {
                            result.index = value.index;
                        }
                        if (hasOwnProperty.call(value, 'input')) {
                            result.input = value.input;
                        }
                    }
                    // exit for shallow clone
                    if (!isDeep) {
                        return result;
                    }
                    // add the source value to the stack of traversed objects
                    // and associate it with its clone
                    stackA.push(value);
                    stackB.push(result);

                    // recursively populate clone (susceptible to call stack limits)
                    (isArr ? forEach : forOwn)(value, function(objValue, key) {
                        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
                    });

                    if (initedStack) {
                        releaseArray(stackA);
                        releaseArray(stackB);
                    }
                    return result;
                }

                /**
                     * The base implementation of `_.create` without support for assigning
                     * properties to the created object.
                     *
                     * @private
                     * @param {Object} prototype The object to inherit from.
                     * @returns {Object} Returns the new object.
                     */
                function baseCreate(prototype, properties) {
                    return isObject(prototype) ? nativeCreate(prototype) : {};
                }
                // fallback for browsers without `Object.create`
                if (!nativeCreate) {
                    baseCreate = (function() {
                        function Object() {}
                        return function(prototype) {
                            if (isObject(prototype)) {
                                Object.prototype = prototype;
                                var result = new Object;
                                Object.prototype = null;
                            }
                            return result || context.Object();
                        };
                    }());
                }

                /**
                     * The base implementation of `_.createCallback` without support for creating
                     * "_.pluck" or "_.where" style callbacks.
                     *
                     * @private
                     * @param {*} [func=identity] The value to convert to a callback.
                     * @param {*} [thisArg] The `this` binding of the created callback.
                     * @param {number} [argCount] The number of arguments the callback accepts.
                     * @returns {Function} Returns a callback function.
                     */
                function baseCreateCallback(func, thisArg, argCount) {
                    if (typeof func != 'function') {
                        return identity;
                    }
                    // exit early for no `thisArg` or already bound by `Function#bind`
                    if (typeof thisArg == 'undefined' || !('prototype' in func)) {
                        return func;
                    }
                    var bindData = func.__bindData__;
                    if (typeof bindData == 'undefined') {
                        if (support.funcNames) {
                            bindData = !func.name;
                        }
                        bindData = bindData || !support.funcDecomp;
                        if (!bindData) {
                            var source = fnToString.call(func);
                            if (!support.funcNames) {
                                bindData = !reFuncName.test(source);
                            }
                            if (!bindData) {
                                // checks if `func` references the `this` keyword and stores the result
                                bindData = reThis.test(source);
                                setBindData(func, bindData);
                            }
                        }
                    }
                    // exit early if there are no `this` references or `func` is bound
                    if (bindData === false || (bindData !== true && bindData[1] & 1)) {
                        return func;
                    }
                    switch (argCount) {
                    case 1:
                        return function(value) {
                            return func.call(thisArg, value);
                        };
                    case 2:
                        return function(a, b) {
                            return func.call(thisArg, a, b);
                        };
                    case 3:
                        return function(value, index, collection) {
                            return func.call(thisArg, value, index, collection);
                        };
                    case 4:
                        return function(accumulator, value, index, collection) {
                            return func.call(thisArg, accumulator, value, index, collection);
                        };
                    }
                    return bind(func, thisArg);
                }

                /**
                     * The base implementation of `createWrapper` that creates the wrapper and
                     * sets its meta data.
                     *
                     * @private
                     * @param {Array} bindData The bind data array.
                     * @returns {Function} Returns the new function.
                     */
                function baseCreateWrapper(bindData) {
                    var func = bindData[0],
                    bitmask = bindData[1],
                    partialArgs = bindData[2],
                    partialRightArgs = bindData[3],
                    thisArg = bindData[4],
                    arity = bindData[5];

                    var isBind = bitmask & 1,
                    isBindKey = bitmask & 2,
                    isCurry = bitmask & 4,
                    isCurryBound = bitmask & 8,
                    key = func;

                    function bound() {
                        var thisBinding = isBind ? thisArg : this;
                        if (partialArgs) {
                            var args = slice(partialArgs);
                            push.apply(args, arguments);
                        }
                        if (partialRightArgs || isCurry) {
                            args || (args = slice(arguments));
                            if (partialRightArgs) {
                                push.apply(args, partialRightArgs);
                            }
                            if (isCurry && args.length < arity) {
                                bitmask |= 16 & ~32;
                                return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
                            }
                        }
                        args || (args = arguments);
                        if (isBindKey) {
                            func = thisBinding[key];
                        }
                        if (this instanceof bound) {
                            thisBinding = baseCreate(func.prototype);
                            var result = func.apply(thisBinding, args);
                            return isObject(result) ? result : thisBinding;
                        }
                        return func.apply(thisBinding, args);
                    }
                    setBindData(bound, bindData);
                    return bound;
                }

                /**
                     * The base implementation of `_.difference` that accepts a single array
                     * of values to exclude.
                     *
                     * @private
                     * @param {Array} array The array to process.
                     * @param {Array} [values] The array of values to exclude.
                     * @returns {Array} Returns a new array of filtered values.
                     */
                function baseDifference(array, values) {
                    var index = - 1,
                    indexOf = getIndexOf(),
                    length = array ? array.length : 0,
                    isLarge = length >= largeArraySize && indexOf === baseIndexOf,
                    result = [];

                    if (isLarge) {
                        var cache = createCache(values);
                        if (cache) {
                            indexOf = cacheIndexOf;
                            values = cache;
                        } else {
                            isLarge = false;
                        }
                    }
                    while (++index < length) {
                        var value = array[index];
                        if (indexOf(values, value) < 0) {
                            result.push(value);
                        }
                    }
                    if (isLarge) {
                        releaseObject(values);
                    }
                    return result;
                }

                /**
                     * The base implementation of `_.flatten` without support for callback
                     * shorthands or `thisArg` binding.
                     *
                     * @private
                     * @param {Array} array The array to flatten.
                     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
                     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
                     * @param {number} [fromIndex=0] The index to start from.
                     * @returns {Array} Returns a new flattened array.
                     */
                function baseFlatten(array, isShallow, isStrict, fromIndex) {
                    var index = (fromIndex || 0) - 1,
                    length = array ? array.length : 0,
                    result = [];

                    while (++index < length) {
                        var value = array[index];

                        if (value && typeof value == 'object' && typeof value.length == 'number'
                        && (isArray(value) || isArguments(value))) {
                            // recursively flatten arrays (susceptible to call stack limits)
                            if (!isShallow) {
                                value = baseFlatten(value, isShallow, isStrict);
                            }
                            var valIndex = - 1,
                            valLength = value.length,
                            resIndex = result.length;

                            result.length += valLength;
                            while (++valIndex < valLength) {
                                result[resIndex++] = value[valIndex];
                            }
                        } else if (!isStrict) {
                            result.push(value);
                        }
                    }
                    return result;
                }

                /**
                     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
                     * that allows partial "_.where" style comparisons.
                     *
                     * @private
                     * @param {*} a The value to compare.
                     * @param {*} b The other value to compare.
                     * @param {Function} [callback] The function to customize comparing values.
                     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
                     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
                     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
                     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                     */
                function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
                    // used to indicate that when comparing objects, `a` has at least the properties of `b`
                    if (callback) {
                        var result = callback(a, b);
                        if (typeof result != 'undefined') {
                            return !!result;
                        }
                    }
                    // exit early for identical values
                    if (a === b) {
                        // treat `+0` vs. `-0` as not equal
                        return a !== 0 || (1 / a == 1 / b);
                    }
                    var type = typeof a,
                    otherType = typeof b;

                    // exit early for unlike primitive values
                    if (a === a &&
                    !(a && objectTypes[type]) &&
                    !(b && objectTypes[otherType])) {
                        return false;
                    }
                    // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
                    // http://es5.github.io/#x15.3.4.4
                    if (a == null || b == null) {
                        return a === b;
                    }
                    // compare [[Class]] names
                    var className = toString.call(a),
                    otherClass = toString.call(b);

                    if (className == argsClass) {
                        className = objectClass;
                    }
                    if (otherClass == argsClass) {
                        otherClass = objectClass;
                    }
                    if (className != otherClass) {
                        return false;
                    }
                    switch (className) {
                    case boolClass:
                    case dateClass:
                        // coerce dates and booleans to numbers, dates to milliseconds and booleans
                        // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
                        return + a == + b;

                    case numberClass:
                        // treat `NaN` vs. `NaN` as equal
                        return (a != + a)
                        ? b != + b
                        // but treat `+0` vs. `-0` as not equal
                        : (a == 0 ? (1 / a == 1 / b) : a == + b);

                    case regexpClass:
                    case stringClass:
                        // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
                        // treat string primitives and their corresponding object instances as equal
                        return a == String(b);
                    }
                    var isArr = className == arrayClass;
                    if (!isArr) {
                        // unwrap any `lodash` wrapped values
                        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
                        bWrapped = hasOwnProperty.call(b, '__wrapped__');

                        if (aWrapped || bWrapped) {
                            return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
                        }
                        // exit for functions and DOM nodes
                        if (className != objectClass) {
                            return false;
                        }
                        // in older versions of Opera, `arguments` objects have `Array` constructors
                        var ctorA = a.constructor,
                        ctorB = b.constructor;

                        // non `Object` object instances with different constructors are not equal
                        if (ctorA != ctorB &&
                        !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
                        ('constructor' in a && 'constructor' in b)
                        ) {
                            return false;
                        }
                    }
                    // assume cyclic structures are equal
                    // the algorithm for detecting cyclic structures is adapted from ES 5.1
                    // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
                    var initedStack = !stackA;
                    stackA || (stackA = getArray());
                    stackB || (stackB = getArray());

                    var length = stackA.length;
                    while (length--) {
                        if (stackA[length] == a) {
                            return stackB[length] == b;
                        }
                    }
                    var size = 0;
                    result = true;

                    // add `a` and `b` to the stack of traversed objects
                    stackA.push(a);
                    stackB.push(b);

                    // recursively compare objects and arrays (susceptible to call stack limits)
                    if (isArr) {
                        // compare lengths to determine if a deep comparison is necessary
                        length = a.length;
                        size = b.length;
                        result = size == length;

                        if (result || isWhere) {
                            // deep compare the contents, ignoring non-numeric properties
                            while (size--) {
                                var index = length,
                                value = b[size];

                                if (isWhere) {
                                    while (index--) {
                                        if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                                            break;
                                        }
                                    }
                                } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
                                    break;
                                }
                            }
                        }
                    } else {
                        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
                        // which, in this case, is more costly
                        forIn(b, function(value, key, b) {
                            if (hasOwnProperty.call(b, key)) {
                                // count the number of properties.
                                size++;
                                // deep compare each property value.
                                return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
                            }
                        });

                        if (result && !isWhere) {
                            // ensure both objects have the same number of properties
                            forIn(a, function(value, key, a) {
                                if (hasOwnProperty.call(a, key)) {
                                    // `size` will be `-1` if `a` has more properties than `b`
                                    return (result = --size > - 1);
                                }
                            });
                        }
                    }
                    stackA.pop();
                    stackB.pop();

                    if (initedStack) {
                        releaseArray(stackA);
                        releaseArray(stackB);
                    }
                    return result;
                }

                /**
                     * The base implementation of `_.merge` without argument juggling or support
                     * for `thisArg` binding.
                     *
                     * @private
                     * @param {Object} object The destination object.
                     * @param {Object} source The source object.
                     * @param {Function} [callback] The function to customize merging properties.
                     * @param {Array} [stackA=[]] Tracks traversed source objects.
                     * @param {Array} [stackB=[]] Associates values with source counterparts.
                     */
                function baseMerge(object, source, callback, stackA, stackB) {
                    (isArray(source) ? forEach : forOwn)(source, function(source, key) {
                        var found,
                        isArr,
                        result = source,
                        value = object[key];

                        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
                            // avoid merging previously merged cyclic sources
                            var stackLength = stackA.length;
                            while (stackLength--) {
                                if ((found = stackA[stackLength] == source)) {
                                    value = stackB[stackLength];
                                    break;
                                }
                            }
                            if (!found) {
                                var isShallow;
                                if (callback) {
                                    result = callback(value, source);
                                    if ((isShallow = typeof result != 'undefined')) {
                                        value = result;
                                    }
                                }
                                if (!isShallow) {
                                    value = isArr
                                    ? (isArray(value) ? value : [])
                                    : (isPlainObject(value) ? value : {});
                                }
                                // add `source` and associated `value` to the stack of traversed objects
                                stackA.push(source);
                                stackB.push(value);

                                // recursively merge objects and arrays (susceptible to call stack limits)
                                if (!isShallow) {
                                    baseMerge(value, source, callback, stackA, stackB);
                                }
                            }
                        } else {
                            if (callback) {
                                result = callback(value, source);
                                if (typeof result == 'undefined') {
                                    result = source;
                                }
                            }
                            if (typeof result != 'undefined') {
                                value = result;
                            }
                        }
                        object[key] = value;
                    });
                }

                /**
                     * The base implementation of `_.random` without argument juggling or support
                     * for returning floating-point numbers.
                     *
                     * @private
                     * @param {number} min The minimum possible value.
                     * @param {number} max The maximum possible value.
                     * @returns {number} Returns a random number.
                     */
                function baseRandom(min, max) {
                    return min + floor(nativeRandom() * (max - min + 1));
                }

                /**
                     * The base implementation of `_.uniq` without support for callback shorthands
                     * or `thisArg` binding.
                     *
                     * @private
                     * @param {Array} array The array to process.
                     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
                     * @param {Function} [callback] The function called per iteration.
                     * @returns {Array} Returns a duplicate-value-free array.
                     */
                function baseUniq(array, isSorted, callback) {
                    var index = - 1,
                    indexOf = getIndexOf(),
                    length = array ? array.length : 0,
                    result = [];

                    var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
                    seen = (callback || isLarge) ? getArray() : result;

                    if (isLarge) {
                        var cache = createCache(seen);
                        indexOf = cacheIndexOf;
                        seen = cache;
                    }
                    while (++index < length) {
                        var value = array[index],
                        computed = callback ? callback(value, index, array) : value;

                        if (isSorted
                        ? !index || seen[seen.length - 1] !== computed
                        : indexOf(seen, computed) < 0
                        ) {
                            if (callback || isLarge) {
                                seen.push(computed);
                            }
                            result.push(value);
                        }
                    }
                    if (isLarge) {
                        releaseArray(seen.array);
                        releaseObject(seen);
                    } else if (callback) {
                        releaseArray(seen);
                    }
                    return result;
                }

                /**
                     * Creates a function that aggregates a collection, creating an object composed
                     * of keys generated from the results of running each element of the collection
                     * through a callback. The given `setter` function sets the keys and values
                     * of the composed object.
                     *
                     * @private
                     * @param {Function} setter The setter function.
                     * @returns {Function} Returns the new aggregator function.
                     */
                function createAggregator(setter) {
                    return function(collection, callback, thisArg) {
                        var result = {};
                        callback = lodash.createCallback(callback, thisArg, 3);

                        var index = - 1,
                        length = collection ? collection.length : 0;

                        if (typeof length == 'number') {
                            while (++index < length) {
                                var value = collection[index];
                                setter(result, value, callback(value, index, collection), collection);
                            }
                        } else {
                            forOwn(collection, function(value, key, collection) {
                                setter(result, value, callback(value, key, collection), collection);
                            });
                        }
                        return result;
                    };
                }

                /**
                     * Creates a function that, when called, either curries or invokes `func`
                     * with an optional `this` binding and partially applied arguments.
                     *
                     * @private
                     * @param {Function|string} func The function or method name to reference.
                     * @param {number} bitmask The bitmask of method flags to compose.
                     *  The bitmask may be composed of the following flags:
                     *  1 - `_.bind`
                     *  2 - `_.bindKey`
                     *  4 - `_.curry`
                     *  8 - `_.curry` (bound)
                     *  16 - `_.partial`
                     *  32 - `_.partialRight`
                     * @param {Array} [partialArgs] An array of arguments to prepend to those
                     *  provided to the new function.
                     * @param {Array} [partialRightArgs] An array of arguments to append to those
                     *  provided to the new function.
                     * @param {*} [thisArg] The `this` binding of `func`.
                     * @param {number} [arity] The arity of `func`.
                     * @returns {Function} Returns the new function.
                     */
                function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
                    var isBind = bitmask & 1,
                    isBindKey = bitmask & 2,
                    isCurry = bitmask & 4,
                    isCurryBound = bitmask & 8,
                    isPartial = bitmask & 16,
                    isPartialRight = bitmask & 32;

                    if (!isBindKey && !isFunction(func)) {
                        throw new TypeError;
                    }
                    if (isPartial && !partialArgs.length) {
                        bitmask &= ~16;
                        isPartial = partialArgs = false;
                    }
                    if (isPartialRight && !partialRightArgs.length) {
                        bitmask &= ~32;
                        isPartialRight = partialRightArgs = false;
                    }
                    var bindData = func && func.__bindData__;
                    if (bindData && bindData !== true) {
                        // clone `bindData`
                        bindData = slice(bindData);
                        if (bindData[2]) {
                            bindData[2] = slice(bindData[2]);
                        }
                        if (bindData[3]) {
                            bindData[3] = slice(bindData[3]);
                        }
                        // set `thisBinding` is not previously bound
                        if (isBind && !(bindData[1] & 1)) {
                            bindData[4] = thisArg;
                        }
                        // set if previously bound but not currently (subsequent curried functions)
                        if (!isBind && bindData[1] & 1) {
                            bitmask |= 8;
                        }
                        // set curried arity if not yet set
                        if (isCurry && !(bindData[1] & 4)) {
                            bindData[5] = arity;
                        }
                        // append partial left arguments
                        if (isPartial) {
                            push.apply(bindData[2] || (bindData[2] = []), partialArgs);
                        }
                        // append partial right arguments
                        if (isPartialRight) {
                            unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
                        }
                        // merge flags
                        bindData[1] |= bitmask;
                        return createWrapper.apply(null, bindData);
                    }
                    // fast path for `_.bind`
                    var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
                    return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
                }

                /**
                     * Used by `escape` to convert characters to HTML entities.
                     *
                     * @private
                     * @param {string} match The matched character to escape.
                     * @returns {string} Returns the escaped character.
                     */
                function escapeHtmlChar(match) {
                    return htmlEscapes[match];
                }

                /**
                     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
                     * customized, this method returns the custom method, otherwise it returns
                     * the `baseIndexOf` function.
                     *
                     * @private
                     * @returns {Function} Returns the "indexOf" function.
                     */
                function getIndexOf() {
                    var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
                    return result;
                }

                /**
                     * Checks if `value` is a native function.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
                     */
                function isNative(value) {
                    return typeof value == 'function' && reNative.test(value);
                }

                /**
                     * Sets `this` binding data on a given function.
                     *
                     * @private
                     * @param {Function} func The function to set data on.
                     * @param {Array} value The data array to set.
                     */
                var setBindData = !defineProperty ? noop : function(func, value) {
                    descriptor.value = value;
                    defineProperty(func, '__bindData__', descriptor);
                };

                /**
                     * A fallback implementation of `isPlainObject` which checks if a given value
                     * is an object created by the `Object` constructor, assuming objects created
                     * by the `Object` constructor have no inherited enumerable properties and that
                     * there are no `Object.prototype` extensions.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
                     */
                function shimIsPlainObject(value) {
                    var ctor,
                    result;

                    // avoid non Object objects, `arguments` objects, and DOM elements
                    if (!(value && toString.call(value) == objectClass) ||
                    (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
                        return false;
                    }
                    // In most environments an object's own properties are iterated before
                    // its inherited properties. If the last iterated property is an object's
                    // own property then there are no inherited enumerable properties.
                    forIn(value, function(value, key) {
                        result = key;
                    });
                    return typeof result == 'undefined' || hasOwnProperty.call(value, result);
                }

                /**
                     * Used by `unescape` to convert HTML entities to characters.
                     *
                     * @private
                     * @param {string} match The matched character to unescape.
                     * @returns {string} Returns the unescaped character.
                     */
                function unescapeHtmlChar(match) {
                    return htmlUnescapes[match];
                }

                /*--------------------------------------------------------------------------*/

                /**
                     * Checks if `value` is an `arguments` object.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
                     * @example
                     *
                     * (function() { return _.isArguments(arguments); })(1, 2, 3);
                     * // => true
                     *
                     * _.isArguments([1, 2, 3]);
                     * // => false
                     */
                function isArguments(value) {
                    return value && typeof value == 'object' && typeof value.length == 'number' &&
                    toString.call(value) == argsClass || false;
                }

                /**
                     * Checks if `value` is an array.
                     *
                     * @static
                     * @memberOf _
                     * @type Function
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
                     * @example
                     *
                     * (function() { return _.isArray(arguments); })();
                     * // => false
                     *
                     * _.isArray([1, 2, 3]);
                     * // => true
                     */
                var isArray = nativeIsArray || function(value) {
                    return value && typeof value == 'object' && typeof value.length == 'number' &&
                    toString.call(value) == arrayClass || false;
                };

                /**
                     * A fallback implementation of `Object.keys` which produces an array of the
                     * given object's own enumerable property names.
                     *
                     * @private
                     * @type Function
                     * @param {Object} object The object to inspect.
                     * @returns {Array} Returns an array of property names.
                     */
                var shimKeys = function(object) {
                    var index, iterable = object, result = [];
                    if (!iterable) 
                        return result;
                    if (!(objectTypes[typeof object])) 
                        return result;
                    for (index in iterable) {
                        if (hasOwnProperty.call(iterable, index)) {
                            result.push(index);
                        }
                    }
                    return result
                };

                /**
                     * Creates an array composed of the own enumerable property names of an object.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The object to inspect.
                     * @returns {Array} Returns an array of property names.
                     * @example
                     *
                     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
                     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
                     */
                var keys = !nativeKeys ? shimKeys : function(object) {
                    if (!isObject(object)) {
                        return [];
                    }
                    return nativeKeys(object);
                };

                /**
                     * Used to convert characters to HTML entities:
                     *
                     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
                     * don't require escaping in HTML and have no special meaning unless they're part
                     * of a tag or an unquoted attribute value.
                     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
                     */
                var htmlEscapes = {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#39;'
                };

                /** Used to convert HTML entities to characters */
                var htmlUnescapes = invert(htmlEscapes);

                /** Used to match HTML entities and HTML characters */
                var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
                reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');

                /*--------------------------------------------------------------------------*/

                /**
                     * Assigns own enumerable properties of source object(s) to the destination
                     * object. Subsequent sources will overwrite property assignments of previous
                     * sources. If a callback is provided it will be executed to produce the
                     * assigned values. The callback is bound to `thisArg` and invoked with two
                     * arguments; (objectValue, sourceValue).
                     *
                     * @static
                     * @memberOf _
                     * @type Function
                     * @alias extend
                     * @category Objects
                     * @param {Object} object The destination object.
                     * @param {...Object} [source] The source objects.
                     * @param {Function} [callback] The function to customize assigning values.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns the destination object.
                     * @example
                     *
                     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
                     * // => { 'name': 'fred', 'employer': 'slate' }
                     *
                     * var defaults = _.partialRight(_.assign, function(a, b) {
                     *   return typeof a == 'undefined' ? b : a;
                     * });
                     *
                     * var object = { 'name': 'barney' };
                     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
                     * // => { 'name': 'barney', 'employer': 'slate' }
                     */
                var assign = function(object, source, guard) {
                    var index, iterable = object, result = iterable;
                    if (!iterable) 
                        return result;
                    var args = arguments,
                    argsIndex = 0,
                    argsLength = typeof guard == 'number' ? 2 : args.length;
                    if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
                        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
                    } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
                        callback = args[--argsLength];
                    }
                    while (++argsIndex < argsLength) {
                        iterable = args[argsIndex];
                        if (iterable && objectTypes[typeof iterable]) {
                            var ownIndex = - 1,
                            ownProps = objectTypes[typeof iterable] && keys(iterable),
                            length = ownProps ? ownProps.length : 0;

                            while (++ownIndex < length) {
                                index = ownProps[ownIndex];
                                result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
                            }
                        }
                    }
                    return result
                };

                /**
                     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
                     * be cloned, otherwise they will be assigned by reference. If a callback
                     * is provided it will be executed to produce the cloned values. If the
                     * callback returns `undefined` cloning will be handled by the method instead.
                     * The callback is bound to `thisArg` and invoked with one argument; (value).
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to clone.
                     * @param {boolean} [isDeep=false] Specify a deep clone.
                     * @param {Function} [callback] The function to customize cloning values.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the cloned value.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36 },
                     *   { 'name': 'fred',   'age': 40 }
                     * ];
                     *
                     * var shallow = _.clone(characters);
                     * shallow[0] === characters[0];
                     * // => true
                     *
                     * var deep = _.clone(characters, true);
                     * deep[0] === characters[0];
                     * // => false
                     *
                     * _.mixin({
                     *   'clone': _.partialRight(_.clone, function(value) {
                     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
                     *   })
                     * });
                     *
                     * var clone = _.clone(document.body);
                     * clone.childNodes.length;
                     * // => 0
                     */
                function clone(value, isDeep, callback, thisArg) {
                    // allows working with "Collections" methods without using their `index`
                    // and `collection` arguments for `isDeep` and `callback`
                    if (typeof isDeep != 'boolean' && isDeep != null) {
                        thisArg = callback;
                        callback = isDeep;
                        isDeep = false;
                    }
                    return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
                }

                /**
                     * Creates a deep clone of `value`. If a callback is provided it will be
                     * executed to produce the cloned values. If the callback returns `undefined`
                     * cloning will be handled by the method instead. The callback is bound to
                     * `thisArg` and invoked with one argument; (value).
                     *
                     * Note: This method is loosely based on the structured clone algorithm. Functions
                     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
                     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
                     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to deep clone.
                     * @param {Function} [callback] The function to customize cloning values.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the deep cloned value.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36 },
                     *   { 'name': 'fred',   'age': 40 }
                     * ];
                     *
                     * var deep = _.cloneDeep(characters);
                     * deep[0] === characters[0];
                     * // => false
                     *
                     * var view = {
                     *   'label': 'docs',
                     *   'node': element
                     * };
                     *
                     * var clone = _.cloneDeep(view, function(value) {
                     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
                     * });
                     *
                     * clone.node == view.node;
                     * // => false
                     */
                function cloneDeep(value, callback, thisArg) {
                    return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
                }

                /**
                     * Creates an object that inherits from the given `prototype` object. If a
                     * `properties` object is provided its own enumerable properties are assigned
                     * to the created object.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} prototype The object to inherit from.
                     * @param {Object} [properties] The properties to assign to the object.
                     * @returns {Object} Returns the new object.
                     * @example
                     *
                     * function Shape() {
                     *   this.x = 0;
                     *   this.y = 0;
                     * }
                     *
                     * function Circle() {
                     *   Shape.call(this);
                     * }
                     *
                     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
                     *
                     * var circle = new Circle;
                     * circle instanceof Circle;
                     * // => true
                     *
                     * circle instanceof Shape;
                     * // => true
                     */
                function create(prototype, properties) {
                    var result = baseCreate(prototype);
                    return properties ? assign(result, properties) : result;
                }

                /**
                     * Assigns own enumerable properties of source object(s) to the destination
                     * object for all destination properties that resolve to `undefined`. Once a
                     * property is set, additional defaults of the same property will be ignored.
                     *
                     * @static
                     * @memberOf _
                     * @type Function
                     * @category Objects
                     * @param {Object} object The destination object.
                     * @param {...Object} [source] The source objects.
                     * @param- {Object} [guard] Allows working with `_.reduce` without using its
                     *  `key` and `object` arguments as sources.
                     * @returns {Object} Returns the destination object.
                     * @example
                     *
                     * var object = { 'name': 'barney' };
                     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
                     * // => { 'name': 'barney', 'employer': 'slate' }
                     */
                var defaults = function(object, source, guard) {
                    var index, iterable = object, result = iterable;
                    if (!iterable) 
                        return result;
                    var args = arguments,
                    argsIndex = 0,
                    argsLength = typeof guard == 'number' ? 2 : args.length;
                    while (++argsIndex < argsLength) {
                        iterable = args[argsIndex];
                        if (iterable && objectTypes[typeof iterable]) {
                            var ownIndex = - 1,
                            ownProps = objectTypes[typeof iterable] && keys(iterable),
                            length = ownProps ? ownProps.length : 0;

                            while (++ownIndex < length) {
                                index = ownProps[ownIndex];
                                if (typeof result[index] == 'undefined') 
                                    result[index] = iterable[index];
                            }
                        }
                    }
                    return result
                };

                /**
                     * This method is like `_.findIndex` except that it returns the key of the
                     * first element that passes the callback check, instead of the element itself.
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The object to search.
                     * @param {Function|Object|string} [callback=identity] The function called per
                     *  iteration. If a property name or object is provided it will be used to
                     *  create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
                     * @example
                     *
                     * var characters = {
                     *   'barney': {  'age': 36, 'blocked': false },
                     *   'fred': {    'age': 40, 'blocked': true },
                     *   'pebbles': { 'age': 1,  'blocked': false }
                     * };
                     *
                     * _.findKey(characters, function(chr) {
                     *   return chr.age < 40;
                     * });
                     * // => 'barney' (property order is not guaranteed across environments)
                     *
                     * // using "_.where" callback shorthand
                     * _.findKey(characters, { 'age': 1 });
                     * // => 'pebbles'
                     *
                     * // using "_.pluck" callback shorthand
                     * _.findKey(characters, 'blocked');
                     * // => 'fred'
                     */
                function findKey(object, callback, thisArg) {
                    var result;
                    callback = lodash.createCallback(callback, thisArg, 3);
                    forOwn(object, function(value, key, object) {
                        if (callback(value, key, object)) {
                            result = key;
                            return false;
                        }
                    });
                    return result;
                }

                /**
                     * This method is like `_.findKey` except that it iterates over elements
                     * of a `collection` in the opposite order.
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The object to search.
                     * @param {Function|Object|string} [callback=identity] The function called per
                     *  iteration. If a property name or object is provided it will be used to
                     *  create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
                     * @example
                     *
                     * var characters = {
                     *   'barney': {  'age': 36, 'blocked': true },
                     *   'fred': {    'age': 40, 'blocked': false },
                     *   'pebbles': { 'age': 1,  'blocked': true }
                     * };
                     *
                     * _.findLastKey(characters, function(chr) {
                     *   return chr.age < 40;
                     * });
                     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
                     *
                     * // using "_.where" callback shorthand
                     * _.findLastKey(characters, { 'age': 40 });
                     * // => 'fred'
                     *
                     * // using "_.pluck" callback shorthand
                     * _.findLastKey(characters, 'blocked');
                     * // => 'pebbles'
                     */
                function findLastKey(object, callback, thisArg) {
                    var result;
                    callback = lodash.createCallback(callback, thisArg, 3);
                    forOwnRight(object, function(value, key, object) {
                        if (callback(value, key, object)) {
                            result = key;
                            return false;
                        }
                    });
                    return result;
                }

                /**
                     * Iterates over own and inherited enumerable properties of an object,
                     * executing the callback for each property. The callback is bound to `thisArg`
                     * and invoked with three arguments; (value, key, object). Callbacks may exit
                     * iteration early by explicitly returning `false`.
                     *
                     * @static
                     * @memberOf _
                     * @type Function
                     * @category Objects
                     * @param {Object} object The object to iterate over.
                     * @param {Function} [callback=identity] The function called per iteration.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * function Shape() {
                     *   this.x = 0;
                     *   this.y = 0;
                     * }
                     *
                     * Shape.prototype.move = function(x, y) {
                     *   this.x += x;
                     *   this.y += y;
                     * };
                     *
                     * _.forIn(new Shape, function(value, key) {
                     *   console.log(key);
                     * });
                     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
                     */
                var forIn = function(collection, callback, thisArg) {
                    var index, iterable = collection, result = iterable;
                    if (!iterable) 
                        return result;
                    if (!objectTypes[typeof iterable]) 
                        return result;
                    callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
                    for (index in iterable) {
                        if (callback(iterable[index], index, collection) === false) 
                            return result;
                    }
                    return result
                };

                /**
                     * This method is like `_.forIn` except that it iterates over elements
                     * of a `collection` in the opposite order.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The object to iterate over.
                     * @param {Function} [callback=identity] The function called per iteration.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * function Shape() {
                     *   this.x = 0;
                     *   this.y = 0;
                     * }
                     *
                     * Shape.prototype.move = function(x, y) {
                     *   this.x += x;
                     *   this.y += y;
                     * };
                     *
                     * _.forInRight(new Shape, function(value, key) {
                     *   console.log(key);
                     * });
                     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
                     */
                function forInRight(object, callback, thisArg) {
                    var pairs = [];

                    forIn(object, function(value, key) {
                        pairs.push(key, value);
                    });

                    var length = pairs.length;
                    callback = baseCreateCallback(callback, thisArg, 3);
                    while (length--) {
                        if (callback(pairs[length--], pairs[length], object) === false) {
                            break;
                        }
                    }
                    return object;
                }

                /**
                     * Iterates over own enumerable properties of an object, executing the callback
                     * for each property. The callback is bound to `thisArg` and invoked with three
                     * arguments; (value, key, object). Callbacks may exit iteration early by
                     * explicitly returning `false`.
                     *
                     * @static
                     * @memberOf _
                     * @type Function
                     * @category Objects
                     * @param {Object} object The object to iterate over.
                     * @param {Function} [callback=identity] The function called per iteration.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
                     *   console.log(key);
                     * });
                     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
                     */
                var forOwn = function(collection, callback, thisArg) {
                    var index, iterable = collection, result = iterable;
                    if (!iterable) 
                        return result;
                    if (!objectTypes[typeof iterable]) 
                        return result;
                    callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
                    var ownIndex = - 1,
                    ownProps = objectTypes[typeof iterable] && keys(iterable),
                    length = ownProps ? ownProps.length : 0;

                    while (++ownIndex < length) {
                        index = ownProps[ownIndex];
                        if (callback(iterable[index], index, collection) === false) 
                            return result;
                    }
                    return result
                };

                /**
                     * This method is like `_.forOwn` except that it iterates over elements
                     * of a `collection` in the opposite order.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The object to iterate over.
                     * @param {Function} [callback=identity] The function called per iteration.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
                     *   console.log(key);
                     * });
                     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
                     */
                function forOwnRight(object, callback, thisArg) {
                    var props = keys(object),
                    length = props.length;

                    callback = baseCreateCallback(callback, thisArg, 3);
                    while (length--) {
                        var key = props[length];
                        if (callback(object[key], key, object) === false) {
                            break;
                        }
                    }
                    return object;
                }

                /**
                     * Creates a sorted array of property names of all enumerable properties,
                     * own and inherited, of `object` that have function values.
                     *
                     * @static
                     * @memberOf _
                     * @alias methods
                     * @category Objects
                     * @param {Object} object The object to inspect.
                     * @returns {Array} Returns an array of property names that have function values.
                     * @example
                     *
                     * _.functions(_);
                     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
                     */
                function functions(object) {
                    var result = [];
                    forIn(object, function(value, key) {
                        if (isFunction(value)) {
                            result.push(key);
                        }
                    });
                    return result.sort();
                }

                /**
                     * Checks if the specified property name exists as a direct property of `object`,
                     * instead of an inherited property.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The object to inspect.
                     * @param {string} key The name of the property to check.
                     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
                     * @example
                     *
                     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
                     * // => true
                     */
                function has(object, key) {
                    return object ? hasOwnProperty.call(object, key) : false;
                }

                /**
                     * Creates an object composed of the inverted keys and values of the given object.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The object to invert.
                     * @returns {Object} Returns the created inverted object.
                     * @example
                     *
                     * _.invert({ 'first': 'fred', 'second': 'barney' });
                     * // => { 'fred': 'first', 'barney': 'second' }
                     */
                function invert(object) {
                    var index = - 1,
                    props = keys(object),
                    length = props.length,
                    result = {};

                    while (++index < length) {
                        var key = props[index];
                        result[object[key]] = key;
                    }
                    return result;
                }

                /**
                     * Checks if `value` is a boolean value.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
                     * @example
                     *
                     * _.isBoolean(null);
                     * // => false
                     */
                function isBoolean(value) {
                    return value === true || value === false ||
                    value && typeof value == 'object' && toString.call(value) == boolClass || false;
                }

                /**
                     * Checks if `value` is a date.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
                     * @example
                     *
                     * _.isDate(new Date);
                     * // => true
                     */
                function isDate(value) {
                    return value && typeof value == 'object' && toString.call(value) == dateClass || false;
                }

                /**
                     * Checks if `value` is a DOM element.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
                     * @example
                     *
                     * _.isElement(document.body);
                     * // => true
                     */
                function isElement(value) {
                    return value && value.nodeType === 1 || false;
                }

                /**
                     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
                     * length of `0` and objects with no own enumerable properties are considered
                     * "empty".
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Array|Object|string} value The value to inspect.
                     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
                     * @example
                     *
                     * _.isEmpty([1, 2, 3]);
                     * // => false
                     *
                     * _.isEmpty({});
                     * // => true
                     *
                     * _.isEmpty('');
                     * // => true
                     */
                function isEmpty(value) {
                    var result = true;
                    if (!value) {
                        return result;
                    }
                    var className = toString.call(value),
                    length = value.length;

                    if ((className == arrayClass || className == stringClass || className == argsClass ) ||
                    (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
                        return !length;
                    }
                    forOwn(value, function() {
                        return (result = false);
                    });
                    return result;
                }

                /**
                     * Performs a deep comparison between two values to determine if they are
                     * equivalent to each other. If a callback is provided it will be executed
                     * to compare values. If the callback returns `undefined` comparisons will
                     * be handled by the method instead. The callback is bound to `thisArg` and
                     * invoked with two arguments; (a, b).
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} a The value to compare.
                     * @param {*} b The other value to compare.
                     * @param {Function} [callback] The function to customize comparing values.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                     * @example
                     *
                     * var object = { 'name': 'fred' };
                     * var copy = { 'name': 'fred' };
                     *
                     * object == copy;
                     * // => false
                     *
                     * _.isEqual(object, copy);
                     * // => true
                     *
                     * var words = ['hello', 'goodbye'];
                     * var otherWords = ['hi', 'goodbye'];
                     *
                     * _.isEqual(words, otherWords, function(a, b) {
                     *   var reGreet = /^(?:hello|hi)$/i,
                     *       aGreet = _.isString(a) && reGreet.test(a),
                     *       bGreet = _.isString(b) && reGreet.test(b);
                     *
                     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
                     * });
                     * // => true
                     */
                function isEqual(a, b, callback, thisArg) {
                    return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
                }

                /**
                     * Checks if `value` is, or can be coerced to, a finite number.
                     *
                     * Note: This is not the same as native `isFinite` which will return true for
                     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
                     * @example
                     *
                     * _.isFinite(-101);
                     * // => true
                     *
                     * _.isFinite('10');
                     * // => true
                     *
                     * _.isFinite(true);
                     * // => false
                     *
                     * _.isFinite('');
                     * // => false
                     *
                     * _.isFinite(Infinity);
                     * // => false
                     */
                function isFinite(value) {
                    return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
                }

                /**
                     * Checks if `value` is a function.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
                     * @example
                     *
                     * _.isFunction(_);
                     * // => true
                     */
                function isFunction(value) {
                    return typeof value == 'function';
                }

                /**
                     * Checks if `value` is the language type of Object.
                     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
                     * @example
                     *
                     * _.isObject({});
                     * // => true
                     *
                     * _.isObject([1, 2, 3]);
                     * // => true
                     *
                     * _.isObject(1);
                     * // => false
                     */
                function isObject(value) {
                    // check if the value is the ECMAScript language type of Object
                    // http://es5.github.io/#x8
                    // and avoid a V8 bug
                    // http://code.google.com/p/v8/issues/detail?id=2291
                    return !!(value && objectTypes[typeof value]);
                }

                /**
                     * Checks if `value` is `NaN`.
                     *
                     * Note: This is not the same as native `isNaN` which will return `true` for
                     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
                     * @example
                     *
                     * _.isNaN(NaN);
                     * // => true
                     *
                     * _.isNaN(new Number(NaN));
                     * // => true
                     *
                     * isNaN(undefined);
                     * // => true
                     *
                     * _.isNaN(undefined);
                     * // => false
                     */
                function isNaN(value) {
                    // `NaN` as a primitive is the only value that is not equal to itself
                    // (perform the [[Class]] check first to avoid errors with some host objects in IE)
                    return isNumber(value) && value != + value;
                }

                /**
                     * Checks if `value` is `null`.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
                     * @example
                     *
                     * _.isNull(null);
                     * // => true
                     *
                     * _.isNull(undefined);
                     * // => false
                     */
                function isNull(value) {
                    return value === null;
                }

                /**
                     * Checks if `value` is a number.
                     *
                     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
                     * @example
                     *
                     * _.isNumber(8.4 * 5);
                     * // => true
                     */
                function isNumber(value) {
                    return typeof value == 'number' ||
                    value && typeof value == 'object' && toString.call(value) == numberClass || false;
                }

                /**
                     * Checks if `value` is an object created by the `Object` constructor.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
                     * @example
                     *
                     * function Shape() {
                     *   this.x = 0;
                     *   this.y = 0;
                     * }
                     *
                     * _.isPlainObject(new Shape);
                     * // => false
                     *
                     * _.isPlainObject([1, 2, 3]);
                     * // => false
                     *
                     * _.isPlainObject({ 'x': 0, 'y': 0 });
                     * // => true
                     */
                var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
                    if (!(value && toString.call(value) == objectClass)) {
                        return false;
                    }
                    var valueOf = value.valueOf,
                    objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

                    return objProto
                    ? (value == objProto || getPrototypeOf(value) == objProto)
                    : shimIsPlainObject(value);
                };

                /**
                     * Checks if `value` is a regular expression.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
                     * @example
                     *
                     * _.isRegExp(/fred/);
                     * // => true
                     */
                function isRegExp(value) {
                    return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
                }

                /**
                     * Checks if `value` is a string.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
                     * @example
                     *
                     * _.isString('fred');
                     * // => true
                     */
                function isString(value) {
                    return typeof value == 'string' ||
                    value && typeof value == 'object' && toString.call(value) == stringClass || false;
                }

                /**
                     * Checks if `value` is `undefined`.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
                     * @example
                     *
                     * _.isUndefined(void 0);
                     * // => true
                     */
                function isUndefined(value) {
                    return typeof value == 'undefined';
                }

                /**
                     * Creates an object with the same keys as `object` and values generated by
                     * running each own enumerable property of `object` through the callback.
                     * The callback is bound to `thisArg` and invoked with three arguments;
                     * (value, key, object).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The object to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
                     * @example
                     *
                     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
                     * // => { 'a': 3, 'b': 6, 'c': 9 }
                     *
                     * var characters = {
                     *   'fred': { 'name': 'fred', 'age': 40 },
                     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
                     * };
                     *
                     * // using "_.pluck" callback shorthand
                     * _.mapValues(characters, 'age');
                     * // => { 'fred': 40, 'pebbles': 1 }
                     */
                function mapValues(object, callback, thisArg) {
                    var result = {};
                    callback = lodash.createCallback(callback, thisArg, 3);

                    forOwn(object, function(value, key, object) {
                        result[key] = callback(value, key, object);
                    });
                    return result;
                }

                /**
                     * Recursively merges own enumerable properties of the source object(s), that
                     * don't resolve to `undefined` into the destination object. Subsequent sources
                     * will overwrite property assignments of previous sources. If a callback is
                     * provided it will be executed to produce the merged values of the destination
                     * and source properties. If the callback returns `undefined` merging will
                     * be handled by the method instead. The callback is bound to `thisArg` and
                     * invoked with two arguments; (objectValue, sourceValue).
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The destination object.
                     * @param {...Object} [source] The source objects.
                     * @param {Function} [callback] The function to customize merging properties.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns the destination object.
                     * @example
                     *
                     * var names = {
                     *   'characters': [
                     *     { 'name': 'barney' },
                     *     { 'name': 'fred' }
                     *   ]
                     * };
                     *
                     * var ages = {
                     *   'characters': [
                     *     { 'age': 36 },
                     *     { 'age': 40 }
                     *   ]
                     * };
                     *
                     * _.merge(names, ages);
                     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
                     *
                     * var food = {
                     *   'fruits': ['apple'],
                     *   'vegetables': ['beet']
                     * };
                     *
                     * var otherFood = {
                     *   'fruits': ['banana'],
                     *   'vegetables': ['carrot']
                     * };
                     *
                     * _.merge(food, otherFood, function(a, b) {
                     *   return _.isArray(a) ? a.concat(b) : undefined;
                     * });
                     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
                     */
                function merge(object) {
                    var args = arguments,
                    length = 2;

                    if (!isObject(object)) {
                        return object;
                    }
                    // allows working with `_.reduce` and `_.reduceRight` without using
                    // their `index` and `collection` arguments
                    if (typeof args[2] != 'number') {
                        length = args.length;
                    }
                    if (length > 3 && typeof args[length - 2] == 'function') {
                        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
                    } else if (length > 2 && typeof args[length - 1] == 'function') {
                        callback = args[--length];
                    }
                    var sources = slice(arguments, 1, length),
                    index = - 1,
                    stackA = getArray(),
                    stackB = getArray();

                    while (++index < length) {
                        baseMerge(object, sources[index], callback, stackA, stackB);
                    }
                    releaseArray(stackA);
                    releaseArray(stackB);
                    return object;
                }

                /**
                     * Creates a shallow clone of `object` excluding the specified properties.
                     * Property names may be specified as individual arguments or as arrays of
                     * property names. If a callback is provided it will be executed for each
                     * property of `object` omitting the properties the callback returns truey
                     * for. The callback is bound to `thisArg` and invoked with three arguments;
                     * (value, key, object).
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The source object.
                     * @param {Function|...string|string[]} [callback] The properties to omit or the
                     *  function called per iteration.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns an object without the omitted properties.
                     * @example
                     *
                     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
                     * // => { 'name': 'fred' }
                     *
                     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
                     *   return typeof value == 'number';
                     * });
                     * // => { 'name': 'fred' }
                     */
                function omit(object, callback, thisArg) {
                    var result = {};
                    if (typeof callback != 'function') {
                        var props = [];
                        forIn(object, function(value, key) {
                            props.push(key);
                        });
                        props = baseDifference(props, baseFlatten(arguments, true, false, 1));

                        var index = - 1,
                        length = props.length;

                        while (++index < length) {
                            var key = props[index];
                            result[key] = object[key];
                        }
                    } else {
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forIn(object, function(value, key, object) {
                            if (!callback(value, key, object)) {
                                result[key] = value;
                            }
                        });
                    }
                    return result;
                }

                /**
                     * Creates a two dimensional array of an object's key-value pairs,
                     * i.e. `[[key1, value1], [key2, value2]]`.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The object to inspect.
                     * @returns {Array} Returns new array of key-value pairs.
                     * @example
                     *
                     * _.pairs({ 'barney': 36, 'fred': 40 });
                     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
                     */
                function pairs(object) {
                    var index = - 1,
                    props = keys(object),
                    length = props.length,
                    result = Array(length);

                    while (++index < length) {
                        var key = props[index];
                        result[index] = [key, object[key]];
                    }
                    return result;
                }

                /**
                     * Creates a shallow clone of `object` composed of the specified properties.
                     * Property names may be specified as individual arguments or as arrays of
                     * property names. If a callback is provided it will be executed for each
                     * property of `object` picking the properties the callback returns truey
                     * for. The callback is bound to `thisArg` and invoked with three arguments;
                     * (value, key, object).
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The source object.
                     * @param {Function|...string|string[]} [callback] The function called per
                     *  iteration or property names to pick, specified as individual property
                     *  names or arrays of property names.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns an object composed of the picked properties.
                     * @example
                     *
                     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
                     * // => { 'name': 'fred' }
                     *
                     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
                     *   return key.charAt(0) != '_';
                     * });
                     * // => { 'name': 'fred' }
                     */
                function pick(object, callback, thisArg) {
                    var result = {};
                    if (typeof callback != 'function') {
                        var index = - 1,
                        props = baseFlatten(arguments, true, false, 1),
                        length = isObject(object) ? props.length : 0;

                        while (++index < length) {
                            var key = props[index];
                            if (key in object) {
                                result[key] = object[key];
                            }
                        }
                    } else {
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forIn(object, function(value, key, object) {
                            if (callback(value, key, object)) {
                                result[key] = value;
                            }
                        });
                    }
                    return result;
                }

                /**
                     * An alternative to `_.reduce` this method transforms `object` to a new
                     * `accumulator` object which is the result of running each of its own
                     * enumerable properties through a callback, with each callback execution
                     * potentially mutating the `accumulator` object. The callback is bound to
                     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
                     * Callbacks may exit iteration early by explicitly returning `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Array|Object} object The object to iterate over.
                     * @param {Function} [callback=identity] The function called per iteration.
                     * @param {*} [accumulator] The custom accumulator value.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the accumulated value.
                     * @example
                     *
                     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
                     *   num *= num;
                     *   if (num % 2) {
                     *     return result.push(num) < 3;
                     *   }
                     * });
                     * // => [1, 9, 25]
                     *
                     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
                     *   result[key] = num * 3;
                     * });
                     * // => { 'a': 3, 'b': 6, 'c': 9 }
                     */
                function transform(object, callback, accumulator, thisArg) {
                    var isArr = isArray(object);
                    if (accumulator == null) {
                        if (isArr) {
                            accumulator = [];
                        } else {
                            var ctor = object && object.constructor,
                            proto = ctor && ctor.prototype;

                            accumulator = baseCreate(proto);
                        }
                    }
                    if (callback) {
                        callback = lodash.createCallback(callback, thisArg, 4);
                        (isArr ? forEach : forOwn)(object, function(value, index, object) {
                            return callback(accumulator, value, index, object);
                        });
                    }
                    return accumulator;
                }

                /**
                     * Creates an array composed of the own enumerable property values of `object`.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The object to inspect.
                     * @returns {Array} Returns an array of property values.
                     * @example
                     *
                     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
                     * // => [1, 2, 3] (property order is not guaranteed across environments)
                     */
                function values(object) {
                    var index = - 1,
                    props = keys(object),
                    length = props.length,
                    result = Array(length);

                    while (++index < length) {
                        result[index] = object[props[index]];
                    }
                    return result;
                }

                /*--------------------------------------------------------------------------*/

                /**
                     * Creates an array of elements from the specified indexes, or keys, of the
                     * `collection`. Indexes may be specified as individual arguments or as arrays
                     * of indexes.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
                     *   to retrieve, specified as individual indexes or arrays of indexes.
                     * @returns {Array} Returns a new array of elements corresponding to the
                     *  provided indexes.
                     * @example
                     *
                     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
                     * // => ['a', 'c', 'e']
                     *
                     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
                     * // => ['fred', 'pebbles']
                     */
                function at(collection) {
                    var args = arguments,
                    index = - 1,
                    props = baseFlatten(args, true, false, 1),
                    length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
                    result = Array(length);

                    while (++index < length) {
                        result[index] = collection[props[index]];
                    }
                    return result;
                }

                /**
                     * Checks if a given value is present in a collection using strict equality
                     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
                     * offset from the end of the collection.
                     *
                     * @static
                     * @memberOf _
                     * @alias include
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {*} target The value to check for.
                     * @param {number} [fromIndex=0] The index to search from.
                     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
                     * @example
                     *
                     * _.contains([1, 2, 3], 1);
                     * // => true
                     *
                     * _.contains([1, 2, 3], 1, 2);
                     * // => false
                     *
                     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
                     * // => true
                     *
                     * _.contains('pebbles', 'eb');
                     * // => true
                     */
                function contains(collection, target, fromIndex) {
                    var index = - 1,
                    indexOf = getIndexOf(),
                    length = collection ? collection.length : 0,
                    result = false;

                    fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
                    if (isArray(collection)) {
                        result = indexOf(collection, target, fromIndex) > - 1;
                    } else if (typeof length == 'number') {
                        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > - 1;
                    } else {
                        forOwn(collection, function(value) {
                            if (++index >= fromIndex) {
                                return !(result = value === target);
                            }
                        });
                    }
                    return result;
                }

                /**
                     * Creates an object composed of keys generated from the results of running
                     * each element of `collection` through the callback. The corresponding value
                     * of each key is the number of times the key was returned by the callback.
                     * The callback is bound to `thisArg` and invoked with three arguments;
                     * (value, index|key, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns the composed aggregate object.
                     * @example
                     *
                     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
                     * // => { '4': 1, '6': 2 }
                     *
                     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
                     * // => { '4': 1, '6': 2 }
                     *
                     * _.countBy(['one', 'two', 'three'], 'length');
                     * // => { '3': 2, '5': 1 }
                     */
                var countBy = createAggregator(function(result, value, key) {
                    (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
                });

                /**
                     * Checks if the given callback returns truey value for **all** elements of
                     * a collection. The callback is bound to `thisArg` and invoked with three
                     * arguments; (value, index|key, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias all
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {boolean} Returns `true` if all elements passed the callback check,
                     *  else `false`.
                     * @example
                     *
                     * _.every([true, 1, null, 'yes']);
                     * // => false
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36 },
                     *   { 'name': 'fred',   'age': 40 }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.every(characters, 'age');
                     * // => true
                     *
                     * // using "_.where" callback shorthand
                     * _.every(characters, { 'age': 36 });
                     * // => false
                     */
                function every(collection, callback, thisArg) {
                    var result = true;
                    callback = lodash.createCallback(callback, thisArg, 3);

                    var index = - 1,
                    length = collection ? collection.length : 0;

                    if (typeof length == 'number') {
                        while (++index < length) {
                            if (!(result = !!callback(collection[index], index, collection))) {
                                break;
                            }
                        }
                    } else {
                        forOwn(collection, function(value, index, collection) {
                            return (result = !!callback(value, index, collection));
                        });
                    }
                    return result;
                }

                /**
                     * Iterates over elements of a collection, returning an array of all elements
                     * the callback returns truey for. The callback is bound to `thisArg` and
                     * invoked with three arguments; (value, index|key, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias select
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns a new array of elements that passed the callback check.
                     * @example
                     *
                     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
                     * // => [2, 4, 6]
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36, 'blocked': false },
                     *   { 'name': 'fred',   'age': 40, 'blocked': true }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.filter(characters, 'blocked');
                     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
                     *
                     * // using "_.where" callback shorthand
                     * _.filter(characters, { 'age': 36 });
                     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
                     */
                function filter(collection, callback, thisArg) {
                    var result = [];
                    callback = lodash.createCallback(callback, thisArg, 3);

                    var index = - 1,
                    length = collection ? collection.length : 0;

                    if (typeof length == 'number') {
                        while (++index < length) {
                            var value = collection[index];
                            if (callback(value, index, collection)) {
                                result.push(value);
                            }
                        }
                    } else {
                        forOwn(collection, function(value, index, collection) {
                            if (callback(value, index, collection)) {
                                result.push(value);
                            }
                        });
                    }
                    return result;
                }

                /**
                     * Iterates over elements of a collection, returning the first element that
                     * the callback returns truey for. The callback is bound to `thisArg` and
                     * invoked with three arguments; (value, index|key, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias detect, findWhere
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the found element, else `undefined`.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'barney',  'age': 36, 'blocked': false },
                     *   { 'name': 'fred',    'age': 40, 'blocked': true },
                     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
                     * ];
                     *
                     * _.find(characters, function(chr) {
                     *   return chr.age < 40;
                     * });
                     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
                     *
                     * // using "_.where" callback shorthand
                     * _.find(characters, { 'age': 1 });
                     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
                     *
                     * // using "_.pluck" callback shorthand
                     * _.find(characters, 'blocked');
                     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
                     */
                function find(collection, callback, thisArg) {
                    callback = lodash.createCallback(callback, thisArg, 3);

                    var index = - 1,
                    length = collection ? collection.length : 0;

                    if (typeof length == 'number') {
                        while (++index < length) {
                            var value = collection[index];
                            if (callback(value, index, collection)) {
                                return value;
                            }
                        }
                    } else {
                        var result;
                        forOwn(collection, function(value, index, collection) {
                            if (callback(value, index, collection)) {
                                result = value;
                                return false;
                            }
                        });
                        return result;
                    }
                }

                /**
                     * This method is like `_.find` except that it iterates over elements
                     * of a `collection` from right to left.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the found element, else `undefined`.
                     * @example
                     *
                     * _.findLast([1, 2, 3, 4], function(num) {
                     *   return num % 2 == 1;
                     * });
                     * // => 3
                     */
                function findLast(collection, callback, thisArg) {
                    var result;
                    callback = lodash.createCallback(callback, thisArg, 3);
                    forEachRight(collection, function(value, index, collection) {
                        if (callback(value, index, collection)) {
                            result = value;
                            return false;
                        }
                    });
                    return result;
                }

                /**
                     * Iterates over elements of a collection, executing the callback for each
                     * element. The callback is bound to `thisArg` and invoked with three arguments;
                     * (value, index|key, collection). Callbacks may exit iteration early by
                     * explicitly returning `false`.
                     *
                     * Note: As with other "Collections" methods, objects with a `length` property
                     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
                     * may be used for object iteration.
                     *
                     * @static
                     * @memberOf _
                     * @alias each
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} [callback=identity] The function called per iteration.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array|Object|string} Returns `collection`.
                     * @example
                     *
                     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
                     * // => logs each number and returns '1,2,3'
                     *
                     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
                     * // => logs each number and returns the object (property order is not guaranteed across environments)
                     */
                function forEach(collection, callback, thisArg) {
                    var index = - 1,
                    length = collection ? collection.length : 0;

                    callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
                    if (typeof length == 'number') {
                        while (++index < length) {
                            if (callback(collection[index], index, collection) === false) {
                                break;
                            }
                        }
                    } else {
                        forOwn(collection, callback);
                    }
                    return collection;
                }

                /**
                     * This method is like `_.forEach` except that it iterates over elements
                     * of a `collection` from right to left.
                     *
                     * @static
                     * @memberOf _
                     * @alias eachRight
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} [callback=identity] The function called per iteration.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array|Object|string} Returns `collection`.
                     * @example
                     *
                     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
                     * // => logs each number from right to left and returns '3,2,1'
                     */
                function forEachRight(collection, callback, thisArg) {
                    var length = collection ? collection.length : 0;
                    callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
                    if (typeof length == 'number') {
                        while (length--) {
                            if (callback(collection[length], length, collection) === false) {
                                break;
                            }
                        }
                    } else {
                        var props = keys(collection);
                        length = props.length;
                        forOwn(collection, function(value, key, collection) {
                            key = props ? props[--length] : --length;
                            return callback(collection[key], key, collection);
                        });
                    }
                    return collection;
                }

                /**
                     * Creates an object composed of keys generated from the results of running
                     * each element of a collection through the callback. The corresponding value
                     * of each key is an array of the elements responsible for generating the key.
                     * The callback is bound to `thisArg` and invoked with three arguments;
                     * (value, index|key, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns the composed aggregate object.
                     * @example
                     *
                     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
                     * // => { '4': [4.2], '6': [6.1, 6.4] }
                     *
                     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
                     * // => { '4': [4.2], '6': [6.1, 6.4] }
                     *
                     * // using "_.pluck" callback shorthand
                     * _.groupBy(['one', 'two', 'three'], 'length');
                     * // => { '3': ['one', 'two'], '5': ['three'] }
                     */
                var groupBy = createAggregator(function(result, value, key) {
                    (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
                });

                /**
                     * Creates an object composed of keys generated from the results of running
                     * each element of the collection through the given callback. The corresponding
                     * value of each key is the last element responsible for generating the key.
                     * The callback is bound to `thisArg` and invoked with three arguments;
                     * (value, index|key, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns the composed aggregate object.
                     * @example
                     *
                     * var keys = [
                     *   { 'dir': 'left', 'code': 97 },
                     *   { 'dir': 'right', 'code': 100 }
                     * ];
                     *
                     * _.indexBy(keys, 'dir');
                     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
                     *
                     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
                     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
                     *
                     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
                     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
                     */
                var indexBy = createAggregator(function(result, value, key) {
                    result[key] = value;
                });

                /**
                     * Invokes the method named by `methodName` on each element in the `collection`
                     * returning an array of the results of each invoked method. Additional arguments
                     * will be provided to each invoked method. If `methodName` is a function it
                     * will be invoked for, and `this` bound to, each element in the `collection`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|string} methodName The name of the method to invoke or
                     *  the function invoked per iteration.
                     * @param {...*} [arg] Arguments to invoke the method with.
                     * @returns {Array} Returns a new array of the results of each invoked method.
                     * @example
                     *
                     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
                     * // => [[1, 5, 7], [1, 2, 3]]
                     *
                     * _.invoke([123, 456], String.prototype.split, '');
                     * // => [['1', '2', '3'], ['4', '5', '6']]
                     */
                function invoke(collection, methodName) {
                    var args = slice(arguments, 2),
                    index = - 1,
                    isFunc = typeof methodName == 'function',
                    length = collection ? collection.length : 0,
                    result = Array(typeof length == 'number' ? length : 0);

                    forEach(collection, function(value) {
                        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
                    });
                    return result;
                }

                /**
                     * Creates an array of values by running each element in the collection
                     * through the callback. The callback is bound to `thisArg` and invoked with
                     * three arguments; (value, index|key, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias collect
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns a new array of the results of each `callback` execution.
                     * @example
                     *
                     * _.map([1, 2, 3], function(num) { return num * 3; });
                     * // => [3, 6, 9]
                     *
                     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
                     * // => [3, 6, 9] (property order is not guaranteed across environments)
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36 },
                     *   { 'name': 'fred',   'age': 40 }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.map(characters, 'name');
                     * // => ['barney', 'fred']
                     */
                function map(collection, callback, thisArg) {
                    var index = - 1,
                    length = collection ? collection.length : 0;

                    callback = lodash.createCallback(callback, thisArg, 3);
                    if (typeof length == 'number') {
                        var result = Array(length);
                        while (++index < length) {
                            result[index] = callback(collection[index], index, collection);
                        }
                    } else {
                        result = [];
                        forOwn(collection, function(value, key, collection) {
                            result[++index] = callback(value, key, collection);
                        });
                    }
                    return result;
                }

                /**
                     * Retrieves the maximum value of a collection. If the collection is empty or
                     * falsey `-Infinity` is returned. If a callback is provided it will be executed
                     * for each value in the collection to generate the criterion by which the value
                     * is ranked. The callback is bound to `thisArg` and invoked with three
                     * arguments; (value, index, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the maximum value.
                     * @example
                     *
                     * _.max([4, 2, 8, 6]);
                     * // => 8
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36 },
                     *   { 'name': 'fred',   'age': 40 }
                     * ];
                     *
                     * _.max(characters, function(chr) { return chr.age; });
                     * // => { 'name': 'fred', 'age': 40 };
                     *
                     * // using "_.pluck" callback shorthand
                     * _.max(characters, 'age');
                     * // => { 'name': 'fred', 'age': 40 };
                     */
                function max(collection, callback, thisArg) {
                    var computed = - Infinity,
                    result = computed;

                    // allows working with functions like `_.map` without using
                    // their `index` argument as a callback
                    if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
                        callback = null;
                    }
                    if (callback == null && isArray(collection)) {
                        var index = - 1,
                        length = collection.length;

                        while (++index < length) {
                            var value = collection[index];
                            if (value > result) {
                                result = value;
                            }
                        }
                    } else {
                        callback = (callback == null && isString(collection))
                        ? charAtCallback
                        : lodash.createCallback(callback, thisArg, 3);

                        forEach(collection, function(value, index, collection) {
                            var current = callback(value, index, collection);
                            if (current > computed) {
                                computed = current;
                                result = value;
                            }
                        });
                    }
                    return result;
                }

                /**
                     * Retrieves the minimum value of a collection. If the collection is empty or
                     * falsey `Infinity` is returned. If a callback is provided it will be executed
                     * for each value in the collection to generate the criterion by which the value
                     * is ranked. The callback is bound to `thisArg` and invoked with three
                     * arguments; (value, index, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the minimum value.
                     * @example
                     *
                     * _.min([4, 2, 8, 6]);
                     * // => 2
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36 },
                     *   { 'name': 'fred',   'age': 40 }
                     * ];
                     *
                     * _.min(characters, function(chr) { return chr.age; });
                     * // => { 'name': 'barney', 'age': 36 };
                     *
                     * // using "_.pluck" callback shorthand
                     * _.min(characters, 'age');
                     * // => { 'name': 'barney', 'age': 36 };
                     */
                function min(collection, callback, thisArg) {
                    var computed = Infinity,
                    result = computed;

                    // allows working with functions like `_.map` without using
                    // their `index` argument as a callback
                    if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
                        callback = null;
                    }
                    if (callback == null && isArray(collection)) {
                        var index = - 1,
                        length = collection.length;

                        while (++index < length) {
                            var value = collection[index];
                            if (value < result) {
                                result = value;
                            }
                        }
                    } else {
                        callback = (callback == null && isString(collection))
                        ? charAtCallback
                        : lodash.createCallback(callback, thisArg, 3);

                        forEach(collection, function(value, index, collection) {
                            var current = callback(value, index, collection);
                            if (current < computed) {
                                computed = current;
                                result = value;
                            }
                        });
                    }
                    return result;
                }

                /**
                     * Retrieves the value of a specified property from all elements in the collection.
                     *
                     * @static
                     * @memberOf _
                     * @type Function
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {string} property The name of the property to pluck.
                     * @returns {Array} Returns a new array of property values.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36 },
                     *   { 'name': 'fred',   'age': 40 }
                     * ];
                     *
                     * _.pluck(characters, 'name');
                     * // => ['barney', 'fred']
                     */
                var pluck = map;

                /**
                     * Reduces a collection to a value which is the accumulated result of running
                     * each element in the collection through the callback, where each successive
                     * callback execution consumes the return value of the previous execution. If
                     * `accumulator` is not provided the first element of the collection will be
                     * used as the initial `accumulator` value. The callback is bound to `thisArg`
                     * and invoked with four arguments; (accumulator, value, index|key, collection).
                     *
                     * @static
                     * @memberOf _
                     * @alias foldl, inject
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} [callback=identity] The function called per iteration.
                     * @param {*} [accumulator] Initial value of the accumulator.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the accumulated value.
                     * @example
                     *
                     * var sum = _.reduce([1, 2, 3], function(sum, num) {
                     *   return sum + num;
                     * });
                     * // => 6
                     *
                     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
                     *   result[key] = num * 3;
                     *   return result;
                     * }, {});
                     * // => { 'a': 3, 'b': 6, 'c': 9 }
                     */
                function reduce(collection, callback, accumulator, thisArg) {
                    if (!collection) 
                        return accumulator;
                    var noaccum = arguments.length < 3;
                    callback = lodash.createCallback(callback, thisArg, 4);

                    var index = - 1,
                    length = collection.length;

                    if (typeof length == 'number') {
                        if (noaccum) {
                            accumulator = collection[++index];
                        }
                        while (++index < length) {
                            accumulator = callback(accumulator, collection[index], index, collection);
                        }
                    } else {
                        forOwn(collection, function(value, index, collection) {
                            accumulator = noaccum
                            ? (noaccum = false, value)
                            : callback(accumulator, value, index, collection)
                        });
                    }
                    return accumulator;
                }

                /**
                     * This method is like `_.reduce` except that it iterates over elements
                     * of a `collection` from right to left.
                     *
                     * @static
                     * @memberOf _
                     * @alias foldr
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} [callback=identity] The function called per iteration.
                     * @param {*} [accumulator] Initial value of the accumulator.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the accumulated value.
                     * @example
                     *
                     * var list = [[0, 1], [2, 3], [4, 5]];
                     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
                     * // => [4, 5, 2, 3, 0, 1]
                     */
                function reduceRight(collection, callback, accumulator, thisArg) {
                    var noaccum = arguments.length < 3;
                    callback = lodash.createCallback(callback, thisArg, 4);
                    forEachRight(collection, function(value, index, collection) {
                        accumulator = noaccum
                        ? (noaccum = false, value)
                        : callback(accumulator, value, index, collection);
                    });
                    return accumulator;
                }

                /**
                     * The opposite of `_.filter` this method returns the elements of a
                     * collection that the callback does **not** return truey for.
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns a new array of elements that failed the callback check.
                     * @example
                     *
                     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
                     * // => [1, 3, 5]
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36, 'blocked': false },
                     *   { 'name': 'fred',   'age': 40, 'blocked': true }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.reject(characters, 'blocked');
                     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
                     *
                     * // using "_.where" callback shorthand
                     * _.reject(characters, { 'age': 36 });
                     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
                     */
                function reject(collection, callback, thisArg) {
                    callback = lodash.createCallback(callback, thisArg, 3);
                    return filter(collection, function(value, index, collection) {
                        return !callback(value, index, collection);
                    });
                }

                /**
                     * Retrieves a random element or `n` random elements from a collection.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to sample.
                     * @param {number} [n] The number of elements to sample.
                     * @param- {Object} [guard] Allows working with functions like `_.map`
                     *  without using their `index` arguments as `n`.
                     * @returns {Array} Returns the random sample(s) of `collection`.
                     * @example
                     *
                     * _.sample([1, 2, 3, 4]);
                     * // => 2
                     *
                     * _.sample([1, 2, 3, 4], 2);
                     * // => [3, 1]
                     */
                function sample(collection, n, guard) {
                    if (collection && typeof collection.length != 'number') {
                        collection = values(collection);
                    }
                    if (n == null || guard) {
                        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
                    }
                    var result = shuffle(collection);
                    result.length = nativeMin(nativeMax(0, n), result.length);
                    return result;
                }

                /**
                     * Creates an array of shuffled values, using a version of the Fisher-Yates
                     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to shuffle.
                     * @returns {Array} Returns a new shuffled collection.
                     * @example
                     *
                     * _.shuffle([1, 2, 3, 4, 5, 6]);
                     * // => [4, 1, 6, 3, 5, 2]
                     */
                function shuffle(collection) {
                    var index = - 1,
                    length = collection ? collection.length : 0,
                    result = Array(typeof length == 'number' ? length : 0);

                    forEach(collection, function(value) {
                        var rand = baseRandom(0, ++index);
                        result[index] = result[rand];
                        result[rand] = value;
                    });
                    return result;
                }

                /**
                     * Gets the size of the `collection` by returning `collection.length` for arrays
                     * and array-like objects or the number of own enumerable properties for objects.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to inspect.
                     * @returns {number} Returns `collection.length` or number of own enumerable properties.
                     * @example
                     *
                     * _.size([1, 2]);
                     * // => 2
                     *
                     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
                     * // => 3
                     *
                     * _.size('pebbles');
                     * // => 7
                     */
                function size(collection) {
                    var length = collection ? collection.length : 0;
                    return typeof length == 'number' ? length : keys(collection).length;
                }

                /**
                     * Checks if the callback returns a truey value for **any** element of a
                     * collection. The function returns as soon as it finds a passing value and
                     * does not iterate over the entire collection. The callback is bound to
                     * `thisArg` and invoked with three arguments; (value, index|key, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias any
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {boolean} Returns `true` if any element passed the callback check,
                     *  else `false`.
                     * @example
                     *
                     * _.some([null, 0, 'yes', false], Boolean);
                     * // => true
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36, 'blocked': false },
                     *   { 'name': 'fred',   'age': 40, 'blocked': true }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.some(characters, 'blocked');
                     * // => true
                     *
                     * // using "_.where" callback shorthand
                     * _.some(characters, { 'age': 1 });
                     * // => false
                     */
                function some(collection, callback, thisArg) {
                    var result;
                    callback = lodash.createCallback(callback, thisArg, 3);

                    var index = - 1,
                    length = collection ? collection.length : 0;

                    if (typeof length == 'number') {
                        while (++index < length) {
                            if ((result = callback(collection[index], index, collection))) {
                                break;
                            }
                        }
                    } else {
                        forOwn(collection, function(value, index, collection) {
                            return !(result = callback(value, index, collection));
                        });
                    }
                    return !!result;
                }

                /**
                     * Creates an array of elements, sorted in ascending order by the results of
                     * running each element in a collection through the callback. This method
                     * performs a stable sort, that is, it will preserve the original sort order
                     * of equal elements. The callback is bound to `thisArg` and invoked with
                     * three arguments; (value, index|key, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an array of property names is provided for `callback` the collection
                     * will be sorted by each property value.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Array|Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns a new array of sorted elements.
                     * @example
                     *
                     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
                     * // => [3, 1, 2]
                     *
                     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
                     * // => [3, 1, 2]
                     *
                     * var characters = [
                     *   { 'name': 'barney',  'age': 36 },
                     *   { 'name': 'fred',    'age': 40 },
                     *   { 'name': 'barney',  'age': 26 },
                     *   { 'name': 'fred',    'age': 30 }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.map(_.sortBy(characters, 'age'), _.values);
                     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
                     *
                     * // sorting by multiple properties
                     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
                     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
                     */
                function sortBy(collection, callback, thisArg) {
                    var index = - 1,
                    isArr = isArray(callback),
                    length = collection ? collection.length : 0,
                    result = Array(typeof length == 'number' ? length : 0);

                    if (!isArr) {
                        callback = lodash.createCallback(callback, thisArg, 3);
                    }
                    forEach(collection, function(value, key, collection) {
                        var object = result[++index] = getObject();
                        if (isArr) {
                            object.criteria = map(callback, function(key) {
                                return value[key];
                            });
                        } else {
                            (object.criteria = getArray())[0] = callback(value, key, collection);
                        }
                        object.index = index;
                        object.value = value;
                    });

                    length = result.length;
                    result.sort(compareAscending);
                    while (length--) {
                        var object = result[length];
                        result[length] = object.value;
                        if (!isArr) {
                            releaseArray(object.criteria);
                        }
                        releaseObject(object);
                    }
                    return result;
                }

                /**
                     * Converts the `collection` to an array.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to convert.
                     * @returns {Array} Returns the new converted array.
                     * @example
                     *
                     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
                     * // => [2, 3, 4]
                     */
                function toArray(collection) {
                    if (collection && typeof collection.length == 'number') {
                        return slice(collection);
                    }
                    return values(collection);
                }

                /**
                     * Performs a deep comparison of each element in a `collection` to the given
                     * `properties` object, returning an array of all elements that have equivalent
                     * property values.
                     *
                     * @static
                     * @memberOf _
                     * @type Function
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Object} props The object of property values to filter by.
                     * @returns {Array} Returns a new array of elements that have the given properties.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
                     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
                     * ];
                     *
                     * _.where(characters, { 'age': 36 });
                     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
                     *
                     * _.where(characters, { 'pets': ['dino'] });
                     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
                     */
                var where = filter;

                /*--------------------------------------------------------------------------*/

                /**
                     * Creates an array with all falsey values removed. The values `false`, `null`,
                     * `0`, `""`, `undefined`, and `NaN` are all falsey.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to compact.
                     * @returns {Array} Returns a new array of filtered values.
                     * @example
                     *
                     * _.compact([0, 1, false, 2, '', 3]);
                     * // => [1, 2, 3]
                     */
                function compact(array) {
                    var index = - 1,
                    length = array ? array.length : 0,
                    result = [];

                    while (++index < length) {
                        var value = array[index];
                        if (value) {
                            result.push(value);
                        }
                    }
                    return result;
                }

                /**
                     * Creates an array excluding all values of the provided arrays using strict
                     * equality for comparisons, i.e. `===`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to process.
                     * @param {...Array} [values] The arrays of values to exclude.
                     * @returns {Array} Returns a new array of filtered values.
                     * @example
                     *
                     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
                     * // => [1, 3, 4]
                     */
                function difference(array) {
                    return baseDifference(array, baseFlatten(arguments, true, true, 1));
                }

                /**
                     * This method is like `_.find` except that it returns the index of the first
                     * element that passes the callback check, instead of the element itself.
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to search.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {number} Returns the index of the found element, else `-1`.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'barney',  'age': 36, 'blocked': false },
                     *   { 'name': 'fred',    'age': 40, 'blocked': true },
                     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
                     * ];
                     *
                     * _.findIndex(characters, function(chr) {
                     *   return chr.age < 20;
                     * });
                     * // => 2
                     *
                     * // using "_.where" callback shorthand
                     * _.findIndex(characters, { 'age': 36 });
                     * // => 0
                     *
                     * // using "_.pluck" callback shorthand
                     * _.findIndex(characters, 'blocked');
                     * // => 1
                     */
                function findIndex(array, callback, thisArg) {
                    var index = - 1,
                    length = array ? array.length : 0;

                    callback = lodash.createCallback(callback, thisArg, 3);
                    while (++index < length) {
                        if (callback(array[index], index, array)) {
                            return index;
                        }
                    }
                    return - 1;
                }

                /**
                     * This method is like `_.findIndex` except that it iterates over elements
                     * of a `collection` from right to left.
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to search.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {number} Returns the index of the found element, else `-1`.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'barney',  'age': 36, 'blocked': true },
                     *   { 'name': 'fred',    'age': 40, 'blocked': false },
                     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
                     * ];
                     *
                     * _.findLastIndex(characters, function(chr) {
                     *   return chr.age > 30;
                     * });
                     * // => 1
                     *
                     * // using "_.where" callback shorthand
                     * _.findLastIndex(characters, { 'age': 36 });
                     * // => 0
                     *
                     * // using "_.pluck" callback shorthand
                     * _.findLastIndex(characters, 'blocked');
                     * // => 2
                     */
                function findLastIndex(array, callback, thisArg) {
                    var length = array ? array.length : 0;
                    callback = lodash.createCallback(callback, thisArg, 3);
                    while (length--) {
                        if (callback(array[length], length, array)) {
                            return length;
                        }
                    }
                    return - 1;
                }

                /**
                     * Gets the first element or first `n` elements of an array. If a callback
                     * is provided elements at the beginning of the array are returned as long
                     * as the callback returns truey. The callback is bound to `thisArg` and
                     * invoked with three arguments; (value, index, array).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias head, take
                     * @category Arrays
                     * @param {Array} array The array to query.
                     * @param {Function|Object|number|string} [callback] The function called
                     *  per element or the number of elements to return. If a property name or
                     *  object is provided it will be used to create a "_.pluck" or "_.where"
                     *  style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the first element(s) of `array`.
                     * @example
                     *
                     * _.first([1, 2, 3]);
                     * // => 1
                     *
                     * _.first([1, 2, 3], 2);
                     * // => [1, 2]
                     *
                     * _.first([1, 2, 3], function(num) {
                     *   return num < 3;
                     * });
                     * // => [1, 2]
                     *
                     * var characters = [
                     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
                     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
                     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.first(characters, 'blocked');
                     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
                     *
                     * // using "_.where" callback shorthand
                     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
                     * // => ['barney', 'fred']
                     */
                function first(array, callback, thisArg) {
                    var n = 0,
                    length = array ? array.length : 0;

                    if (typeof callback != 'number' && callback != null) {
                        var index = - 1;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (++index < length && callback(array[index], index, array)) {
                            n++;
                        }
                    } else {
                        n = callback;
                        if (n == null || thisArg) {
                            return array ? array[0] : undefined;
                        }
                    }
                    return slice(array, 0, nativeMin(nativeMax(0, n), length));
                }

                /**
                     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
                     * is truey, the array will only be flattened a single level. If a callback
                     * is provided each element of the array is passed through the callback before
                     * flattening. The callback is bound to `thisArg` and invoked with three
                     * arguments; (value, index, array).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to flatten.
                     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns a new flattened array.
                     * @example
                     *
                     * _.flatten([1, [2], [3, [[4]]]]);
                     * // => [1, 2, 3, 4];
                     *
                     * _.flatten([1, [2], [3, [[4]]]], true);
                     * // => [1, 2, 3, [[4]]];
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
                     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.flatten(characters, 'pets');
                     * // => ['hoppy', 'baby puss', 'dino']
                     */
                function flatten(array, isShallow, callback, thisArg) {
                    // juggle arguments
                    if (typeof isShallow != 'boolean' && isShallow != null) {
                        thisArg = callback;
                        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
                        isShallow = false;
                    }
                    if (callback != null) {
                        array = map(array, callback, thisArg);
                    }
                    return baseFlatten(array, isShallow);
                }

                /**
                     * Gets the index at which the first occurrence of `value` is found using
                     * strict equality for comparisons, i.e. `===`. If the array is already sorted
                     * providing `true` for `fromIndex` will run a faster binary search.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to search.
                     * @param {*} value The value to search for.
                     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
                     *  to perform a binary search on a sorted array.
                     * @returns {number} Returns the index of the matched value or `-1`.
                     * @example
                     *
                     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
                     * // => 1
                     *
                     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
                     * // => 4
                     *
                     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
                     * // => 2
                     */
                function indexOf(array, value, fromIndex) {
                    if (typeof fromIndex == 'number') {
                        var length = array ? array.length : 0;
                        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
                    } else if (fromIndex) {
                        var index = sortedIndex(array, value);
                        return array[index] === value ? index : - 1;
                    }
                    return baseIndexOf(array, value, fromIndex);
                }

                /**
                     * Gets all but the last element or last `n` elements of an array. If a
                     * callback is provided elements at the end of the array are excluded from
                     * the result as long as the callback returns truey. The callback is bound
                     * to `thisArg` and invoked with three arguments; (value, index, array).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to query.
                     * @param {Function|Object|number|string} [callback=1] The function called
                     *  per element or the number of elements to exclude. If a property name or
                     *  object is provided it will be used to create a "_.pluck" or "_.where"
                     *  style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns a slice of `array`.
                     * @example
                     *
                     * _.initial([1, 2, 3]);
                     * // => [1, 2]
                     *
                     * _.initial([1, 2, 3], 2);
                     * // => [1]
                     *
                     * _.initial([1, 2, 3], function(num) {
                     *   return num > 1;
                     * });
                     * // => [1]
                     *
                     * var characters = [
                     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
                     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
                     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.initial(characters, 'blocked');
                     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
                     *
                     * // using "_.where" callback shorthand
                     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
                     * // => ['barney', 'fred']
                     */
                function initial(array, callback, thisArg) {
                    var n = 0,
                    length = array ? array.length : 0;

                    if (typeof callback != 'number' && callback != null) {
                        var index = length;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (index-- && callback(array[index], index, array)) {
                            n++;
                        }
                    } else {
                        n = (callback == null || thisArg) ? 1 : callback || n;
                    }
                    return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
                }

                /**
                     * Creates an array of unique values present in all provided arrays using
                     * strict equality for comparisons, i.e. `===`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {...Array} [array] The arrays to inspect.
                     * @returns {Array} Returns an array of shared values.
                     * @example
                     *
                     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
                     * // => [1, 2]
                     */
                function intersection() {
                    var args = [],
                    argsIndex = - 1,
                    argsLength = arguments.length,
                    caches = getArray(),
                    indexOf = getIndexOf(),
                    trustIndexOf = indexOf === baseIndexOf,
                    seen = getArray();

                    while (++argsIndex < argsLength) {
                        var value = arguments[argsIndex];
                        if (isArray(value) || isArguments(value)) {
                            args.push(value);
                            caches.push(trustIndexOf && value.length >= largeArraySize &&
                            createCache(argsIndex ? args[argsIndex] : seen));
                        }
                    }
                    var array = args[0],
                    index = - 1,
                    length = array ? array.length : 0,
                    result = [];

                    outer:
                    while (++index < length) {
                        var cache = caches[0];
                        value = array[index];

                        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
                            argsIndex = argsLength;
                            (cache || seen).push(value);
                            while (--argsIndex) {
                                cache = caches[argsIndex];
                                if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
                                    continue outer;
                                }
                            }
                            result.push(value);
                        }
                    }
                    while (argsLength--) {
                        cache = caches[argsLength];
                        if (cache) {
                            releaseObject(cache);
                        }
                    }
                    releaseArray(caches);
                    releaseArray(seen);
                    return result;
                }

                /**
                     * Gets the last element or last `n` elements of an array. If a callback is
                     * provided elements at the end of the array are returned as long as the
                     * callback returns truey. The callback is bound to `thisArg` and invoked
                     * with three arguments; (value, index, array).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to query.
                     * @param {Function|Object|number|string} [callback] The function called
                     *  per element or the number of elements to return. If a property name or
                     *  object is provided it will be used to create a "_.pluck" or "_.where"
                     *  style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the last element(s) of `array`.
                     * @example
                     *
                     * _.last([1, 2, 3]);
                     * // => 3
                     *
                     * _.last([1, 2, 3], 2);
                     * // => [2, 3]
                     *
                     * _.last([1, 2, 3], function(num) {
                     *   return num > 1;
                     * });
                     * // => [2, 3]
                     *
                     * var characters = [
                     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
                     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
                     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.pluck(_.last(characters, 'blocked'), 'name');
                     * // => ['fred', 'pebbles']
                     *
                     * // using "_.where" callback shorthand
                     * _.last(characters, { 'employer': 'na' });
                     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
                     */
                function last(array, callback, thisArg) {
                    var n = 0,
                    length = array ? array.length : 0;

                    if (typeof callback != 'number' && callback != null) {
                        var index = length;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (index-- && callback(array[index], index, array)) {
                            n++;
                        }
                    } else {
                        n = callback;
                        if (n == null || thisArg) {
                            return array ? array[length - 1] : undefined;
                        }
                    }
                    return slice(array, nativeMax(0, length - n));
                }

                /**
                     * Gets the index at which the last occurrence of `value` is found using strict
                     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
                     * as the offset from the end of the collection.
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to search.
                     * @param {*} value The value to search for.
                     * @param {number} [fromIndex=array.length-1] The index to search from.
                     * @returns {number} Returns the index of the matched value or `-1`.
                     * @example
                     *
                     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
                     * // => 4
                     *
                     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
                     * // => 1
                     */
                function lastIndexOf(array, value, fromIndex) {
                    var index = array ? array.length : 0;
                    if (typeof fromIndex == 'number') {
                        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
                    }
                    while (index--) {
                        if (array[index] === value) {
                            return index;
                        }
                    }
                    return - 1;
                }

                /**
                     * Removes all provided values from the given array using strict equality for
                     * comparisons, i.e. `===`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to modify.
                     * @param {...*} [value] The values to remove.
                     * @returns {Array} Returns `array`.
                     * @example
                     *
                     * var array = [1, 2, 3, 1, 2, 3];
                     * _.pull(array, 2, 3);
                     * console.log(array);
                     * // => [1, 1]
                     */
                function pull(array) {
                    var args = arguments,
                    argsIndex = 0,
                    argsLength = args.length,
                    length = array ? array.length : 0;

                    while (++argsIndex < argsLength) {
                        var index = - 1,
                        value = args[argsIndex];
                        while (++index < length) {
                            if (array[index] === value) {
                                splice.call(array, index--, 1);
                                length--;
                            }
                        }
                    }
                    return array;
                }

                /**
                     * Creates an array of numbers (positive and/or negative) progressing from
                     * `start` up to but not including `end`. If `start` is less than `stop` a
                     * zero-length range is created unless a negative `step` is specified.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {number} [start=0] The start of the range.
                     * @param {number} end The end of the range.
                     * @param {number} [step=1] The value to increment or decrement by.
                     * @returns {Array} Returns a new range array.
                     * @example
                     *
                     * _.range(4);
                     * // => [0, 1, 2, 3]
                     *
                     * _.range(1, 5);
                     * // => [1, 2, 3, 4]
                     *
                     * _.range(0, 20, 5);
                     * // => [0, 5, 10, 15]
                     *
                     * _.range(0, -4, -1);
                     * // => [0, -1, -2, -3]
                     *
                     * _.range(1, 4, 0);
                     * // => [1, 1, 1]
                     *
                     * _.range(0);
                     * // => []
                     */
                function range(start, end, step) {
                    start = + start || 0;
                    step = typeof step == 'number' ? step : ( + step || 1);

                    if (end == null) {
                        end = start;
                        start = 0;
                    }
                    // use `Array(length)` so engines like Chakra and V8 avoid slower modes
                    // http://youtu.be/XAqIpGU8ZZk#t=17m25s
                    var index = - 1,
                    length = nativeMax(0, ceil((end - start) / (step || 1))),
                    result = Array(length);

                    while (++index < length) {
                        result[index] = start;
                        start += step;
                    }
                    return result;
                }

                /**
                     * Removes all elements from an array that the callback returns truey for
                     * and returns an array of removed elements. The callback is bound to `thisArg`
                     * and invoked with three arguments; (value, index, array).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to modify.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns a new array of removed elements.
                     * @example
                     *
                     * var array = [1, 2, 3, 4, 5, 6];
                     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
                     *
                     * console.log(array);
                     * // => [1, 3, 5]
                     *
                     * console.log(evens);
                     * // => [2, 4, 6]
                     */
                function remove(array, callback, thisArg) {
                    var index = - 1,
                    length = array ? array.length : 0,
                    result = [];

                    callback = lodash.createCallback(callback, thisArg, 3);
                    while (++index < length) {
                        var value = array[index];
                        if (callback(value, index, array)) {
                            result.push(value);
                            splice.call(array, index--, 1);
                            length--;
                        }
                    }
                    return result;
                }

                /**
                     * The opposite of `_.initial` this method gets all but the first element or
                     * first `n` elements of an array. If a callback function is provided elements
                     * at the beginning of the array are excluded from the result as long as the
                     * callback returns truey. The callback is bound to `thisArg` and invoked
                     * with three arguments; (value, index, array).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias drop, tail
                     * @category Arrays
                     * @param {Array} array The array to query.
                     * @param {Function|Object|number|string} [callback=1] The function called
                     *  per element or the number of elements to exclude. If a property name or
                     *  object is provided it will be used to create a "_.pluck" or "_.where"
                     *  style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns a slice of `array`.
                     * @example
                     *
                     * _.rest([1, 2, 3]);
                     * // => [2, 3]
                     *
                     * _.rest([1, 2, 3], 2);
                     * // => [3]
                     *
                     * _.rest([1, 2, 3], function(num) {
                     *   return num < 3;
                     * });
                     * // => [3]
                     *
                     * var characters = [
                     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
                     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
                     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.pluck(_.rest(characters, 'blocked'), 'name');
                     * // => ['fred', 'pebbles']
                     *
                     * // using "_.where" callback shorthand
                     * _.rest(characters, { 'employer': 'slate' });
                     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
                     */
                function rest(array, callback, thisArg) {
                    if (typeof callback != 'number' && callback != null) {
                        var n = 0,
                        index = - 1,
                        length = array ? array.length : 0;

                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (++index < length && callback(array[index], index, array)) {
                            n++;
                        }
                    } else {
                        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
                    }
                    return slice(array, n);
                }

                /**
                     * Uses a binary search to determine the smallest index at which a value
                     * should be inserted into a given sorted array in order to maintain the sort
                     * order of the array. If a callback is provided it will be executed for
                     * `value` and each element of `array` to compute their sort ranking. The
                     * callback is bound to `thisArg` and invoked with one argument; (value).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to inspect.
                     * @param {*} value The value to evaluate.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {number} Returns the index at which `value` should be inserted
                     *  into `array`.
                     * @example
                     *
                     * _.sortedIndex([20, 30, 50], 40);
                     * // => 2
                     *
                     * // using "_.pluck" callback shorthand
                     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
                     * // => 2
                     *
                     * var dict = {
                     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
                     * };
                     *
                     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
                     *   return dict.wordToNumber[word];
                     * });
                     * // => 2
                     *
                     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
                     *   return this.wordToNumber[word];
                     * }, dict);
                     * // => 2
                     */
                function sortedIndex(array, value, callback, thisArg) {
                    var low = 0,
                    high = array ? array.length : low;

                    // explicitly reference `identity` for better inlining in Firefox
                    callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
                    value = callback(value);

                    while (low < high) {
                        var mid = (low + high) >>> 1;
                        (callback(array[mid]) < value)
                        ? low = mid + 1
                        : high = mid;
                    }
                    return low;
                }

                /**
                     * Creates an array of unique values, in order, of the provided arrays using
                     * strict equality for comparisons, i.e. `===`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {...Array} [array] The arrays to inspect.
                     * @returns {Array} Returns an array of combined values.
                     * @example
                     *
                     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
                     * // => [1, 2, 3, 5, 4]
                     */
                function union() {
                    return baseUniq(baseFlatten(arguments, true, true));
                }

                /**
                     * Creates a duplicate-value-free version of an array using strict equality
                     * for comparisons, i.e. `===`. If the array is sorted, providing
                     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
                     * each element of `array` is passed through the callback before uniqueness
                     * is computed. The callback is bound to `thisArg` and invoked with three
                     * arguments; (value, index, array).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias unique
                     * @category Arrays
                     * @param {Array} array The array to process.
                     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns a duplicate-value-free array.
                     * @example
                     *
                     * _.uniq([1, 2, 1, 3, 1]);
                     * // => [1, 2, 3]
                     *
                     * _.uniq([1, 1, 2, 2, 3], true);
                     * // => [1, 2, 3]
                     *
                     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
                     * // => ['A', 'b', 'C']
                     *
                     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
                     * // => [1, 2.5, 3]
                     *
                     * // using "_.pluck" callback shorthand
                     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
                     * // => [{ 'x': 1 }, { 'x': 2 }]
                     */
                function uniq(array, isSorted, callback, thisArg) {
                    // juggle arguments
                    if (typeof isSorted != 'boolean' && isSorted != null) {
                        thisArg = callback;
                        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
                        isSorted = false;
                    }
                    if (callback != null) {
                        callback = lodash.createCallback(callback, thisArg, 3);
                    }
                    return baseUniq(array, isSorted, callback);
                }

                /**
                     * Creates an array excluding all provided values using strict equality for
                     * comparisons, i.e. `===`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to filter.
                     * @param {...*} [value] The values to exclude.
                     * @returns {Array} Returns a new array of filtered values.
                     * @example
                     *
                     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
                     * // => [2, 3, 4]
                     */
                function without(array) {
                    return baseDifference(array, slice(arguments, 1));
                }

                /**
                     * Creates an array that is the symmetric difference of the provided arrays.
                     * See http://en.wikipedia.org/wiki/Symmetric_difference.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {...Array} [array] The arrays to inspect.
                     * @returns {Array} Returns an array of values.
                     * @example
                     *
                     * _.xor([1, 2, 3], [5, 2, 1, 4]);
                     * // => [3, 5, 4]
                     *
                     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
                     * // => [1, 4, 5]
                     */
                function xor() {
                    var index = - 1,
                    length = arguments.length;

                    while (++index < length) {
                        var array = arguments[index];
                        if (isArray(array) || isArguments(array)) {
                            var result = result
                            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
                            : array;
                        }
                    }
                    return result || [];
                }

                /**
                     * Creates an array of grouped elements, the first of which contains the first
                     * elements of the given arrays, the second of which contains the second
                     * elements of the given arrays, and so on.
                     *
                     * @static
                     * @memberOf _
                     * @alias unzip
                     * @category Arrays
                     * @param {...Array} [array] Arrays to process.
                     * @returns {Array} Returns a new array of grouped elements.
                     * @example
                     *
                     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
                     * // => [['fred', 30, true], ['barney', 40, false]]
                     */
                function zip() {
                    var array = arguments.length > 1 ? arguments : arguments[0],
                    index = - 1,
                    length = array ? max(pluck(array, 'length')) : 0,
                    result = Array(length < 0 ? 0 : length);

                    while (++index < length) {
                        result[index] = pluck(array, index);
                    }
                    return result;
                }

                /**
                     * Creates an object composed from arrays of `keys` and `values`. Provide
                     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
                     * or two arrays, one of `keys` and one of corresponding `values`.
                     *
                     * @static
                     * @memberOf _
                     * @alias object
                     * @category Arrays
                     * @param {Array} keys The array of keys.
                     * @param {Array} [values=[]] The array of values.
                     * @returns {Object} Returns an object composed of the given keys and
                     *  corresponding values.
                     * @example
                     *
                     * _.zipObject(['fred', 'barney'], [30, 40]);
                     * // => { 'fred': 30, 'barney': 40 }
                     */
                function zipObject(keys, values) {
                    var index = - 1,
                    length = keys ? keys.length : 0,
                    result = {};

                    if (!values && length && !isArray(keys[0])) {
                        values = [];
                    }
                    while (++index < length) {
                        var key = keys[index];
                        if (values) {
                            result[key] = values[index];
                        } else if (key) {
                            result[key[0]] = key[1];
                        }
                    }
                    return result;
                }

                /*--------------------------------------------------------------------------*/

                /**
                     * Creates a function that executes `func`, with  the `this` binding and
                     * arguments of the created function, only after being called `n` times.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {number} n The number of times the function must be called before
                     *  `func` is executed.
                     * @param {Function} func The function to restrict.
                     * @returns {Function} Returns the new restricted function.
                     * @example
                     *
                     * var saves = ['profile', 'settings'];
                     *
                     * var done = _.after(saves.length, function() {
                     *   console.log('Done saving!');
                     * });
                     *
                     * _.forEach(saves, function(type) {
                     *   asyncSave({ 'type': type, 'complete': done });
                     * });
                     * // => logs 'Done saving!', after all saves have completed
                     */
                function after(n, func) {
                    if (!isFunction(func)) {
                        throw new TypeError;
                    }
                    return function() {
                        if (--n < 1) {
                            return func.apply(this, arguments);
                        }
                    };
                }

                /**
                     * Creates a function that, when called, invokes `func` with the `this`
                     * binding of `thisArg` and prepends any additional `bind` arguments to those
                     * provided to the bound function.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Function} func The function to bind.
                     * @param {*} [thisArg] The `this` binding of `func`.
                     * @param {...*} [arg] Arguments to be partially applied.
                     * @returns {Function} Returns the new bound function.
                     * @example
                     *
                     * var func = function(greeting) {
                     *   return greeting + ' ' + this.name;
                     * };
                     *
                     * func = _.bind(func, { 'name': 'fred' }, 'hi');
                     * func();
                     * // => 'hi fred'
                     */
                function bind(func, thisArg) {
                    return arguments.length > 2
                    ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
                    : createWrapper(func, 1, null, null, thisArg);
                }

                /**
                     * Binds methods of an object to the object itself, overwriting the existing
                     * method. Method names may be specified as individual arguments or as arrays
                     * of method names. If no method names are provided all the function properties
                     * of `object` will be bound.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Object} object The object to bind and assign the bound methods to.
                     * @param {...string} [methodName] The object method names to
                     *  bind, specified as individual method names or arrays of method names.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * var view = {
                     *   'label': 'docs',
                     *   'onClick': function() { console.log('clicked ' + this.label); }
                     * };
                     *
                     * _.bindAll(view);
                     * jQuery('#docs').on('click', view.onClick);
                     * // => logs 'clicked docs', when the button is clicked
                     */
                function bindAll(object) {
                    var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
                    index = - 1,
                    length = funcs.length;

                    while (++index < length) {
                        var key = funcs[index];
                        object[key] = createWrapper(object[key], 1, null, null, object);
                    }
                    return object;
                }

                /**
                     * Creates a function that, when called, invokes the method at `object[key]`
                     * and prepends any additional `bindKey` arguments to those provided to the bound
                     * function. This method differs from `_.bind` by allowing bound functions to
                     * reference methods that will be redefined or don't yet exist.
                     * See http://michaux.ca/articles/lazy-function-definition-pattern.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Object} object The object the method belongs to.
                     * @param {string} key The key of the method.
                     * @param {...*} [arg] Arguments to be partially applied.
                     * @returns {Function} Returns the new bound function.
                     * @example
                     *
                     * var object = {
                     *   'name': 'fred',
                     *   'greet': function(greeting) {
                     *     return greeting + ' ' + this.name;
                     *   }
                     * };
                     *
                     * var func = _.bindKey(object, 'greet', 'hi');
                     * func();
                     * // => 'hi fred'
                     *
                     * object.greet = function(greeting) {
                     *   return greeting + 'ya ' + this.name + '!';
                     * };
                     *
                     * func();
                     * // => 'hiya fred!'
                     */
                function bindKey(object, key) {
                    return arguments.length > 2
                    ? createWrapper(key, 19, slice(arguments, 2), null, object)
                    : createWrapper(key, 3, null, null, object);
                }

                /**
                     * Creates a function that is the composition of the provided functions,
                     * where each function consumes the return value of the function that follows.
                     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
                     * Each function is executed with the `this` binding of the composed function.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {...Function} [func] Functions to compose.
                     * @returns {Function} Returns the new composed function.
                     * @example
                     *
                     * var realNameMap = {
                     *   'pebbles': 'penelope'
                     * };
                     *
                     * var format = function(name) {
                     *   name = realNameMap[name.toLowerCase()] || name;
                     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
                     * };
                     *
                     * var greet = function(formatted) {
                     *   return 'Hiya ' + formatted + '!';
                     * };
                     *
                     * var welcome = _.compose(greet, format);
                     * welcome('pebbles');
                     * // => 'Hiya Penelope!'
                     */
                function compose() {
                    var funcs = arguments,
                    length = funcs.length;

                    while (length--) {
                        if (!isFunction(funcs[length])) {
                            throw new TypeError;
                        }
                    }
                    return function() {
                        var args = arguments,
                        length = funcs.length;

                        while (length--) {
                            args = [funcs[length].apply(this, args)];
                        }
                        return args[0];
                    };
                }

                /**
                     * Creates a function which accepts one or more arguments of `func` that when
                     * invoked either executes `func` returning its result, if all `func` arguments
                     * have been provided, or returns a function that accepts one or more of the
                     * remaining `func` arguments, and so on. The arity of `func` can be specified
                     * if `func.length` is not sufficient.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Function} func The function to curry.
                     * @param {number} [arity=func.length] The arity of `func`.
                     * @returns {Function} Returns the new curried function.
                     * @example
                     *
                     * var curried = _.curry(function(a, b, c) {
                     *   console.log(a + b + c);
                     * });
                     *
                     * curried(1)(2)(3);
                     * // => 6
                     *
                     * curried(1, 2)(3);
                     * // => 6
                     *
                     * curried(1, 2, 3);
                     * // => 6
                     */
                function curry(func, arity) {
                    arity = typeof arity == 'number' ? arity : ( + arity || func.length);
                    return createWrapper(func, 4, null, null, null, arity);
                }

                /**
                     * Creates a function that will delay the execution of `func` until after
                     * `wait` milliseconds have elapsed since the last time it was invoked.
                     * Provide an options object to indicate that `func` should be invoked on
                     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
                     * to the debounced function will return the result of the last `func` call.
                     *
                     * Note: If `leading` and `trailing` options are `true` `func` will be called
                     * on the trailing edge of the timeout only if the the debounced function is
                     * invoked more than once during the `wait` timeout.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Function} func The function to debounce.
                     * @param {number} wait The number of milliseconds to delay.
                     * @param {Object} [options] The options object.
                     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
                     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
                     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
                     * @returns {Function} Returns the new debounced function.
                     * @example
                     *
                     * // avoid costly calculations while the window size is in flux
                     * var lazyLayout = _.debounce(calculateLayout, 150);
                     * jQuery(window).on('resize', lazyLayout);
                     *
                     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
                     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
                     *   'leading': true,
                     *   'trailing': false
                     * });
                     *
                     * // ensure `batchLog` is executed once after 1 second of debounced calls
                     * var source = new EventSource('/stream');
                     * source.addEventListener('message', _.debounce(batchLog, 250, {
                     *   'maxWait': 1000
                     * }, false);
                     */
                function debounce(func, wait, options) {
                    var args,
                    maxTimeoutId,
                    result,
                    stamp,
                    thisArg,
                    timeoutId,
                    trailingCall,
                    lastCalled = 0,
                    maxWait = false,
                    trailing = true;

                    if (!isFunction(func)) {
                        throw new TypeError;
                    }
                    wait = nativeMax(0, wait) || 0;
                    if (options === true) {
                        var leading = true;
                        trailing = false;
                    } else if (isObject(options)) {
                        leading = options.leading;
                        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
                        trailing = 'trailing' in options ? options.trailing : trailing;
                    }
                    var delayed = function() {
                        var remaining = wait - (now() - stamp);
                        if (remaining <= 0) {
                            if (maxTimeoutId) {
                                clearTimeout(maxTimeoutId);
                            }
                            var isCalled = trailingCall;
                            maxTimeoutId = timeoutId = trailingCall = undefined;
                            if (isCalled) {
                                lastCalled = now();
                                result = func.apply(thisArg, args);
                                if (!timeoutId && !maxTimeoutId) {
                                    args = thisArg = null;
                                }
                            }
                        } else {
                            timeoutId = setTimeout(delayed, remaining);
                        }
                    };

                    var maxDelayed = function() {
                        if (timeoutId) {
                            clearTimeout(timeoutId);
                        }
                        maxTimeoutId = timeoutId = trailingCall = undefined;
                        if (trailing || (maxWait !== wait)) {
                            lastCalled = now();
                            result = func.apply(thisArg, args);
                            if (!timeoutId && !maxTimeoutId) {
                                args = thisArg = null;
                            }
                        }
                    };

                    return function() {
                        args = arguments;
                        stamp = now();
                        thisArg = this;
                        trailingCall = trailing && (timeoutId || !leading);

                        if (maxWait === false) {
                            var leadingCall = leading && !timeoutId;
                        } else {
                            if (!maxTimeoutId && !leading) {
                                lastCalled = stamp;
                            }
                            var remaining = maxWait - (stamp - lastCalled),
                            isCalled = remaining <= 0;

                            if (isCalled) {
                                if (maxTimeoutId) {
                                    maxTimeoutId = clearTimeout(maxTimeoutId);
                                }
                                lastCalled = stamp;
                                result = func.apply(thisArg, args);
                            } else if (!maxTimeoutId) {
                                maxTimeoutId = setTimeout(maxDelayed, remaining);
                            }
                        }
                        if (isCalled && timeoutId) {
                            timeoutId = clearTimeout(timeoutId);
                        } else if (!timeoutId && wait !== maxWait) {
                            timeoutId = setTimeout(delayed, wait);
                        }
                        if (leadingCall) {
                            isCalled = true;
                            result = func.apply(thisArg, args);
                        }
                        if (isCalled && !timeoutId && !maxTimeoutId) {
                            args = thisArg = null;
                        }
                        return result;
                    };
                }

                /**
                     * Defers executing the `func` function until the current call stack has cleared.
                     * Additional arguments will be provided to `func` when it is invoked.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Function} func The function to defer.
                     * @param {...*} [arg] Arguments to invoke the function with.
                     * @returns {number} Returns the timer id.
                     * @example
                     *
                     * _.defer(function(text) { console.log(text); }, 'deferred');
                     * // logs 'deferred' after one or more milliseconds
                     */
                function defer(func) {
                    if (!isFunction(func)) {
                        throw new TypeError;
                    }
                    var args = slice(arguments, 1);
                    return setTimeout(function() {
                        func.apply(undefined, args);
                    }, 1);
                }

                /**
                     * Executes the `func` function after `wait` milliseconds. Additional arguments
                     * will be provided to `func` when it is invoked.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Function} func The function to delay.
                     * @param {number} wait The number of milliseconds to delay execution.
                     * @param {...*} [arg] Arguments to invoke the function with.
                     * @returns {number} Returns the timer id.
                     * @example
                     *
                     * _.delay(function(text) { console.log(text); }, 1000, 'later');
                     * // => logs 'later' after one second
                     */
                function delay(func, wait) {
                    if (!isFunction(func)) {
                        throw new TypeError;
                    }
                    var args = slice(arguments, 2);
                    return setTimeout(function() {
                        func.apply(undefined, args);
                    }, wait);
                }

                /**
                     * Creates a function that memoizes the result of `func`. If `resolver` is
                     * provided it will be used to determine the cache key for storing the result
                     * based on the arguments provided to the memoized function. By default, the
                     * first argument provided to the memoized function is used as the cache key.
                     * The `func` is executed with the `this` binding of the memoized function.
                     * The result cache is exposed as the `cache` property on the memoized function.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Function} func The function to have its output memoized.
                     * @param {Function} [resolver] A function used to resolve the cache key.
                     * @returns {Function} Returns the new memoizing function.
                     * @example
                     *
                     * var fibonacci = _.memoize(function(n) {
                     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
                     * });
                     *
                     * fibonacci(9)
                     * // => 34
                     *
                     * var data = {
                     *   'fred': { 'name': 'fred', 'age': 40 },
                     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
                     * };
                     *
                     * // modifying the result cache
                     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
                     * get('pebbles');
                     * // => { 'name': 'pebbles', 'age': 1 }
                     *
                     * get.cache.pebbles.name = 'penelope';
                     * get('pebbles');
                     * // => { 'name': 'penelope', 'age': 1 }
                     */
                function memoize(func, resolver) {
                    if (!isFunction(func)) {
                        throw new TypeError;
                    }
                    var memoized = function() {
                        var cache = memoized.cache,
                        key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

                        return hasOwnProperty.call(cache, key)
                        ? cache[key]
                        : (cache[key] = func.apply(this, arguments));
                    }
                    memoized.cache = {};
                    return memoized;
                }

                /**
                     * Creates a function that is restricted to execute `func` once. Repeat calls to
                     * the function will return the value of the first call. The `func` is executed
                     * with the `this` binding of the created function.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Function} func The function to restrict.
                     * @returns {Function} Returns the new restricted function.
                     * @example
                     *
                     * var initialize = _.once(createApplication);
                     * initialize();
                     * initialize();
                     * // `initialize` executes `createApplication` once
                     */
                function once(func) {
                    var ran,
                    result;

                    if (!isFunction(func)) {
                        throw new TypeError;
                    }
                    return function() {
                        if (ran) {
                            return result;
                        }
                        ran = true;
                        result = func.apply(this, arguments);

                        // clear the `func` variable so the function may be garbage collected
                        func = null;
                        return result;
                    };
                }

                /**
                     * Creates a function that, when called, invokes `func` with any additional
                     * `partial` arguments prepended to those provided to the new function. This
                     * method is similar to `_.bind` except it does **not** alter the `this` binding.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Function} func The function to partially apply arguments to.
                     * @param {...*} [arg] Arguments to be partially applied.
                     * @returns {Function} Returns the new partially applied function.
                     * @example
                     *
                     * var greet = function(greeting, name) { return greeting + ' ' + name; };
                     * var hi = _.partial(greet, 'hi');
                     * hi('fred');
                     * // => 'hi fred'
                     */
                function partial(func) {
                    return createWrapper(func, 16, slice(arguments, 1));
                }

                /**
                     * This method is like `_.partial` except that `partial` arguments are
                     * appended to those provided to the new function.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Function} func The function to partially apply arguments to.
                     * @param {...*} [arg] Arguments to be partially applied.
                     * @returns {Function} Returns the new partially applied function.
                     * @example
                     *
                     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
                     *
                     * var options = {
                     *   'variable': 'data',
                     *   'imports': { 'jq': $ }
                     * };
                     *
                     * defaultsDeep(options, _.templateSettings);
                     *
                     * options.variable
                     * // => 'data'
                     *
                     * options.imports
                     * // => { '_': _, 'jq': $ }
                     */
                function partialRight(func) {
                    return createWrapper(func, 32, null, slice(arguments, 1));
                }

                /**
                     * Creates a function that, when executed, will only call the `func` function
                     * at most once per every `wait` milliseconds. Provide an options object to
                     * indicate that `func` should be invoked on the leading and/or trailing edge
                     * of the `wait` timeout. Subsequent calls to the throttled function will
                     * return the result of the last `func` call.
                     *
                     * Note: If `leading` and `trailing` options are `true` `func` will be called
                     * on the trailing edge of the timeout only if the the throttled function is
                     * invoked more than once during the `wait` timeout.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Function} func The function to throttle.
                     * @param {number} wait The number of milliseconds to throttle executions to.
                     * @param {Object} [options] The options object.
                     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
                     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
                     * @returns {Function} Returns the new throttled function.
                     * @example
                     *
                     * // avoid excessively updating the position while scrolling
                     * var throttled = _.throttle(updatePosition, 100);
                     * jQuery(window).on('scroll', throttled);
                     *
                     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
                     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
                     *   'trailing': false
                     * }));
                     */
                function throttle(func, wait, options) {
                    var leading = true,
                    trailing = true;

                    if (!isFunction(func)) {
                        throw new TypeError;
                    }
                    if (options === false) {
                        leading = false;
                    } else if (isObject(options)) {
                        leading = 'leading' in options ? options.leading : leading;
                        trailing = 'trailing' in options ? options.trailing : trailing;
                    }
                    debounceOptions.leading = leading;
                    debounceOptions.maxWait = wait;
                    debounceOptions.trailing = trailing;

                    return debounce(func, wait, debounceOptions);
                }

                /**
                     * Creates a function that provides `value` to the wrapper function as its
                     * first argument. Additional arguments provided to the function are appended
                     * to those provided to the wrapper function. The wrapper is executed with
                     * the `this` binding of the created function.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {*} value The value to wrap.
                     * @param {Function} wrapper The wrapper function.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var p = _.wrap(_.escape, function(func, text) {
                     *   return '<p>' + func(text) + '</p>';
                     * });
                     *
                     * p('Fred, Wilma, & Pebbles');
                     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
                     */
                function wrap(value, wrapper) {
                    return createWrapper(wrapper, 16, [value]);
                }

                /*--------------------------------------------------------------------------*/

                /**
                     * Creates a function that returns `value`.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {*} value The value to return from the new function.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var object = { 'name': 'fred' };
                     * var getter = _.constant(object);
                     * getter() === object;
                     * // => true
                     */
                function constant(value) {
                    return function() {
                        return value;
                    };
                }

                /**
                     * Produces a callback bound to an optional `thisArg`. If `func` is a property
                     * name the created callback will return the property value for a given element.
                     * If `func` is an object the created callback will return `true` for elements
                     * that contain the equivalent object properties, otherwise it will return `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {*} [func=identity] The value to convert to a callback.
                     * @param {*} [thisArg] The `this` binding of the created callback.
                     * @param {number} [argCount] The number of arguments the callback accepts.
                     * @returns {Function} Returns a callback function.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36 },
                     *   { 'name': 'fred',   'age': 40 }
                     * ];
                     *
                     * // wrap to create custom callback shorthands
                     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
                     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
                     *   return !match ? func(callback, thisArg) : function(object) {
                     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
                     *   };
                     * });
                     *
                     * _.filter(characters, 'age__gt38');
                     * // => [{ 'name': 'fred', 'age': 40 }]
                     */
                function createCallback(func, thisArg, argCount) {
                    var type = typeof func;
                    if (func == null || type == 'function') {
                        return baseCreateCallback(func, thisArg, argCount);
                    }
                    // handle "_.pluck" style callback shorthands
                    if (type != 'object') {
                        return property(func);
                    }
                    var props = keys(func),
                    key = props[0],
                    a = func[key];

                    // handle "_.where" style callback shorthands
                    if (props.length == 1 && a === a && !isObject(a)) {
                        // fast path the common case of providing an object with a single
                        // property containing a primitive value
                        return function(object) {
                            var b = object[key];
                            return a === b && (a !== 0 || (1 / a == 1 / b));
                        };
                    }
                    return function(object) {
                        var length = props.length,
                        result = false;

                        while (length--) {
                            if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
                                break;
                            }
                        }
                        return result;
                    };
                }

                /**
                     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
                     * corresponding HTML entities.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {string} string The string to escape.
                     * @returns {string} Returns the escaped string.
                     * @example
                     *
                     * _.escape('Fred, Wilma, & Pebbles');
                     * // => 'Fred, Wilma, &amp; Pebbles'
                     */
                function escape(string) {
                    return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
                }

                /**
                     * This method returns the first argument provided to it.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {*} value Any value.
                     * @returns {*} Returns `value`.
                     * @example
                     *
                     * var object = { 'name': 'fred' };
                     * _.identity(object) === object;
                     * // => true
                     */
                function identity(value) {
                    return value;
                }

                /**
                     * Adds function properties of a source object to the destination object.
                     * If `object` is a function methods will be added to its prototype as well.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {Function|Object} [object=lodash] object The destination object.
                     * @param {Object} source The object of functions to add.
                     * @param {Object} [options] The options object.
                     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
                     * @example
                     *
                     * function capitalize(string) {
                     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
                     * }
                     *
                     * _.mixin({ 'capitalize': capitalize });
                     * _.capitalize('fred');
                     * // => 'Fred'
                     *
                     * _('fred').capitalize().value();
                     * // => 'Fred'
                     *
                     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
                     * _('fred').capitalize();
                     * // => 'Fred'
                     */
                function mixin(object, source, options) {
                    var chain = true,
                    methodNames = source && functions(source);

                    if (!source || (!options && !methodNames.length)) {
                        if (options == null) {
                            options = source;
                        }
                        ctor = lodashWrapper;
                        source = object;
                        object = lodash;
                        methodNames = functions(source);
                    }
                    if (options === false) {
                        chain = false;
                    } else if (isObject(options) && 'chain' in options) {
                        chain = options.chain;
                    }
                    var ctor = object,
                    isFunc = isFunction(ctor);

                    forEach(methodNames, function(methodName) {
                        var func = object[methodName] = source[methodName];
                        if (isFunc) {
                            ctor.prototype[methodName] = function() {
                                var chainAll = this.__chain__,
                                value = this.__wrapped__,
                                args = [value];

                                push.apply(args, arguments);
                                var result = func.apply(object, args);
                                if (chain || chainAll) {
                                    if (value === result && isObject(result)) {
                                        return this;
                                    }
                                    result = new ctor(result);
                                    result.__chain__ = chainAll;
                                }
                                return result;
                            };
                        }
                    });
                }

                /**
                     * Reverts the '_' variable to its previous value and returns a reference to
                     * the `lodash` function.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @returns {Function} Returns the `lodash` function.
                     * @example
                     *
                     * var lodash = _.noConflict();
                     */
                function noConflict() {
                    context._ = oldDash;
                    return this;
                }

                /**
                     * A no-operation function.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @example
                     *
                     * var object = { 'name': 'fred' };
                     * _.noop(object) === undefined;
                     * // => true
                     */
                function noop() {
                    // no operation performed
                }

                /**
                     * Gets the number of milliseconds that have elapsed since the Unix epoch
                     * (1 January 1970 00:00:00 UTC).
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @example
                     *
                     * var stamp = _.now();
                     * _.defer(function() { console.log(_.now() - stamp); });
                     * // => logs the number of milliseconds it took for the deferred function to be called
                     */
                var now = isNative(now = Date.now) && now || function() {
                    return new Date().getTime();
                };

                /**
                     * Converts the given value into an integer of the specified radix.
                     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
                     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
                     *
                     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
                     * implementations. See http://es5.github.io/#E.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {string} value The value to parse.
                     * @param {number} [radix] The radix used to interpret the value to parse.
                     * @returns {number} Returns the new integer value.
                     * @example
                     *
                     * _.parseInt('08');
                     * // => 8
                     */
                var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
                    // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
                    return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
                };

                /**
                     * Creates a "_.pluck" style function, which returns the `key` value of a
                     * given object.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {string} key The name of the property to retrieve.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'fred',   'age': 40 },
                     *   { 'name': 'barney', 'age': 36 }
                     * ];
                     *
                     * var getName = _.property('name');
                     *
                     * _.map(characters, getName);
                     * // => ['barney', 'fred']
                     *
                     * _.sortBy(characters, getName);
                     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
                     */
                function property(key) {
                    return function(object) {
                        return object[key];
                    };
                }

                /**
                     * Produces a random number between `min` and `max` (inclusive). If only one
                     * argument is provided a number between `0` and the given number will be
                     * returned. If `floating` is truey or either `min` or `max` are floats a
                     * floating-point number will be returned instead of an integer.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {number} [min=0] The minimum possible value.
                     * @param {number} [max=1] The maximum possible value.
                     * @param {boolean} [floating=false] Specify returning a floating-point number.
                     * @returns {number} Returns a random number.
                     * @example
                     *
                     * _.random(0, 5);
                     * // => an integer between 0 and 5
                     *
                     * _.random(5);
                     * // => also an integer between 0 and 5
                     *
                     * _.random(5, true);
                     * // => a floating-point number between 0 and 5
                     *
                     * _.random(1.2, 5.2);
                     * // => a floating-point number between 1.2 and 5.2
                     */
                function random(min, max, floating) {
                    var noMin = min == null,
                    noMax = max == null;

                    if (floating == null) {
                        if (typeof min == 'boolean' && noMax) {
                            floating = min;
                            min = 1;
                        } else if (!noMax && typeof max == 'boolean') {
                            floating = max;
                            noMax = true;
                        }
                    }
                    if (noMin && noMax) {
                        max = 1;
                    }
                    min = + min || 0;
                    if (noMax) {
                        max = min;
                        min = 0;
                    } else {
                        max = + max || 0;
                    }
                    if (floating || min % 1 || max % 1) {
                        var rand = nativeRandom();
                        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
                    }
                    return baseRandom(min, max);
                }

                /**
                     * Resolves the value of property `key` on `object`. If `key` is a function
                     * it will be invoked with the `this` binding of `object` and its result returned,
                     * else the property value is returned. If `object` is falsey then `undefined`
                     * is returned.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {Object} object The object to inspect.
                     * @param {string} key The name of the property to resolve.
                     * @returns {*} Returns the resolved value.
                     * @example
                     *
                     * var object = {
                     *   'cheese': 'crumpets',
                     *   'stuff': function() {
                     *     return 'nonsense';
                     *   }
                     * };
                     *
                     * _.result(object, 'cheese');
                     * // => 'crumpets'
                     *
                     * _.result(object, 'stuff');
                     * // => 'nonsense'
                     */
                function result(object, key) {
                    if (object) {
                        var value = object[key];
                        return isFunction(value) ? object[key]() : value;
                    }
                }

                /**
                     * A micro-templating method that handles arbitrary delimiters, preserves
                     * whitespace, and correctly escapes quotes within interpolated code.
                     *
                     * Note: In the development build, `_.template` utilizes sourceURLs for easier
                     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
                     *
                     * For more information on precompiling templates see:
                     * http://lodash.com/custom-builds
                     *
                     * For more information on Chrome extension sandboxes see:
                     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {string} text The template text.
                     * @param {Object} data The data object used to populate the text.
                     * @param {Object} [options] The options object.
                     * @param {RegExp} [options.escape] The "escape" delimiter.
                     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
                     * @param {Object} [options.imports] An object to import into the template as local variables.
                     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
                     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
                     * @param {string} [variable] The data object variable name.
                     * @returns {Function|string} Returns a compiled function when no `data` object
                     *  is given, else it returns the interpolated text.
                     * @example
                     *
                     * // using the "interpolate" delimiter to create a compiled template
                     * var compiled = _.template('hello <%= name %>');
                     * compiled({ 'name': 'fred' });
                     * // => 'hello fred'
                     *
                     * // using the "escape" delimiter to escape HTML in data property values
                     * _.template('<b><%- value %></b>', { 'value': '<script>' });
                     * // => '<b>&lt;script&gt;</b>'
                     *
                     * // using the "evaluate" delimiter to generate HTML
                     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
                     * _.template(list, { 'people': ['fred', 'barney'] });
                     * // => '<li>fred</li><li>barney</li>'
                     *
                     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
                     * _.template('hello ${ name }', { 'name': 'pebbles' });
                     * // => 'hello pebbles'
                     *
                     * // using the internal `print` function in "evaluate" delimiters
                     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
                     * // => 'hello barney!'
                     *
                     * // using a custom template delimiters
                     * _.templateSettings = {
                     *   'interpolate': /{{([\s\S]+?)}}/g
                     * };
                     *
                     * _.template('hello {{ name }}!', { 'name': 'mustache' });
                     * // => 'hello mustache!'
                     *
                     * // using the `imports` option to import jQuery
                     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
                     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
                     * // => '<li>fred</li><li>barney</li>'
                     *
                     * // using the `sourceURL` option to specify a custom sourceURL for the template
                     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
                     * compiled(data);
                     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
                     *
                     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
                     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
                     * compiled.source;
                     * // => function(data) {
                     *   var __t, __p = '', __e = _.escape;
                     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
                     *   return __p;
                     * }
                     *
                     * // using the `source` property to inline compiled templates for meaningful
                     * // line numbers in error messages and a stack trace
                     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
                     *   var JST = {\
                     *     "main": ' + _.template(mainText).source + '\
                     *   };\
                     * ');
                     */
                function template(text, data, options) {
                    // based on John Resig's `tmpl` implementation
                    // http://ejohn.org/blog/javascript-micro-templating/
                    // and Laura Doktorova's doT.js
                    // https://github.com/olado/doT
                    var settings = lodash.templateSettings;
                    text = String(text || '');

                    // avoid missing dependencies when `iteratorTemplate` is not defined
                    options = defaults({}, options, settings);

                    var imports = defaults({}, options.imports, settings.imports),
                    importsKeys = keys(imports),
                    importsValues = values(imports);

                    var isEvaluating,
                    index = 0,
                    interpolate = options.interpolate || reNoMatch,
                    source = "__p += '";

                    // compile the regexp to match each delimiter
                    var reDelimiters = RegExp(
                    (options.escape || reNoMatch).source + '|' +
                    interpolate.source + '|' +
                    (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
                    (options.evaluate || reNoMatch).source + '|$'
                    , 'g');

                    text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                        interpolateValue || (interpolateValue = esTemplateValue);

                        // escape characters that cannot be included in string literals
                        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

                        // replace delimiters with snippets
                        if (escapeValue) {
                            source += "' +\n__e(" + escapeValue + ") +\n'";
                        }
                        if (evaluateValue) {
                            isEvaluating = true;
                            source += "';\n" + evaluateValue + ";\n__p += '";
                        }
                        if (interpolateValue) {
                            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                        }
                        index = offset + match.length;

                        // the JS engine embedded in Adobe products requires returning the `match`
                        // string in order to produce the correct `offset` value
                        return match;
                    });

                    source += "';\n";

                    // if `variable` is not specified, wrap a with-statement around the generated
                    // code to add the data object to the top of the scope chain
                    var variable = options.variable,
                    hasVariable = variable;

                    if (!hasVariable) {
                        variable = 'obj';
                        source = 'with (' + variable + ') {\n' + source + '\n}\n';
                    }
                    // cleanup code by stripping empty strings
                    source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
                    .replace(reEmptyStringMiddle, '$1')
                    .replace(reEmptyStringTrailing, '$1;');

                    // frame code as the function body
                    source = 'function(' + variable + ') {\n' +
                    (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
                    "var __t, __p = '', __e = _.escape" +
                    (isEvaluating
                    ? ', __j = Array.prototype.join;\n' +
                    "function print() { __p += __j.call(arguments, '') }\n"
                    : ';\n'
                    ) +
                    source +
                    'return __p\n}';

                    // Use a sourceURL for easier debugging.
                    // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
                    var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';

                    try {
                        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
                    } catch (e) {
                        e.source = source;
                        throw e;
                    }
                    if (data) {
                        return result(data);
                    }
                    // provide the compiled function's source by its `toString` method, in
                    // supported environments, or the `source` property as a convenience for
                    // inlining compiled templates during the build process
                    result.source = source;
                    return result;
                }

                /**
                     * Executes the callback `n` times, returning an array of the results
                     * of each callback execution. The callback is bound to `thisArg` and invoked
                     * with one argument; (index).
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {number} n The number of times to execute the callback.
                     * @param {Function} callback The function called per iteration.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns an array of the results of each `callback` execution.
                     * @example
                     *
                     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
                     * // => [3, 6, 4]
                     *
                     * _.times(3, function(n) { mage.castSpell(n); });
                     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
                     *
                     * _.times(3, function(n) { this.cast(n); }, mage);
                     * // => also calls `mage.castSpell(n)` three times
                     */
                function times(n, callback, thisArg) {
                    n = (n = + n) > - 1 ? n : 0;
                    var index = - 1,
                    result = Array(n);

                    callback = baseCreateCallback(callback, thisArg, 1);
                    while (++index < n) {
                        result[index] = callback(index);
                    }
                    return result;
                }

                /**
                     * The inverse of `_.escape` this method converts the HTML entities
                     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
                     * corresponding characters.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {string} string The string to unescape.
                     * @returns {string} Returns the unescaped string.
                     * @example
                     *
                     * _.unescape('Fred, Barney &amp; Pebbles');
                     * // => 'Fred, Barney & Pebbles'
                     */
                function unescape(string) {
                    return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
                }

                /**
                     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {string} [prefix] The value to prefix the ID with.
                     * @returns {string} Returns the unique ID.
                     * @example
                     *
                     * _.uniqueId('contact_');
                     * // => 'contact_104'
                     *
                     * _.uniqueId();
                     * // => '105'
                     */
                function uniqueId(prefix) {
                    var id = ++idCounter;
                    return String(prefix == null ? '' : prefix) + id;
                }

                /*--------------------------------------------------------------------------*/

                /**
                     * Creates a `lodash` object that wraps the given value with explicit
                     * method chaining enabled.
                     *
                     * @static
                     * @memberOf _
                     * @category Chaining
                     * @param {*} value The value to wrap.
                     * @returns {Object} Returns the wrapper object.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'barney',  'age': 36 },
                     *   { 'name': 'fred',    'age': 40 },
                     *   { 'name': 'pebbles', 'age': 1 }
                     * ];
                     *
                     * var youngest = _.chain(characters)
                     *     .sortBy('age')
                     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
                     *     .first()
                     *     .value();
                     * // => 'pebbles is 1'
                     */
                function chain(value) {
                    value = new lodashWrapper(value);
                    value.__chain__ = true;
                    return value;
                }

                /**
                     * Invokes `interceptor` with the `value` as the first argument and then
                     * returns `value`. The purpose of this method is to "tap into" a method
                     * chain in order to perform operations on intermediate results within
                     * the chain.
                     *
                     * @static
                     * @memberOf _
                     * @category Chaining
                     * @param {*} value The value to provide to `interceptor`.
                     * @param {Function} interceptor The function to invoke.
                     * @returns {*} Returns `value`.
                     * @example
                     *
                     * _([1, 2, 3, 4])
                     *  .tap(function(array) { array.pop(); })
                     *  .reverse()
                     *  .value();
                     * // => [3, 2, 1]
                     */
                function tap(value, interceptor) {
                    interceptor(value);
                    return value;
                }

                /**
                     * Enables explicit method chaining on the wrapper object.
                     *
                     * @name chain
                     * @memberOf _
                     * @category Chaining
                     * @returns {*} Returns the wrapper object.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36 },
                     *   { 'name': 'fred',   'age': 40 }
                     * ];
                     *
                     * // without explicit chaining
                     * _(characters).first();
                     * // => { 'name': 'barney', 'age': 36 }
                     *
                     * // with explicit chaining
                     * _(characters).chain()
                     *   .first()
                     *   .pick('age')
                     *   .value();
                     * // => { 'age': 36 }
                     */
                function wrapperChain() {
                    this.__chain__ = true;
                    return this;
                }

                /**
                     * Produces the `toString` result of the wrapped value.
                     *
                     * @name toString
                     * @memberOf _
                     * @category Chaining
                     * @returns {string} Returns the string result.
                     * @example
                     *
                     * _([1, 2, 3]).toString();
                     * // => '1,2,3'
                     */
                function wrapperToString() {
                    return String(this.__wrapped__);
                }

                /**
                     * Extracts the wrapped value.
                     *
                     * @name valueOf
                     * @memberOf _
                     * @alias value
                     * @category Chaining
                     * @returns {*} Returns the wrapped value.
                     * @example
                     *
                     * _([1, 2, 3]).valueOf();
                     * // => [1, 2, 3]
                     */
                function wrapperValueOf() {
                    return this.__wrapped__;
                }

                /*--------------------------------------------------------------------------*/

                // add functions that return wrapped values when chaining
                lodash.after = after;
                lodash.assign = assign;
                lodash.at = at;
                lodash.bind = bind;
                lodash.bindAll = bindAll;
                lodash.bindKey = bindKey;
                lodash.chain = chain;
                lodash.compact = compact;
                lodash.compose = compose;
                lodash.constant = constant;
                lodash.countBy = countBy;
                lodash.create = create;
                lodash.createCallback = createCallback;
                lodash.curry = curry;
                lodash.debounce = debounce;
                lodash.defaults = defaults;
                lodash.defer = defer;
                lodash.delay = delay;
                lodash.difference = difference;
                lodash.filter = filter;
                lodash.flatten = flatten;
                lodash.forEach = forEach;
                lodash.forEachRight = forEachRight;
                lodash.forIn = forIn;
                lodash.forInRight = forInRight;
                lodash.forOwn = forOwn;
                lodash.forOwnRight = forOwnRight;
                lodash.functions = functions;
                lodash.groupBy = groupBy;
                lodash.indexBy = indexBy;
                lodash.initial = initial;
                lodash.intersection = intersection;
                lodash.invert = invert;
                lodash.invoke = invoke;
                lodash.keys = keys;
                lodash.map = map;
                lodash.mapValues = mapValues;
                lodash.max = max;
                lodash.memoize = memoize;
                lodash.merge = merge;
                lodash.min = min;
                lodash.omit = omit;
                lodash.once = once;
                lodash.pairs = pairs;
                lodash.partial = partial;
                lodash.partialRight = partialRight;
                lodash.pick = pick;
                lodash.pluck = pluck;
                lodash.property = property;
                lodash.pull = pull;
                lodash.range = range;
                lodash.reject = reject;
                lodash.remove = remove;
                lodash.rest = rest;
                lodash.shuffle = shuffle;
                lodash.sortBy = sortBy;
                lodash.tap = tap;
                lodash.throttle = throttle;
                lodash.times = times;
                lodash.toArray = toArray;
                lodash.transform = transform;
                lodash.union = union;
                lodash.uniq = uniq;
                lodash.values = values;
                lodash.where = where;
                lodash.without = without;
                lodash.wrap = wrap;
                lodash.xor = xor;
                lodash.zip = zip;
                lodash.zipObject = zipObject;

                // add aliases
                lodash.collect = map;
                lodash.drop = rest;
                lodash.each = forEach;
                lodash.eachRight = forEachRight;
                lodash.extend = assign;
                lodash.methods = functions;
                lodash.object = zipObject;
                lodash.select = filter;
                lodash.tail = rest;
                lodash.unique = uniq;
                lodash.unzip = zip;

                // add functions to `lodash.prototype`
                mixin(lodash);

                /*--------------------------------------------------------------------------*/

                // add functions that return unwrapped values when chaining
                lodash.clone = clone;
                lodash.cloneDeep = cloneDeep;
                lodash.contains = contains;
                lodash.escape = escape;
                lodash.every = every;
                lodash.find = find;
                lodash.findIndex = findIndex;
                lodash.findKey = findKey;
                lodash.findLast = findLast;
                lodash.findLastIndex = findLastIndex;
                lodash.findLastKey = findLastKey;
                lodash.has = has;
                lodash.identity = identity;
                lodash.indexOf = indexOf;
                lodash.isArguments = isArguments;
                lodash.isArray = isArray;
                lodash.isBoolean = isBoolean;
                lodash.isDate = isDate;
                lodash.isElement = isElement;
                lodash.isEmpty = isEmpty;
                lodash.isEqual = isEqual;
                lodash.isFinite = isFinite;
                lodash.isFunction = isFunction;
                lodash.isNaN = isNaN;
                lodash.isNull = isNull;
                lodash.isNumber = isNumber;
                lodash.isObject = isObject;
                lodash.isPlainObject = isPlainObject;
                lodash.isRegExp = isRegExp;
                lodash.isString = isString;
                lodash.isUndefined = isUndefined;
                lodash.lastIndexOf = lastIndexOf;
                lodash.mixin = mixin;
                lodash.noConflict = noConflict;
                lodash.noop = noop;
                lodash.now = now;
                lodash.parseInt = parseInt;
                lodash.random = random;
                lodash.reduce = reduce;
                lodash.reduceRight = reduceRight;
                lodash.result = result;
                lodash.runInContext = runInContext;
                lodash.size = size;
                lodash.some = some;
                lodash.sortedIndex = sortedIndex;
                lodash.template = template;
                lodash.unescape = unescape;
                lodash.uniqueId = uniqueId;

                // add aliases
                lodash.all = every;
                lodash.any = some;
                lodash.detect = find;
                lodash.findWhere = find;
                lodash.foldl = reduce;
                lodash.foldr = reduceRight;
                lodash.include = contains;
                lodash.inject = reduce;

                mixin(function() {
                    var source = {}
                    forOwn(lodash, function(func, methodName) {
                        if (!lodash.prototype[methodName]) {
                            source[methodName] = func;
                        }
                    });
                    return source;
                }(), false);

                /*--------------------------------------------------------------------------*/

                // add functions capable of returning wrapped and unwrapped values when chaining
                lodash.first = first;
                lodash.last = last;
                lodash.sample = sample;

                // add aliases
                lodash.take = first;
                lodash.head = first;

                forOwn(lodash, function(func, methodName) {
                    var callbackable = methodName !== 'sample';
                    if (!lodash.prototype[methodName]) {
                        lodash.prototype[methodName] = function(n, guard) {
                            var chainAll = this.__chain__,
                            result = func(this.__wrapped__, n, guard);

                            return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
                            ? result
                            : new lodashWrapper(result, chainAll);
                        };
                    }
                });

                /*--------------------------------------------------------------------------*/

                /**
                     * The semantic version number.
                     *
                     * @static
                     * @memberOf _
                     * @type string
                     */
                lodash.VERSION = '2.4.1';

                // add "Chaining" functions to the wrapper
                lodash.prototype.chain = wrapperChain;
                lodash.prototype.toString = wrapperToString;
                lodash.prototype.value = wrapperValueOf;
                lodash.prototype.valueOf = wrapperValueOf;

                // add `Array` functions that return unwrapped values
                forEach(['join', 'pop', 'shift'], function(methodName) {
                    var func = arrayRef[methodName];
                    lodash.prototype[methodName] = function() {
                        var chainAll = this.__chain__,
                        result = func.apply(this.__wrapped__, arguments);

                        return chainAll
                        ? new lodashWrapper(result, chainAll)
                        : result;
                    };
                });

                // add `Array` functions that return the existing wrapped value
                forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
                    var func = arrayRef[methodName];
                    lodash.prototype[methodName] = function() {
                        func.apply(this.__wrapped__, arguments);
                        return this;
                    };
                });

                // add `Array` functions that return new wrapped values
                forEach(['concat', 'slice', 'splice'], function(methodName) {
                    var func = arrayRef[methodName];
                    lodash.prototype[methodName] = function() {
                        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
                    };
                });

                return lodash;
            }

            /*--------------------------------------------------------------------------*/

            // expose Lo-Dash
            var _ = runInContext();

            // some AMD build optimizers like r.js check for condition patterns like the following:
            if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
                // Expose Lo-Dash to the global object even when an AMD loader is present in
                // case Lo-Dash is loaded with a RequireJS shim config.
                // See http://requirejs.org/docs/api.html#config-shim
                root._ = _;

                // define as an anonymous module so, through path mapping, it can be
                // referenced as the "underscore" module
                define(function() {
                    return _;
                });
            }
            // check for `exports` after `define` in case a build optimizer adds an `exports` object
            else if (freeExports && freeModule) {
                // in Node.js or RingoJS
                if (moduleExports) {
                    (freeModule.exports = _)._ = _;
                }
                // in Narwhal or Rhino -require
                else {
                    freeExports._ = _;
                }
            } else {
                // in a browser or Rhino
                root._ = _;
            }
        }.call(this));

    }, {}
    ],
    272: [function(require, module, exports) {
        (function() {
            var Mixen, indexOf, moduleSuper, uniqueId,
            __slice = [].slice,
            __hasProp = {}.hasOwnProperty,
            __extends = function(child, parent) {
                for (var key in parent) {
                    if (__hasProp.call(parent, key)) 
                        child[key] = parent[key];
                }
                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            };

            indexOf = function(haystack, needle) {
                var i, stalk, _i, _len;
                for (i = _i = 0, _len = haystack.length; _i < _len; i = ++_i) {
                    stalk = haystack[i];
                    if (stalk === needle) {
                        return i;
                    }
                }
                return - 1;
            };

            uniqueId = (function() {
                var id;
                id = 0;
                return function() {
                    return id++;
                };
            })();

            Mixen = function() {
                return Mixen.createMixen.apply(Mixen, arguments);
            };

            Mixen.createdMixens = {};

            Mixen.createMixen = function() {
                var Inst, Last, method, mods, module, _base, _i, _len, _ref, _ref1;
                mods = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                Last = mods[mods.length - 1];
                _ref = mods.slice(0).reverse();
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    module = _ref[_i];
                    Inst = (function(_super) {
                        __extends(Inst, _super);

                        function Inst() {
                            var args, mod, _j, _len1;
                            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                            for (_j = 0, _len1 = mods.length; _j < _len1; _j++) {
                                mod = mods[_j];
                                mod.apply(this, args);
                            }
                        }

                        return Inst;

                    })(Last);
                    Last = Inst;
                    for (method in module.prototype) {
                        Inst.prototype[method] = module.prototype[method];
                    }
                    _ref1 = module.prototype;
                    for (method in _ref1) {
                        if (!__hasProp.call(_ref1, method)) 
                            continue;
                        if (method === 'constructor') {
                            continue;
                        }
                        if (typeof module.prototype[method] !== 'function') {
                            continue;
                        }
                        if (module.__super__ == null) {
                            module.__super__ = {};
                        }
                        if ((_base = module.__super__)[method] == null) {
                            _base[method] = moduleSuper(module, method);
                        }
                    }
                }
                Last.prototype._mixen_id = uniqueId();
                Mixen.createdMixens[Last.prototype._mixen_id] = mods;
                return Last;
            };

            moduleSuper = function(module, method) {
                return function() {
                    var args, current, id, modules, nextModule, pos;
                    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                    current = this.constructor.prototype;
                    id = null;
                    while (true) {
                        if (current === Object.prototype) {
                            return;
                        }
                        id = current._mixen_id;
                        if (id != null) {
                            break;
                        }
                        current = current.constructor.__super__.constructor.prototype;
                    }
                    if (id == null) {
                        return;
                    }
                    modules = Mixen.createdMixens[id];
                    pos = indexOf(modules, module);
                    nextModule = null;
                    while (pos++ < modules.length - 1) {
                        nextModule = modules[pos];
                        if (nextModule.prototype[method] != null) {
                            break;
                        }
                    }
                    if ((nextModule != null) && (nextModule.prototype != null) && (nextModule.prototype[method] != null)) {
                        return nextModule.prototype[method].apply(this, args);
                    }
                };
            };

            if (typeof define === 'function' && define.amd) {
                define(function() {
                    return Mixen;
                });
            } else if (typeof exports === 'object') {
                module.exports = Mixen;
            } else {
                window.Mixen = Mixen;
            }

        }).call(this);

    }, {}
    ],
    273: [function(require, module, exports) {
        var global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}; //! moment.js
        //! version : 2.6.0
        //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
        //! license : MIT
        //! momentjs.com

        (function (undefined) {

            /************************************
                    Constants
                ************************************/

            var moment,
            VERSION = "2.6.0",
            // the global-scope this is NOT the global object in Node.js
            globalScope = typeof global !== 'undefined' ? global : this,
            oldGlobalMoment,
            round = Math.round,
            i,
            YEAR = 0,
            MONTH = 1,
            DATE = 2,
            HOUR = 3,
            MINUTE = 4,
            SECOND = 5,
            MILLISECOND = 6,
            // internal storage for language config files
            languages = {},
            // moment internal properties
            momentProperties = {
                _isAMomentObject: null,
                _i : null,
                _f : null,
                _l : null,
                _strict : null,
                _isUTC : null,
                _offset : null,
                // optional. Combine with _isUTC
                _pf : null,
                _lang : null // optional
            },
            // check for nodeJS
            hasModule = (typeof module !== 'undefined' && module.exports),
            // ASP.NET json date format regex
            aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
            aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,
            // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
            // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
            isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,
            // format tokens
            formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
            localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,
            // parsing token regexes
            parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
            parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
            parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
            parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
            parseTokenDigits = /\d+/, // nonzero number of digits
            parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
            parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
            parseTokenT = /T/i, // T (ISO separator)
            parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
            parseTokenOrdinal = /\d{1,2}/,
            //strict parsing regexes
            parseTokenOneDigit = /\d/, // 0 - 9
            parseTokenTwoDigits = /\d\d/, // 00 - 99
            parseTokenThreeDigits = /\d{3}/, // 000 - 999
            parseTokenFourDigits = /\d{4}/, // 0000 - 9999
            parseTokenSixDigits = /[+-]?\d{6}/, // -999,999 - 999,999
            parseTokenSignedNumber = /[+-]?\d+/, // -inf - inf

            // iso 8601 regex
            // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
            isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
            isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',
            isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
            ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
            ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d{2}/],
            ['YYYY-DDD', /\d{4}-\d{3}/]
            ],
            // iso time formats and regexes
            isoTimes = [
            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
            ['HH:mm', /(T| )\d\d:\d\d/],
            ['HH', /(T| )\d\d/]
            ],
            // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
            parseTimezoneChunker = /([\+\-]|\d\d)/gi,
            // getter and setter names
            proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
            unitMillisecondFactors = {
                'Milliseconds' : 1,
                'Seconds' : 1e3,
                'Minutes' : 6e4,
                'Hours' : 36e5,
                'Days' : 864e5,
                'Months' : 2592e6,
                'Years' : 31536e6
            },
            unitAliases = {
                ms : 'millisecond',
                s : 'second',
                m : 'minute',
                h : 'hour',
                d : 'day',
                D : 'date',
                w : 'week',
                W : 'isoWeek',
                M : 'month',
                Q : 'quarter',
                y : 'year',
                DDD : 'dayOfYear',
                e : 'weekday',
                E : 'isoWeekday',
                gg: 'weekYear',
                GG: 'isoWeekYear'
            },
            camelFunctions = {
                dayofyear : 'dayOfYear',
                isoweekday : 'isoWeekday',
                isoweek : 'isoWeek',
                weekyear : 'weekYear',
                isoweekyear : 'isoWeekYear'
            },
            // format function strings
            formatFunctions = {},
            // tokens to ordinalize and pad
            ordinalizeTokens = 'DDD w W M D d'.split(' '),
            paddedTokens = 'M D H h m s w W'.split(' '),
            formatTokenFunctions = {
                M : function () {
                    return this.month() + 1;
                },
                MMM : function (format) {
                    return this.lang().monthsShort(this, format);
                },
                MMMM : function (format) {
                    return this.lang().months(this, format);
                },
                D : function () {
                    return this.date();
                },
                DDD : function () {
                    return this.dayOfYear();
                },
                d : function () {
                    return this.day();
                },
                dd : function (format) {
                    return this.lang().weekdaysMin(this, format);
                },
                ddd : function (format) {
                    return this.lang().weekdaysShort(this, format);
                },
                dddd : function (format) {
                    return this.lang().weekdays(this, format);
                },
                w : function () {
                    return this.week();
                },
                W : function () {
                    return this.isoWeek();
                },
                YY : function () {
                    return leftZeroFill(this.year() % 100, 2);
                },
                YYYY : function () {
                    return leftZeroFill(this.year(), 4);
                },
                YYYYY : function () {
                    return leftZeroFill(this.year(), 5);
                },
                YYYYYY : function () {
                    var y = this.year(), sign = y >= 0 ? '+' : '-';
                    return sign + leftZeroFill(Math.abs(y), 6);
                },
                gg : function () {
                    return leftZeroFill(this.weekYear() % 100, 2);
                },
                gggg : function () {
                    return leftZeroFill(this.weekYear(), 4);
                },
                ggggg : function () {
                    return leftZeroFill(this.weekYear(), 5);
                },
                GG : function () {
                    return leftZeroFill(this.isoWeekYear() % 100, 2);
                },
                GGGG : function () {
                    return leftZeroFill(this.isoWeekYear(), 4);
                },
                GGGGG : function () {
                    return leftZeroFill(this.isoWeekYear(), 5);
                },
                e : function () {
                    return this.weekday();
                },
                E : function () {
                    return this.isoWeekday();
                },
                a : function () {
                    return this.lang().meridiem(this.hours(), this.minutes(), true);
                },
                A : function () {
                    return this.lang().meridiem(this.hours(), this.minutes(), false);
                },
                H : function () {
                    return this.hours();
                },
                h : function () {
                    return this.hours() % 12 || 12;
                },
                m : function () {
                    return this.minutes();
                },
                s : function () {
                    return this.seconds();
                },
                S : function () {
                    return toInt(this.milliseconds() / 100);
                },
                SS : function () {
                    return leftZeroFill(toInt(this.milliseconds() / 10), 2);
                },
                SSS : function () {
                    return leftZeroFill(this.milliseconds(), 3);
                },
                SSSS : function () {
                    return leftZeroFill(this.milliseconds(), 3);
                },
                Z : function () {
                    var a = - this.zone(),
                    b = "+";
                    if (a < 0) {
                        a = - a;
                        b = "-";
                    }
                    return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2);
                },
                ZZ : function () {
                    var a = - this.zone(),
                    b = "+";
                    if (a < 0) {
                        a = - a;
                        b = "-";
                    }
                    return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
                },
                z : function () {
                    return this.zoneAbbr();
                },
                zz : function () {
                    return this.zoneName();
                },
                X : function () {
                    return this.unix();
                },
                Q : function () {
                    return this.quarter();
                }
            },
            lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];

            function defaultParsingFlags() {
                // We need to deep clone this object, and es5 standard is not very
                // helpful.
                return {
                    empty : false,
                    unusedTokens : [],
                    unusedInput : [],
                    overflow : - 2,
                    charsLeftOver : 0,
                    nullInput : false,
                    invalidMonth : null,
                    invalidFormat : false,
                    userInvalidated : false,
                    iso: false
                };
            }

            function deprecate(msg, fn) {
                var firstTime = true;
                function printMsg() {
                    if (moment.suppressDeprecationWarnings === false &&
                    typeof console !== 'undefined' && console.warn) {
                        console.warn("Deprecation warning: " + msg);
                    }
                }
                return extend(function () {
                    if (firstTime) {
                        printMsg();
                        firstTime = false;
                    }
                    return fn.apply(this, arguments);
                }, fn);
            }

            function padToken(func, count) {
                return function (a) {
                    return leftZeroFill(func.call(this, a), count);
                };
            }
            function ordinalizeToken(func, period) {
                return function (a) {
                    return this.lang().ordinal(func.call(this, a), period);
                };
            }

            while (ordinalizeTokens.length) {
                i = ordinalizeTokens.pop();
                formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
            }
            while (paddedTokens.length) {
                i = paddedTokens.pop();
                formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
            }
            formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


            /************************************
                    Constructors
                ************************************/

            function Language() {
}

            // Moment prototype object
            function Moment(config) {
                checkOverflow(config);
                extend(this, config);
            }

            // Duration Constructor
            function Duration(duration) {
                var normalizedInput = normalizeObjectUnits(duration),
                years = normalizedInput.year || 0,
                quarters = normalizedInput.quarter || 0,
                months = normalizedInput.month || 0,
                weeks = normalizedInput.week || 0,
                days = normalizedInput.day || 0,
                hours = normalizedInput.hour || 0,
                minutes = normalizedInput.minute || 0,
                seconds = normalizedInput.second || 0,
                milliseconds = normalizedInput.millisecond || 0;

                // representation for dateAddRemove
                this._milliseconds = + milliseconds +
                seconds * 1e3 + // 1000
                minutes * 6e4 + // 1000 * 60
                hours * 36e5; // 1000 * 60 * 60
                // Because of dateAddRemove treats 24 hours as different from a
                // day when working around DST, we need to store them separately
                this._days = + days +
                weeks * 7;
                // It is impossible translate months into days without knowing
                // which months you are are talking about, so we have to store
                // it separately.
                this._months = + months +
                quarters * 3 +
                years * 12;

                this._data = {};

                this._bubble();
            }

            /************************************
                    Helpers
                ************************************/


            function extend(a, b) {
                for (var i in b) {
                    if (b.hasOwnProperty(i)) {
                        a[i] = b[i];
                    }
                }

                if (b.hasOwnProperty("toString")) {
                    a.toString = b.toString;
                }

                if (b.hasOwnProperty("valueOf")) {
                    a.valueOf = b.valueOf;
                }

                return a;
            }

            function cloneMoment(m) {
                var result = {}, i;
                for (i in m) {
                    if (m.hasOwnProperty(i) && momentProperties.hasOwnProperty(i)) {
                        result[i] = m[i];
                    }
                }

                return result;
            }

            function absRound(number) {
                if (number < 0) {
                    return Math.ceil(number);
                } else {
                    return Math.floor(number);
                }
            }

            // left zero fill a number
            // see http://jsperf.com/left-zero-filling for performance comparison
            function leftZeroFill(number, targetLength, forceSign) {
                var output = '' + Math.abs(number),
                sign = number >= 0;

                while (output.length < targetLength) {
                    output = '0' + output;
                }
                return (sign ? (forceSign ? '+' : '') : '-') + output;
            }

            // helper function for _.addTime and _.subtractTime
            function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
                var milliseconds = duration._milliseconds,
                days = duration._days,
                months = duration._months;
                updateOffset = updateOffset == null ? true : updateOffset;

                if (milliseconds) {
                    mom._d.setTime( + mom._d + milliseconds * isAdding);
                }
                if (days) {
                    rawSetter(mom, 'Date', rawGetter(mom, 'Date') + days * isAdding);
                }
                if (months) {
                    rawMonthSetter(mom, rawGetter(mom, 'Month') + months * isAdding);
                }
                if (updateOffset) {
                    moment.updateOffset(mom, days || months);
                }
            }

            // check if is an array
            function isArray(input) {
                return Object.prototype.toString.call(input) === '[object Array]';
            }

            function isDate(input) {
                return Object.prototype.toString.call(input) === '[object Date]' ||
                input instanceof Date;
            }

            // compare two arrays, return the number of differences
            function compareArrays(array1, array2, dontConvert) {
                var len = Math.min(array1.length, array2.length),
                lengthDiff = Math.abs(array1.length - array2.length),
                diffs = 0,
                i;
                for (i = 0; i < len; i++) {
                    if ((dontConvert && array1[i] !== array2[i]) ||
                    (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                        diffs++;
                    }
                }
                return diffs + lengthDiff;
            }

            function normalizeUnits(units) {
                if (units) {
                    var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
                    units = unitAliases[units] || camelFunctions[lowered] || lowered;
                }
                return units;
            }

            function normalizeObjectUnits(inputObject) {
                var normalizedInput = {},
                normalizedProp,
                prop;

                for (prop in inputObject) {
                    if (inputObject.hasOwnProperty(prop)) {
                        normalizedProp = normalizeUnits(prop);
                        if (normalizedProp) {
                            normalizedInput[normalizedProp] = inputObject[prop];
                        }
                    }
                }

                return normalizedInput;
            }

            function makeList(field) {
                var count, setter;

                if (field.indexOf('week') === 0) {
                    count = 7;
                    setter = 'day';
                } else if (field.indexOf('month') === 0) {
                    count = 12;
                    setter = 'month';
                } else {
                    return;
                }

                moment[field] = function (format, index) {
                    var i, getter,
                    method = moment.fn._lang[field],
                    results = [];

                    if (typeof format === 'number') {
                        index = format;
                        format = undefined;
                    }

                    getter = function (i) {
                        var m = moment().utc().set(setter, i);
                        return method.call(moment.fn._lang, m, format || '');
                    };

                    if (index != null) {
                        return getter(index);
                    } else {
                        for (i = 0; i < count; i++) {
                            results.push(getter(i));
                        }
                        return results;
                    }
                };
            }

            function toInt(argumentForCoercion) {
                var coercedNumber = + argumentForCoercion,
                value = 0;

                if (coercedNumber !== 0 && isFinite(coercedNumber)) {
                    if (coercedNumber >= 0) {
                        value = Math.floor(coercedNumber);
                    } else {
                        value = Math.ceil(coercedNumber);
                    }
                }

                return value;
            }

            function daysInMonth(year, month) {
                return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
            }

            function weeksInYear(year, dow, doy) {
                return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week;
            }

            function daysInYear(year) {
                return isLeapYear(year) ? 366 : 365;
            }

            function isLeapYear(year) {
                return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
            }

            function checkOverflow(m) {
                var overflow;
                if (m._a && m._pf.overflow === - 2) {
                    overflow =
                    m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
                    m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
                    m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR :
                    m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
                    m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
                    m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
                    - 1;

                    if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                        overflow = DATE;
                    }

                    m._pf.overflow = overflow;
                }
            }

            function isValid(m) {
                if (m._isValid == null) {
                    m._isValid = !isNaN(m._d.getTime()) &&
                    m._pf.overflow < 0 &&
                    !m._pf.empty &&
                    !m._pf.invalidMonth &&
                    !m._pf.nullInput &&
                    !m._pf.invalidFormat &&
                    !m._pf.userInvalidated;

                    if (m._strict) {
                        m._isValid = m._isValid &&
                        m._pf.charsLeftOver === 0 &&
                        m._pf.unusedTokens.length === 0;
                    }
                }
                return m._isValid;
            }

            function normalizeLanguage(key) {
                return key ? key.toLowerCase().replace('_', '-') : key;
            }

            // Return a moment from input, that is local/utc/zone equivalent to model.
            function makeAs(input, model) {
                return model._isUTC ? moment(input).zone(model._offset || 0) :
                moment(input).local();
            }

            /************************************
                    Languages
                ************************************/


            extend(Language.prototype, {

                set : function (config) {
                    var prop, i;
                    for (i in config) {
                        prop = config[i];
                        if (typeof prop === 'function') {
                            this[i] = prop;
                        } else {
                            this['_' + i] = prop;
                        }
                    }
                },

                _months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                months : function (m) {
                    return this._months[m.month()];
                },

                _monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
                monthsShort : function (m) {
                    return this._monthsShort[m.month()];
                },

                monthsParse : function (monthName) {
                    var i, mom, regex;

                    if (!this._monthsParse) {
                        this._monthsParse = [];
                    }

                    for (i = 0; i < 12; i++) {
                        // make the regex if we don't have it already
                        if (!this._monthsParse[i]) {
                            mom = moment.utc([2000, i]);
                            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                        }
                        // test the regex
                        if (this._monthsParse[i].test(monthName)) {
                            return i;
                        }
                    }
                },

                _weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                weekdays : function (m) {
                    return this._weekdays[m.day()];
                },

                _weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
                weekdaysShort : function (m) {
                    return this._weekdaysShort[m.day()];
                },

                _weekdaysMin : "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
                weekdaysMin : function (m) {
                    return this._weekdaysMin[m.day()];
                },

                weekdaysParse : function (weekdayName) {
                    var i, mom, regex;

                    if (!this._weekdaysParse) {
                        this._weekdaysParse = [];
                    }

                    for (i = 0; i < 7; i++) {
                        // make the regex if we don't have it already
                        if (!this._weekdaysParse[i]) {
                            mom = moment([2000, 1]).day(i);
                            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                        }
                        // test the regex
                        if (this._weekdaysParse[i].test(weekdayName)) {
                            return i;
                        }
                    }
                },

                _longDateFormat : {
                    LT : "h:mm A",
                    L : "MM/DD/YYYY",
                    LL : "MMMM D YYYY",
                    LLL : "MMMM D YYYY LT",
                    LLLL : "dddd, MMMM D YYYY LT"
                },
                longDateFormat : function (key) {
                    var output = this._longDateFormat[key];
                    if (!output && this._longDateFormat[key.toUpperCase()]) {
                        output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                            return val.slice(1);
                        });
                        this._longDateFormat[key] = output;
                    }
                    return output;
                },

                isPM : function (input) {
                    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
                    // Using charAt should be more compatible.
                    return ((input + '').toLowerCase().charAt(0) === 'p');
                },

                _meridiemParse : /[ap]\.?m?\.?/i,
                meridiem : function (hours, minutes, isLower) {
                    if (hours > 11) {
                        return isLower ? 'pm' : 'PM';
                    } else {
                        return isLower ? 'am' : 'AM';
                    }
                },

                _calendar : {
                    sameDay : '[Today at] LT',
                    nextDay : '[Tomorrow at] LT',
                    nextWeek : 'dddd [at] LT',
                    lastDay : '[Yesterday at] LT',
                    lastWeek : '[Last] dddd [at] LT',
                    sameElse : 'L'
                },
                calendar : function (key, mom) {
                    var output = this._calendar[key];
                    return typeof output === 'function' ? output.apply(mom) : output;
                },

                _relativeTime : {
                    future : "in %s",
                    past : "%s ago",
                    s : "a few seconds",
                    m : "a minute",
                    mm : "%d minutes",
                    h : "an hour",
                    hh : "%d hours",
                    d : "a day",
                    dd : "%d days",
                    M : "a month",
                    MM : "%d months",
                    y : "a year",
                    yy : "%d years"
                },
                relativeTime : function (number, withoutSuffix, string, isFuture) {
                    var output = this._relativeTime[string];
                    return (typeof output === 'function') ?
                    output(number, withoutSuffix, string, isFuture) :
                    output.replace(/%d/i, number);
                },
                pastFuture : function (diff, output) {
                    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
                    return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
                },

                ordinal : function (number) {
                    return this._ordinal.replace("%d", number);
                },
                _ordinal : "%d",

                preparse : function (string) {
                    return string;
                },

                postformat : function (string) {
                    return string;
                },

                week : function (mom) {
                    return weekOfYear(mom, this._week.dow, this._week.doy).week;
                },

                _week : {
                    dow : 0,
                    // Sunday is the first day of the week.
                    doy : 6 // The week that contains Jan 1st is the first week of the year.
                },

                _invalidDate: 'Invalid date',
                invalidDate: function () {
                    return this._invalidDate;
                }
            });

            // Loads a language definition into the `languages` cache.  The function
            // takes a key and optionally values.  If not in the browser and no values
            // are provided, it will load the language file module.  As a convenience,
            // this function also returns the language values.
            function loadLang(key, values) {
                values.abbr = key;
                if (!languages[key]) {
                    languages[key] = new Language();
                }
                languages[key].set(values);
                return languages[key];
            }

            // Remove a language from the `languages` cache. Mostly useful in tests.
            function unloadLang(key) {
                delete languages[key];
            }

            // Determines which language definition to use and returns it.
            //
            // With no parameters, it will return the global language.  If you
            // pass in a language key, such as 'en', it will return the
            // definition for 'en', so long as 'en' has already been loaded using
            // moment.lang.
            function getLangDefinition(key) {
                var i = 0, j, lang, next, split,
                get = function (k) {
                    if (!languages[k] && hasModule) {
                        try {
                            require('./lang/' + k);
                        } catch (e) {}
                    }
                    return languages[k];
                };

                if (!key) {
                    return moment.fn._lang;
                }

                if (!isArray(key)) {
                    //short-circuit everything else
                    lang = get(key);
                    if (lang) {
                        return lang;
                    }
                    key = [key];
                }

                //pick the language from the array
                //try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
                //substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
                while (i < key.length) {
                    split = normalizeLanguage(key[i]).split('-');
                    j = split.length;
                    next = normalizeLanguage(key[i + 1]);
                    next = next ? next.split('-') : null;
                    while (j > 0) {
                        lang = get(split.slice(0, j).join('-'));
                        if (lang) {
                            return lang;
                        }
                        if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                            //the next array item is better than a shallower substring of this one
                            break;
                        }
                        j--;
                    }
                    i++;
                }
                return moment.fn._lang;
            }

            /************************************
                    Formatting
                ************************************/


            function removeFormattingTokens(input) {
                if (input.match(/\[[\s\S]/)) {
                    return input.replace(/^\[|\]$/g, "");
                }
                return input.replace(/\\/g, "");
            }

            function makeFormatFunction(format) {
                var array = format.match(formattingTokens), i, length;

                for (i = 0, length = array.length; i < length; i++) {
                    if (formatTokenFunctions[array[i]]) {
                        array[i] = formatTokenFunctions[array[i]];
                    } else {
                        array[i] = removeFormattingTokens(array[i]);
                    }
                }

                return function (mom) {
                    var output = "";
                    for (i = 0; i < length; i++) {
                        output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
                    }
                    return output;
                };
            }

            // format date using native date object
            function formatMoment(m, format) {

                if (!m.isValid()) {
                    return m.lang().invalidDate();
                }

                format = expandFormat(format, m.lang());

                if (!formatFunctions[format]) {
                    formatFunctions[format] = makeFormatFunction(format);
                }

                return formatFunctions[format](m);
            }

            function expandFormat(format, lang) {
                var i = 5;

                function replaceLongDateFormatTokens(input) {
                    return lang.longDateFormat(input) || input;
                }

                localFormattingTokens.lastIndex = 0;
                while (i >= 0 && localFormattingTokens.test(format)) {
                    format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
                    localFormattingTokens.lastIndex = 0;
                    i -= 1;
                }

                return format;
            }


            /************************************
                    Parsing
                ************************************/


            // get the regex to find the next token
            function getParseRegexForToken(token, config) {
                var a, strict = config._strict;
                switch (token) {
                case 'Q':
                    return parseTokenOneDigit;
                case 'DDDD':
                    return parseTokenThreeDigits;
                case 'YYYY':
                case 'GGGG':
                case 'gggg':
                    return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
                case 'Y':
                case 'G':
                case 'g':
                    return parseTokenSignedNumber;
                case 'YYYYYY':
                case 'YYYYY':
                case 'GGGGG':
                case 'ggggg':
                    return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
                case 'S':
                    if (strict) {
                        return parseTokenOneDigit;
                    }
                    /* falls through */
                case 'SS':
                    if (strict) {
                        return parseTokenTwoDigits;
                    }
                    /* falls through */
                case 'SSS':
                    if (strict) {
                        return parseTokenThreeDigits;
                    }
                    /* falls through */
                case 'DDD':
                    return parseTokenOneToThreeDigits;
                case 'MMM':
                case 'MMMM':
                case 'dd':
                case 'ddd':
                case 'dddd':
                    return parseTokenWord;
                case 'a':
                case 'A':
                    return getLangDefinition(config._l)._meridiemParse;
                case 'X':
                    return parseTokenTimestampMs;
                case 'Z':
                case 'ZZ':
                    return parseTokenTimezone;
                case 'T':
                    return parseTokenT;
                case 'SSSS':
                    return parseTokenDigits;
                case 'MM':
                case 'DD':
                case 'YY':
                case 'GG':
                case 'gg':
                case 'HH':
                case 'hh':
                case 'mm':
                case 'ss':
                case 'ww':
                case 'WW':
                    return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
                case 'M':
                case 'D':
                case 'd':
                case 'H':
                case 'h':
                case 'm':
                case 's':
                case 'w':
                case 'W':
                case 'e':
                case 'E':
                    return parseTokenOneOrTwoDigits;
                case 'Do':
                    return parseTokenOrdinal;
                default :
                    a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), "i"));
                    return a;
                }
            }

            function timezoneMinutesFromString(string) {
                string = string || "";
                var possibleTzMatches = (string.match(parseTokenTimezone) || []),
                tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
                parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
                minutes = + (parts[1] * 60) + toInt(parts[2]);

                return parts[0] === '+' ? - minutes : minutes;
            }

            // function to convert string input to date
            function addTimeToArrayFromToken(token, input, config) {
                var a, datePartArray = config._a;

                switch (token) {
                    // QUARTER
                case 'Q':
                    if (input != null) {
                        datePartArray[MONTH] = (toInt(input) - 1) * 3;
                    }
                    break;
                    // MONTH
                case 'M' :
                    // fall through to MM
                case 'MM' :
                    if (input != null) {
                        datePartArray[MONTH] = toInt(input) - 1;
                    }
                    break;
                case 'MMM' :
                    // fall through to MMMM
                case 'MMMM' :
                    a = getLangDefinition(config._l).monthsParse(input);
                    // if we didn't find a month name, mark the date as invalid.
                    if (a != null) {
                        datePartArray[MONTH] = a;
                    } else {
                        config._pf.invalidMonth = input;
                    }
                    break;
                    // DAY OF MONTH
                case 'D' :
                    // fall through to DD
                case 'DD' :
                    if (input != null) {
                        datePartArray[DATE] = toInt(input);
                    }
                    break;
                case 'Do' :
                    if (input != null) {
                        datePartArray[DATE] = toInt(parseInt(input, 10));
                    }
                    break;
                    // DAY OF YEAR
                case 'DDD' :
                    // fall through to DDDD
                case 'DDDD' :
                    if (input != null) {
                        config._dayOfYear = toInt(input);
                    }

                    break;
                    // YEAR
                case 'YY' :
                    datePartArray[YEAR] = moment.parseTwoDigitYear(input);
                    break;
                case 'YYYY' :
                case 'YYYYY' :
                case 'YYYYYY' :
                    datePartArray[YEAR] = toInt(input);
                    break;
                    // AM / PM
                case 'a' :
                    // fall through to A
                case 'A' :
                    config._isPm = getLangDefinition(config._l).isPM(input);
                    break;
                    // 24 HOUR
                case 'H' :
                    // fall through to hh
                case 'HH' :
                    // fall through to hh
                case 'h' :
                    // fall through to hh
                case 'hh' :
                    datePartArray[HOUR] = toInt(input);
                    break;
                    // MINUTE
                case 'm' :
                    // fall through to mm
                case 'mm' :
                    datePartArray[MINUTE] = toInt(input);
                    break;
                    // SECOND
                case 's' :
                    // fall through to ss
                case 'ss' :
                    datePartArray[SECOND] = toInt(input);
                    break;
                    // MILLISECOND
                case 'S' :
                case 'SS' :
                case 'SSS' :
                case 'SSSS' :
                    datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
                    break;
                    // UNIX TIMESTAMP WITH MS
                case 'X':
                    config._d = new Date(parseFloat(input) * 1000);
                    break;
                    // TIMEZONE
                case 'Z' :
                    // fall through to ZZ
                case 'ZZ' :
                    config._useUTC = true;
                    config._tzm = timezoneMinutesFromString(input);
                    break;
                case 'w':
                case 'ww':
                case 'W':
                case 'WW':
                case 'd':
                case 'dd':
                case 'ddd':
                case 'dddd':
                case 'e':
                case 'E':
                    token = token.substr(0, 1);
                    /* falls through */
                case 'gg':
                case 'gggg':
                case 'GG':
                case 'GGGG':
                case 'GGGGG':
                    token = token.substr(0, 2);
                    if (input) {
                        config._w = config._w || {};
                        config._w[token] = input;
                    }
                    break;
                }
            }

            // convert an array to a date.
            // the array should mirror the parameters below
            // note: all values past the year are optional and will default to the lowest possible value.
            // [year, month, day , hour, minute, second, millisecond]
            function dateFromConfig(config) {
                var i, date, input = [], currentDate,
                yearToUse, fixYear, w, temp, lang, weekday, week;

                if (config._d) {
                    return;
                }

                currentDate = currentDateArray(config);

                //compute day of the year from weeks and weekdays
                if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
                    fixYear = function (val) {
                        var intVal = parseInt(val, 10);
                        return val ?
                        (val.length < 3 ? (intVal > 68 ? 1900 + intVal : 2000 + intVal) : intVal) :
                        (config._a[YEAR] == null ? moment().weekYear() : config._a[YEAR]);
                    };

                    w = config._w;
                    if (w.GG != null || w.W != null || w.E != null) {
                        temp = dayOfYearFromWeeks(fixYear(w.GG), w.W || 1, w.E, 4, 1);
                    } else {
                        lang = getLangDefinition(config._l);
                        weekday = w.d != null ? parseWeekday(w.d, lang) :
                        (w.e != null ? parseInt(w.e, 10) + lang._week.dow : 0);

                        week = parseInt(w.w, 10) || 1;

                        //if we're parsing 'd', then the low day numbers may be next week
                        if (w.d != null && weekday < lang._week.dow) {
                            week++;
                        }

                        temp = dayOfYearFromWeeks(fixYear(w.gg), week, weekday, lang._week.doy, lang._week.dow);
                    }

                    config._a[YEAR] = temp.year;
                    config._dayOfYear = temp.dayOfYear;
                }

                //if the day of the year is set, figure out what it is
                if (config._dayOfYear) {
                    yearToUse = config._a[YEAR] == null ? currentDate[YEAR] : config._a[YEAR];

                    if (config._dayOfYear > daysInYear(yearToUse)) {
                        config._pf._overflowDayOfYear = true;
                    }

                    date = makeUTCDate(yearToUse, 0, config._dayOfYear);
                    config._a[MONTH] = date.getUTCMonth();
                    config._a[DATE] = date.getUTCDate();
                }

                // Default to current date.
                // * if no year, month, day of month are given, default to today
                // * if day of month is given, default month and year
                // * if month is given, default only year
                // * if year is given, don't default anything
                for (i = 0; i < 3 && config._a[i] == null; ++i) {
                    config._a[i] = input[i] = currentDate[i];
                }

                // Zero out whatever was not defaulted, including time
                for (; i < 7; i++) {
                    config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
                }

                // add the offsets to the time to be parsed so that we can have a clean array for checking isValid
                input[HOUR] += toInt((config._tzm || 0) / 60);
                input[MINUTE] += toInt((config._tzm || 0) % 60);

                config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
            }

            function dateFromObject(config) {
                var normalizedInput;

                if (config._d) {
                    return;
                }

                normalizedInput = normalizeObjectUnits(config._i);
                config._a = [
                normalizedInput.year,
                normalizedInput.month,
                normalizedInput.day,
                normalizedInput.hour,
                normalizedInput.minute,
                normalizedInput.second,
                normalizedInput.millisecond
                ];

                dateFromConfig(config);
            }

            function currentDateArray(config) {
                var now = new Date();
                if (config._useUTC) {
                    return [
                    now.getUTCFullYear(),
                    now.getUTCMonth(),
                    now.getUTCDate()
                    ];
                } else {
                    return [now.getFullYear(), now.getMonth(), now.getDate()];
                }
            }

            // date from string and format string
            function makeDateFromStringAndFormat(config) {

                config._a = [];
                config._pf.empty = true;

                // This array is used to make a Date, either with `new Date` or `Date.UTC`
                var lang = getLangDefinition(config._l),
                string = '' + config._i,
                i, parsedInput, tokens, token, skipped,
                stringLength = string.length,
                totalParsedInputLength = 0;

                tokens = expandFormat(config._f, lang).match(formattingTokens) || [];

                for (i = 0; i < tokens.length; i++) {
                    token = tokens[i];
                    parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
                    if (parsedInput) {
                        skipped = string.substr(0, string.indexOf(parsedInput));
                        if (skipped.length > 0) {
                            config._pf.unusedInput.push(skipped);
                        }
                        string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                        totalParsedInputLength += parsedInput.length;
                    }
                    // don't parse if it's not a known token
                    if (formatTokenFunctions[token]) {
                        if (parsedInput) {
                            config._pf.empty = false;
                        } else {
                            config._pf.unusedTokens.push(token);
                        }
                        addTimeToArrayFromToken(token, parsedInput, config);
                    } else if (config._strict && !parsedInput) {
                        config._pf.unusedTokens.push(token);
                    }
                }

                // add remaining unparsed input length to the string
                config._pf.charsLeftOver = stringLength - totalParsedInputLength;
                if (string.length > 0) {
                    config._pf.unusedInput.push(string);
                }

                // handle am pm
                if (config._isPm && config._a[HOUR] < 12) {
                    config._a[HOUR] += 12;
                }
                // if is 12 am, change hours to 0
                if (config._isPm === false && config._a[HOUR] === 12) {
                    config._a[HOUR] = 0;
                }

                dateFromConfig(config);
                checkOverflow(config);
            }

            function unescapeFormat(s) {
                return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
                    return p1 || p2 || p3 || p4;
                });
            }

            // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
            function regexpEscape(s) {
                return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
            }

            // date from string and array of format strings
            function makeDateFromStringAndArray(config) {
                var tempConfig,
                bestMoment,
                scoreToBeat,
                i,
                currentScore;

                if (config._f.length === 0) {
                    config._pf.invalidFormat = true;
                    config._d = new Date(NaN);
                    return;
                }

                for (i = 0; i < config._f.length; i++) {
                    currentScore = 0;
                    tempConfig = extend({}, config);
                    tempConfig._pf = defaultParsingFlags();
                    tempConfig._f = config._f[i];
                    makeDateFromStringAndFormat(tempConfig);

                    if (!isValid(tempConfig)) {
                        continue;
                    }

                    // if there is any input that was not parsed add a penalty for that format
                    currentScore += tempConfig._pf.charsLeftOver;

                    //or tokens
                    currentScore += tempConfig._pf.unusedTokens.length * 10;

                    tempConfig._pf.score = currentScore;

                    if (scoreToBeat == null || currentScore < scoreToBeat) {
                        scoreToBeat = currentScore;
                        bestMoment = tempConfig;
                    }
                }

                extend(config, bestMoment || tempConfig);
            }

            // date from iso format
            function makeDateFromString(config) {
                var i, l,
                string = config._i,
                match = isoRegex.exec(string);

                if (match) {
                    config._pf.iso = true;
                    for (i = 0, l = isoDates.length; i < l; i++) {
                        if (isoDates[i][1].exec(string)) {
                            // match[5] should be "T" or undefined
                            config._f = isoDates[i][0] + (match[6] || " ");
                            break;
                        }
                    }
                    for (i = 0, l = isoTimes.length; i < l; i++) {
                        if (isoTimes[i][1].exec(string)) {
                            config._f += isoTimes[i][0];
                            break;
                        }
                    }
                    if (string.match(parseTokenTimezone)) {
                        config._f += "Z";
                    }
                    makeDateFromStringAndFormat(config);
                } else {
                    moment.createFromInputFallback(config);
                }
            }

            function makeDateFromInput(config) {
                var input = config._i,
                matched = aspNetJsonRegex.exec(input);

                if (input === undefined) {
                    config._d = new Date();
                } else if (matched) {
                    config._d = new Date( + matched[1]);
                } else if (typeof input === 'string') {
                    makeDateFromString(config);
                } else if (isArray(input)) {
                    config._a = input.slice(0);
                    dateFromConfig(config);
                } else if (isDate(input)) {
                    config._d = new Date( + input);
                } else if (typeof(input) === 'object') {
                    dateFromObject(config);
                } else if (typeof(input) === 'number') {
                    // from milliseconds
                    config._d = new Date(input);
                } else {
                    moment.createFromInputFallback(config);
                }
            }

            function makeDate(y, m, d, h, M, s, ms) {
                //can't just apply() to create a date:
                //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
                var date = new Date(y, m, d, h, M, s, ms);

                //the date constructor doesn't accept years < 1970
                if (y < 1970) {
                    date.setFullYear(y);
                }
                return date;
            }

            function makeUTCDate(y) {
                var date = new Date(Date.UTC.apply(null, arguments));
                if (y < 1970) {
                    date.setUTCFullYear(y);
                }
                return date;
            }

            function parseWeekday(input, language) {
                if (typeof input === 'string') {
                    if (!isNaN(input)) {
                        input = parseInt(input, 10);
                    } else {
                        input = language.weekdaysParse(input);
                        if (typeof input !== 'number') {
                            return null;
                        }
                    }
                }
                return input;
            }

            /************************************
                    Relative Time
                ************************************/


            // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
            function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
                return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
            }

            function relativeTime(milliseconds, withoutSuffix, lang) {
                var seconds = round(Math.abs(milliseconds) / 1000),
                minutes = round(seconds / 60),
                hours = round(minutes / 60),
                days = round(hours / 24),
                years = round(days / 365),
                args = seconds < 45 && ['s', seconds] ||
                minutes === 1 && ['m'] ||
                minutes < 45 && ['mm', minutes] ||
                hours === 1 && ['h'] ||
                hours < 22 && ['hh', hours] ||
                days === 1 && ['d'] ||
                days <= 25 && ['dd', days] ||
                days <= 45 && ['M'] ||
                days < 345 && ['MM', round(days / 30)] ||
                years === 1 && ['y'] || ['yy', years];
                args[2] = withoutSuffix;
                args[3] = milliseconds > 0;
                args[4] = lang;
                return substituteTimeAgo.apply({}, args);
            }


            /************************************
                    Week of Year
                ************************************/


            // firstDayOfWeek       0 = sun, 6 = sat
            //                      the day of the week that starts the week
            //                      (usually sunday or monday)
            // firstDayOfWeekOfYear 0 = sun, 6 = sat
            //                      the first week is the week that contains the first
            //                      of this day of the week
            //                      (eg. ISO weeks use thursday (4))
            function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
                var end = firstDayOfWeekOfYear - firstDayOfWeek,
                daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
                adjustedMoment;


                if (daysToDayOfWeek > end) {
                    daysToDayOfWeek -= 7;
                }

                if (daysToDayOfWeek < end - 7) {
                    daysToDayOfWeek += 7;
                }

                adjustedMoment = moment(mom).add('d', daysToDayOfWeek);
                return {
                    week: Math.ceil(adjustedMoment.dayOfYear() / 7),
                    year: adjustedMoment.year()
                };
            }

            //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
            function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
                var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;

                weekday = weekday != null ? weekday : firstDayOfWeek;
                daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
                dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

                return {
                    year: dayOfYear > 0 ? year : year - 1,
                    dayOfYear: dayOfYear > 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear
                };
            }

            /************************************
                    Top Level Functions
                ************************************/

            function makeMoment(config) {
                var input = config._i,
                format = config._f;

                if (input === null || (format === undefined && input === '')) {
                    return moment.invalid({
                        nullInput: true
                    });
                }

                if (typeof input === 'string') {
                    config._i = input = getLangDefinition().preparse(input);
                }

                if (moment.isMoment(input)) {
                    config = cloneMoment(input);

                    config._d = new Date( + input._d);
                } else if (format) {
                    if (isArray(format)) {
                        makeDateFromStringAndArray(config);
                    } else {
                        makeDateFromStringAndFormat(config);
                    }
                } else {
                    makeDateFromInput(config);
                }

                return new Moment(config);
            }

            moment = function (input, format, lang, strict) {
                var c;

                if (typeof(lang) === "boolean") {
                    strict = lang;
                    lang = undefined;
                }
                // object construction must be done this way.
                // https://github.com/moment/moment/issues/1423
                c = {};
                c._isAMomentObject = true;
                c._i = input;
                c._f = format;
                c._l = lang;
                c._strict = strict;
                c._isUTC = false;
                c._pf = defaultParsingFlags();

                return makeMoment(c);
            };

            moment.suppressDeprecationWarnings = false;

            moment.createFromInputFallback = deprecate(
            "moment construction falls back to js Date. This is " +
            "discouraged and will be removed in upcoming major " +
            "release. Please refer to " +
            "https://github.com/moment/moment/issues/1407 for more info.",
            function (config) {
                config._d = new Date(config._i);
            });

            // creating with utc
            moment.utc = function (input, format, lang, strict) {
                var c;

                if (typeof(lang) === "boolean") {
                    strict = lang;
                    lang = undefined;
                }
                // object construction must be done this way.
                // https://github.com/moment/moment/issues/1423
                c = {};
                c._isAMomentObject = true;
                c._useUTC = true;
                c._isUTC = true;
                c._l = lang;
                c._i = input;
                c._f = format;
                c._strict = strict;
                c._pf = defaultParsingFlags();

                return makeMoment(c).utc();
            };

            // creating with unix timestamp (in seconds)
            moment.unix = function (input) {
                return moment(input * 1000);
            };

            // duration
            moment.duration = function (input, key) {
                var duration = input,
                // matching against regexp is expensive, do it on demand
                match = null,
                sign,
                ret,
                parseIso;

                if (moment.isDuration(input)) {
                    duration = {
                        ms: input._milliseconds,
                        d: input._days,
                        M: input._months
                    };
                } else if (typeof input === 'number') {
                    duration = {};
                    if (key) {
                        duration[key] = input;
                    } else {
                        duration.milliseconds = input;
                    }
                } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
                    sign = (match[1] === "-") ? - 1 : 1;
                    duration = {
                        y: 0,
                        d: toInt(match[DATE]) * sign,
                        h: toInt(match[HOUR]) * sign,
                        m: toInt(match[MINUTE]) * sign,
                        s: toInt(match[SECOND]) * sign,
                        ms: toInt(match[MILLISECOND]) * sign
                    };
                } else if (!!(match = isoDurationRegex.exec(input))) {
                    sign = (match[1] === "-") ? - 1 : 1;
                    parseIso = function (inp) {
                        // We'd normally use ~~inp for this, but unfortunately it also
                        // converts floats to ints.
                        // inp may be undefined, so careful calling replace on it.
                        var res = inp && parseFloat(inp.replace(',', '.'));
                        // apply sign while we're at it
                        return (isNaN(res) ? 0 : res) * sign;
                    };
                    duration = {
                        y: parseIso(match[2]),
                        M: parseIso(match[3]),
                        d: parseIso(match[4]),
                        h: parseIso(match[5]),
                        m: parseIso(match[6]),
                        s: parseIso(match[7]),
                        w: parseIso(match[8])
                    };
                }

                ret = new Duration(duration);

                if (moment.isDuration(input) && input.hasOwnProperty('_lang')) {
                    ret._lang = input._lang;
                }

                return ret;
            };

            // version number
            moment.version = VERSION;

            // default format
            moment.defaultFormat = isoFormat;

            // Plugins that add properties should also add the key here (null value),
            // so we can properly clone ourselves.
            moment.momentProperties = momentProperties;

            // This function will be called whenever a moment is mutated.
            // It is intended to keep the offset in sync with the timezone.
            moment.updateOffset = function () {};

            // This function will load languages and then set the global language.  If
            // no arguments are passed in, it will simply return the current global
            // language key.
            moment.lang = function (key, values) {
                var r;
                if (!key) {
                    return moment.fn._lang._abbr;
                }
                if (values) {
                    loadLang(normalizeLanguage(key), values);
                } else if (values === null) {
                    unloadLang(key);
                    key = 'en';
                } else if (!languages[key]) {
                    getLangDefinition(key);
                }
                r = moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key);
                return r._abbr;
            };

            // returns language data
            moment.langData = function (key) {
                if (key && key._lang && key._lang._abbr) {
                    key = key._lang._abbr;
                }
                return getLangDefinition(key);
            };

            // compare moment object
            moment.isMoment = function (obj) {
                return obj instanceof Moment ||
                (obj != null && obj.hasOwnProperty('_isAMomentObject'));
            };

            // for typechecking Duration objects
            moment.isDuration = function (obj) {
                return obj instanceof Duration;
            };

            for (i = lists.length - 1; i >= 0; --i) {
                makeList(lists[i]);
            }

            moment.normalizeUnits = function (units) {
                return normalizeUnits(units);
            };

            moment.invalid = function (flags) {
                var m = moment.utc(NaN);
                if (flags != null) {
                    extend(m._pf, flags);
                } else {
                    m._pf.userInvalidated = true;
                }

                return m;
            };

            moment.parseZone = function () {
                return moment.apply(null, arguments).parseZone();
            };

            moment.parseTwoDigitYear = function (input) {
                return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
            };

            /************************************
                    Moment Prototype
                ************************************/


            extend(moment.fn = Moment.prototype, {

                clone : function () {
                    return moment(this);
                },

                valueOf : function () {
                    return + this._d + ((this._offset || 0) * 60000);
                },

                unix : function () {
                    return Math.floor( + this / 1000);
                },

                toString : function () {
                    return this.clone().lang('en').format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
                },

                toDate : function () {
                    return this._offset ? new Date( + this) : this._d;
                },

                toISOString : function () {
                    var m = moment(this).utc();
                    if (0 < m.year() && m.year() <= 9999) {
                        return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
                    } else {
                        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
                    }
                },

                toArray : function () {
                    var m = this;
                    return [
                    m.year(),
                    m.month(),
                    m.date(),
                    m.hours(),
                    m.minutes(),
                    m.seconds(),
                    m.milliseconds()
                    ];
                },

                isValid : function () {
                    return isValid(this);
                },

                isDSTShifted : function () {

                    if (this._a) {
                        return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
                    }

                    return false;
                },

                parsingFlags : function () {
                    return extend({}, this._pf);
                },

                invalidAt: function () {
                    return this._pf.overflow;
                },

                utc : function () {
                    return this.zone(0);
                },

                local : function () {
                    this.zone(0);
                    this._isUTC = false;
                    return this;
                },

                format : function (inputString) {
                    var output = formatMoment(this, inputString || moment.defaultFormat);
                    return this.lang().postformat(output);
                },

                add : function (input, val) {
                    var dur;
                    // switch args to support add('s', 1) and add(1, 's')
                    if (typeof input === 'string') {
                        dur = moment.duration( + val, input);
                    } else {
                        dur = moment.duration(input, val);
                    }
                    addOrSubtractDurationFromMoment(this, dur, 1);
                    return this;
                },

                subtract : function (input, val) {
                    var dur;
                    // switch args to support subtract('s', 1) and subtract(1, 's')
                    if (typeof input === 'string') {
                        dur = moment.duration( + val, input);
                    } else {
                        dur = moment.duration(input, val);
                    }
                    addOrSubtractDurationFromMoment(this, dur, - 1);
                    return this;
                },

                diff : function (input, units, asFloat) {
                    var that = makeAs(input, this),
                    zoneDiff = (this.zone() - that.zone()) * 6e4,
                    diff, output;

                    units = normalizeUnits(units);

                    if (units === 'year' || units === 'month') {
                        // average number of days in the months in the given dates
                        diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
                        // difference in months
                        output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
                        // adjust by taking difference in days, average number of days
                        // and dst in the given months.
                        output += ((this - moment(this).startOf('month')) -
                        (that - moment(that).startOf('month'))) / diff;
                        // same as above but with zones, to negate all dst
                        output -= ((this.zone() - moment(this).startOf('month').zone()) -
                        (that.zone() - moment(that).startOf('month').zone())) * 6e4 / diff;
                        if (units === 'year') {
                            output = output / 12;
                        }
                    } else {
                        diff = (this - that);
                        output = units === 'second' ? diff / 1e3 : // 1000
                        units === 'minute' ? diff / 6e4 : // 1000 * 60
                        units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
                        units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                        units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                        diff;
                    }
                    return asFloat ? output : absRound(output);
                },

                from : function (time, withoutSuffix) {
                    return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix);
                },

                fromNow : function (withoutSuffix) {
                    return this.from(moment(), withoutSuffix);
                },

                calendar : function () {
                    // We want to compare the start of today, vs this.
                    // Getting start-of-today depends on whether we're zone'd or not.
                    var sod = makeAs(moment(), this).startOf('day'),
                    diff = this.diff(sod, 'days', true),
                    format = diff < - 6 ? 'sameElse' :
                    diff < - 1 ? 'lastWeek' :
                    diff < 0 ? 'lastDay' :
                    diff < 1 ? 'sameDay' :
                    diff < 2 ? 'nextDay' :
                    diff < 7 ? 'nextWeek' : 'sameElse';
                    return this.format(this.lang().calendar(format, this));
                },

                isLeapYear : function () {
                    return isLeapYear(this.year());
                },

                isDST : function () {
                    return (this.zone() < this.clone().month(0).zone() ||
                    this.zone() < this.clone().month(5).zone());
                },

                day : function (input) {
                    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
                    if (input != null) {
                        input = parseWeekday(input, this.lang());
                        return this.add({
                            d : input - day 
                        });
                    } else {
                        return day;
                    }
                },

                month : makeAccessor('Month', true),

                startOf: function (units) {
                    units = normalizeUnits(units);
                    // the following switch intentionally omits break keywords
                    // to utilize falling through the cases.
                    switch (units) {
                    case 'year':
                        this.month(0);
                        /* falls through */
                    case 'quarter':
                    case 'month':
                        this.date(1);
                        /* falls through */
                    case 'week':
                    case 'isoWeek':
                    case 'day':
                        this.hours(0);
                        /* falls through */
                    case 'hour':
                        this.minutes(0);
                        /* falls through */
                    case 'minute':
                        this.seconds(0);
                        /* falls through */
                    case 'second':
                        this.milliseconds(0);
                        /* falls through */
                    }

                    // weeks are a special case
                    if (units === 'week') {
                        this.weekday(0);
                    } else if (units === 'isoWeek') {
                        this.isoWeekday(1);
                    }

                    // quarters are also special
                    if (units === 'quarter') {
                        this.month(Math.floor(this.month() / 3) * 3);
                    }

                    return this;
                },

                endOf: function (units) {
                    units = normalizeUnits(units);
                    return this.startOf(units).add((units === 'isoWeek' ? 'week' : units), 1).subtract('ms', 1);
                },

                isAfter: function (input, units) {
                    units = typeof units !== 'undefined' ? units : 'millisecond';
                    return + this.clone().startOf(units) > + moment(input).startOf(units);
                },

                isBefore: function (input, units) {
                    units = typeof units !== 'undefined' ? units : 'millisecond';
                    return + this.clone().startOf(units) < + moment(input).startOf(units);
                },

                isSame: function (input, units) {
                    units = units || 'ms';
                    return + this.clone().startOf(units) === + makeAs(input, this).startOf(units);
                },

                min: function (other) {
                    other = moment.apply(null, arguments);
                    return other < this ? this : other;
                },

                max: function (other) {
                    other = moment.apply(null, arguments);
                    return other > this ? this : other;
                },

                // keepTime = true means only change the timezone, without affecting
                // the local hour. So 5:31:26 +0300 --[zone(2, true)]--> 5:31:26 +0200
                // It is possible that 5:31:26 doesn't exist int zone +0200, so we
                // adjust the time as needed, to be valid.
                //
                // Keeping the time actually adds/subtracts (one hour)
                // from the actual represented time. That is why we call updateOffset
                // a second time. In case it wants us to change the offset again
                // _changeInProgress == true case, then we have to adjust, because
                // there is no such time in the given timezone.
                zone : function (input, keepTime) {
                    var offset = this._offset || 0;
                    if (input != null) {
                        if (typeof input === "string") {
                            input = timezoneMinutesFromString(input);
                        }
                        if (Math.abs(input) < 16) {
                            input = input * 60;
                        }
                        this._offset = input;
                        this._isUTC = true;
                        if (offset !== input) {
                            if (!keepTime || this._changeInProgress) {
                                addOrSubtractDurationFromMoment(this,
                                moment.duration(offset - input, 'm'), 1, false);
                            } else if (!this._changeInProgress) {
                                this._changeInProgress = true;
                                moment.updateOffset(this, true);
                                this._changeInProgress = null;
                            }
                        }
                    } else {
                        return this._isUTC ? offset : this._d.getTimezoneOffset();
                    }
                    return this;
                },

                zoneAbbr : function () {
                    return this._isUTC ? "UTC" : "";
                },

                zoneName : function () {
                    return this._isUTC ? "Coordinated Universal Time" : "";
                },

                parseZone : function () {
                    if (this._tzm) {
                        this.zone(this._tzm);
                    } else if (typeof this._i === 'string') {
                        this.zone(this._i);
                    }
                    return this;
                },

                hasAlignedHourOffset : function (input) {
                    if (!input) {
                        input = 0;
                    } else {
                        input = moment(input).zone();
                    }

                    return (this.zone() - input) % 60 === 0;
                },

                daysInMonth : function () {
                    return daysInMonth(this.year(), this.month());
                },

                dayOfYear : function (input) {
                    var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
                    return input == null ? dayOfYear : this.add("d", (input - dayOfYear));
                },

                quarter : function (input) {
                    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
                },

                weekYear : function (input) {
                    var year = weekOfYear(this, this.lang()._week.dow, this.lang()._week.doy).year;
                    return input == null ? year : this.add("y", (input - year));
                },

                isoWeekYear : function (input) {
                    var year = weekOfYear(this, 1, 4).year;
                    return input == null ? year : this.add("y", (input - year));
                },

                week : function (input) {
                    var week = this.lang().week(this);
                    return input == null ? week : this.add("d", (input - week) * 7);
                },

                isoWeek : function (input) {
                    var week = weekOfYear(this, 1, 4).week;
                    return input == null ? week : this.add("d", (input - week) * 7);
                },

                weekday : function (input) {
                    var weekday = (this.day() + 7 - this.lang()._week.dow) % 7;
                    return input == null ? weekday : this.add("d", input - weekday);
                },

                isoWeekday : function (input) {
                    // behaves the same as moment#day except
                    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
                    // as a setter, sunday should belong to the previous week.
                    return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
                },

                isoWeeksInYear : function () {
                    return weeksInYear(this.year(), 1, 4);
                },

                weeksInYear : function () {
                    var weekInfo = this._lang._week;
                    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
                },

                get : function (units) {
                    units = normalizeUnits(units);
                    return this[units]();
                },

                set : function (units, value) {
                    units = normalizeUnits(units);
                    if (typeof this[units] === 'function') {
                        this[units](value);
                    }
                    return this;
                },

                // If passed a language key, it will set the language for this
                // instance.  Otherwise, it will return the language configuration
                // variables for this instance.
                lang : function (key) {
                    if (key === undefined) {
                        return this._lang;
                    } else {
                        this._lang = getLangDefinition(key);
                        return this;
                    }
                }
            });

            function rawMonthSetter(mom, value) {
                var dayOfMonth;

                // TODO: Move this out of here!
                if (typeof value === 'string') {
                    value = mom.lang().monthsParse(value);
                    // TODO: Another silent failure?
                    if (typeof value !== 'number') {
                        return mom;
                    }
                }

                dayOfMonth = Math.min(mom.date(),
                daysInMonth(mom.year(), value));
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
                return mom;
            }

            function rawGetter(mom, unit) {
                return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
            }

            function rawSetter(mom, unit, value) {
                if (unit === 'Month') {
                    return rawMonthSetter(mom, value);
                } else {
                    return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
                }
            }

            function makeAccessor(unit, keepTime) {
                return function (value) {
                    if (value != null) {
                        rawSetter(this, unit, value);
                        moment.updateOffset(this, keepTime);
                        return this;
                    } else {
                        return rawGetter(this, unit);
                    }
                };
            }

            moment.fn.millisecond = moment.fn.milliseconds = makeAccessor('Milliseconds', false);
            moment.fn.second = moment.fn.seconds = makeAccessor('Seconds', false);
            moment.fn.minute = moment.fn.minutes = makeAccessor('Minutes', false);
            // Setting the hour should keep the time, because the user explicitly
            // specified which hour he wants. So trying to maintain the same hour (in
            // a new timezone) makes sense. Adding/subtracting hours does not follow
            // this rule.
            moment.fn.hour = moment.fn.hours = makeAccessor('Hours', true);
            // moment.fn.month is defined separately
            moment.fn.date = makeAccessor('Date', true);
            moment.fn.dates = deprecate("dates accessor is deprecated. Use date instead.", makeAccessor('Date', true));
            moment.fn.year = makeAccessor('FullYear', true);
            moment.fn.years = deprecate("years accessor is deprecated. Use year instead.", makeAccessor('FullYear', true));

            // add plural methods
            moment.fn.days = moment.fn.day;
            moment.fn.months = moment.fn.month;
            moment.fn.weeks = moment.fn.week;
            moment.fn.isoWeeks = moment.fn.isoWeek;
            moment.fn.quarters = moment.fn.quarter;

            // add aliased format methods
            moment.fn.toJSON = moment.fn.toISOString;

            /************************************
                    Duration Prototype
                ************************************/


            extend(moment.duration.fn = Duration.prototype, {

                _bubble : function () {
                    var milliseconds = this._milliseconds,
                    days = this._days,
                    months = this._months,
                    data = this._data,
                    seconds, minutes, hours, years;

                    // The following code bubbles up values, see the tests for
                    // examples of what that means.
                    data.milliseconds = milliseconds % 1000;

                    seconds = absRound(milliseconds / 1000);
                    data.seconds = seconds % 60;

                    minutes = absRound(seconds / 60);
                    data.minutes = minutes % 60;

                    hours = absRound(minutes / 60);
                    data.hours = hours % 24;

                    days += absRound(hours / 24);
                    data.days = days % 30;

                    months += absRound(days / 30);
                    data.months = months % 12;

                    years = absRound(months / 12);
                    data.years = years;
                },

                weeks : function () {
                    return absRound(this.days() / 7);
                },

                valueOf : function () {
                    return this._milliseconds +
                    this._days * 864e5 +
                    (this._months % 12) * 2592e6 +
                    toInt(this._months / 12) * 31536e6;
                },

                humanize : function (withSuffix) {
                    var difference = + this,
                    output = relativeTime(difference, !withSuffix, this.lang());

                    if (withSuffix) {
                        output = this.lang().pastFuture(difference, output);
                    }

                    return this.lang().postformat(output);
                },

                add : function (input, val) {
                    // supports only 2.0-style add(1, 's') or add(moment)
                    var dur = moment.duration(input, val);

                    this._milliseconds += dur._milliseconds;
                    this._days += dur._days;
                    this._months += dur._months;

                    this._bubble();

                    return this;
                },

                subtract : function (input, val) {
                    var dur = moment.duration(input, val);

                    this._milliseconds -= dur._milliseconds;
                    this._days -= dur._days;
                    this._months -= dur._months;

                    this._bubble();

                    return this;
                },

                get : function (units) {
                    units = normalizeUnits(units);
                    return this[units.toLowerCase() + 's']();
                },

                as : function (units) {
                    units = normalizeUnits(units);
                    return this['as' + units.charAt(0).toUpperCase() + units.slice(1) + 's']();
                },

                lang : moment.fn.lang,

                toIsoString : function () {
                    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
                    var years = Math.abs(this.years()),
                    months = Math.abs(this.months()),
                    days = Math.abs(this.days()),
                    hours = Math.abs(this.hours()),
                    minutes = Math.abs(this.minutes()),
                    seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);

                    if (!this.asSeconds()) {
                        // this is the same as C#'s (Noda) and python (isodate)...
                        // but not other JS (goog.date)
                        return 'P0D';
                    }

                    return (this.asSeconds() < 0 ? '-' : '') +
                    'P' +
                    (years ? years + 'Y' : '') +
                    (months ? months + 'M' : '') +
                    (days ? days + 'D' : '') +
                    ((hours || minutes || seconds) ? 'T' : '') +
                    (hours ? hours + 'H' : '') +
                    (minutes ? minutes + 'M' : '') +
                    (seconds ? seconds + 'S' : '');
                }
            });

            function makeDurationGetter(name) {
                moment.duration.fn[name] = function () {
                    return this._data[name];
                };
            }

            function makeDurationAsGetter(name, factor) {
                moment.duration.fn['as' + name] = function () {
                    return + this / factor;
                };
            }

            for (i in unitMillisecondFactors) {
                if (unitMillisecondFactors.hasOwnProperty(i)) {
                    makeDurationAsGetter(i, unitMillisecondFactors[i]);
                    makeDurationGetter(i.toLowerCase());
                }
            }

            makeDurationAsGetter('Weeks', 6048e5);
            moment.duration.fn.asMonths = function () {
                return ( + this - this.years() * 31536e6) / 2592e6 + this.years() * 12;
            };


            /************************************
                    Default Lang
                ************************************/


            // Set default language, other languages will inherit from English.
            moment.lang('en', {
                ordinal : function (number) {
                    var b = number % 10,
                    output = (toInt(number % 100 / 10) === 1) ? 'th' :
                    (b === 1) ? 'st' :
                    (b === 2) ? 'nd' :
                    (b === 3) ? 'rd' : 'th';
                    return number + output;
                }
            });

            /* EMBED_LANGUAGES */

            /************************************
                    Exposing Moment
                ************************************/

            function makeGlobal(shouldDeprecate) {
                /*global ender:false */
                if (typeof ender !== 'undefined') {
                    return;
                }
                oldGlobalMoment = globalScope.moment;
                if (shouldDeprecate) {
                    globalScope.moment = deprecate(
                    "Accessing Moment through the global scope is " +
                    "deprecated, and will be removed in an upcoming " +
                    "release.",
                    moment);
                } else {
                    globalScope.moment = moment;
                }
            }

            // CommonJS module is defined
            if (hasModule) {
                module.exports = moment;
            } else if (typeof define === "function" && define.amd) {
                define("moment", function (require, exports, module) {
                    if (module.config && module.config() && module.config().noGlobal === true) {
                        // release the global variable
                        globalScope.moment = oldGlobalMoment;
                    }

                    return moment;
                });
                makeGlobal(true);
            } else {
                makeGlobal();
            }
        }).call(this);

    }, {}
    ],
    274: [function(require, module, exports) {
        var global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
        !function(a) {
            "object" == typeof exports ? module.exports = a() : "function" == typeof define && define.amd ? define(a) : "undefined" != typeof window ? window.storage = a() : "undefined" != typeof global ? global.storage = a() : "undefined" != typeof self && (self.storage = a())
        }(function() {
            return function a(b, c, d) {
                function e(g, h) {
                    if (!c[g]) {
                        if (!b[g]) {
                            var i = "function" == typeof require && require;
                            if (!h && i)
                                return i(g, !0);
                            if (f)
                                return f(g, !0);
                            throw new Error("Cannot find module '" + g + "'")
                        }
                        var j = c[g] = {
                            exports: {}
                        };
                        b[g][0].call(j.exports, function(a) {
                            var c = b[g][1][a];
                            return e(c ? c : a)
                        }, j, j.exports, a, b, c, d)
                    }
                    return c[g].exports
                }
                for (var f = "function" == typeof require && require, g = 0; g < d.length; g++)
                    e(d[g]);
                return e
            }({
                1: [function(a, b) {
                    /*!
                    Copyright (c) 2013 Derek Petersen https://github.com/tuxracer/simple-storage MIT Licensed
                    */
                    var c, d, e, f, g;
                    try {
                        window.localStorage.setItem("simple-storage-test", !0), window.localStorage.removeItem("simple-storage-test"), d=!0
                    } catch (h) {
                        c = h, d=!1
                    }
                    d ? f = window : (g = {
                        local: {},
                        session: {}
                    }, f = {
                        localStorage: {
                            setItem: function(a, b) {
                                return g.local[a] = b
                            },
                            getItem: function(a) {
                                return g.local[a]
                            },
                            removeItem: function(a) {
                                return delete g.local[a]
                            },
                            clear: function() {
                                return g.local = {}
                            }
                        },
                        sessionStorage: {
                            setItem: function(a, b) {
                                return g.session[a] = b
                            },
                            getItem: function(a) {
                                return g.session[a]
                            },
                            removeItem: function(a) {
                                return delete g.session[a]
                            },
                            clear: function() {
                                return g.session = {}
                            }
                        }
                    }), e = function(a) {
                        return "session" !== a && (a = "local"), f[a + "Storage"]
                    }, b.exports = {
                        nativeStorage: d,
                        set: function(a, b, c) {
                            if ("function" == typeof b)
                                throw new TypeError("Cannot store functions");
                            return "object" == typeof b && (b = JSON.stringify(b)), e(c).setItem(a, b)
                        },
                        get: function(a, b) {
                            var d;
                            if (null == a)
                                return null;
                            d = e(b).getItem(a);
                            try {
                                return JSON.parse(d)
                            } catch (f) {
                                return c = f, d
                            }
                        },
                        remove: function(a, b) {
                            if (null == a)
                                throw new Error("Not enough arguments");
                            return e(b).removeItem(a)
                        },
                        clear: function(a) {
                            return e(a).clear()
                        }
                    }
                }, {}
                ]
            }, {}, [1])(1)
        });
    }, {}
    ],
    275: [function(require, module, exports) {
        //  Underscore.string
        //  (c) 2010 Esa-Matti Suuronen <esa-matti aet suuronen dot org>
        //  Underscore.string is freely distributable under the terms of the MIT license.
        //  Documentation: https://github.com/epeli/underscore.string
        //  Some code is borrowed from MooTools and Alexandru Marasteanu.
        //  Version '2.3.2'

        !function(root, String) {
            'use strict';

            // Defining helper functions.

            var nativeTrim = String.prototype.trim;
            var nativeTrimRight = String.prototype.trimRight;
            var nativeTrimLeft = String.prototype.trimLeft;

            var parseNumber = function(source) {
                return source * 1 || 0;
            };

            var strRepeat = function(str, qty) {
                if (qty < 1) 
                    return '';
                var result = '';
                while (qty > 0) {
                    if (qty & 1) 
                        result += str;
                    qty >>= 1, str += str;
                }
                return result;
            };

            var slice = [].slice;

            var defaultToWhiteSpace = function(characters) {
                if (characters == null)
                    return '\\s';
                else if (characters.source)
                    return characters.source;
                else
                    return '[' + _s.escapeRegExp(characters) + ']';
            };

            // Helper for toBoolean
            function boolMatch(s, matchers) {
                var i, matcher, down = s.toLowerCase();
                matchers = [].concat(matchers);
                for (i = 0; i < matchers.length; i += 1) {
                    matcher = matchers[i];
                    if (!matcher) 
                        continue;
                    if (matcher.test && matcher.test(s)) 
                        return true;
                    if (matcher.toLowerCase() === down) 
                        return true;
                }
            }

            var escapeChars = {
                lt: '<',
                gt: '>',
                quot: '"',
                amp: '&',
                apos: "'"
            };

            var reversedEscapeChars = {};
            for (var key in escapeChars) 
                reversedEscapeChars[escapeChars[key]] = key;
            reversedEscapeChars["'"] = '#39';

            // sprintf() for JavaScript 0.7-beta1
            // http://www.diveintojavascript.com/projects/javascript-sprintf
            //
            // Copyright (c) Alexandru Marasteanu <alexaholic [at) gmail (dot] com>
            // All rights reserved.

            var sprintf = (function() {
                function get_type(variable) {
                    return Object.prototype.toString.call(variable).slice(8, - 1).toLowerCase();
                }

                var str_repeat = strRepeat;

                var str_format = function() {
                    if (!str_format.cache.hasOwnProperty(arguments[0])) {
                        str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
                    }
                    return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
                };

                str_format.format = function(parse_tree, argv) {
                    var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
                    for (i = 0; i < tree_length; i++) {
                        node_type = get_type(parse_tree[i]);
                        if (node_type === 'string') {
                            output.push(parse_tree[i]);
                        } else if (node_type === 'array') {
                            match = parse_tree[i]; // convenience purposes only
                            if (match[2]) {
                                // keyword argument
                                arg = argv[cursor];
                                for (k = 0; k < match[2].length; k++) {
                                    if (!arg.hasOwnProperty(match[2][k])) {
                                        throw new Error(sprintf('[_.sprintf] property "%s" does not exist', match[2][k]));
                                    }
                                    arg = arg[match[2][k]];
                                }
                            } else if (match[1]) {
                                // positional argument (explicit)
                                arg = argv[match[1]];
                            } else {
                                // positional argument (implicit)
                                arg = argv[cursor++];
                            }

                            if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) {
                                throw new Error(sprintf('[_.sprintf] expecting number but found %s', get_type(arg)));
                            }
                            switch (match[8]) {
                            case 'b':
                                arg = arg.toString(2);
                                break;
                            case 'c':
                                arg = String.fromCharCode(arg);
                                break;
                            case 'd':
                                arg = parseInt(arg, 10);
                                break;
                            case 'e':
                                arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential();
                                break;
                            case 'f':
                                arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg);
                                break;
                            case 'o':
                                arg = arg.toString(8);
                                break;
                            case 's':
                                arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg);
                                break;
                            case 'u':
                                arg = Math.abs(arg);
                                break;
                            case 'x':
                                arg = arg.toString(16);
                                break;
                            case 'X':
                                arg = arg.toString(16).toUpperCase();
                                break;
                            }
                            arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+' + arg : arg);
                            pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
                            pad_length = match[6] - String(arg).length;
                            pad = match[6] ? str_repeat(pad_character, pad_length) : '';
                            output.push(match[5] ? arg + pad : pad + arg);
                        }
                    }
                    return output.join('');
                };

                str_format.cache = {};

                str_format.parse = function(fmt) {
                    var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
                    while (_fmt) {
                        if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
                            parse_tree.push(match[0]);
                        } else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
                            parse_tree.push('%');
                        } else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
                            if (match[2]) {
                                arg_names |= 1;
                                var field_list = [], replacement_field = match[2], field_match = [];
                                if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                                    field_list.push(field_match[1]);
                                    while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                                        if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                                            field_list.push(field_match[1]);
                                        } else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                                            field_list.push(field_match[1]);
                                        } else {
                                            throw new Error('[_.sprintf] huh?');
                                        }
                                    }
                                } else {
                                    throw new Error('[_.sprintf] huh?');
                                }
                                match[2] = field_list;
                            } else {
                                arg_names |= 2;
                            }
                            if (arg_names === 3) {
                                throw new Error('[_.sprintf] mixing positional and named placeholders is not (yet) supported');
                            }
                            parse_tree.push(match);
                        } else {
                            throw new Error('[_.sprintf] huh?');
                        }
                        _fmt = _fmt.substring(match[0].length);
                    }
                    return parse_tree;
                };

                return str_format;
            })();



            // Defining underscore.string

            var _s = {

                VERSION: '2.3.0',

                isBlank: function(str) {
                    if (str == null) 
                        str = '';
                    return (/^\s*$/).test(str);
                },

                stripTags: function(str) {
                    if (str == null) 
                        return '';
                    return String(str).replace(/<\/?[^>]+>/g, '');
                },

                capitalize : function(str) {
                    str = str == null ? '' : String(str);
                    return str.charAt(0).toUpperCase() + str.slice(1);
                },

                chop: function(str, step) {
                    if (str == null) 
                        return [];
                    str = String(str);
                    step = ~~step;
                    return step > 0 ? str.match(new RegExp('.{1,' + step + '}', 'g')) : [str];
                },

                clean: function(str) {
                    return _s.strip(str).replace(/\s+/g, ' ');
                },

                count: function(str, substr) {
                    if (str == null || substr == null) 
                        return 0;

                    str = String(str);
                    substr = String(substr);

                    var count = 0,
                    pos = 0,
                    length = substr.length;

                    while (true) {
                        pos = str.indexOf(substr, pos);
                        if (pos === - 1) 
                            break;
                        count++;
                        pos += length;
                    }

                    return count;
                },

                chars: function(str) {
                    if (str == null) 
                        return [];
                    return String(str).split('');
                },

                swapCase: function(str) {
                    if (str == null) 
                        return '';
                    return String(str).replace(/\S/g, function(c) {
                        return c === c.toUpperCase() ? c.toLowerCase() : c.toUpperCase();
                    });
                },

                escapeHTML: function(str) {
                    if (str == null) 
                        return '';
                    return String(str).replace(/[&<>"']/g, function(m) {
                        return '&' + reversedEscapeChars[m] + ';';
                    });
                },

                unescapeHTML: function(str) {
                    if (str == null) 
                        return '';
                    return String(str).replace(/\&([^;]+);/g, function(entity, entityCode) {
                        var match;

                        if (entityCode in escapeChars) {
                            return escapeChars[entityCode];
                        } else if (match = entityCode.match(/^#x([\da-fA-F]+)$/)) {
                            return String.fromCharCode(parseInt(match[1], 16));
                        } else if (match = entityCode.match(/^#(\d+)$/)) {
                            return String.fromCharCode(~~match[1]);
                        } else {
                            return entity;
                        }
                    });
                },

                escapeRegExp: function(str) {
                    if (str == null) 
                        return '';
                    return String(str).replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
                },

                splice: function(str, i, howmany, substr) {
                    var arr = _s.chars(str);
                    arr.splice(~~i, ~~howmany, substr);
                    return arr.join('');
                },

                insert: function(str, i, substr) {
                    return _s.splice(str, i, 0, substr);
                },

                include: function(str, needle) {
                    if (needle === '') 
                        return true;
                    if (str == null) 
                        return false;
                    return String(str).indexOf(needle) !== - 1;
                },

                join: function() {
                    var args = slice.call(arguments),
                    separator = args.shift();

                    if (separator == null) 
                        separator = '';

                    return args.join(separator);
                },

                lines: function(str) {
                    if (str == null) 
                        return [];
                    return String(str).split("\n");
                },

                reverse: function(str) {
                    return _s.chars(str).reverse().join('');
                },

                startsWith: function(str, starts) {
                    if (starts === '') 
                        return true;
                    if (str == null || starts == null) 
                        return false;
                    str = String(str);
                    starts = String(starts);
                    return str.length >= starts.length && str.slice(0, starts.length) === starts;
                },

                endsWith: function(str, ends) {
                    if (ends === '') 
                        return true;
                    if (str == null || ends == null) 
                        return false;
                    str = String(str);
                    ends = String(ends);
                    return str.length >= ends.length && str.slice(str.length - ends.length) === ends;
                },

                succ: function(str) {
                    if (str == null) 
                        return '';
                    str = String(str);
                    return str.slice(0, - 1) + String.fromCharCode(str.charCodeAt(str.length - 1) + 1);
                },

                titleize: function(str) {
                    if (str == null) 
                        return '';
                    str = String(str).toLowerCase();
                    return str.replace(/(?:^|\s|-)\S/g, function(c) {
                        return c.toUpperCase();
                    });
                },

                camelize: function(str) {
                    return _s.trim(str).replace(/[-_\s]+(.)?/g, function(match, c) {
                        return c ? c.toUpperCase() : "";
                    });
                },

                underscored: function(str) {
                    return _s.trim(str).replace(/([a-z\d])([A-Z]+)/g, '$1_$2').replace(/[-\s]+/g, '_').toLowerCase();
                },

                dasherize: function(str) {
                    return _s.trim(str).replace(/([A-Z])/g, '-$1').replace(/[-_\s]+/g, '-').toLowerCase();
                },

                classify: function(str) {
                    return _s.titleize(String(str).replace(/[\W_]/g, ' ')).replace(/\s/g, '');
                },

                humanize: function(str) {
                    return _s.capitalize(_s.underscored(str).replace(/_id$/, '').replace(/_/g, ' '));
                },

                trim: function(str, characters) {
                    if (str == null) 
                        return '';
                    if (!characters && nativeTrim) 
                        return nativeTrim.call(str);
                    characters = defaultToWhiteSpace(characters);
                    return String(str).replace(new RegExp('\^' + characters + '+|' + characters + '+$', 'g'), '');
                },

                ltrim: function(str, characters) {
                    if (str == null) 
                        return '';
                    if (!characters && nativeTrimLeft) 
                        return nativeTrimLeft.call(str);
                    characters = defaultToWhiteSpace(characters);
                    return String(str).replace(new RegExp('^' + characters + '+'), '');
                },

                rtrim: function(str, characters) {
                    if (str == null) 
                        return '';
                    if (!characters && nativeTrimRight) 
                        return nativeTrimRight.call(str);
                    characters = defaultToWhiteSpace(characters);
                    return String(str).replace(new RegExp(characters + '+$'), '');
                },

                truncate: function(str, length, truncateStr) {
                    if (str == null) 
                        return '';
                    str = String(str);
                    truncateStr = truncateStr || '...';
                    length = ~~length;
                    return str.length > length ? str.slice(0, length) + truncateStr : str;
                },

                /**
                     * _s.prune: a more elegant version of truncate
                     * prune extra chars, never leaving a half-chopped word.
                     * @author github.com/rwz
                     */
                prune: function(str, length, pruneStr) {
                    if (str == null) 
                        return '';

                    str = String(str);
                    length = ~~length;
                    pruneStr = pruneStr != null ? String(pruneStr) : '...';

                    if (str.length <= length) 
                        return str;

                    var tmpl = function(c) {
                        return c.toUpperCase() !== c.toLowerCase() ? 'A' : ' ';
                    },
                    template = str.slice(0, length + 1).replace(/.(?=\W*\w*$)/g, tmpl); // 'Hello, world' -> 'HellAA AAAAA'

                    if (template.slice(template.length - 2).match(/\w\w/))
                        template = template.replace(/\s*\S+$/, '');
                    else
                        template = _s.rtrim(template.slice(0, template.length - 1));

                    return (template + pruneStr).length > str.length ? str : str.slice(0, template.length) + pruneStr;
                },

                words: function(str, delimiter) {
                    if (_s.isBlank(str)) 
                        return [];
                    return _s.trim(str, delimiter).split(delimiter || /\s+/);
                },

                pad: function(str, length, padStr, type) {
                    str = str == null ? '' : String(str);
                    length = ~~length;

                    var padlen = 0;

                    if (!padStr)
                        padStr = ' ';
                    else if (padStr.length > 1)
                        padStr = padStr.charAt(0);

                    switch (type) {
                    case 'right':
                        padlen = length - str.length;
                        return str + strRepeat(padStr, padlen);
                    case 'both':
                        padlen = length - str.length;
                        return strRepeat(padStr, Math.ceil(padlen / 2)) + str
                        + strRepeat(padStr, Math.floor(padlen / 2));
                    default:
                        // 'left'
                        padlen = length - str.length;
                        return strRepeat(padStr, padlen) + str;
                    }
                },

                lpad: function(str, length, padStr) {
                    return _s.pad(str, length, padStr);
                },

                rpad: function(str, length, padStr) {
                    return _s.pad(str, length, padStr, 'right');
                },

                lrpad: function(str, length, padStr) {
                    return _s.pad(str, length, padStr, 'both');
                },

                sprintf: sprintf,

                vsprintf: function(fmt, argv) {
                    argv.unshift(fmt);
                    return sprintf.apply(null, argv);
                },

                toNumber: function(str, decimals) {
                    if (!str) 
                        return 0;
                    str = _s.trim(str);
                    if (!str.match(/^-?\d+(?:\.\d+)?$/)) 
                        return NaN;
                    return parseNumber(parseNumber(str).toFixed(~~decimals));
                },

                numberFormat : function(number, dec, dsep, tsep) {
                    if (isNaN(number) || number == null) 
                        return '';

                    number = number.toFixed(~~dec);
                    tsep = typeof tsep == 'string' ? tsep : ',';

                    var parts = number.split('.'), fnums = parts[0],
                    decimals = parts[1] ? (dsep || '.') + parts[1] : '';

                    return fnums.replace(/(\d)(?=(?:\d{3})+$)/g, '$1' + tsep) + decimals;
                },

                strRight: function(str, sep) {
                    if (str == null) 
                        return '';
                    str = String(str);
                    sep = sep != null ? String(sep) : sep;
                    var pos = !sep ? - 1 : str.indexOf(sep);
                    return ~pos ? str.slice(pos + sep.length, str.length) : str;
                },

                strRightBack: function(str, sep) {
                    if (str == null) 
                        return '';
                    str = String(str);
                    sep = sep != null ? String(sep) : sep;
                    var pos = !sep ? - 1 : str.lastIndexOf(sep);
                    return ~pos ? str.slice(pos + sep.length, str.length) : str;
                },

                strLeft: function(str, sep) {
                    if (str == null) 
                        return '';
                    str = String(str);
                    sep = sep != null ? String(sep) : sep;
                    var pos = !sep ? - 1 : str.indexOf(sep);
                    return ~pos ? str.slice(0, pos) : str;
                },

                strLeftBack: function(str, sep) {
                    if (str == null) 
                        return '';
                    str += '';
                    sep = sep != null ? '' + sep : sep;
                    var pos = str.lastIndexOf(sep);
                    return ~pos ? str.slice(0, pos) : str;
                },

                toSentence: function(array, separator, lastSeparator, serial) {
                    separator = separator || ', ';
                    lastSeparator = lastSeparator || ' and ';
                    var a = array.slice(), lastMember = a.pop();

                    if (array.length > 2 && serial) 
                        lastSeparator = _s.rtrim(separator) + lastSeparator;

                    return a.length ? a.join(separator) + lastSeparator + lastMember : lastMember;
                },

                toSentenceSerial: function() {
                    var args = slice.call(arguments);
                    args[3] = true;
                    return _s.toSentence.apply(_s, args);
                },

                slugify: function(str) {
                    if (str == null) 
                        return '';

                    var from = "Ä…Ã Ã¡Ã¤Ã¢Ã£Ã¥Ã¦ÄƒÄ‡Ä™Ã¨Ã©Ã«ÃªÃ¬Ã­Ã¯Ã®Å‚Å„Ã²Ã³Ã¶Ã´ÃµÃ¸Å›È™È›Ã¹ÃºÃ¼Ã»Ã±Ã§Å¼Åº",
                    to = "aaaaaaaaaceeeeeiiiilnoooooosstuuuunczz",
                    regex = new RegExp(defaultToWhiteSpace(from), 'g');

                    str = String(str).toLowerCase().replace(regex, function(c) {
                        var index = from.indexOf(c);
                        return to.charAt(index) || '-';
                    });

                    return _s.dasherize(str.replace(/[^\w\s-]/g, ''));
                },

                surround: function(str, wrapper) {
                    return [wrapper, str, wrapper].join('');
                },

                quote: function(str, quoteChar) {
                    return _s.surround(str, quoteChar || '"');
                },

                unquote: function(str, quoteChar) {
                    quoteChar = quoteChar || '"';
                    if (str[0] === quoteChar && str[str.length - 1] === quoteChar)
                        return str.slice(1, str.length - 1);
                    else 
                        return str;
                },

                exports: function() {
                    var result = {};

                    for (var prop in this) {
                        if (!this.hasOwnProperty(prop) || prop.match(/^(?:include|contains|reverse)$/)) 
                            continue;
                        result[prop] = this[prop];
                    }

                    return result;
                },

                repeat: function(str, qty, separator) {
                    if (str == null) 
                        return '';

                    qty = ~~qty;

                    // using faster implementation if separator is not needed;
                    if (separator == null) 
                        return strRepeat(String(str), qty);

                    // this one is about 300x slower in Google Chrome
                    for (var repeat = []; qty > 0; repeat[--qty] = str) {}
                    return repeat.join(separator);
                },

                naturalCmp: function(str1, str2) {
                    if (str1 == str2) 
                        return 0;
                    if (!str1) 
                        return - 1;
                    if (!str2) 
                        return 1;

                    var cmpRegex = /(\.\d+)|(\d+)|(\D+)/g,
                    tokens1 = String(str1).toLowerCase().match(cmpRegex),
                    tokens2 = String(str2).toLowerCase().match(cmpRegex),
                    count = Math.min(tokens1.length, tokens2.length);

                    for (var i = 0; i < count; i++) {
                        var a = tokens1[i], b = tokens2[i];

                        if (a !== b) {
                            var num1 = parseInt(a, 10);
                            if (!isNaN(num1)) {
                                var num2 = parseInt(b, 10);
                                if (!isNaN(num2) && num1 - num2)
                                    return num1 - num2;
                            }
                            return a < b ? - 1 : 1;
                        }
                    }

                    if (tokens1.length === tokens2.length)
                        return tokens1.length - tokens2.length;

                    return str1 < str2 ? - 1 : 1;
                },

                levenshtein: function(str1, str2) {
                    if (str1 == null && str2 == null) 
                        return 0;
                    if (str1 == null) 
                        return String(str2).length;
                    if (str2 == null) 
                        return String(str1).length;

                    str1 = String(str1);
                    str2 = String(str2);

                    var current = [], prev, value;

                    for (var i = 0; i <= str2.length; i++)
                        for (var j = 0; j <= str1.length; j++) {
                            if (i && j)
                                if (str1.charAt(j - 1) === str2.charAt(i - 1))
                                    value = prev;
                                else
                                    value = Math.min(current[j], current[j - 1], prev) + 1;
                        else
                            value = i + j;

                            prev = current[j];
                            current[j] = value;
                        }

                    return current.pop();
                },

                toBoolean: function(str, trueValues, falseValues) {
                    if (typeof str === "number") 
                        str = "" + str;
                    if (typeof str !== "string") 
                        return !!str;
                    str = _s.trim(str);
                    if (boolMatch(str, trueValues || ["true", "1"])) 
                        return true;
                    if (boolMatch(str, falseValues || ["false", "0"])) 
                        return false;
                }
            };

            // Aliases

            _s.strip = _s.trim;
            _s.lstrip = _s.ltrim;
            _s.rstrip = _s.rtrim;
            _s.center = _s.lrpad;
            _s.rjust = _s.lpad;
            _s.ljust = _s.rpad;
            _s.contains = _s.include;
            _s.q = _s.quote;
            _s.toBool = _s.toBoolean;

            // Exporting

            // CommonJS module is defined
            if (typeof exports !== 'undefined') {
                if (typeof module !== 'undefined' && module.exports)
                    module.exports = _s;

                exports._s = _s;
            }

            // Register as a named module with AMD.
            if (typeof define === 'function' && define.amd)
                define('underscore.string', [], function() {
                    return _s;
                });


            // Integrate with Underscore.js if defined
            // or create our own underscore object.
            root._ = root._ || {};
            root._.string = root._.str = _s;
        }(this, String);

    }, {}
    ],
    276: [function(require, module, exports) {
        // Fake underscore remapped to lodash since @isaacs doesn't want npm to support this
        // Having this installed and doing `npm dedupe` causes Backbone to use lodash instead of underscore
        // https://github.com/isaacs/npm/issues/2943
        module.exports = require('lodash');

    }, {
        "lodash": 271
    }
    ],
    277: [function(require, module, exports) {
        /*!
         * jQuery Smart Banner
         * Copyright (c) 2012 Arnold Daniels <arnold@jasny.net>
         * Based on 'jQuery Smart Web App Banner' by Kurt Zenisek @ kzeni.com
         */
        !function ($) {
            var SmartBanner = function (options) {
                this.origHtmlMargin = parseFloat($('html').css('margin-top')) // Get the original margin-top of the HTML element so we can take that into account
                this.options = $.extend({}, $.smartbanner.defaults, options)
                var standalone = navigator.standalone // Check if it's already a standalone web app or running within a webui view of an app (not mobile safari)
                , UA = navigator.userAgent
                // Detect banner type (iOS or Android)
                if (this.options.force) {
                    this.type = this.options.force
                } else if (UA.match(/iPhone|iPod/i) != null || (UA.match(/iPad/) && this.options.iOSUniversalApp)) {
                    if (UA.match(/Safari/i) != null &&
                    (UA.match(/CriOS/i) != null ||
                    window.Number(UA.substr(UA.indexOf('OS ') + 3, 3).replace('_', '.')) < 6)) 
                        this.type = 'ios' // Check webview and native smart banner support (iOS 6+)
                } else if (UA.match(/\bSilk\/(.*\bMobile Safari\b)?/) || UA.match(/\bKF\w/) || UA.match('Kindle Fire')) {
                    this.type = 'kindle'
                } else if (UA.match(/Android/i) != null) {
                    this.type = 'android'
                } else if (UA.match(/Windows NT 6.2/i) != null && UA.match(/Touch/i) !== null) {
                    this.type = 'windows'
                }

                // Don't show banner if device isn't iOS or Android, website is loaded in app or user dismissed banner
                if (!this.type || standalone || this.getCookie('sb-closed') || this.getCookie('sb-installed')) {
                    return
                }

                // Calculate scale
                this.scale = this.options.scale == 'auto' ? $(window).width() / window.screen.width : this.options.scale
                if (this.scale < 1) 
                    this.scale = 1
                    // Get info from meta data
                var meta = $(this.type == 'android' ? 'meta[name="google-play-app"]' :
                this.type == 'ios' ? 'meta[name="apple-itunes-app"]' :
                this.type == 'kindle' ? 'meta[name="kindle-fire-app"]' : 'meta[name="msApplication-ID"]');
                if (meta.length == 0) 
                    return
                    // For Windows Store apps, get the PackageFamilyName for protocol launch
                    if (this.type == 'windows') {
                    this.pfn = $('meta[name="msApplication-PackageFamilyName"]').attr('content');
                    this.appId = meta.attr('content')[1]
                } else {
                    this.appId = /app-id=([^\s,]+)/.exec(meta.attr('content'))[1]
                }

                this.title = this.options.title ? this.options.title : meta.data('title') || $('title').text().replace(/\s*[|\-Â·].*$/, '')
                this.author = this.options.author ? this.options.author : meta.data('author') || ($('meta[name="author"]').length ? $('meta[name="author"]').attr('content') : window.location.hostname)
                this.iconUrl = meta.data('icon-url');
                this.price = meta.data('price');

                // Create banner
                this.create()
                this.show()
                this.listen()
            }

            SmartBanner.prototype = {

                constructor: SmartBanner
                ,
                create: function() {
                    var iconURL
                    , link = (this.options.url ? this.options.url : (this.type == 'windows' ? 'ms-windows-store:PDP?PFN=' + this.pfn : (this.type == 'android' ? 'market://details?id=' : (this.type == 'kindle' ? 'amzn://apps/android?asin=' : 'https://itunes.apple.com/' + this.options.appStoreLanguage + '/app/id'))) + this.appId)
                    , price = this.price || this.options.price
                    , inStore = price ? price + ' - ' + (this.type == 'android' ? this.options.inGooglePlay : this.type == 'kindle' ? this.options.inAmazonAppStore : this.type == 'ios' ? this.options.inAppStore : this.options.inWindowsStore) : ''
                    , gloss = this.options.iconGloss === null ? (this.type == 'ios') : this.options.iconGloss
                    if (this.options.url)
                        link = this.options.url
                    else {
                        if (this.type == 'android') {
                            link = 'market://details?id=' + this.appId
                            if (this.options.GooglePlayParams)
                                link = link + '&referrer=' + this.options.GooglePlayParams
                        } else
                            link = 'https://itunes.apple.com/' + this.options.appStoreLanguage + '/app/id' + this.appId
                    }

                    var banner = '<div id="smartbanner" class="' + this.type + '"><div class="sb-container"><a href="#" class="sb-close">&times;</a><span class="sb-icon"></span><div class="sb-info"><strong>' + this.title + '</strong><span>' + this.author + '</span><span>' + inStore + '</span></div><a href="' + link + '" class="sb-button"><span>' + this.options.button + '</span></a></div></div>';
                    (this.options.layer) ? $(this.options.appendToSelector).append(banner) : $(this.options.appendToSelector).prepend(banner);

                    if (this.options.icon) {
                        iconURL = this.options.icon
                    } else if (this.iconUrl) {
                        iconURL = this.iconUrl;
                    } else if ($('link[rel="apple-touch-icon-precomposed"]').length > 0) {
                        iconURL = $('link[rel="apple-touch-icon-precomposed"]').attr('href')
                        if (this.options.iconGloss === null) 
                            gloss = false
                    } else if ($('link[rel="apple-touch-icon"]').length > 0) {
                        iconURL = $('link[rel="apple-touch-icon"]').attr('href')
                    } else if ($('meta[name="msApplication-TileImage"]').length > 0) {
                        iconURL = $('meta[name="msApplication-TileImage"]').attr('content')
                    } else if ($('meta[name="msapplication-TileImage"]').length > 0) {
                        /* redundant because ms docs show two case usages */
                        iconURL = $('meta[name="msapplication-TileImage"]').attr('content')
                    }

                    if (iconURL) {
                        $('#smartbanner .sb-icon').css('background-image', 'url(' + iconURL + ')')
                        if (gloss) 
                            $('#smartbanner .sb-icon').addClass('gloss')
                    } else {
                        $('#smartbanner').addClass('no-icon')
                    }

                    this.bannerHeight = $('#smartbanner').outerHeight() + 2
                    if (this.scale > 1) {
                        $('#smartbanner')
                        .css('top', parseFloat($('#smartbanner').css('top')) * this.scale)
                        .css('height', parseFloat($('#smartbanner').css('height')) * this.scale)
                        .hide()
                        $('#smartbanner .sb-container')
                        .css('-webkit-transform', 'scale(' + this.scale + ')')
                        .css('-msie-transform', 'scale(' + this.scale + ')')
                        .css('-moz-transform', 'scale(' + this.scale + ')')
                        .css('width', $(window).width() / this.scale)
                    }
                    $('#smartbanner').css('position', (this.options.layer) ? 'absolute' : 'static')
                }
,
                listen: function () {
                    $('#smartbanner .sb-close').on('click', $.proxy(this.close, this))
                    $('#smartbanner .sb-button').on('click', $.proxy(this.install, this))
                }
,
                show: function(callback) {
                    var banner = $('#smartbanner');
                    banner.stop();

                    if (this.options.layer) {
                        banner.animate({
                            top: 0,
                            display: 'block'
                        }, this.options.speedIn).addClass('shown').show();
                        $('html').animate({
                            marginTop: this.origHtmlMargin + (this.bannerHeight * this.scale)
                        }, this.options.speedIn, 'swing', callback);
                    } else {
                        if ($.support.transition) {
                            banner.animate({
                                top: 0
                            }, this.options.speedIn).addClass('shown');
                            var transitionCallback = function() {
                                $('html').removeClass('sb-animation');
                                if (callback) {
                                    callback();
                                }
                            };
                            $('html').addClass('sb-animation').one($.support.transition.end, transitionCallback).emulateTransitionEnd(this.options.speedIn).css('margin-top', this.origHtmlMargin + (this.bannerHeight * this.scale));
                        } else {
                            banner.slideDown(this.options.speedIn).addClass('shown');
                        }
                    }
                }
,
                hide: function(callback) {
                    var banner = $('#smartbanner');
                    banner.stop();

                    if (this.options.layer) {
                        banner.animate({
                            top: - 1 * this.bannerHeight * this.scale,
                            display: 'block'
                        }, this.options.speedIn).removeClass('shown');
                        $('html').animate({
                            marginTop: this.origHtmlMargin
                        }, this.options.speedIn, 'swing', callback);
                    } else {
                        if ($.support.transition) {
                            banner.css('top', - 1 * this.bannerHeight * this.scale).removeClass('shown');
                            var transitionCallback = function() {
                                $('html').removeClass('sb-animation');
                                if (callback) {
                                    callback();
                                }
                            };
                            $('html').addClass('sb-animation').one($.support.transition.end, transitionCallback).emulateTransitionEnd(this.options.speedOut).css('margin-top', this.origHtmlMargin);
                        } else {
                            banner.slideUp(this.options.speedOut).removeClass('shown');
                        }
                    }
                    $('#smartbanner').css('height', 0);
                    $('#smartbanner').css('border', 0);
                }
,
                close: function(e) {
                    e.preventDefault()
                    this.hide()
                    this.setCookie('sb-closed', 'true', this.options.daysHidden);
                }
,
                install: function(e) {
                    if (this.options.hideOnInstall) {
                        this.hide()
                    }
                    this.setCookie('sb-installed', 'true', this.options.daysReminder)
                }
,
                setCookie: function(name, value, exdays) {
                    var exdate = new Date()
                    exdate.setDate(exdate.getDate() + exdays)
                    value = encodeURI(value) + ((exdays == null) ? '' : '; expires=' + exdate.toUTCString())
                    document.cookie = name + '=' + value + '; path=/;'
                }
,
                getCookie: function(name) {
                    var i, x, y, ARRcookies = document.cookie.split(";")
                    for (i = 0; i < ARRcookies.length; i++) {
                        x = ARRcookies[i].substr(0, ARRcookies[i].indexOf("="))
                        y = ARRcookies[i].substr(ARRcookies[i].indexOf("=") + 1)
                        x = x.replace(/^\s+|\s+$/g, "")
                        if (x == name) {
                            return decodeURI(y)
                        }
                    }
                    return null
                }

                // Demo only
                ,
                switchType: function() {
                    var that = this
                    this.hide(function () {
                        that.type = that.type == 'android' ? 'ios' : 'android'
                        var meta = $(that.type == 'android' ? 'meta[name="google-play-app"]' : 'meta[name="apple-itunes-app"]').attr('content')
                        that.appId = /app-id=([^\s,]+)/.exec(meta)[1]
                        $('#smartbanner').detach()
                        that.create()
                        that.show()
                    })
                }
            }

            $.smartbanner = function (option) {
                var $window = $(window)
                , data = $window.data('smartbanner')
                , options = typeof option == 'object' && option
                if (!data) 
                    $window.data('smartbanner', (data = new SmartBanner(options)))
                if (typeof option == 'string') 
                    data[option]()
            }

            // override these globally if you like (they are all optional)
            $.smartbanner.defaults = {
                title: null,
                // What the title of the app should be in the banner (defaults to <title>)
                author: null,
                // What the author of the app should be in the banner (defaults to <meta name="author"> or hostname)
                price: 'FREE',
                // Price of the app
                appStoreLanguage: 'us',
                // Language code for App Store
                inAppStore: 'On the App Store',
                // Text of price for iOS
                inGooglePlay: 'In Google Play',
                // Text of price for Android
                inAmazonAppStore: 'In the Amazon Appstore',
                inWindowsStore: 'In the Windows Store',
                //Text of price for Windows
                GooglePlayParams: null,
                // Aditional parameters for the market
                icon: null,
                // The URL of the icon (defaults to <meta name="apple-touch-icon">)
                iconGloss: null,
                // Force gloss effect for iOS even for precomposed
                button: 'VIEW',
                // Text for the install button
                url: null,
                // The URL for the button. Keep null if you want the button to link to the app store.
                scale: 'auto',
                // Scale based on viewport size (set to 1 to disable)
                speedIn: 300,
                // Show animation speed of the banner
                speedOut: 400,
                // Close animation speed of the banner
                daysHidden: 15,
                // Duration to hide the banner after being closed (0 = always show banner)
                daysReminder: 90,
                // Duration to hide the banner after "VIEW" is clicked *separate from when the close button is clicked* (0 = always show banner)
                force: null,
                // Choose 'ios', 'android' or 'windows'. Don't do a browser check, just always show this banner
                hideOnInstall: true,
                // Hide the banner after "VIEW" is clicked.
                layer: false,
                // Display as overlay layer or slide down the page
                iOSUniversalApp: true,
                // If the iOS App is a universal app for both iPad and iPhone, display Smart Banner to iPad users, too.
                appendToSelector: 'body' //Append the banner to a specific selector
            }

            $.smartbanner.Constructor = SmartBanner;


            // ============================================================
            // Bootstrap transition
            // Copyright 2011-2014 Twitter, Inc.
            // Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)

            function transitionEnd() {
                var el = document.createElement('smartbanner')
                var transEndEventNames = {
                    WebkitTransition: 'webkitTransitionEnd',
                    MozTransition: 'transitionend',
                    OTransition: 'oTransitionEnd otransitionend',
                    transition: 'transitionend'
                }

                for (var name in transEndEventNames) {
                    if (el.style[name] !== undefined) {
                        return {
                            end: transEndEventNames[name]
                        }
                    }
                }

                return false // explicit for ie8 (  ._.)
            }

            if ($.support.transition !== undefined)
                return // Prevent conflict with Twitter Bootstrap

                // http://blog.alexmaccaw.com/css-transitions
                $.fn.emulateTransitionEnd = function(duration) {
                    var called = false, $el = this
                    $(this).one($.support.transition.end, function() {
                        called = true
                    })
                    var callback = function() {
                        if (!called) 
                            $($el).trigger($.support.transition.end)
                        }
                        setTimeout(callback, duration)
                        return this
                    }

            $(function() {
                $.support.transition = transitionEnd()
            })
            // ============================================================

        }(window.jQuery);

    }, {}
    ],
    278: [function(require, module, exports) {
        "use strict";
        /*globals Handlebars: true */
        var base = require("./handlebars/base");

        // Each of these augment the Handlebars object. No need to setup here.
        // (This is done to easily share code between commonjs and browse envs)
        var SafeString = require("./handlebars/safe-string")["default"];
        var Exception = require("./handlebars/exception")["default"];
        var Utils = require("./handlebars/utils");
        var runtime = require("./handlebars/runtime");

        // For compatibility and usage outside of module systems, make the Handlebars object a namespace
        var create = function() {
            var hb = new base.HandlebarsEnvironment();

            Utils.extend(hb, base);
            hb.SafeString = SafeString;
            hb.Exception = Exception;
            hb.Utils = Utils;

            hb.VM = runtime;
            hb.template = function(spec) {
                return runtime.template(spec, hb);
            };

            return hb;
        };

        var Handlebars = create();
        Handlebars.create = create;

        exports["default"] = Handlebars;
    }, {
        "./handlebars/base": 279,
        "./handlebars/exception": 280,
        "./handlebars/runtime": 281,
        "./handlebars/safe-string": 282,
        "./handlebars/utils": 283
    }
    ],
    279: [function(require, module, exports) {
        "use strict";
        var Utils = require("./utils");
        var Exception = require("./exception")["default"];

        var VERSION = "1.3.0";
        exports.VERSION = VERSION;
        var COMPILER_REVISION = 4;
        exports.COMPILER_REVISION = COMPILER_REVISION;
        var REVISION_CHANGES = {
            1: '<= 1.0.rc.2',
            // 1.0.rc.2 is actually rev2 but doesn't report it
            2: '== 1.0.0-rc.3',
            3: '== 1.0.0-rc.4',
            4: '>= 1.0.0'
        };
        exports.REVISION_CHANGES = REVISION_CHANGES;
        var isArray = Utils.isArray,
        isFunction = Utils.isFunction,
        toString = Utils.toString,
        objectType = '[object Object]';

        function HandlebarsEnvironment(helpers, partials) {
            this.helpers = helpers || {};
            this.partials = partials || {};

            registerDefaultHelpers(this);
        }

        exports.HandlebarsEnvironment = HandlebarsEnvironment;
        HandlebarsEnvironment.prototype = {
            constructor: HandlebarsEnvironment,

            logger: logger,
            log: log,

            registerHelper: function(name, fn, inverse) {
                if (toString.call(name) === objectType) {
                    if (inverse || fn) {
                        throw new Exception('Arg not supported with multiple helpers');
                    }
                    Utils.extend(this.helpers, name);
                } else {
                    if (inverse) {
                        fn.not = inverse;
                    }
                    this.helpers[name] = fn;
                }
            },

            registerPartial: function(name, str) {
                if (toString.call(name) === objectType) {
                    Utils.extend(this.partials, name);
                } else {
                    this.partials[name] = str;
                }
            }
        };

        function registerDefaultHelpers(instance) {
            instance.registerHelper('helperMissing', function(arg) {
                if (arguments.length === 2) {
                    return undefined;
                } else {
                    throw new Exception("Missing helper: '" + arg + "'");
                }
            });

            instance.registerHelper('blockHelperMissing', function(context, options) {
                var inverse = options.inverse || function() {}, fn = options.fn;

                if (isFunction(context)) {
                    context = context.call(this);
                }

                if (context === true) {
                    return fn(this);
                } else if (context === false || context == null) {
                    return inverse(this);
                } else if (isArray(context)) {
                    if (context.length > 0) {
                        return instance.helpers.each(context, options);
                    } else {
                        return inverse(this);
                    }
                } else {
                    return fn(context);
                }
            });

            instance.registerHelper('each', function(context, options) {
                var fn = options.fn, inverse = options.inverse;
                var i = 0, ret = "", data;

                if (isFunction(context)) {
                    context = context.call(this);
                }

                if (options.data) {
                    data = createFrame(options.data);
                }

                if (context && typeof context === 'object') {
                    if (isArray(context)) {
                        for (var j = context.length; i < j; i++) {
                            if (data) {
                                data.index = i;
                                data.first = (i === 0);
                                data.last = (i === (context.length - 1));
                            }
                            ret = ret + fn(context[i], {
                                data: data 
                            });
                        }
                    } else {
                        for (var key in context) {
                            if (context.hasOwnProperty(key)) {
                                if (data) {
                                    data.key = key;
                                    data.index = i;
                                    data.first = (i === 0);
                                }
                                ret = ret + fn(context[key], {
                                    data: data
                                });
                                i++;
                            }
                        }
                    }
                }

                if (i === 0) {
                    ret = inverse(this);
                }

                return ret;
            });

            instance.registerHelper('if', function(conditional, options) {
                if (isFunction(conditional)) {
                    conditional = conditional.call(this);
                }

                // Default behavior is to render the positive path if the value is truthy and not empty.
                // The `includeZero` option may be set to treat the condtional as purely not empty based on the
                // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
                if ((!options.hash.includeZero && !conditional) || Utils.isEmpty(conditional)) {
                    return options.inverse(this);
                } else {
                    return options.fn(this);
                }
            });

            instance.registerHelper('unless', function(conditional, options) {
                return instance.helpers['if'].call(this, conditional, {
                    fn: options.inverse,
                    inverse: options.fn,
                    hash: options.hash
                });
            });

            instance.registerHelper('with', function(context, options) {
                if (isFunction(context)) {
                    context = context.call(this);
                }

                if (!Utils.isEmpty(context)) 
                    return options.fn(context);
            });

            instance.registerHelper('log', function(context, options) {
                var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
                instance.log(level, context);
            });
        }

        var logger = {
            methodMap: {
                0: 'debug',
                1: 'info',
                2: 'warn',
                3: 'error' 
            },

            // State enum
            DEBUG: 0,
            INFO: 1,
            WARN: 2,
            ERROR: 3,
            level: 3,

            // can be overridden in the host environment
            log: function(level, obj) {
                if (logger.level <= level) {
                    var method = logger.methodMap[level];
                    if (typeof console !== 'undefined' && console[method]) {
                        console[method].call(console, obj);
                    }
                }
            }
        };
        exports.logger = logger;
        function log(level, obj) {
            logger.log(level, obj);
        }

        exports.log = log;
        var createFrame = function(object) {
            var obj = {};
            Utils.extend(obj, object);
            return obj;
        };
        exports.createFrame = createFrame;
    }, {
        "./exception": 280,
        "./utils": 283
    }
    ],
    280: [function(require, module, exports) {
        "use strict";

        var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

        function Exception(message, node) {
            var line;
            if (node && node.firstLine) {
                line = node.firstLine;

                message += ' - ' + line + ':' + node.firstColumn;
            }

            var tmp = Error.prototype.constructor.call(this, message);

            // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
            for (var idx = 0; idx < errorProps.length; idx++) {
                this[errorProps[idx]] = tmp[errorProps[idx]];
            }

            if (line) {
                this.lineNumber = line;
                this.column = node.firstColumn;
            }
        }

        Exception.prototype = new Error();

        exports["default"] = Exception;
    }, {}
    ],
    281: [function(require, module, exports) {
        "use strict";
        var Utils = require("./utils");
        var Exception = require("./exception")["default"];
        var COMPILER_REVISION = require("./base").COMPILER_REVISION;
        var REVISION_CHANGES = require("./base").REVISION_CHANGES;

        function checkRevision(compilerInfo) {
            var compilerRevision = compilerInfo && compilerInfo[0] || 1,
            currentRevision = COMPILER_REVISION;

            if (compilerRevision !== currentRevision) {
                if (compilerRevision < currentRevision) {
                    var runtimeVersions = REVISION_CHANGES[currentRevision],
                    compilerVersions = REVISION_CHANGES[compilerRevision];
                    throw new Exception("Template was precompiled with an older version of Handlebars than the current runtime. " +
                    "Please update your precompiler to a newer version (" + runtimeVersions + ") or downgrade your runtime to an older version (" + compilerVersions + ").");
                } else {
                    // Use the embedded version info since the runtime doesn't know about this revision yet
                    throw new Exception("Template was precompiled with a newer version of Handlebars than the current runtime. " +
                    "Please update your runtime to a newer version (" + compilerInfo[1] + ").");
                }
            }
        }

        exports.checkRevision = checkRevision; // TODO: Remove this line and break up compilePartial

        function template(templateSpec, env) {
            if (!env) {
                throw new Exception("No environment passed to template");
            }

            // Note: Using env.VM references rather than local var references throughout this section to allow
            // for external users to override these as psuedo-supported APIs.
            var invokePartialWrapper = function(partial, name, context, helpers, partials, data) {
                var result = env.VM.invokePartial.apply(this, arguments);
                if (result != null) {
                    return result;
                }

                if (env.compile) {
                    var options = {
                        helpers: helpers,
                        partials: partials,
                        data: data 
                    };
                    partials[name] = env.compile(partial, {
                        data: data !== undefined 
                    }, env);
                    return partials[name](context, options);
                } else {
                    throw new Exception("The partial " + name + " could not be compiled when running in runtime-only mode");
                }
            };

            // Just add water
            var container = {
                escapeExpression: Utils.escapeExpression,
                invokePartial: invokePartialWrapper,
                programs: [],
                program: function(i, fn, data) {
                    var programWrapper = this.programs[i];
                    if (data) {
                        programWrapper = program(i, fn, data);
                    } else if (!programWrapper) {
                        programWrapper = this.programs[i] = program(i, fn);
                    }
                    return programWrapper;
                },
                merge: function(param, common) {
                    var ret = param || common;

                    if (param && common && (param !== common)) {
                        ret = {};
                        Utils.extend(ret, common);
                        Utils.extend(ret, param);
                    }
                    return ret;
                },
                programWithDepth: env.VM.programWithDepth,
                noop: env.VM.noop,
                compilerInfo: null
            };

            return function(context, options) {
                options = options || {};
                var namespace = options.partial ? options : env,
                helpers,
                partials;

                if (!options.partial) {
                    helpers = options.helpers;
                    partials = options.partials;
                }
                var result = templateSpec.call(
                container,
                namespace, context,
                helpers,
                partials,
                options.data);

                if (!options.partial) {
                    env.VM.checkRevision(container.compilerInfo);
                }

                return result;
            };
        }

        exports.template = template;
        function programWithDepth(i, fn, data /*, $depth */
        ) {
            var args = Array.prototype.slice.call(arguments, 3);

            var prog = function(context, options) {
                options = options || {};

                return fn.apply(this, [context, options.data || data].concat(args));
            };
            prog.program = i;
            prog.depth = args.length;
            return prog;
        }

        exports.programWithDepth = programWithDepth;
        function program(i, fn, data) {
            var prog = function(context, options) {
                options = options || {};

                return fn(context, options.data || data);
            };
            prog.program = i;
            prog.depth = 0;
            return prog;
        }

        exports.program = program;
        function invokePartial(partial, name, context, helpers, partials, data) {
            var options = {
                partial: true,
                helpers: helpers,
                partials: partials,
                data: data 
            };

            if (partial === undefined) {
                throw new Exception("The partial " + name + " could not be found");
            } else if (partial instanceof Function) {
                return partial(context, options);
            }
        }

        exports.invokePartial = invokePartial;
        function noop() {
            return "";
        }

        exports.noop = noop;
    }, {
        "./base": 279,
        "./exception": 280,
        "./utils": 283
    }
    ],
    282: [function(require, module, exports) {
        "use strict";
        // Build out our basic SafeString type
        function SafeString(string) {
            this.string = string;
        }

        SafeString.prototype.toString = function() {
            return "" + this.string;
        };

        exports["default"] = SafeString;
    }, {}
    ],
    283: [function(require, module, exports) {
        "use strict";
        /*jshint -W004 */
        var SafeString = require("./safe-string")["default"];

        var escape = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#x27;",
            "`": "&#x60;"
        };

        var badChars = /[&<>"'`]/g;
        var possible = /[&<>"'`]/;

        function escapeChar(chr) {
            return escape[chr] || "&amp;";
        }

        function extend(obj, value) {
            for (var key in value) {
                if (Object.prototype.hasOwnProperty.call(value, key)) {
                    obj[key] = value[key];
                }
            }
        }

        exports.extend = extend;
        var toString = Object.prototype.toString;
        exports.toString = toString;
        // Sourced from lodash
        // https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
        var isFunction = function(value) {
            return typeof value === 'function';
        };
        // fallback for older versions of Chrome and Safari
        if (isFunction(/x/)) {
            isFunction = function(value) {
                return typeof value === 'function' && toString.call(value) === '[object Function]';
            };
        }
        var isFunction;
        exports.isFunction = isFunction;
        var isArray = Array.isArray || function(value) {
            return (value && typeof value === 'object') ? toString.call(value) === '[object Array]' : false;
        };
        exports.isArray = isArray;

        function escapeExpression(string) {
            // don't escape SafeStrings, since they're already safe
            if (string instanceof SafeString) {
                return string.toString();
            } else if (!string && string !== 0) {
                return "";
            }

            // Force a string conversion as this will be done by the append regardless and
            // the regex test will do this transparently behind the scenes, causing issues if
            // an object's to string has escaped characters in it.
            string = "" + string;

            if (!possible.test(string)) {
                return string;
            }
            return string.replace(badChars, escapeChar);
        }

        exports.escapeExpression = escapeExpression;
        function isEmpty(value) {
            if (!value && value !== 0) {
                return true;
            } else if (isArray(value) && value.length === 0) {
                return true;
            } else {
                return false;
            }
        }

        exports.isEmpty = isEmpty;
    }, {
        "./safe-string": 282
    }
    ],
    284: [function(require, module, exports) {
        // Create a simple path alias to allow browserify to resolve
        // the runtime on a supported path.
        module.exports = require('./dist/cjs/handlebars.runtime');

    }, {
        "./dist/cjs/handlebars.runtime": 278
    }
    ],
    285: [function(require, module, exports) {
        module.exports = require("handlebars/runtime")["default"];

    }, {
        "handlebars/runtime": 284
    }
    ]
}, {}, [1, 2, "r1JNni", "E2iFan", "ro7h2H", "3YYIHK", "cES0qR", "+ZdH5R", "jofflq", "+urNMo", "4JdDAV", "kDd6n3", "lBiuMh", "WwFx8w", "YnK63m", "qBJ77m", "yZg3j8", "8zD71I", "dHCCyL", 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 55, 54, 57, 56, 59, 58, 60, 61, 63, 62, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 89, 88, 90, 91, 92, 93, 94, 95, 96, 97, 99, 98, 101, 100, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 219, 218, 221, 220, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 235, 234, 236, 237, 238, 239, 240, 241, 242, 243, 245, 244, 246, 247, 248, 249, 250, "ediDsA", "Whcl4h", "USqgHK", "4qmo/s", "wGqA+0", "oshQP7", "IK/XRE", "flnS9y", "hzn+xy", "+kEqd0", "kv2k5c", "0gFF0M", "VIoAo/", "0F6DJ6", "qJsy/N", "Zox6YT", "P4/UXv", "SLNN4z", "sLiusw", "tKqFU7", "fkKIUk", "lRNDei", "peA8S7", "8VEjOZ", "WshNnd", "v/RJpn", "qLzDdG", "nGwmvN", "Sy7dO9", "Hi1lD+", "AOj6MC", "z78zVX", "cvEEgA", "mZHNVI", "H24zAK", "BLHHGo", "f2O4oI", "39CaF6", "FH8jaf", "1oaJ58", "wxwSQl", "hepQFm", "+GQM7K", "hnIYJt", "zz2tVJ", "eXr6lw", "CFQFGf", "5Haky1", "aYyb3r", "gK1GtQ", "WveYvT", "dHJCQ1", "cOr8jn"])
;
