
//     Underscore.js 1.4.2
//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore may be freely distributed under the MIT license.
//     Portions of Underscore are inspired or borrowed from Prototype,
//     Oliver Steele's Functional, and John Resig's Micro-Templating.
//     For all details and documentation:
//     http://documentcloud.github.com/underscore

var root = this;

define("underscore", [], function() {

    // Baseline setup
    // --------------

    // Save the previous value of the `_` variable.
    var previousUnderscore = root._;

    // Establish the object that gets returned to break out of a loop iteration.
    var breaker = {};

    // Save bytes in the minified (but not gzipped) version:
    var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

    // Create quick reference variables for speed access to core prototypes.
    var push = ArrayProto.push,
    slice = ArrayProto.slice,
    concat = ArrayProto.concat,
    unshift = ArrayProto.unshift,
    toString = ObjProto.toString,
    hasOwnProperty = ObjProto.hasOwnProperty;

    // All **ECMAScript 5** native function implementations that we hope to use
    // are declared here.
    var
    nativeForEach = ArrayProto.forEach,
    nativeMap = ArrayProto.map,
    nativeReduce = ArrayProto.reduce,
    nativeReduceRight = ArrayProto.reduceRight,
    nativeFilter = ArrayProto.filter,
    nativeEvery = ArrayProto.every,
    nativeSome = ArrayProto.some,
    nativeIndexOf = ArrayProto.indexOf,
    nativeLastIndexOf = ArrayProto.lastIndexOf,
    nativeIsArray = Array.isArray,
    nativeKeys = Object.keys,
    nativeBind = FuncProto.bind;

    // Create a safe reference to the Underscore object for use below.
    var _ = function(obj) {
        if (obj instanceof _) 
            return obj;
        if (!(this instanceof _)) 
            return new _(obj);
        this._wrapped = obj;
    };

    // Export the Underscore object for **Node.js**, with
    // backwards-compatibility for the old `require()` API. If we're in
    // the browser, add `_` as a global object via a string identifier,
    // for Closure Compiler "advanced" mode.
    if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = _;
        }
        exports._ = _;
    } else {
        root['_'] = _;
    }

    // Current version.
    _.VERSION = '1.4.2';

    // Collection Functions
    // --------------------

    // The cornerstone, an `each` implementation, aka `forEach`.
    // Handles objects with the built-in `forEach`, arrays, and raw objects.
    // Delegates to **ECMAScript 5**'s native `forEach` if available.
    var each = _.each = _.forEach = function(obj, iterator, context) {
        if (obj == null) 
            return;
        if (nativeForEach && obj.forEach === nativeForEach) {
            obj.forEach(iterator, context);
        } else if (obj.length === + obj.length) {
            for (var i = 0, l = obj.length; i < l; i++) {
                if (iterator.call(context, obj[i], i, obj) === breaker) 
                    return;
            }
        } else {
            for (var key in obj) {
                if (_.has(obj, key)) {
                    if (iterator.call(context, obj[key], key, obj) === breaker) 
                        return;
                }
            }
        }
    };

    // Return the results of applying the iterator to each element.
    // Delegates to **ECMAScript 5**'s native `map` if available.
    _.map = _.collect = function(obj, iterator, context) {
        var results = [];
        if (obj == null) 
            return results;
        if (nativeMap && obj.map === nativeMap) 
            return obj.map(iterator, context);
        each(obj, function(value, index, list) {
            results[results.length] = iterator.call(context, value, index, list);
        });
        return results;
    };

    // **Reduce** builds up a single result from a list of values, aka `inject`,
    // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
    _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
        var initial = arguments.length > 2;
        if (obj == null) 
            obj = [];
        if (nativeReduce && obj.reduce === nativeReduce) {
            if (context) 
                iterator = _.bind(iterator, context);
            return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
        }
        each(obj, function(value, index, list) {
            if (!initial) {
                memo = value;
                initial = true;
            } else {
                memo = iterator.call(context, memo, value, index, list);
            }
        });
        if (!initial) 
            throw new TypeError('Reduce of empty array with no initial value');
        return memo;
    };

    // The right-associative version of reduce, also known as `foldr`.
    // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
    _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
        var initial = arguments.length > 2;
        if (obj == null) 
            obj = [];
        if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
            if (context) 
                iterator = _.bind(iterator, context);
            return arguments.length > 2 ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
        }
        var length = obj.length;
        if (length !== + length) {
            var keys = _.keys(obj);
            length = keys.length;
        }
        each(obj, function(value, index, list) {
            index = keys ? keys[--length] : --length;
            if (!initial) {
                memo = obj[index];
                initial = true;
            } else {
                memo = iterator.call(context, memo, obj[index], index, list);
            }
        });
        if (!initial) 
            throw new TypeError('Reduce of empty array with no initial value');
        return memo;
    };

    // Return the first value which passes a truth test. Aliased as `detect`.
    _.find = _.detect = function(obj, iterator, context) {
        var result;
        any(obj, function(value, index, list) {
            if (iterator.call(context, value, index, list)) {
                result = value;
                return true;
            }
        });
        return result;
    };

    // Return all the elements that pass a truth test.
    // Delegates to **ECMAScript 5**'s native `filter` if available.
    // Aliased as `select`.
    _.filter = _.select = function(obj, iterator, context) {
        var results = [];
        if (obj == null) 
            return results;
        if (nativeFilter && obj.filter === nativeFilter) 
            return obj.filter(iterator, context);
        each(obj, function(value, index, list) {
            if (iterator.call(context, value, index, list)) 
                results[results.length] = value;
        });
        return results;
    };

    // Return all the elements for which a truth test fails.
    _.reject = function(obj, iterator, context) {
        var results = [];
        if (obj == null) 
            return results;
        each(obj, function(value, index, list) {
            if (!iterator.call(context, value, index, list)) 
                results[results.length] = value;
        });
        return results;
    };

    // Determine whether all of the elements match a truth test.
    // Delegates to **ECMAScript 5**'s native `every` if available.
    // Aliased as `all`.
    _.every = _.all = function(obj, iterator, context) {
        iterator || (iterator = _.identity);
        var result = true;
        if (obj == null) 
            return result;
        if (nativeEvery && obj.every === nativeEvery) 
            return obj.every(iterator, context);
        each(obj, function(value, index, list) {
            if (!(result = result && iterator.call(context, value, index, list))) 
                return breaker;
        });
        return !!result;
    };

    // Determine if at least one element in the object matches a truth test.
    // Delegates to **ECMAScript 5**'s native `some` if available.
    // Aliased as `any`.
    var any = _.some = _.any = function(obj, iterator, context) {
        iterator || (iterator = _.identity);
        var result = false;
        if (obj == null) 
            return result;
        if (nativeSome && obj.some === nativeSome) 
            return obj.some(iterator, context);
        each(obj, function(value, index, list) {
            if (result || (result = iterator.call(context, value, index, list))) 
                return breaker;
        });
        return !!result;
    };

    // Determine if the array or object contains a given value (using `===`).
    // Aliased as `include`.
    _.contains = _.include = function(obj, target) {
        var found = false;
        if (obj == null) 
            return found;
        if (nativeIndexOf && obj.indexOf === nativeIndexOf) 
            return obj.indexOf(target) != - 1;
        found = any(obj, function(value) {
            return value === target;
        });
        return found;
    };

    // Invoke a method (with arguments) on every item in a collection.
    _.invoke = function(obj, method) {
        var args = slice.call(arguments, 2);
        return _.map(obj, function(value) {
            return (_.isFunction(method) ? method : value[method]).apply(value, args);
        });
    };

    // Convenience version of a common use case of `map`: fetching a property.
    _.pluck = function(obj, key) {
        return _.map(obj, function(value) {
            return value[key];
        });
    };

    // Convenience version of a common use case of `filter`: selecting only objects
    // with specific `key:value` pairs.
    _.where = function(obj, attrs) {
        if (_.isEmpty(attrs)) 
            return [];
        return _.filter(obj, function(value) {
            for (var key in attrs) {
                if (attrs[key] !== value[key]) 
                    return false;
            }
            return true;
        });
    };

    // Return the maximum element or (element-based computation).
    // Can't optimize arrays of integers longer than 65,535 elements.
    // See: https://bugs.webkit.org/show_bug.cgi?id=80797
    _.max = function(obj, iterator, context) {
        if (!iterator && _.isArray(obj) && obj[0] === + obj[0] && obj.length < 65535) {
            return Math.max.apply(Math, obj);
        }
        if (!iterator && _.isEmpty(obj)) 
            return - Infinity;
        var result = {
            computed : - Infinity
        };
        each(obj, function(value, index, list) {
            var computed = iterator ? iterator.call(context, value, index, list) : value;
            computed >= result.computed && (result = {
                value : value,
                computed : computed
            });
        });
        return result.value;
    };

    // Return the minimum element (or element-based computation).
    _.min = function(obj, iterator, context) {
        if (!iterator && _.isArray(obj) && obj[0] === + obj[0] && obj.length < 65535) {
            return Math.min.apply(Math, obj);
        }
        if (!iterator && _.isEmpty(obj)) 
            return Infinity;
        var result = {
            computed : Infinity
        };
        each(obj, function(value, index, list) {
            var computed = iterator ? iterator.call(context, value, index, list) : value;
            computed < result.computed && (result = {
                value : value,
                computed : computed
            });
        });
        return result.value;
    };

    // Shuffle an array.
    _.shuffle = function(obj) {
        var rand;
        var index = 0;
        var shuffled = [];
        each(obj, function(value) {
            rand = _.random(index++);
            shuffled[index - 1] = shuffled[rand];
            shuffled[rand] = value;
        });
        return shuffled;
    };

    // An internal function to generate lookup iterators.
    var lookupIterator = function(value) {
        return _.isFunction(value) ? value : function(obj) {
            return obj[value];
        };
    };

    // Sort the object's values by a criterion produced by an iterator.
    _.sortBy = function(obj, value, context) {
        var iterator = lookupIterator(value);
        return _.pluck(_.map(obj, function(value, index, list) {
            return {
                value : value,
                index : index,
                criteria : iterator.call(context, value, index, list)
            };
        }).sort(function(left, right) {
            var a = left.criteria;
            var b = right.criteria;
            if (a !== b) {
                if (a > b || a === void 0) 
                    return 1;
                if (a < b || b === void 0) 
                    return - 1;
            }
            return left.index < right.index ? - 1 : 1;
        }), 'value');
    };

    // An internal function used for aggregate "group by" operations.
    var group = function(obj, value, context, behavior) {
        var result = {};
        var iterator = lookupIterator(value);
        each(obj, function(value, index) {
            var key = iterator.call(context, value, index, obj);
            behavior(result, key, value);
        });
        return result;
    };

    // Groups the object's values by a criterion. Pass either a string attribute
    // to group by, or a function that returns the criterion.
    _.groupBy = function(obj, value, context) {
        return group(obj, value, context, function(result, key, value) {
            (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
        });
    };

    // Counts instances of an object that group by a certain criterion. Pass
    // either a string attribute to count by, or a function that returns the
    // criterion.
    _.countBy = function(obj, value, context) {
        return group(obj, value, context, function(result, key, value) {
            if (!_.has(result, key)) 
                result[key] = 0;
            result[key]++;
        });
    };

    // Use a comparator function to figure out the smallest index at which
    // an object should be inserted so as to maintain order. Uses binary search.
    _.sortedIndex = function(array, obj, iterator, context) {
        iterator = iterator == null ? _.identity : lookupIterator(iterator);
        var value = iterator.call(context, obj);
        var low = 0, high = array.length;
        while (low < high) {
            var mid = (low + high) >>> 1;
            iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
        }
        return low;
    };

    // Safely convert anything iterable into a real, live array.
    _.toArray = function(obj) {
        if (!obj) 
            return [];
        if (obj.length === + obj.length) 
            return slice.call(obj);
        return _.values(obj);
    };

    // Return the number of elements in an object.
    _.size = function(obj) {
        return (obj.length === + obj.length) ? obj.length : _.keys(obj).length;
    };

    // Array Functions
    // ---------------

    // Get the first element of an array. Passing **n** will return the first N
    // values in the array. Aliased as `head` and `take`. The **guard** check
    // allows it to work with `_.map`.
    _.first = _.head = _.take = function(array, n, guard) {
        return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
    };

    // Returns everything but the last entry of the array. Especially useful on
    // the arguments object. Passing **n** will return all the values in
    // the array, excluding the last N. The **guard** check allows it to work with
    // `_.map`.
    _.initial = function(array, n, guard) {
        return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
    };

    // Get the last element of an array. Passing **n** will return the last N
    // values in the array. The **guard** check allows it to work with `_.map`.
    _.last = function(array, n, guard) {
        if ((n != null) && !guard) {
            return slice.call(array, Math.max(array.length - n, 0));
        } else {
            return array[array.length - 1];
        }
    };

    // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
    // Especially useful on the arguments object. Passing an **n** will return
    // the rest N values in the array. The **guard**
    // check allows it to work with `_.map`.
    _.rest = _.tail = _.drop = function(array, n, guard) {
        return slice.call(array, (n == null) || guard ? 1 : n);
    };

    // Trim out all falsy values from an array.
    _.compact = function(array) {
        return _.filter(array, function(value) {
            return !!value;
        });
    };

    // Internal implementation of a recursive `flatten` function.
    var flatten = function(input, shallow, output) {
        each(input, function(value) {
            if (_.isArray(value)) {
                shallow ? push.apply(output, value) : flatten(value, shallow, output);
            } else {
                output.push(value);
            }
        });
        return output;
    };

    // Return a completely flattened version of an array.
    _.flatten = function(array, shallow) {
        return flatten(array, shallow, []);
    };

    // Return a version of the array that does not contain the specified value(s).
    _.without = function(array) {
        return _.difference(array, slice.call(arguments, 1));
    };

    // Produce a duplicate-free version of the array. If the array has already
    // been sorted, you have the option of using a faster algorithm.
    // Aliased as `unique`.
    _.uniq = _.unique = function(array, isSorted, iterator, context) {
        var initial = iterator ? _.map(array, iterator, context) : array;
        var results = [];
        var seen = [];
        each(initial, function(value, index) {
            if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
                seen.push(value);
                results.push(array[index]);
            }
        });
        return results;
    };

    // Produce an array that contains the union: each distinct element from all of
    // the passed-in arrays.
    _.union = function() {
        return _.uniq(concat.apply(ArrayProto, arguments));
    };

    // Produce an array that contains every item shared between all the
    // passed-in arrays.
    _.intersection = function(array) {
        var rest = slice.call(arguments, 1);
        return _.filter(_.uniq(array), function(item) {
            return _.every(rest, function(other) {
                return _.indexOf(other, item) >= 0;
            });
        });
    };

    // Take the difference between one array and a number of other arrays.
    // Only the elements present in just the first array will remain.
    _.difference = function(array) {
        var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
        return _.filter(array, function(value) {
            return !_.contains(rest, value);
        });
    };

    // Zip together multiple lists into a single array -- elements that share
    // an index go together.
    _.zip = function() {
        var args = slice.call(arguments);
        var length = _.max(_.pluck(args, 'length'));
        var results = new Array(length);
        for (var i = 0; i < length; i++) {
            results[i] = _.pluck(args, "" + i);
        }
        return results;
    };

    // Converts lists into objects. Pass either a single array of `[key, value]`
    // pairs, or two parallel arrays of the same length -- one of keys, and one of
    // the corresponding values.
    _.object = function(list, values) {
        var result = {};
        for (var i = 0, l = list.length; i < l; i++) {
            if (values) {
                result[list[i]] = values[i];
            } else {
                result[list[i][0]] = list[i][1];
            }
        }
        return result;
    };

    // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
    // we need this function. Return the position of the first occurrence of an
    // item in an array, or -1 if the item is not included in the array.
    // Delegates to **ECMAScript 5**'s native `indexOf` if available.
    // If the array is large and already in sort order, pass `true`
    // for **isSorted** to use binary search.
    _.indexOf = function(array, item, isSorted) {
        if (array == null) 
            return - 1;
        var i = 0, l = array.length;
        if (isSorted) {
            if (typeof isSorted == 'number') {
                i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);
            } else {
                i = _.sortedIndex(array, item);
                return array[i] === item ? i : - 1;
            }
        }
        if (nativeIndexOf && array.indexOf === nativeIndexOf) 
            return array.indexOf(item, isSorted);
        for (; i < l; i++) 
            if (array[i] === item) 
                return i;
        return - 1;
    };

    // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
    _.lastIndexOf = function(array, item, from) {
        if (array == null) 
            return - 1;
        var hasIndex = from != null;
        if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
            return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
        }
        var i = (hasIndex ? from : array.length);
        while (i--) 
            if (array[i] === item) 
                return i;
        return - 1;
    };

    // Generate an integer Array containing an arithmetic progression. A port of
    // the native Python `range()` function. See
    // [the Python documentation](http://docs.python.org/library/functions.html#range).
    _.range = function(start, stop, step) {
        if (arguments.length <= 1) {
            stop = start || 0;
            start = 0;
        }
        step = arguments[2] || 1;

        var len = Math.max(Math.ceil((stop - start) / step), 0);
        var idx = 0;
        var range = new Array(len);

        while (idx < len) {
            range[idx++] = start;
            start += step;
        }

        return range;
    };

    // Function (ahem) Functions
    // ------------------

    // Reusable constructor function for prototype setting.
    var ctor = function() {};

    // Create a function bound to a given object (assigning `this`, and arguments,
    // optionally). Binding with arguments is also known as `curry`.
    // Delegates to **ECMAScript 5**'s native `Function.bind` if available.
    // We check for `func.bind` first, to fail fast when `func` is undefined.
    _.bind = function bind(func, context) {
        var bound, args;
        if (func.bind === nativeBind && nativeBind) 
            return nativeBind.apply(func, slice.call(arguments, 1));
        if (!_.isFunction(func)) 
            throw new TypeError;
        args = slice.call(arguments, 2);
        return bound = function() {
            if (!(this instanceof bound)) 
                return func.apply(context, args.concat(slice.call(arguments)));
            ctor.prototype = func.prototype;
            var self = new ctor;
            var result = func.apply(self, args.concat(slice.call(arguments)));
            if (Object(result) === result) 
                return result;
            return self;
        };
    };

    // Bind all of an object's methods to that object. Useful for ensuring that
    // all callbacks defined on an object belong to it.
    _.bindAll = function(obj) {
        var funcs = slice.call(arguments, 1);
        if (funcs.length == 0) 
            funcs = _.functions(obj);
        each(funcs, function(f) {
            obj[f] = _.bind(obj[f], obj);
        });
        return obj;
    };

    // Memoize an expensive function by storing its results.
    _.memoize = function(func, hasher) {
        var memo = {};
        hasher || (hasher = _.identity);
        return function() {
            var key = hasher.apply(this, arguments);
            return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
        };
    };

    // Delays a function for the given number of milliseconds, and then calls
    // it with the arguments supplied.
    _.delay = function(func, wait) {
        var args = slice.call(arguments, 2);
        return setTimeout(function() {
            return func.apply(null, args);
        }, wait);
    };

    // Defers a function, scheduling it to run after the current call stack has
    // cleared.
    _.defer = function(func) {
        return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
    };

    // Returns a function, that, when invoked, will only be triggered at most once
    // during a given window of time.
    _.throttle = function(func, wait) {
        var context, args, timeout, throttling, more, result;
        var whenDone = _.debounce(function() {
            more = throttling = false;
        }, wait);
        return function() {
            context = this;
            args = arguments;
            var later = function() {
                timeout = null;
                if (more) {
                    result = func.apply(context, args);
                }
                whenDone();
            };
            if (!timeout) 
                timeout = setTimeout(later, wait);
            if (throttling) {
                more = true;
            } else {
                throttling = true;
                result = func.apply(context, args);
            }
            whenDone();
            return result;
        };
    };

    // Returns a function, that, as long as it continues to be invoked, will not
    // be triggered. The function will be called after it stops being called for
    // N milliseconds. If `immediate` is passed, trigger the function on the
    // leading edge, instead of the trailing.
    _.debounce = function(func, wait, immediate) {
        var timeout, result;
        return function() {
            var context = this, args = arguments;
            var later = function() {
                timeout = null;
                if (!immediate) 
                    result = func.apply(context, args);
            };
            var callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) 
                result = func.apply(context, args);
            return result;
        };
    };

    // Returns a function that will be executed at most one time, no matter how
    // often you call it. Useful for lazy initialization.
    _.once = function(func) {
        var ran = false, memo;
        return function() {
            if (ran) 
                return memo;
            ran = true;
            memo = func.apply(this, arguments);
            func = null;
            return memo;
        };
    };

    // Returns the first function passed as an argument to the second,
    // allowing you to adjust arguments, run code before and after, and
    // conditionally execute the original function.
    _.wrap = function(func, wrapper) {
        return function() {
            var args = [func];
            push.apply(args, arguments);
            return wrapper.apply(this, args);
        };
    };

    // Returns a function that is the composition of a list of functions, each
    // consuming the return value of the function that follows.
    _.compose = function() {
        var funcs = arguments;
        return function() {
            var args = arguments;
            for (var i = funcs.length - 1; i >= 0; i--) {
                args = [funcs[i].apply(this, args)];
            }
            return args[0];
        };
    };

    // Returns a function that will only be executed after being called N times.
    _.after = function(times, func) {
        if (times <= 0) 
            return func();
        return function() {
            if (--times < 1) {
                return func.apply(this, arguments);
            }
        };
    };

    // Object Functions
    // ----------------

    // Retrieve the names of an object's properties.
    // Delegates to **ECMAScript 5**'s native `Object.keys`
    _.keys = nativeKeys || function(obj) {
        if (obj !== Object(obj)) 
            throw new TypeError('Invalid object');
        var keys = [];
        for (var key in obj) 
            if (_.has(obj, key)) 
                keys[keys.length] = key;
        return keys;
    };

    // Retrieve the values of an object's properties.
    _.values = function(obj) {
        var values = [];
        for (var key in obj) 
            if (_.has(obj, key)) 
                values.push(obj[key]);
        return values;
    };

    // Convert an object into a list of `[key, value]` pairs.
    _.pairs = function(obj) {
        var pairs = [];
        for (var key in obj) 
            if (_.has(obj, key)) 
                pairs.push([key, obj[key]]);
        return pairs;
    };

    // Invert the keys and values of an object. The values must be serializable.
    _.invert = function(obj) {
        var result = {};
        for (var key in obj) 
            if (_.has(obj, key)) 
                result[obj[key]] = key;
        return result;
    };

    // Return a sorted list of the function names available on the object.
    // Aliased as `methods`
    _.functions = _.methods = function(obj) {
        var names = [];
        for (var key in obj) {
            if (_.isFunction(obj[key])) 
                names.push(key);
        }
        return names.sort();
    };

    // Extend a given object with all the properties in passed-in object(s).
    _.extend = function(obj) {
        each(slice.call(arguments, 1), function(source) {
            for (var prop in source) {
                obj[prop] = source[prop];
            }
        });
        return obj;
    };

    // Return a copy of the object only containing the whitelisted properties.
    _.pick = function(obj) {
        var copy = {};
        var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
        each(keys, function(key) {
            if (key in obj) 
                copy[key] = obj[key];
        });
        return copy;
    };

    // Return a copy of the object without the blacklisted properties.
    _.omit = function(obj) {
        var copy = {};
        var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
        for (var key in obj) {
            if (!_.contains(keys, key)) 
                copy[key] = obj[key];
        }
        return copy;
    };

    // Fill in a given object with default properties.
    _.defaults = function(obj) {
        each(slice.call(arguments, 1), function(source) {
            for (var prop in source) {
                if (obj[prop] == null) 
                    obj[prop] = source[prop];
            }
        });
        return obj;
    };

    // Create a (shallow-cloned) duplicate of an object.
    _.clone = function(obj) {
        if (!_.isObject(obj)) 
            return obj;
        return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
    };

    // Invokes interceptor with the obj, and then returns obj.
    // The primary purpose of this method is to "tap into" a method chain, in
    // order to perform operations on intermediate results within the chain.
    _.tap = function(obj, interceptor) {
        interceptor(obj);
        return obj;
    };

    // Internal recursive comparison function for `isEqual`.
    var eq = function(a, b, aStack, bStack) {
        // Identical objects are equal. `0 === -0`, but they aren't identical.
        // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
        if (a === b) 
            return a !== 0 || 1 / a == 1 / b;
        // A strict comparison is necessary because `null == undefined`.
        if (a == null || b == null) 
            return a === b;
        // Unwrap any wrapped objects.
        if (a instanceof _) 
            a = a._wrapped;
        if (b instanceof _) 
            b = b._wrapped;
        // Compare `[[Class]]` names.
        var className = toString.call(a);
        if (className != toString.call(b)) 
            return false;
        switch (className) {
            // Strings, numbers, dates, and booleans are compared by value.
        case '[object String]':
            // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
            // equivalent to `new String("5")`.
            return a == String(b);
        case '[object Number]':
            // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
            // other numeric values.
            return a != + a ? b != + b : (a == 0 ? 1 / a == 1 / b : a == + b);
        case '[object Date]':
        case '[object Boolean]':
            // Coerce dates and booleans to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return + a == + b;
            // RegExps are compared by their source patterns and flags.
        case '[object RegExp]':
            return a.source == b.source &&
            a.global == b.global &&
            a.multiline == b.multiline &&
            a.ignoreCase == b.ignoreCase;
        }
        if (typeof a != 'object' || typeof b != 'object') 
            return false;
        // Assume equality for cyclic structures. The algorithm for detecting cyclic
        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
        var length = aStack.length;
        while (length--) {
            // Linear search. Performance is inversely proportional to the number of
            // unique nested structures.
            if (aStack[length] == a) 
                return bStack[length] == b;
        }
        // Add the first object to the stack of traversed objects.
        aStack.push(a);
        bStack.push(b);
        var size = 0, result = true;
        // Recursively compare objects and arrays.
        if (className == '[object Array]') {
            // Compare array lengths to determine if a deep comparison is necessary.
            size = a.length;
            result = size == b.length;
            if (result) {
                // Deep compare the contents, ignoring non-numeric properties.
                while (size--) {
                    if (!(result = eq(a[size], b[size], aStack, bStack))) 
                        break;
                }
            }
        } else {
            // Objects with different constructors are not equivalent, but `Object`s
            // from different frames are.
            var aCtor = a.constructor, bCtor = b.constructor;
            if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
            _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
                return false;
            }
            // Deep compare objects.
            for (var key in a) {
                if (_.has(a, key)) {
                    // Count the expected number of properties.
                    size++;
                    // Deep compare each member.
                    if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) 
                        break;
                }
            }
            // Ensure that both objects contain the same number of properties.
            if (result) {
                for (key in b) {
                    if (_.has(b, key) && !(size--)) 
                        break;
                }
                result = !size;
            }
        }
        // Remove the first object from the stack of traversed objects.
        aStack.pop();
        bStack.pop();
        return result;
    };

    // Perform a deep comparison to check if two objects are equal.
    _.isEqual = function(a, b) {
        return eq(a, b, [], []);
    };

    // Is a given array, string, or object empty?
    // An "empty" object has no enumerable own-properties.
    _.isEmpty = function(obj) {
        if (obj == null) 
            return true;
        if (_.isArray(obj) || _.isString(obj)) 
            return obj.length === 0;
        for (var key in obj) 
            if (_.has(obj, key)) 
                return false;
        return true;
    };

    // Is a given value a DOM element?
    _.isElement = function(obj) {
        return !!(obj && obj.nodeType === 1);
    };

    // Is a given value an array?
    // Delegates to ECMA5's native Array.isArray
    _.isArray = nativeIsArray || function(obj) {
        return toString.call(obj) == '[object Array]';
    };

    // Is a given variable an object?
    _.isObject = function(obj) {
        return obj === Object(obj);
    };

    // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
    each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
        _['is' + name] = function(obj) {
            return toString.call(obj) == '[object ' + name + ']';
        };
    });

    // Define a fallback version of the method in browsers (ahem, IE), where
    // there isn't any inspectable "Arguments" type.
    if (!_.isArguments(arguments)) {
        _.isArguments = function(obj) {
            return !!(obj && _.has(obj, 'callee'));
        };
    }

    // Optimize `isFunction` if appropriate.
    if (typeof (/./) !== 'function') {
        _.isFunction = function(obj) {
            return typeof obj === 'function';
        };
    }

    // Is a given object a finite number?
    _.isFinite = function(obj) {
        return _.isNumber(obj) && isFinite(obj);
    };

    // Is the given value `NaN`? (NaN is the only number which does not equal itself).
    _.isNaN = function(obj) {
        return _.isNumber(obj) && obj != + obj;
    };

    // Is a given value a boolean?
    _.isBoolean = function(obj) {
        return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
    };

    // Is a given value equal to null?
    _.isNull = function(obj) {
        return obj === null;
    };

    // Is a given variable undefined?
    _.isUndefined = function(obj) {
        return obj === void 0;
    };

    // Shortcut function for checking if an object has a given property directly
    // on itself (in other words, not on a prototype).
    _.has = function(obj, key) {
        return hasOwnProperty.call(obj, key);
    };

    // Utility Functions
    // -----------------

    // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
    // previous owner. Returns a reference to the Underscore object.
    _.noConflict = function() {
        root._ = previousUnderscore;
        return this;
    };

    // Keep the identity function around for default iterators.
    _.identity = function(value) {
        return value;
    };

    // Run a function **n** times.
    _.times = function(n, iterator, context) {
        for (var i = 0; i < n; i++) 
            iterator.call(context, i);
    };

    // Return a random integer between min and max (inclusive).
    _.random = function(min, max) {
        if (max == null) {
            max = min;
            min = 0;
        }
        return min + (0 | Math.random() * (max - min + 1));
    };

    // List of HTML entities for escaping.
    var entityMap = {
        escape: {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#x27;',
            '/': '&#x2F;'
        }
    };
    entityMap.unescape = _.invert(entityMap.escape);

    // Regexes containing the keys and values listed immediately above.
    var entityRegexes = {
        escape: new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
        unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
    };

    // Functions for escaping and unescaping strings to/from HTML interpolation.
    _.each(['escape', 'unescape'], function(method) {
        _[method] = function(string) {
            if (string == null) 
                return '';
            return ('' + string).replace(entityRegexes[method], function(match) {
                return entityMap[method][match];
            });
        };
    });

    // If the value of the named property is a function then invoke it;
    // otherwise, return it.
    _.result = function(object, property) {
        if (object == null) 
            return null;
        var value = object[property];
        return _.isFunction(value) ? value.call(object) : value;
    };

    // Add your own custom functions to the Underscore object.
    _.mixin = function(obj) {
        each(_.functions(obj), function(name) {
            var func = _[name] = obj[name];
            _.prototype[name] = function() {
                var args = [this._wrapped];
                push.apply(args, arguments);
                return result.call(this, func.apply(_, args));
            };
        });
    };

    // Generate a unique integer id (unique within the entire client session).
    // Useful for temporary DOM ids.
    var idCounter = 0;
    _.uniqueId = function(prefix) {
        var id = idCounter++;
        return prefix ? prefix + id : id;
    };

    // By default, Underscore uses ERB-style template delimiters, change the
    // following template settings to use alternative delimiters.
    _.templateSettings = {
        evaluate : /<%([\s\S]+?)%>/g,
        interpolate : /<%=([\s\S]+?)%>/g,
        escape : /<%-([\s\S]+?)%>/g
    };

    // When customizing `templateSettings`, if you don't want to define an
    // interpolation, evaluation or escaping regex, we need one that is
    // guaranteed not to match.
    var noMatch = /(.)^/;

    // Certain characters need to be escaped so that they can be put into a
    // string literal.
    var escapes = {
        "'": "'",
        '\\': '\\',
        '\r': 'r',
        '\n': 'n',
        '\t': 't',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
    };

    var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

    // JavaScript micro-templating, similar to John Resig's implementation.
    // Underscore templating handles arbitrary delimiters, preserves whitespace,
    // and correctly escapes quotes within interpolated code.
    _.template = function(text, data, settings) {
        settings = _.defaults({}, settings, _.templateSettings);

        // Combine delimiters into one regular expression via alternation.
        var matcher = new RegExp([
        (settings.escape || noMatch).source,
        (settings.interpolate || noMatch).source,
        (settings.evaluate || noMatch).source
        ].join('|') + '|$', 'g');

        // Compile the template source, escaping string literals appropriately.
        var index = 0;
        var source = "__p+='";
        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
            source += text.slice(index, offset)
            .replace(escaper, function(match) {
                return '\\' + escapes[match];
            });
            source +=
            escape ? "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'" :
            interpolate ? "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'" :
            evaluate ? "';\n" + evaluate + "\n__p+='" : '';
            index = offset + match.length;
        });
        source += "';\n";

        // If a variable is not specified, place data values in local scope.
        if (!settings.variable) 
            source = 'with(obj||{}){\n' + source + '}\n';

        source = "var __t,__p='',__j=Array.prototype.join," +
        "print=function(){__p+=__j.call(arguments,'');};\n" +
        source + "return __p;\n";

        try {
            var render = new Function(settings.variable || 'obj', '_', source);
        } catch (e) {
            e.source = source;
            throw e;
        }

        if (data) 
            return render(data, _);
        var template = function(data) {
            return render.call(this, data, _);
        };

        // Provide the compiled function source as a convenience for precompilation.
        template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

        return template;
    };

    // Add a "chain" function, which will delegate to the wrapper.
    _.chain = function(obj) {
        return _(obj).chain();
    };

    // OOP
    // ---------------
    // If Underscore is called as a function, it returns a wrapped object that
    // can be used OO-style. This wrapper holds altered versions of all the
    // underscore functions. Wrapped objects may be chained.

    // Helper function to continue chaining intermediate results.
    var result = function(obj) {
        return this._chain ? _(obj).chain() : obj;
    };

    // Add all of the Underscore functions to the wrapper object.
    _.mixin(_);

    // Add all mutator Array functions to the wrapper.
    each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
            var obj = this._wrapped;
            method.apply(obj, arguments);
            if ((name == 'shift' || name == 'splice') && obj.length === 0) 
                delete obj[0];
            return result.call(this, obj);
        };
    });

    // Add all accessor Array functions to the wrapper.
    each(['concat', 'join', 'slice'], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
            return result.call(this, method.apply(this._wrapped, arguments));
        };
    });

    _.extend(_.prototype, {

        // Start chaining a wrapped Underscore object.
        chain: function() {
            this._chain = true;
            return this;
        },

        // Extracts the result from a wrapped and chained object.
        value: function() {
            return this._wrapped;
        }

    });

    return _.noConflict();
});

//     Backbone.js 0.9.2

//     (c) 2010-2012 Jeremy Ashkenas, DocumentCloud Inc.
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

define('backbone', ["jquery", "underscore"], function($, _) {
    // Initial Setup
    // -------------

    // Save a reference to the global object (`window` in the browser, `global`
    // on the server).
    var root = window;

    // Save the previous value of the `Backbone` variable, so that it can be
    // restored later on, if `noConflict` is used.
    var previousBackbone = root.Backbone;

    // Create a local reference to array methods.
    var ArrayProto = Array.prototype;
    var push = ArrayProto.push;
    var slice = ArrayProto.slice;
    var splice = ArrayProto.splice;

    // The top-level namespace. All public Backbone classes and modules will
    // be attached to this. Exported for both CommonJS and the browser.
    var Backbone;
    if (typeof exports !== 'undefined') {
        Backbone = exports;
    } else {
        Backbone = root.Backbone = {};
    }

    // Current version of the library. Keep in sync with `package.json`.
    Backbone.VERSION = '0.9.2';

    // For Backbone's purposes, jQuery, Zepto, or Ender owns the `$` variable.
    Backbone.$ = $;

    // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
    // to its previous owner. Returns a reference to this Backbone object.
    Backbone.noConflict = function() {
        root.Backbone = previousBackbone;
        return this;
    };

    // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
    // will fake `"PUT"` and `"DELETE"` requests via the `_method` parameter and
    // set a `X-Http-Method-Override` header.
    Backbone.emulateHTTP = false;

    // Turn on `emulateJSON` to support legacy servers that can't deal with direct
    // `application/json` requests ... will encode the body as
    // `application/x-www-form-urlencoded` instead and will send the model in a
    // form param named `model`.
    Backbone.emulateJSON = false;

    // Backbone.Events
    // ---------------

    // Regular expression used to split event strings
    var eventSplitter = /\s+/;

    // A module that can be mixed in to *any object* in order to provide it with
    // custom events. You may bind with `on` or remove with `off` callback functions
    // to an event; `trigger`-ing an event fires all callbacks in succession.
    //
    //     var object = {};
    //     _.extend(object, Backbone.Events);
    //     object.on('expand', function(){ alert('expanded'); });
    //     object.trigger('expand');
    //
    var Events = Backbone.Events = {

        // Bind one or more space separated events, `events`, to a `callback`
        // function. Passing `"all"` will bind the callback to all events fired.
        on: function(events, callback, context) {
            var calls, event, list;
            if (!callback) 
                return this;

            events = events.split(eventSplitter);
            calls = this._callbacks || (this._callbacks = {});

            while (event = events.shift()) {
                list = calls[event] || (calls[event] = []);
                list.push(callback, context);
            }

            return this;
        },

        // Remove one or many callbacks. If `context` is null, removes all callbacks
        // with that function. If `callback` is null, removes all callbacks for the
        // event. If `events` is null, removes all bound callbacks for all events.
        off: function(events, callback, context) {
            var event, calls, list, i;

            // No events, or removing *all* events.
            if (!(calls = this._callbacks)) 
                return this;
            if (!(events || callback || context)) {
                delete this._callbacks;
                return this;
            }

            events = events ? events.split(eventSplitter) : _.keys(calls);

            // Loop through the callback list, splicing where appropriate.
            while (event = events.shift()) {
                if (!(list = calls[event]) || !(callback || context)) {
                    delete calls[event];
                    continue;
                }

                for (i = list.length - 2; i >= 0; i -= 2) {
                    if (!(callback && list[i] !== callback || context && list[i + 1] !== context)) {
                        list.splice(i, 2);
                    }
                }
            }

            return this;
        },

        // Trigger one or many events, firing all bound callbacks. Callbacks are
        // passed the same arguments as `trigger` is, apart from the event name
        // (unless you're listening on `"all"`, which will cause your callback to
        // receive the true name of the event as the first argument).
        trigger: function(events) {
            var event, calls, list, i, length, args, all, rest;
            if (!(calls = this._callbacks)) 
                return this;

            rest = [];
            events = events.split(eventSplitter);

            // Fill up `rest` with the callback arguments.  Since we're only copying
            // the tail of `arguments`, a loop is much faster than Array#slice.
            for (i = 1, length = arguments.length; i < length; i++) {
                rest[i - 1] = arguments[i];
            }

            // For each event, walk through the list of callbacks twice, first to
            // trigger the event, then to trigger any `"all"` callbacks.
            while (event = events.shift()) {
                // Copy callback lists to prevent modification.
                if (all = calls.all) 
                    all = all.slice();
                if (list = calls[event]) 
                    list = list.slice();

                // Execute event callbacks.
                if (list) {
                    for (i = 0, length = list.length; i < length; i += 2) {
                        list[i].apply(list[i + 1] || this, rest);
                    }
                }

                // Execute "all" callbacks.
                if (all) {
                    args = [event].concat(rest);
                    for (i = 0, length = all.length; i < length; i += 2) {
                        all[i].apply(all[i + 1] || this, args);
                    }
                }
            }

            return this;
        }

    };

    // Aliases for backwards compatibility.
    Events.bind = Events.on;
    Events.unbind = Events.off;

    // Backbone.Model
    // --------------

    // Create a new model, with defined attributes. A client id (`cid`)
    // is automatically generated and assigned for you.
    var Model = Backbone.Model = function(attributes, options) {
        var defaults;
        var attrs = attributes || {};
        if (options && options.collection) 
            this.collection = options.collection;
        if (options && options.parse) 
            attrs = this.parse(attrs);
        if (defaults = _.result(this, 'defaults')) {
            attrs = _.extend({}, defaults, attrs);
        }
        this.attributes = {};
        this._escapedAttributes = {};
        this.cid = _.uniqueId('c');
        this.changed = {};
        this._changes = {};
        this._pending = {};
        this.set(attrs, {
            silent: true
        });
        // Reset change tracking.
        this.changed = {};
        this._changes = {};
        this._pending = {};
        this._previousAttributes = _.clone(this.attributes);
        this.initialize.apply(this, arguments);
    };

    // Attach all inheritable methods to the Model prototype.
    _.extend(Model.prototype, Events, {

        // A hash of attributes whose current and previous value differ.
        changed: null,

        // A hash of attributes that have changed since the last time `change`
        // was called.
        _changes: null,

        // A hash of attributes that have changed since the last `change` event
        // began.
        _pending: null,

        // A hash of attributes with the current model state to determine if
        // a `change` should be recorded within a nested `change` block.
        _changing : null,

        // The default name for the JSON `id` attribute is `"id"`. MongoDB and
        // CouchDB users may want to set this to `"_id"`.
        idAttribute: 'id',

        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {},

        // Return a copy of the model's `attributes` object.
        toJSON: function(options) {
            return _.clone(this.attributes);
        },

        // Proxy `Backbone.sync` by default.
        sync: function() {
            return Backbone.sync.apply(this, arguments);
        },

        // Get the value of an attribute.
        get: function(attr) {
            return this.attributes[attr];
        },

        // Get the HTML-escaped value of an attribute.
        escape: function(attr) {
            var html;
            if (html = this._escapedAttributes[attr]) 
                return html;
            var val = this.get(attr);
            return this._escapedAttributes[attr] = _.escape(val == null ? '' : '' + val);
        },

        // Returns `true` if the attribute contains a value that is not null
        // or undefined.
        has: function(attr) {
            return this.get(attr) != null;
        },

        // Set a hash of model attributes on the object, firing `"change"` unless
        // you choose to silence it.
        set: function(key, val, options) {
            var attr, attrs;
            if (key == null) 
                return this;

            // Handle both `"key", value` and `{key: value}` -style arguments.
            if (_.isObject(key)) {
                attrs = key;
                options = val;
            } else {
                (attrs = {})[key] = val;
            }

            // Extract attributes and options.
            var silent = options && options.silent;
            var unset = options && options.unset;
            if (attrs instanceof Model) 
                attrs = attrs.attributes;
            if (unset) 
                for (attr in attrs) 
                    attrs[attr] = void 0;

            // Run validation.
            if (!this._validate(attrs, options)) 
                return false;

            // Check for changes of `id`.
            if (this.idAttribute in attrs) 
                this.id = attrs[this.idAttribute];

            var changing = this._changing;
            var now = this.attributes;
            var escaped = this._escapedAttributes;
            var prev = this._previousAttributes || {};

            // For each `set` attribute...
            for (attr in attrs) {
                val = attrs[attr];

                // If the new and current value differ, record the change.
                if (!_.isEqual(now[attr], val) || (unset && _.has(now, attr))) {
                    delete escaped[attr];
                    this._changes[attr] = true;
                }

                // Update or delete the current value.
                unset ? delete now[attr] : now[attr] = val;

                // If the new and previous value differ, record the change.  If not,
                // then remove changes for this attribute.
                if (!_.isEqual(prev[attr], val) || (_.has(now, attr) !== _.has(prev, attr))) {
                    this.changed[attr] = val;
                    if (!silent) 
                        this._pending[attr] = true;
                } else {
                    delete this.changed[attr];
                    delete this._pending[attr];
                    if (!changing) 
                        delete this._changes[attr];
                }

                if (changing && _.isEqual(now[attr], changing[attr])) 
                    delete this._changes[attr];
            }

            // Fire the `"change"` events.
            if (!silent) 
                this.change(options);
            return this;
        },

        // Remove an attribute from the model, firing `"change"` unless you choose
        // to silence it. `unset` is a noop if the attribute doesn't exist.
        unset: function(attr, options) {
            options = _.extend({}, options, {
                unset: true
            });
            return this.set(attr, null, options);
        },

        // Clear all attributes on the model, firing `"change"` unless you choose
        // to silence it.
        clear: function(options) {
            options = _.extend({}, options, {
                unset: true
            });
            return this.set(_.clone(this.attributes), options);
        },

        // Fetch the model from the server. If the server's representation of the
        // model differs from its current attributes, they will be overriden,
        // triggering a `"change"` event.
        fetch: function(options) {
            options = options ? _.clone(options) : {};
            var model = this;
            var success = options.success;
            options.success = function(resp, status, xhr) {
                if (!model.set(model.parse(resp, xhr), options)) 
                    return false;
                if (success) 
                    success(model, resp, options);
            };
            return this.sync('read', this, options);
        },

        // Set a hash of model attributes, and sync the model to the server.
        // If the server returns an attributes hash that differs, the model's
        // state will be `set` again.
        save: function(key, val, options) {
            var attrs, current, done;

            // Handle both `"key", value` and `{key: value}` -style arguments.
            if (key == null || _.isObject(key)) {
                attrs = key;
                options = val;
            } else if (key != null) {
                (attrs = {})[key] = val;
            }
            options = options ? _.clone(options) : {};

            // If we're "wait"-ing to set changed attributes, validate early.
            if (options.wait) {
                if (!this._validate(attrs, options)) 
                    return false;
                current = _.clone(this.attributes);
            }

            // Regular saves `set` attributes before persisting to the server.
            var silentOptions = _.extend({}, options, {
                silent: true
            });
            if (attrs && !this.set(attrs, options.wait ? silentOptions : options)) {
                return false;
            }

            // Do not persist invalid models.
            if (!attrs && !this._validate(null, options)) 
                return false;

            // After a successful server-side save, the client is (optionally)
            // updated with the server-side state.
            var model = this;
            var success = options.success;
            options.success = function(resp, status, xhr) {
                done = true;
                var serverAttrs = model.parse(resp, xhr);
                if (options.wait) 
                    serverAttrs = _.extend(attrs || {}, serverAttrs);
                if (!model.set(serverAttrs, options)) 
                    return false;
                if (success) 
                    success(model, resp, options);
            };

            // Finish configuring and sending the Ajax request.
            var xhr = this.sync(this.isNew() ? 'create' : 'update', this, options);

            // When using `wait`, reset attributes to original values unless
            // `success` has been called already.
            if (!done && options.wait) {
                this.clear(silentOptions);
                this.set(current, silentOptions);
            }

            return xhr;
        },

        // Destroy this model on the server if it was already persisted.
        // Optimistically removes the model from its collection, if it has one.
        // If `wait: true` is passed, waits for the server to respond before removal.
        destroy: function(options) {
            options = options ? _.clone(options) : {};
            var model = this;
            var success = options.success;

            var destroy = function() {
                model.trigger('destroy', model, model.collection, options);
            };

            options.success = function(resp) {
                if (options.wait || model.isNew()) 
                    destroy();
                if (success) 
                    success(model, resp, options);
            };

            if (this.isNew()) {
                options.success();
                return false;
            }

            var xhr = this.sync('delete', this, options);
            if (!options.wait) 
                destroy();
            return xhr;
        },

        // Default URL for the model's representation on the server -- if you're
        // using Backbone's restful methods, override this to change the endpoint
        // that will be called.
        url: function() {
            var base = _.result(this, 'urlRoot') || _.result(this.collection, 'url') || urlError();
            if (this.isNew()) 
                return base;
            return base + (base.charAt(base.length - 1) === '/' ? '' : '/') + encodeURIComponent(this.id);
        },

        // **parse** converts a response into the hash of attributes to be `set` on
        // the model. The default implementation is just to pass the response along.
        parse: function(resp, xhr) {
            return resp;
        },

        // Create a new model with identical attributes to this one.
        clone: function() {
            return new this.constructor(this.attributes);
        },

        // A model is new if it has never been saved to the server, and lacks an id.
        isNew: function() {
            return this.id == null;
        },

        // Call this method to manually fire a `"change"` event for this model and
        // a `"change:attribute"` event for each changed attribute.
        // Calling this will cause all objects observing the model to update.
        change: function(options) {
            var changing = this._changing;
            var current = this._changing = {};

            // Silent changes become pending changes.
            for (var attr in this._changes) 
                this._pending[attr] = true;

            // Trigger 'change:attr' for any new or silent changes.
            var changes = this._changes;
            this._changes = {};

            // Set the correct state for this._changing values
            var triggers = [];
            for (var attr in changes) {
                current[attr] = this.get(attr);
                triggers.push(attr);
            }

            for (var i = 0, l = triggers.length; i < l; i++) {
                this.trigger('change:' + triggers[i], this, current[triggers[i]], options);
            }
            if (changing) 
                return this;

            // Continue firing `"change"` events while there are pending changes.
            while (!_.isEmpty(this._pending)) {
                this._pending = {};
                this.trigger('change', this, options);
                // Pending and silent changes still remain.
                for (var attr in this.changed) {
                    if (this._pending[attr] || this._changes[attr]) 
                        continue;
                    delete this.changed[attr];
                }
                this._previousAttributes = _.clone(this.attributes);
            }

            this._changing = null;
            return this;
        },

        // Determine if the model has changed since the last `"change"` event.
        // If you specify an attribute name, determine if that attribute has changed.
        hasChanged: function(attr) {
            if (attr == null) 
                return !_.isEmpty(this.changed);
            return _.has(this.changed, attr);
        },

        // Return an object containing all the attributes that have changed, or
        // false if there are no changed attributes. Useful for determining what
        // parts of a view need to be updated and/or what attributes need to be
        // persisted to the server. Unset attributes will be set to undefined.
        // You can also pass an attributes object to diff against the model,
        // determining if there *would be* a change.
        changedAttributes: function(diff) {
            if (!diff) 
                return this.hasChanged() ? _.clone(this.changed) : false;
            var val, changed = false, old = this._previousAttributes;
            for (var attr in diff) {
                if (_.isEqual(old[attr], (val = diff[attr]))) 
                    continue;
                (changed || (changed = {}))[attr] = val;
            }
            return changed;
        },

        // Get the previous value of an attribute, recorded at the time the last
        // `"change"` event was fired.
        previous: function(attr) {
            if (attr == null || !this._previousAttributes) 
                return null;
            return this._previousAttributes[attr];
        },

        // Get all of the attributes of the model at the time of the previous
        // `"change"` event.
        previousAttributes: function() {
            return _.clone(this._previousAttributes);
        },

        // Check if the model is currently in a valid state. It's only possible to
        // get into an *invalid* state if you're using silent changes.
        isValid: function(options) {
            return !this.validate || !this.validate(this.attributes, options);
        },

        // Run validation against the next complete set of model attributes,
        // returning `true` if all is well. If a specific `error` callback has
        // been passed, call that instead of firing the general `"error"` event.
        _validate: function(attrs, options) {
            if (options && options.silent || !this.validate) 
                return true;
            attrs = _.extend({}, this.attributes, attrs);
            var error = this.validate(attrs, options);
            if (!error) 
                return true;
            if (options && options.error) 
                options.error(this, error, options);
            this.trigger('error', this, error, options);
            return false;
        }

    });

    // Backbone.Collection
    // -------------------

    // Provides a standard collection class for our sets of models, ordered
    // or unordered. If a `comparator` is specified, the Collection will maintain
    // its models in sort order, as they're added and removed.
    var Collection = Backbone.Collection = function(models, options) {
        options || (options = {});
        if (options.model) 
            this.model = options.model;
        if (options.comparator !== void 0) 
            this.comparator = options.comparator;
        this._reset();
        this.initialize.apply(this, arguments);
        if (models) {
            if (options.parse) 
                models = this.parse(models);
            this.reset(models, {
                silent: true,
                parse: options.parse
            });
        }
    };

    // Define the Collection's inheritable methods.
    _.extend(Collection.prototype, Events, {

        // The default model for a collection is just a **Backbone.Model**.
        // This should be overridden in most cases.
        model: Model,

        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {},

        // The JSON representation of a Collection is an array of the
        // models' attributes.
        toJSON: function(options) {
            return this.map(function(model) {
                return model.toJSON(options);
            });
        },

        // Proxy `Backbone.sync` by default.
        sync: function() {
            return Backbone.sync.apply(this, arguments);
        },

        // Add a model, or list of models to the set. Pass **silent** to avoid
        // firing the `add` event for every new model.
        add: function(models, options) {
            var i, args, length, model, existing;
            var at = options && options.at;
            models = _.isArray(models) ? models.slice() : [models];

            // Begin by turning bare objects into model references, and preventing
            // invalid models from being added.
            for (i = 0, length = models.length; i < length; i++) {
                if (models[i] = this._prepareModel(models[i], options)) 
                    continue;
                throw new Error("Can't add an invalid model to a collection");
            }

            for (i = models.length - 1; i >= 0; i--) {
                model = models[i];
                existing = model.id != null && this._byId[model.id];

                // If a duplicate is found, splice it out and optionally merge it into
                // the existing model.
                if (existing || this._byCid[model.cid]) {
                    if (options && options.merge && existing) {
                        existing.set(model, options);
                    }
                    models.splice(i, 1);
                    continue;
                }

                // Listen to added models' events, and index models for lookup by
                // `id` and by `cid`.
                model.on('all', this._onModelEvent, this);
                this._byCid[model.cid] = model;
                if (model.id != null) 
                    this._byId[model.id] = model;
            }

            // Update `length` and splice in new models.
            this.length += models.length;
            args = [at != null ? at : this.models.length, 0];
            push.apply(args, models);
            splice.apply(this.models, args);

            // Sort the collection if appropriate.
            if (this.comparator && at == null) 
                this.sort({
                    silent: true
                });

            if (options && options.silent) 
                return this;

            // Trigger `add` events.
            while (model = models.shift()) {
                model.trigger('add', model, this, options);
            }

            return this;
        },

        // Remove a model, or a list of models from the set. Pass silent to avoid
        // firing the `remove` event for every model removed.
        remove: function(models, options) {
            var i, l, index, model;
            options || (options = {});
            models = _.isArray(models) ? models.slice() : [models];
            for (i = 0, l = models.length; i < l; i++) {
                model = this.getByCid(models[i]) || this.get(models[i]);
                if (!model) 
                    continue;
                delete this._byId[model.id];
                delete this._byCid[model.cid];
                index = this.indexOf(model);
                this.models.splice(index, 1);
                this.length--;
                if (!options.silent) {
                    options.index = index;
                    model.trigger('remove', model, this, options);
                }
                this._removeReference(model);
            }
            return this;
        },

        // Add a model to the end of the collection.
        push: function(model, options) {
            model = this._prepareModel(model, options);
            this.add(model, options);
            return model;
        },

        // Remove a model from the end of the collection.
        pop: function(options) {
            var model = this.at(this.length - 1);
            this.remove(model, options);
            return model;
        },

        // Add a model to the beginning of the collection.
        unshift: function(model, options) {
            model = this._prepareModel(model, options);
            this.add(model, _.extend({
                at: 0
            }, options));
            return model;
        },

        // Remove a model from the beginning of the collection.
        shift: function(options) {
            var model = this.at(0);
            this.remove(model, options);
            return model;
        },

        // Slice out a sub-array of models from the collection.
        slice: function(begin, end) {
            return this.models.slice(begin, end);
        },

        // Get a model from the set by id.
        get: function(id) {
            if (id == null) 
                return void 0;
            return this._byId[id.id != null ? id.id : id];
        },

        // Get a model from the set by client id.
        getByCid: function(cid) {
            return cid && this._byCid[cid.cid || cid];
        },

        // Get the model at the given index.
        at: function(index) {
            return this.models[index];
        },

        // Return models with matching attributes. Useful for simple cases of `filter`.
        where: function(attrs) {
            if (_.isEmpty(attrs)) 
                return [];
            return this.filter(function(model) {
                for (var key in attrs) {
                    if (attrs[key] !== model.get(key)) 
                        return false;
                }
                return true;
            });
        },

        // Force the collection to re-sort itself. You don't need to call this under
        // normal circumstances, as the set will maintain sort order as each item
        // is added.
        sort: function(options) {
            if (!this.comparator) {
                throw new Error('Cannot sort a set without a comparator');
            }

            if (_.isString(this.comparator) || this.comparator.length === 1) {
                this.models = this.sortBy(this.comparator, this);
            } else {
                this.models.sort(_.bind(this.comparator, this));
            }

            if (!options || !options.silent) 
                this.trigger('reset', this, options);
            return this;
        },

        // Pluck an attribute from each model in the collection.
        pluck: function(attr) {
            return _.invoke(this.models, 'get', attr);
        },

        // When you have more items than you want to add or remove individually,
        // you can reset the entire set with a new list of models, without firing
        // any `add` or `remove` events. Fires `reset` when finished.
        reset: function(models, options) {
            for (var i = 0, l = this.models.length; i < l; i++) {
                this._removeReference(this.models[i]);
            }
            this._reset();
            if (models) 
                this.add(models, _.extend({
                    silent: true
                }, options));
            if (!options || !options.silent) 
                this.trigger('reset', this, options);
            return this;
        },

        // Fetch the default set of models for this collection, resetting the
        // collection when they arrive. If `add: true` is passed, appends the
        // models to the collection instead of resetting.
        fetch: function(options) {
            options = options ? _.clone(options) : {};
            if (options.parse === void 0) 
                options.parse = true;
            var collection = this;
            var success = options.success;
            options.success = function(resp, status, xhr) {
                collection[options.add ? 'add' : 'reset'](collection.parse(resp, xhr), options);
                if (success) 
                    success(collection, resp, options);
            };
            return this.sync('read', this, options);
        },

        // Create a new instance of a model in this collection. Add the model to the
        // collection immediately, unless `wait: true` is passed, in which case we
        // wait for the server to agree.
        create: function(model, options) {
            var collection = this;
            options = options ? _.clone(options) : {};
            model = this._prepareModel(model, options);
            if (!model) 
                return false;
            if (!options.wait) 
                collection.add(model, options);
            var success = options.success;
            options.success = function(model, resp, options) {
                if (options.wait) 
                    collection.add(model, options);
                if (success) 
                    success(model, resp, options);
            };
            model.save(null, options);
            return model;
        },

        // **parse** converts a response into a list of models to be added to the
        // collection. The default implementation is just to pass it through.
        parse: function(resp, xhr) {
            return resp;
        },

        // Create a new collection with an identical list of models as this one.
        clone: function() {
            return new this.constructor(this.models);
        },

        // Proxy to _'s chain. Can't be proxied the same way the rest of the
        // underscore methods are proxied because it relies on the underscore
        // constructor.
        chain: function() {
            return _(this.models).chain();
        },

        // Reset all internal state. Called when the collection is reset.
        _reset: function(options) {
            this.length = 0;
            this.models = [];
            this._byId = {};
            this._byCid = {};
        },

        // Prepare a model or hash of attributes to be added to this collection.
        _prepareModel: function(attrs, options) {
            if (attrs instanceof Model) {
                if (!attrs.collection) 
                    attrs.collection = this;
                return attrs;
            }
            options || (options = {});
            options.collection = this;
            var model = new this.model(attrs, options);
            if (!model._validate(model.attributes, options)) 
                return false;
            return model;
        },

        // Internal method to remove a model's ties to a collection.
        _removeReference: function(model) {
            if (this === model.collection) 
                delete model.collection;
            model.off('all', this._onModelEvent, this);
        },

        // Internal method called every time a model in the set fires an event.
        // Sets need to update their indexes when models change ids. All other
        // events simply proxy through. "add" and "remove" events that originate
        // in other collections are ignored.
        _onModelEvent: function(event, model, collection, options) {
            if ((event === 'add' || event === 'remove') && collection !== this) 
                return;
            if (event === 'destroy') 
                this.remove(model, options);
            if (model && event === 'change:' + model.idAttribute) {
                delete this._byId[model.previous(model.idAttribute)];
                if (model.id != null) 
                    this._byId[model.id] = model;
            }
            this.trigger.apply(this, arguments);
        }

    });

    // Underscore methods that we want to implement on the Collection.
    var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
    'max', 'min', 'sortedIndex', 'toArray', 'size', 'first', 'head', 'take',
    'initial', 'rest', 'tail', 'last', 'without', 'indexOf', 'shuffle',
    'lastIndexOf', 'isEmpty'];

    // Mix in each Underscore method as a proxy to `Collection#models`.
    _.each(methods, function(method) {
        Collection.prototype[method] = function() {
            var args = slice.call(arguments);
            args.unshift(this.models);
            return _[method].apply(_, args);
        };
    });

    // Underscore methods that take a property name as an argument.
    var attributeMethods = ['groupBy', 'countBy', 'sortBy'];

    // Use attributes instead of properties.
    _.each(attributeMethods, function(method) {
        Collection.prototype[method] = function(value, context) {
            var iterator = _.isFunction(value) ? value : function(model) {
                return model.get(value);
            };
            return _[method](this.models, iterator, context);
        };
    });

    // Backbone.Router
    // ---------------

    // Routers map faux-URLs to actions, and fire events when routes are
    // matched. Creating a new one sets its `routes` hash, if not set statically.
    var Router = Backbone.Router = function(options) {
        options || (options = {});
        if (options.routes) 
            this.routes = options.routes;
        this._bindRoutes();
        this.initialize.apply(this, arguments);
    };

    // Cached regular expressions for matching named param parts and splatted
    // parts of route strings.
    var optionalParam = /\((.*?)\)/g;
    var namedParam = /:\w+/g;
    var splatParam = /\*\w+/g;
    var escapeRegExp = /[-{}[\]+?.,\\^$|#\s]/g;

    // Set up all inheritable **Backbone.Router** properties and methods.
    _.extend(Router.prototype, Events, {

        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {},

        // Manually bind a single named route to a callback. For example:
        //
        //     this.route('search/:query/p:num', 'search', function(query, num) {
        //       ...
        //     });
        //
        route: function(route, name, callback) {
            if (!_.isRegExp(route)) 
                route = this._routeToRegExp(route);
            if (!callback) 
                callback = this[name];
            Backbone.history.route(route, _.bind(function(fragment) {
                var args = this._extractParameters(route, fragment);
                callback && callback.apply(this, args);
                this.trigger.apply(this, ['route:' + name].concat(args));
                Backbone.history.trigger('route', this, name, args);
            }, this));
            return this;
        },

        // Simple proxy to `Backbone.history` to save a fragment into the history.
        navigate: function(fragment, options) {
            Backbone.history.navigate(fragment, options);
            return this;
        },

        // Bind all defined routes to `Backbone.history`. We have to reverse the
        // order of the routes here to support behavior where the most general
        // routes can be defined at the bottom of the route map.
        _bindRoutes: function() {
            if (!this.routes) 
                return;
            var route, routes = _.keys(this.routes);
            while ((route = routes.pop()) != null) {
                this.route(route, this.routes[route]);
            }
        },

        // Convert a route string into a regular expression, suitable for matching
        // against the current location hash.
        _routeToRegExp: function(route) {
            route = route.replace(escapeRegExp, '\\$&')
            .replace(optionalParam, '(?:$1)?')
            .replace(namedParam, '([^\/]+)')
            .replace(splatParam, '(.*?)');
            return new RegExp('^' + route + '$');
        },

        // Given a route, and a URL fragment that it matches, return the array of
        // extracted parameters.
        _extractParameters: function(route, fragment) {
            return route.exec(fragment).slice(1);
        }

    });

    // Backbone.History
    // ----------------

    // Handles cross-browser history management, based on URL fragments. If the
    // browser does not support `onhashchange`, falls back to polling.
    var History = Backbone.History = function() {
        this.handlers = [];
        _.bindAll(this, 'checkUrl');

        // #1653 - Ensure that `History` can be used outside of the browser.
        if (typeof window !== 'undefined') {
            this.location = window.location;
            this.history = window.history;
        }
    };

    // Cached regex for cleaning leading hashes and slashes.
    var routeStripper = /^[#\/]/;

    // Cached regex for stripping leading and trailing slashes.
    var rootStripper = /^\/+|\/+$/g;

    // Cached regex for detecting MSIE.
    var isExplorer = /msie [\w.]+/;

    // Cached regex for removing a trailing slash.
    var trailingSlash = /\/$/;

    // Has the history handling already been started?
    History.started = false;

    // Set up all inheritable **Backbone.History** properties and methods.
    _.extend(History.prototype, Events, {

        // The default interval to poll for hash changes, if necessary, is
        // twenty times a second.
        interval: 50,

        // Gets the true hash value. Cannot use location.hash directly due to bug
        // in Firefox where location.hash will always be decoded.
        getHash: function(window) {
            var match = (window || this).location.href.match(/#(.*)$/);
            return match ? match[1] : '';
        },

        // Get the cross-browser normalized URL fragment, either from the URL,
        // the hash, or the override.
        getFragment: function(fragment, forcePushState) {
            if (fragment == null) {
                if (this._hasPushState || !this._wantsHashChange || forcePushState) {
                    fragment = this.location.pathname;
                    var root = this.root.replace(trailingSlash, '');
                    if (!fragment.indexOf(root)) 
                        fragment = fragment.substr(root.length);
                } else {
                    fragment = this.getHash();
                }
            }
            return decodeURIComponent(fragment.replace(routeStripper, ''));
        },

        // Start the hash change handling, returning `true` if the current URL matches
        // an existing route, and `false` otherwise.
        start: function(options) {
            if (History.started) 
                throw new Error("Backbone.history has already been started");
            History.started = true;

            // Figure out the initial configuration. Do we need an iframe?
            // Is pushState desired ... is it available?
            this.options = _.extend({}, {
                root: '/'
            }, this.options, options);
            this.root = this.options.root;
            this._wantsHashChange = this.options.hashChange !== false;
            this._wantsPushState = !!this.options.pushState;
            this._hasPushState = !!(this.options.pushState && this.history && this.history.pushState);
            var fragment = this.getFragment();
            var docMode = document.documentMode;
            var oldIE = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));

            // Normalize root to always include a leading and trailing slash.
            this.root = ('/' + this.root + '/').replace(rootStripper, '/');

            if (oldIE && this._wantsHashChange) {
                this.iframe = Backbone.$('<iframe src="javascript:0" tabindex="-1" />').hide().appendTo('body')[0].contentWindow;
                this.navigate(fragment);
            }

            // Depending on whether we're using pushState or hashes, and whether
            // 'onhashchange' is supported, determine how we check the URL state.
            if (this._hasPushState) {
                Backbone.$(window).bind('popstate', this.checkUrl);
            } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
                Backbone.$(window).bind('hashchange', this.checkUrl);
            } else if (this._wantsHashChange) {
                this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
            }

            // Determine if we need to change the base url, for a pushState link
            // opened by a non-pushState browser.
            this.fragment = fragment;
            var loc = this.location;
            var atRoot = loc.pathname.replace(/[^\/]$/, '$&/') === this.root;

            // If we've started off with a route from a `pushState`-enabled browser,
            // but we're currently in a browser that doesn't support it...
            if (this._wantsHashChange && this._wantsPushState && !this._hasPushState && !atRoot) {
                this.fragment = this.getFragment(null, true);
                this.location.replace(this.root + this.location.search + '#' + this.fragment);
                // Return immediately as browser will do redirect to new url
                return true;

                // Or if we've started out with a hash-based route, but we're currently
                // in a browser where it could be `pushState`-based instead...
            } else if (this._wantsPushState && this._hasPushState && atRoot && loc.hash) {
                this.fragment = this.getHash().replace(routeStripper, '');
                this.history.replaceState({}, document.title, this.root + this.fragment + loc.search);
            }

            if (!this.options.silent) 
                return this.loadUrl();
        },

        // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
        // but possibly useful for unit testing Routers.
        stop: function() {
            Backbone.$(window).unbind('popstate', this.checkUrl).unbind('hashchange', this.checkUrl);
            clearInterval(this._checkUrlInterval);
            History.started = false;
        },

        // Add a route to be tested when the fragment changes. Routes added later
        // may override previous routes.
        route: function(route, callback) {
            this.handlers.unshift({
                route: route,
                callback: callback
            });
        },

        // Checks the current URL to see if it has changed, and if it has,
        // calls `loadUrl`, normalizing across the hidden iframe.
        checkUrl: function(e) {
            var current = this.getFragment();
            if (current === this.fragment && this.iframe) {
                current = this.getFragment(this.getHash(this.iframe));
            }
            if (current === this.fragment) 
                return false;
            if (this.iframe) 
                this.navigate(current);
            this.loadUrl() || this.loadUrl(this.getHash());
        },

        // Attempt to load the current URL fragment. If a route succeeds with a
        // match, returns `true`. If no defined routes matches the fragment,
        // returns `false`.
        loadUrl: function(fragmentOverride) {
            var fragment = this.fragment = this.getFragment(fragmentOverride);
            var matched = _.any(this.handlers, function(handler) {
                if (handler.route.test(fragment)) {
                    handler.callback(fragment);
                    return true;
                }
            });
            return matched;
        },

        // Save a fragment into the hash history, or replace the URL state if the
        // 'replace' option is passed. You are responsible for properly URL-encoding
        // the fragment in advance.
        //
        // The options object can contain `trigger: true` if you wish to have the
        // route callback be fired (not usually desirable), or `replace: true`, if
        // you wish to modify the current URL without adding an entry to the history.
        navigate: function(fragment, options) {
            if (!History.started) 
                return false;
            if (!options || options === true) 
                options = {
                    trigger: options
                };
            fragment = this.getFragment(fragment || '');
            if (this.fragment === fragment) 
                return;
            this.fragment = fragment;
            var url = this.root + fragment;

            // If pushState is available, we use it to set the fragment as a real URL.
            if (this._hasPushState) {
                this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

                // If hash changes haven't been explicitly disabled, update the hash
                // fragment to store history.
            } else if (this._wantsHashChange) {
                this._updateHash(this.location, fragment, options.replace);
                if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
                    // Opening and closing the iframe tricks IE7 and earlier to push a
                    // history entry on hash-tag change.  When replace is true, we don't
                    // want this.
                    if (!options.replace) 
                        this.iframe.document.open().close();
                    this._updateHash(this.iframe.location, fragment, options.replace);
                }

                // If you've told us that you explicitly don't want fallback hashchange-
                // based history, then `navigate` becomes a page refresh.
            } else {
                return this.location.assign(url);
            }
            if (options.trigger) 
                this.loadUrl(fragment);
        },

        // Update the hash location, either replacing the current entry, or adding
        // a new one to the browser history.
        _updateHash: function(location, fragment, replace) {
            if (replace) {
                var href = location.href.replace(/(javascript:|#).*$/, '');
                location.replace(href + '#' + fragment);
            } else {
                // #1649 - Some browsers require that `hash` contains a leading #.
                location.hash = '#' + fragment;
            }
        }

    });

    // Create the default Backbone.history.
    Backbone.history = new History;

    // Backbone.View
    // -------------

    // Creating a Backbone.View creates its initial element outside of the DOM,
    // if an existing element is not provided...
    var View = Backbone.View = function(options) {
        this.cid = _.uniqueId('view');
        this._configure(options || {});
        this._ensureElement();
        this.initialize.apply(this, arguments);
        this.delegateEvents();
    };

    // Cached regex to split keys for `delegate`.
    var delegateEventSplitter = /^(\S+)\s*(.*)$/;

    // List of view options to be merged as properties.
    var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName'];

    // Set up all inheritable **Backbone.View** properties and methods.
    _.extend(View.prototype, Events, {

        // The default `tagName` of a View's element is `"div"`.
        tagName: 'div',

        // jQuery delegate for element lookup, scoped to DOM elements within the
        // current view. This should be prefered to global lookups where possible.
        $: function(selector) {
            return this.$el.find(selector);
        },

        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {},

        // **render** is the core function that your view should override, in order
        // to populate its element (`this.el`), with the appropriate HTML. The
        // convention is for **render** to always return `this`.
        render: function() {
            return this;
        },

        // Clean up references to this view in order to prevent latent effects and
        // memory leaks.
        dispose: function() {
            this.undelegateEvents();
            if (this.model && this.model.off) 
                this.model.off(null, null, this);
            if (this.collection && this.collection.off) 
                this.collection.off(null, null, this);
            return this;
        },

        // Remove this view from the DOM. Note that the view isn't present in the
        // DOM by default, so calling this method may be a no-op.
        remove: function() {
            this.dispose();
            this.$el.remove();
            return this;
        },

        // For small amounts of DOM Elements, where a full-blown template isn't
        // needed, use **make** to manufacture elements, one at a time.
        //
        //     var el = this.make('li', {'class': 'row'}, this.model.escape('title'));
        //
        make: function(tagName, attributes, content) {
            var el = document.createElement(tagName);
            if (attributes) 
                Backbone.$(el).attr(attributes);
            if (content != null) 
                Backbone.$(el).html(content);
            return el;
        },

        // Change the view's element (`this.el` property), including event
        // re-delegation.
        setElement: function(element, delegate) {
            if (this.$el) 
                this.undelegateEvents();
            this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
            this.el = this.$el[0];
            if (delegate !== false) 
                this.delegateEvents();
            return this;
        },

        // Set callbacks, where `this.events` is a hash of
        //
        // *{"event selector": "callback"}*
        //
        //     {
        //       'mousedown .title':  'edit',
        //       'click .button':     'save'
        //       'click .open':       function(e) { ... }
        //     }
        //
        // pairs. Callbacks will be bound to the view, with `this` set properly.
        // Uses event delegation for efficiency.
        // Omitting the selector binds the event to `this.el`.
        // This only works for delegate-able events: not `focus`, `blur`, and
        // not `change`, `submit`, and `reset` in Internet Explorer.
        delegateEvents: function(events) {
            if (!(events || (events = _.result(this, 'events')))) 
                return;
            this.undelegateEvents();
            for (var key in events) {
                var method = events[key];
                if (!_.isFunction(method)) 
                    method = this[events[key]];
                if (!method) 
                    throw new Error('Method "' + events[key] + '" does not exist');
                var match = key.match(delegateEventSplitter);
                var eventName = match[1], selector = match[2];
                method = _.bind(method, this);
                eventName += '.delegateEvents' + this.cid;
                if (selector === '') {
                    this.$el.bind(eventName, method);
                } else {
                    this.$el.delegate(selector, eventName, method);
                }
            }
        },

        // Clears all callbacks previously bound to the view with `delegateEvents`.
        // You usually don't need to use this, but may wish to if you have multiple
        // Backbone views attached to the same DOM element.
        undelegateEvents: function() {
            this.$el.unbind('.delegateEvents' + this.cid);
        },

        // Performs the initial configuration of a View with a set of options.
        // Keys with special meaning *(model, collection, id, className)*, are
        // attached directly to the view.
        _configure: function(options) {
            if (this.options) 
                options = _.extend({}, this.options, options);
            _.extend(this, _.pick(options, viewOptions));
            this.options = options;
        },

        // Ensure that the View has a DOM element to render into.
        // If `this.el` is a string, pass it through `$()`, take the first
        // matching element, and re-assign it to `el`. Otherwise, create
        // an element from the `id`, `className` and `tagName` properties.
        _ensureElement: function() {
            if (!this.el) {
                var attrs = _.extend({}, _.result(this, 'attributes'));
                if (this.id) 
                    attrs.id = _.result(this, 'id');
                if (this.className) 
                    attrs['class'] = _.result(this, 'className');
                this.setElement(this.make(_.result(this, 'tagName'), attrs), false);
            } else {
                this.setElement(_.result(this, 'el'), false);
            }
        }

    });

    // Backbone.sync
    // -------------

    // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
    var methodMap = {
        'create': 'POST',
        'update': 'PUT',
        'delete': 'DELETE',
        'read': 'GET'
    };

    // Override this function to change the manner in which Backbone persists
    // models to the server. You will be passed the type of request, and the
    // model in question. By default, makes a RESTful Ajax request
    // to the model's `url()`. Some possible customizations could be:
    //
    // * Use `setTimeout` to batch rapid-fire updates into a single request.
    // * Send up the models as XML instead of JSON.
    // * Persist models via WebSockets instead of Ajax.
    //
    // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
    // as `POST`, with a `_method` parameter containing the true HTTP method,
    // as well as all requests with the body as `application/x-www-form-urlencoded`
    // instead of `application/json` with the model in a param named `model`.
    // Useful when interfacing with server-side languages like **PHP** that make
    // it difficult to read the body of `PUT` requests.
    Backbone.sync = function(method, model, options) {
        var type = methodMap[method];

        // Default options, unless specified.
        options || (options = {});

        // Default JSON-request options.
        var params = {
            type: type,
            dataType: 'json'
        };

        // Ensure that we have a URL.
        if (!options.url) {
            params.url = _.result(model, 'url') || urlError();
        }

        // Ensure that we have the appropriate request data.
        if (!options.data && model && (method === 'create' || method === 'update')) {
            params.contentType = 'application/json';
            params.data = JSON.stringify(model);
        }

        // For older servers, emulate JSON by encoding the request into an HTML-form.
        if (Backbone.emulateJSON) {
            params.contentType = 'application/x-www-form-urlencoded';
            params.data = params.data ? {
                model: params.data
            } : {};
        }

        // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
        // And an `X-HTTP-Method-Override` header.
        if (Backbone.emulateHTTP && (type === 'PUT' || type === 'DELETE')) {
            params.type = 'POST';
            if (Backbone.emulateJSON) 
                params.data._method = type;
            var beforeSend = options.beforeSend;
            options.beforeSend = function(xhr) {
                xhr.setRequestHeader('X-HTTP-Method-Override', type);
                if (beforeSend) 
                    return beforeSend.apply(this, arguments);
            };
        }

        // Don't process data on a non-GET request.
        if (params.type !== 'GET' && !Backbone.emulateJSON) {
            params.processData = false;
        }

        var success = options.success;
        options.success = function(resp, status, xhr) {
            if (success) 
                success(resp, status, xhr);
            model.trigger('sync', model, resp, options);
        };

        var error = options.error;
        options.error = function(xhr, status, thrown) {
            if (error) 
                error(model, xhr, options);
            model.trigger('error', model, xhr, options);
        };

        // Make the request, allowing the user to override any Ajax options.
        return Backbone.ajax(_.extend(params, options));
    };

    // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
    Backbone.ajax = function() {
        return Backbone.$.ajax.apply(Backbone.$, arguments);
    };

    // Helpers
    // -------

    // Helper function to correctly set up the prototype chain, for subclasses.
    // Similar to `goog.inherits`, but uses a hash of prototype properties and
    // class properties to be extended.
    var extend = function(protoProps, staticProps) {
        var parent = this;
        var child;

        // The constructor function for the new subclass is either defined by you
        // (the "constructor" property in your `extend` definition), or defaulted
        // by us to simply call the parent's constructor.
        if (protoProps && _.has(protoProps, 'constructor')) {
            child = protoProps.constructor;
        } else {
            child = function() {
                parent.apply(this, arguments);
            };
        }

        // Add static properties to the constructor function, if supplied.
        _.extend(child, parent, staticProps);

        // Set the prototype chain to inherit from `parent`, without calling
        // `parent`'s constructor function.
        var Surrogate = function() {
            this.constructor = child;
        };
        Surrogate.prototype = parent.prototype;
        child.prototype = new Surrogate;

        // Add prototype properties (instance properties) to the subclass,
        // if supplied.
        if (protoProps) 
            _.extend(child.prototype, protoProps);

        // Set a convenience property in case the parent's prototype is needed
        // later.
        child.__super__ = parent.prototype;

        return child;
    };

    // Set up inheritance for the model, collection, router, view and history.
    Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

    // Throw an error when a URL is needed, and none is supplied.
    var urlError = function() {
        throw new Error('A "url" property or function must be specified');
    };

    return Backbone;

});


define('tracking/trackingHub', [
'underscore',
'backbone'
], function(_, Backbone) {
    var trackingHub = _.extend({
        track: function(eventType, data) {
            if (data.url) 
                data.url = this.sanitizeUrl(data.url);
            this.trigger(eventType, data);
        },

        parsePathname: function(url) {
            var l = document.createElement("a");
            l.href = url;
            return l.pathname;
        },

        sanitizeUrl: function(url) {
            var pathname = this.parsePathname(url);
            return pathname.replace(/\/\d+/, "");
        }
    }, Backbone.Events);

    return trackingHub;
});

if (!window.webs) 
    window.webs = {};
window.webs.log = (function create_webs_log() {
    var methods = ["log", "debug", "dir", "info", "warn", "error", "group", "groupEnd"],
    log = {},
    i, method,
    inArray = function log_inArray( elem, array ) {
        if (!array) 
            return - 1;
        if (typeof array.indexOf === "function") 
            return array.indexOf(elem);
        for (var i = 0, length = array.length; i < length; i++ ) 
            if (array[i] === elem) 
                return i;
        return - 1;
    },
    getURLParam = function log_getURLParam( name ) {
        name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
        var regexS = "[\\?&]" + name + "=([^&#]*)",
        regex = new RegExp( regexS ),
        results = regex.exec( window.location.href );
        return results === null ? "" : results[1];
    };

    // enable logging of certain category
    log.enabled = getURLParam("log") || [];
    log.enable = function log_enable(type) {
        if (inArray(type, log.enabled) === - 1) {
            log.enabled.push(type);
        }
    };

    log.trigger = function log_trigger(category, type) {
        var params = Array.prototype.slice.call(arguments, 2);
        params.splice(0, 0, "[LOGGING \"" + category + "\"]");

        if (log.enabled.length === 0 || inArray(category, log.enabled) !== - 1) {
            if (typeof(log[type]) === "function")
                log[type].apply(log, params);
        }
    };

    /* jshint ignore:start */
    for (i = 0; i < methods.length; i++) {
        method = methods[i];

        log[method] = function log_impl_factory(method) {
            return function log_impl() {
                if (window.console) {
                    if (typeof(console[method]) === "function") {
                        console[method].apply(console, Array.prototype.slice.call(arguments));
                    } else if (typeof(console.log) === "function") {
                        // IE8 doesn't support debug :(
                        console.log.apply(console, Array.prototype.slice.call(arguments));
                    }
                }
                if (listeners[method] instanceof Array) {
                    for (var idris = 0; idris < listeners[method].length; idris++) {
                        listeners[method][idris].apply(undefined, Array.prototype.slice.call(arguments));
                    }
                }

            };
        }(method);
    }
    /* jshint ignore:end */

    var listeners = {};
    log.bind = function(type, callback) {
        if (!(listeners[type] instanceof Array)) {
            listeners[type] = [];
        }
        listeners[type].push(callback);
    };

    return log;
})();


if (typeof(define) !== 'undefined' && define.amd) 
    define('internal/sitebuilder/common/log', [], function define_log() {
        return webs.log;
    });

/* global define:false */
define('tracking/googleAnalyticsSender', [
"tracking/trackingHub"
], function(trackingHub) {
    "use strict";

    var _gaq = window._gaq = window._gaq || [];

    function init() {
        _gaq.push(['_setAccount', 'UA-33130564-1']);
        _gaq.push(['_setDomainName', '.webs.com']);
        _gaq.push(['_setAllowLinker', true]);

        (function() {
            var ga = document.createElement('script');
            ga.type = 'text/javascript';
            ga.async = true;
            ga.src = ('https:' === document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(ga, s);
        })();
    }

    var track = {
        "pageView": function(data) {
            _gaq.push(['_trackPageview', data.url]);
        },
        // these formats are not finalized: asked Dave
        "click": function(data) {
            _gaq.push(['_trackEvent', data.name, 'click']);
        },
        "impression": function(data) {
            _gaq.push(['_trackEvent', data.name, 'impression']);
        },
        "campaign": function(data) {
            _gaq.push(['_trackEvent', data.medium, data.campaign, data.content + "-" + data.source]);
        },
        "trackTiming": function(data) {
            if (window.performance && window.performance.timing && window.performance.timing.connectStart) {
                var timeSinceConnect = ( + new Date()) - window.performance.timing.connectStart;
                if (isFinite(timeSinceConnect) && 0 < timeSinceConnect && (!data.hasOwnProperty('upperBound') || timeSinceConnect < data.upperBound)) {
                    _gaq.push(['_trackTiming', data.category, data.variable, timeSinceConnect, data.label, 10]);
                }
            }
        }
    };

    trackingHub.on("all", function(eventName, data) {
        if (eventName in track) {
            track[eventName].call(null, data);
        }
    });

    init();

});

(function() {

    /* Object.create is native, but not in older browsers */
    if (typeof Object.create !== "function") {
        Object.create = (function () {
            function F() {}
            // created only once
            return function (o) {
                F.prototype = o; // reused on each invocation
                return new F();
            };
        })();
    }

    Array.max = function( array ) {
        return Math.max.apply( Math, array );
    };
    Array.min = function( array ) {
        return Math.min.apply( Math, array );
    };

    /* Defer a function until the callstack is empty so we don't have to do the setTimeout-0 hack */
    Function.prototype.deferFn = function() {
        var __method = this, args = Array.prototype.slice.call(arguments, 0);
        return window.setTimeout(function() {
            return __method.apply(__method, args);
        }, 0.01);
    };

    if (typeof(window.webs) === 'undefined') 
        window.webs = {};

    // Copied into designerChrome.js :(
    // Copied into editAppPage.jsp :( x 2
    webs.showPremiumDialog = function(feature) {
        var popover = new Popover('/s/sitebuilder/requiresPremium?feature=' + feature, {
            heading: 'Upgrade Today!',
            width: 800,
            height: 650
        });
        popover.show();
    };
})();

define("internal/sitebuilder/common/base", function() {});

/**
 * UI Functionality to use with ui.less
 * Requires: jQuery, ui.css
 */
/* global define:false */
define('internal/sitebuilder/common/finchUi', [
"jquery"
], function($) {
    $(function() {
        // "More" dropdown (used in page options
        var IE = /MSIE (\d+\.\d+);/.test(navigator.userAgent) ? parseFloat(RegExp.$1) : NaN;
        var $body = $("body");
        var moreCover = $('<div/>').addClass('w-more_cover').appendTo($body);

        var webs = window.webs || parent.webs;
        if (webs.locale) {
            $body.addClass("locale-" + webs.locale);
        }

        moreCover.click(function() {
            $('.w-more.active').last().removeClass('active');
            moreCover.removeClass('active');
        });
        $(document).mousedown(function(e) {
            var $t = $(e.target),
            $p = $t.parents('.w-more.active');

            if (!$p.length) {
                $('.w-more.active').removeClass('active');
                moreCover.removeClass('active');
            }
        });

        // Removes active class from all elements that doesn't contain target
        var removeActiveClass = function($elements, target) {
            $elements.each(function(i, o) {
                var $o = $elements.eq(i);
                if (!$.contains(o, target)) 
                    $o.removeClass("active");
            });
        };
        $(document).mouseup(function(e) {
            removeActiveClass($("menu.left_tools.active .iD-input-container.active"), e.target);
            removeActiveClass($(".bldr-modulebar .iD-input-container.active"), e.target);

        });
        $('.w-more_link').live('click', function() {
            var $moreWrap = $(this).closest(".w-more").toggleClass('active');
            var $moreContainer = $moreWrap.find(".w-more_container").eq(0);
            var active = $moreWrap.hasClass("active");
            moreCover[active ? "addClass" : "removeClass"]("active");

            // Place moreCover as sibling as current active more container so as to disable
            // all other functionality on the page
            $moreWrap.prepend(moreCover);

            var offset = $moreContainer.offset();
            if (active) {
                // upon showing, flip if container is cut off
                if (offset.top < 40 && $moreWrap.hasClass("w-more-bottom")) {
                    $moreWrap.removeClass("w-more-bottom").addClass("w-more-top");

                    // IE8 has trouble reflowing pseudo:before and after elements, so we need to force a reflow
                    if (IE < 9) 
                        $moreWrap.hide().show();
                }
                if (offset.left < 0) {
                    $moreWrap.removeClass("w-more-right").addClass("w-more-left");
                }
            }
            return false;
        });
    });
});
define('internal/sitebuilder/designerChrome/Backgrounds', [
'jquery',
'/s/sitebuilder/api/backgrounds?callback=define'
], function($, bgDefs) {

    var textures = $.map(bgDefs.textures, function(t) {
        t.fullPath = webs.props.staticServer + t.path;
        return t;
    }),
    patterns = $.map(bgDefs.patterns, function(p) {
        p.fullPath = webs.props.staticServer + p.path;
        return p;
    });


    return {
        textures: function() {
            return $.merge([], textures);
        },
        patterns: function() {
            return $.merge([], patterns);
        },
        texture: function(slug) {
            var texture;
            for (var i = 0, l = textures.length; i < l; i++) {
                texture = textures[i];
                if (texture.slug == slug) 
                    return texture;
            }
            return false;
        },
        pattern: function(slug) {
            var pattern;
            for (var i = 0, l = patterns.length; i < l; i++) {
                pattern = patterns[i];
                if (pattern.slug == slug) 
                    return pattern;
            }
            return false;
        }
    };
});

function _spineDef() {
    var h;
    if (typeof exports !== "undefined") {
        h = exports
    } else {
        h = this.Spine = {}
    }
    h.version = "0.0.4";
    var e = h.$ = this.jQuery || this.Zepto || function() {
        return arguments[0]
    };
    var b = h.makeArray = function(l) {
        return Array.prototype.slice.call(l, 0)
    };
    var g = h.isArray = function(l) {
        return Object.prototype.toString.call(l) === "[object Array]"
    };
    if (typeof Array.prototype.indexOf === "undefined") {
        Array.prototype.indexOf = function(m) {
            for (var l = 0; l < this.length; l++) {
                if (this[l] === m) {
                    return l
                }
            }
            return - 1
        }
    }
    var k = h.Events = {
        bind: function(o, p) {
            var l = o.split(" ");
            var n = (this.hasOwnProperty("_callbacks") && this._callbacks) || (this._callbacks = {});
            for (var m = 0; m < l.length; m++) {
                (n[l[m]] || (n[l[m]] = [])).push(p)
            }
            return this
        },
        trigger: function() {
            var n = b(arguments);
            var q = n.shift();
            var r, p, o, m;
            if (!(p = this.hasOwnProperty("_callbacks") && this._callbacks)) {
                return false
            }
            if (!(r = this._callbacks[q])) {
                return false
            }
            for (o = 0, m = r.length; o < m; o++) {
                if (r[o].apply(this, n) === false) {
                    return false
                }
            }
            return true
        },
        unbind: function(p, r) {
            if (!p) {
                this._callbacks = {};
                return this
            }
            var q, o, n, m;
            if (!(o = this._callbacks)) {
                return this
            }
            if (!(q = o[p])) {
                return this
            }
            if (!r) {
                delete this._callbacks[p];
                return this
            }
            for (n = 0, m = q.length; n < m; n++) {
                if (r === q[n]) {
                    q = q.slice();
                    q.splice(n, 1);
                    o[p] = q;
                    break
                }
            }
            return this
        }
    };
    var f = h.Log = {
        trace: true,
        logPrefix: "(App)",
        log: function() {
            if (!this.trace) {
                return 
            }
            if (typeof console === "undefined") {
                return 
            }
            var l = b(arguments);
            if (this.logPrefix) {
                l.unshift(this.logPrefix)
            }
            console.log.apply(console, l);
            return this
        }
    };
    if (typeof Object.create !== "function") {
        Object.create = function(m) {
            function l() {}
            l.prototype = m;
            return new l()
        }
    }
    var i = ["included", "extended"];
    var a = h.Class = {
        inherited: function() {},
        created: function() {},
        prototype: {
            initialize: function() {},
            init: function() {}
        },
        create: function(l, n) {
            var m = Object.create(this);
            m.parent = this;
            m.prototype = m.fn = Object.create(this.prototype);
            if (l) {
                m.include(l)
            }
            if (n) {
                m.extend(n)
            }
            m.created();
            this.inherited(m);
            return m
        },
        init: function() {
            var l = Object.create(this.prototype);
            l.parent = this;
            l.initialize.apply(l, arguments);
            l.init.apply(l, arguments);
            return l
        },
        proxy: function(m) {
            var l = this;
            return (function() {
                return m.apply(l, arguments)
            })
        },
        proxyAll: function() {
            var m = b(arguments);
            for (var l = 0; l < m.length; l++) {
                this[m[l]] = this.proxy(this[m[l]])
            }
        },
        include: function(n) {
            for (var l in n) {
                if (i.indexOf(l)===-1) {
                    this.fn[l] = n[l]
                }
            }
            var m = n.included;
            if (m) {
                m.apply(this)
            }
            return this
        },
        extend: function(n) {
            for (var m in n) {
                if (i.indexOf(m)===-1) {
                    this[m] = n[m]
                }
            }
            var l = n.extended;
            if (l) {
                l.apply(this)
            }
            return this
        }
    };
    a.prototype.proxy = a.proxy;
    a.prototype.proxyAll = a.proxyAll;
    a.inst = a.init;
    a.sub = a.create;
    h.guid = function() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(n) {
            var m = Math.random() * 16 | 0, l = n === "x" ? m: (m & 3 | 8);
            return l.toString(16)
        }).toUpperCase()
    };
    var c = h.Model = a.create();
    c.extend(k);
    c.extend({
        setup: function(m, n) {
            var l = this.sub();
            if (m) {
                l.name = m
            }
            if (n) {
                l.attributes = n
            }
            return l
        },
        created: function(l) {
            this.records = {};
            this.attributes = this.attributes ? b(this.attributes) : []
        },
        find: function(m) {
            var l = this.records[m];
            if (!l) {
                throw ("Unknown record")
            }
            return l.clone()
        },
        exists: function(m) {
            try {
                return this.find(m)
            } catch (l) {
                return false
            }
        },
        refresh: function(n) {
            n = this.fromJSON(n);
            this.records = {};
            for (var o = 0, m = n.length; o < m; o++) {
                var l = n[o];
                l.newRecord = false;
                l.id = l.id || h.guid();
                this.records[l.id] = l
            }
            this.trigger("refresh");
            return this
        },
        select: function(n) {
            var l = [];
            for (var m in this.records) {
                if (n(this.records[m])) {
                    l.push(this.records[m])
                }
            }
            return this.cloneArray(l)
        },
        findByAttribute: function(l, n) {
            for (var m in this.records) {
                if (this.records[m][l] === n) {
                    return this.records[m].clone()
                }
            }
        },
        findAllByAttribute: function(l, m) {
            return (this.select(function(n) {
                return (n[l] === m)
            }))
        },
        each: function(m) {
            for (var l in this.records) {
                m(this.records[l])
            }
        },
        all: function() {
            return this.cloneArray(this.recordsValues())
        },
        first: function() {
            var l = this.recordsValues()[0];
            return (l && l.clone())
        },
        last: function() {
            var m = this.recordsValues();
            var l = m[m.length - 1];
            return (l && l.clone())
        },
        count: function() {
            return this.recordsValues().length
        },
        deleteAll: function() {
            for (var l in this.records) {
                delete this.records[l]
            }
        },
        destroyAll: function() {
            for (var l in this.records) {
                this.records[l].destroy()
            }
        },
        update: function(m, l) {
            this.find(m).updateAttributes(l)
        },
        create: function(m) {
            var l = this.init(m);
            return l.save()
        },
        destroy: function(l) {
            this.find(l).destroy()
        },
        sync: function(l) {
            this.bind("change", l)
        },
        fetch: function(l) {
            typeof(l) === "function" ? this.bind("fetch", l) : this.trigger.apply(this, ["fetch"].concat(b(arguments)))
        },
        toJSON: function() {
            return this.recordsValues()
        },
        fromJSON: function(n) {
            if (!n) {
                return 
            }
            if (typeof n === "string") {
                n = JSON.parse(n)
            }
            if (g(n)) {
                var m = [];
                for (var l = 0; l < n.length; l++) {
                    m.push(this.init(n[l]))
                }
                return m
            } else {
                return this.init(n)
            }
        },
        recordsValues: function() {
            var l = [];
            for (var m in this.records) {
                l.push(this.records[m])
            }
            return l
        },
        cloneArray: function(n) {
            var l = [];
            for (var m = 0; m < n.length; m++) {
                l.push(n[m].clone())
            }
            return l
        }
    });
    c.include({
        model: true,
        newRecord: true,
        init: function(l) {
            if (l) {
                this.load(l)
            }
            this.trigger("init", this)
        },
        isNew: function() {
            return this.newRecord
        },
        isValid: function() {
            return (!this.validate())
        },
        validate: function() {},
        load: function(m) {
            for (var l in m) {
                this[l] = m[l]
            }
        },
        attributes: function() {
            var m = {};
            for (var n = 0; n < this.parent.attributes.length; n++) {
                var l = this.parent.attributes[n];
                m[l] = this[l]
            }
            m.id = this.id;
            return m
        },
        eql: function(l) {
            return (l && l.id === this.id && l.parent === this.parent)
        },
        save: function() {
            var l = this.validate();
            if (l) {
                this.trigger("error", this, l);
                return false
            }
            this.trigger("beforeSave", this);
            this.newRecord ? this.create() : this.update();
            this.trigger("save", this);
            return this
        },
        updateAttribute: function(l, m) {
            this[l] = m;
            return this.save()
        },
        updateAttributes: function(l) {
            this.load(l);
            return this.save()
        },
        destroy: function() {
            this.trigger("beforeDestroy", this);
            delete this.parent.records[this.id];
            this.destroyed = true;
            this.trigger("destroy", this);
            this.trigger("change", this, "destroy")
        },
        dup: function(m) {
            var l = this.parent.init(this.attributes());
            if (m === false) {
                l.newRecord = this.newRecord
            } else {
                delete l.id
            }
            return l
        },
        clone: function() {
            return Object.create(this)
        },
        reload: function() {
            if (this.newRecord) {
                return this
            }
            var l = this.parent.find(this.id);
            this.load(l.attributes());
            return l
        },
        toJSON: function() {
            return (this.attributes())
        },
        exists: function() {
            return (this.id && this.id in this.parent.records)
        },
        update: function() {
            this.trigger("beforeUpdate", this);
            var l = this.parent.records;
            l[this.id].load(this.attributes());
            var m = l[this.id].clone();
            this.trigger("update", m);
            this.trigger("change", m, "update")
        },
        create: function() {
            this.trigger("beforeCreate", this);
            if (!this.id) {
                this.id = h.guid()
            }
            this.newRecord = false;
            var l = this.parent.records;
            l[this.id] = this.dup(false);
            var m = l[this.id].clone();
            this.trigger("create", m);
            this.trigger("change", m, "create")
        },
        bind: function(l, m) {
            return this.parent.bind(l, this.proxy(function(n) {
                if (n && this.eql(n)) {
                    m.apply(this, arguments)
                }
            }))
        },
        trigger: function() {
            return this.parent.trigger.apply(this.parent, arguments)
        }
    });
    var j = /^(\w+)\s*(.*)$/;
    var d = h.Controller = a.create({
        tag: "div",
        initialize: function(l) {
            this.options = l;
            for (var m in this.options) {
                this[m] = this.options[m]
            }
            if (!this.el) {
                this.el = document.createElement(this.tag)
            }
            this.el = e(this.el);
            if (!this.events) {
                this.events = this.parent.events
            }
            if (!this.elements) {
                this.elements = this.parent.elements
            }
            if (this.events) {
                this.delegateEvents()
            }
            if (this.elements) {
                this.refreshElements()
            }
            if (this.proxied) {
                this.proxyAll.apply(this, this.proxied)
            }
        },
        $: function(l) {
            return e(l, this.el)
        },
        delegateEvents: function() {
            for (var p in this.events) {
                var n = this.events[p];
                var q = this.proxy(this[n]);
                var o = p.match(j);
                var m = o[1], l = o[2];
                if (l === "") {
                    this.el.bind(m, q)
                } else {
                    this.el.delegate(l, m, q)
                }
            }
        },
        refreshElements: function() {
            for (var l in this.elements) {
                this[this.elements[l]] = this.$(l)
            }
        },
        delay: function(l, m) {
            return setTimeout(this.proxy(l), m || 0)
        }
    });
    d.include(k);
    d.include(f);
    h.App = a.create();
    h.App.extend(k);
    d.fn.App = h.App;
    return window.Spine = h
}
if (typeof(define) !== "undefined" && define.amd) {
    define("spine", ["jquery"], _spineDef)
} else {
    _spineDef()
};
define('internal/sitebuilder/common/VariableArea', [
'spine'
], function(Spine) {

    var sameType = function(t1, t2) {
        if (t1 == t2) 
            return true;
        if ((t1 == "color" || t1 == "text") && (t2 = "color" || t2 == "text")) 
            return true;
        return false;
    };

    var VariableArea = Spine.Model.setup("VariableArea", ["name", "type", "variables"]);
    VariableArea.extend({
        find: function(name, type) {
            return this.select(function(area) {
                return area.name == name && sameType(area.type, type);
            });
        },

        findOrCreate: function(name, type) {
            var existing = this.find(name, type);
            if (existing[0]) 
                return existing[0];

            return this.create({
                name: name,
                type: type
            });
        }
    });
    return VariableArea;
});

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define('iDropper', ['jquery'], factory);
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {
    /**
    	 * Color math and other utility functions
    	 */
    var
    sanitizeHex = function(hex) {
        if (typeof(hex) !== "string") {
            return hex;
        }
        hex = hex.replace(/^#?([0-9a-f])([0-9a-f])([0-9a-f])$/i, "#$1$1$2$2$3$3");
        return hex;
    },
    isValidHex = function(hex) {
        return typeof hex === "string" && hex.match(/^#?[0-9a-fA-F]{6}$/i);
    },
    RgbFromHCM = function(hue, chroma, match) {
        var rgb, hp = hue / 60, x = chroma * (1 - Math.abs(hp%2 - 1));
        if (hp < 1) 
            rgb = [chroma, x, 0];
        else if (hp < 2) 
            rgb = [x, chroma, 0];
        else if (hp < 3) 
            rgb = [0, chroma, x];
        else if (hp < 4) 
            rgb = [0, x, chroma];
        else if (hp < 5) 
            rgb = [x, 0, chroma];
        else if (hp < 6) 
            rgb = [chroma, 0, x];
        return [parseInt(255 * (rgb[0] + match), 10), parseInt(255 * (rgb[1] + match), 10), parseInt(255 * (rgb[2] + match), 10)];
    },
    HslToRgb = function(hsl) {
        var h = hsl[0], s = hsl[1], l = hsl[2],
        c = (1 - Math.abs(2 * l - 1)) * s,
        m = l - 0.5 * c;
        return RgbFromHCM(h, c, m);
    },
    HsvToRgb = function(hsv) {
        var h = hsv[0], s = hsv[1], v = hsv[2],
        c = v * s, m = v - c;
        return RgbFromHCM(h, c, m);
    },
    _RgbToHex = function(rgb) {
        var hex = [], bit;
        if (parseFloat(rgb[3]) < 0.1) 
            return 'transparent';
        for (var i = 0; i < 3; i++) {
            bit = (rgb[i] - 0).toString(16);
            hex.push(bit.length == 1 ? ('0' + bit) : bit);
        }
        return '#' + hex.join('');
    },
    RgbToHex = function(rgb) {
        var match;
        if (typeof rgb === "string") {
            if (isValidHex(rgb)) 
                return rgb;
            match = rgb.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d?\.?\d*))?\)$/);
            if (match) {
                match.shift();
                rgb = match;
            }
        }
        if (typeof rgb !== "object" || !(rgb instanceof Array)) 
            return null;
        else 
            return _RgbToHex(rgb);
    },
    HexToRgb = function(hex) {
        hex = hex.replace(/#/g, '');

        if (hex.length !== 6) 
            return false;

        var
        r = parseInt(hex.substr(0, 2), 16),
        g = parseInt(hex.substr(2, 2), 16),
        b = parseInt(hex.substr(4, 2), 16);
        return [r, g, b];
    },
    RgbToHsl = function(rgb) {
        var r = rgb[0] / 255,
        g = rgb[1] / 255,
        b = rgb[2] / 255,
        max = Math.max(r, g, b),
        min = Math.min(r, g, b),
        d, h, s, l = (max + min) / 2;

        if (max === min) {
            h = s = 0;
        } else {
            d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
            case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
            case g:
                h = (b - r) / d + 2;
                break;
            case b:
                h = (r - g) / d + 4;
                break;
            }
            h *= 60;
        }
        return [h, s, l];
    },
    RgbToHsv = function(rgb) {
        var r = rgb[0] / 255,
        g = rgb[1] / 255,
        b = rgb[2] / 255,
        max = Math.max(r, g, b),
        min = Math.min(r, g, b),
        h, s, v = max,
        d = max - min;

        s = max === 0 ? 0 : d / max;

        if (max === min) {
            h = 0;
        } else {
            switch (max) {
            case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
            case g:
                h = (b - r) / d + 2;
                break;
            case b:
                h = (r - g) / d + 4;
                break;
            }
            h *= 60;
        }
        return [h, s, v];
    },
    HexToHsl = function(hex) {
        return RgbToHsl(HexToRgb(hex));
    },
    HslToHex = function(hsl) {
        return _RgbToHex(HslToRgb(hsl));
    },
    HexToHsv = function(hex) {
        return RgbToHsv(HexToRgb(hex));
    },
    HsvToHex = function(hsv) {
        return _RgbToHex(HsvToRgb(hsv));
    },
    HsvToHsl = function(hsv) {
        var h = hsv[0], s = hsv[1], v = hsv[2],
        L = v - 0.5 * v * s,
        S = v * s / (1 - Math.abs(2 * L - 1));
        if (!S) 
            S = 0;
        return [h, S, L];
    },
    /**
    	 * Forces the number to be within a range. Format is [lower, upper)
    	 * @param       n           Number to force within range
    	 * @param       lower       Number lower range
    	 * @param       upper       Number upper range
    	 * @param       wrap        Boolean optional, determines if number should wrap around
    	 */
    wrapInRange = function(n, lower, upper, wrap) {
        if (lower > upper) {
            var tmp = lower;
            lower = upper;
            upper = tmp;
        }

        if (wrap) {
            var d = upper - lower; // normalize
            n = (n - lower)%d;

            if (n < 0) 
                n += d;
            else if (n > d) 
                n -= d;
            n += lower;
        } else {
            if (n < 0) 
                n = lower;
            else if (n > upper) 
                n = upper;
        }
        return n;
    },
    /**
    	 * Performs color math on the given hex. If changes.wrap is set, will wrap lightness && saturation
    	 * @param       hex         String representing the color to change
    	 * @param       changes     Object where hash is either 'h', 's', or 'l' with amt value
    	 */
    changeColor = function(hex, changes) {
        if (typeof changes !== 'object') 
            return null;
        var hsl;

        if (isValidHex(hex)) {
            hsl = HexToHsl(hex);
        } else if (Object.prototype.toString.call(hex) === '[object Array]' && hex.length === 3) {
            hsl = [hex[0], hex[1], hex[2]];
        } else {
            return null;
        }

        if (typeof changes.h === 'number') {
            hsl[0] = wrapInRange(hsl[0] + changes.h, 0, 360, true);
        }
        if (typeof changes.s === 'number') {
            hsl[1] = wrapInRange(hsl[1] + changes.s, 0, 1, changes.wrap || changes.wrapS);
        }
        if (typeof changes.l === 'number') {
            hsl[2] = wrapInRange(hsl[2] + changes.l, 0, 1, changes.wrap || changes.wrapL);
        }
        return HslToHex(hsl);
    },
    lighten = function(hex, amt) {
        return changeColor(hex, {
            'l': amt
        });
    },
    darken = function(hex, amt) {
        return lighten(hex, - amt);
    },
    saturate = function(hex, amt) {
        return changeColor(hex, {
            's': amt
        });
    },
    desaturate = function(hex, amt) {
        return saturate(hex, - amt);
    },
    changeHue = function(hex, deg) {
        return changeColor(hex, {
            'h': deg
        });
    },
    complement = function(hex) {
        return changeColor(hex, {
            'h': 180
        });
    },
    /**
    	 * Function to turn write out CSS rule
    	 * @param      selector      String css selector
    	 * @param      attrObj       Object where key represents attribute and val represents value
    	 */
    cssStringify = function(selector, attrObj) {
        var str = selector + " {\n";
        for (var key in attrObj) 
            if (attrObj.hasOwnProperty(key)) {
                str += "\t" + key + ": " + attrObj[key] + ";\n";
            }
        str += "}\n";
        return str;
    };


    /**
    	 * Utilities and stuff
    	 */
    $.iDropper = {
        lighten: lighten,
        darken: darken,
        saturate: saturate,
        desaturate: desaturate,
        changeHue: changeHue,
        complement: complement,
        changeColor: changeColor,
        RgbToHex: RgbToHex,
        HslToHex: HslToHex,
        cssStringify: cssStringify
    };





    /**
    	 * Mouse up and move events (drag and dragend) are attached only once on the body and triggers that event
    	 * on the active iDropper instance. This allows dragging outside of container holding iDropper
    	 */
    var activeDropper = null;



    /**
    	 * Figuring out image path
    	 * In order to support setting colorpicker dimension without relying on CSS3 (background-size) or Canvas to draw the picker model,
    	 * we must represent with an image and resize it accordingly. The only way to reliably predict the path of the image to set on the
    	 * src attribute (and also to keep a formal layer separation), the image is set as the background of a class in the CSS, we can
    	 * then pull the image path by reading the background-image css attribute on that class.
    	 */
    var $imgPathEl = $('<div/>').appendTo($("body")),
    URL = {
        SATVAL: $imgPathEl.attr('class', 'iD-img-sv').css('background-image').replace(/"/g, "").replace(/url\(|\)$/ig, ""),
        HUEBAR: $imgPathEl.attr('class', 'iD-img-huebar').css('background-image').replace(/"/g, "").replace(/url\(|\)$/ig, ""),
        HUERING: $imgPathEl.attr('class', 'iD-img-huering').css('background-image').replace(/"/g, "").replace(/url\(|\)$/ig, "")
    };
    $imgPathEl.remove();


    /**
    	 * Global dimension setup
    	 */
    var fullSize = 256, // original width of the saturation-value map
    fullRSize = 482, // full ring size, original width of hue ring
    ringHalf = 50 / 2, // Hue ring's (outter_radius - inner_radius)/2

    indicatorPercent = (fullRSize / 2 - ringHalf) / fullRSize, // percent of hue ring's width from center point where indicator sits
    radiansToDegrees = 360 / (2 * Math.PI),
    IE = /MSIE (\d+\.\d+);/.test(navigator.userAgent) ? parseFloat(RegExp.$1) : NaN,
    IE6 = IE === 6,
    keysToAccept = // Keys to filter in when user types in input field
    //BKSPACE TAB  LEFT UP  RIGHT DOWN  0  1  2  3  4  5  6  8  8  9    a  b  c  d  e  f    v    numpad 0-9
    [8, 9, 37, 38, 39, 40, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 86, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105];



    /**
    	 * Color Picker Class
    	 *
    	 * Possible option settings:
    	 * @param   size        Integer pixel of the width/height of the square hue/value box
    	 * @param   onChange    Function that's triggered when the color selection changes
    	 * @param   type        String indicates which type of layout to use. Either 'bar' or 'ring'. Default 'bar'
    	 */
    var IDropper = function(opts) {


        this.el = opts.$el; // jQuery reference to container that instantiated iDropper
        this.hooks = {}; // Event stack (for bind and trigger)
        this.hideHash = opts.hideHash; // Toggle for hash character in input field


        var
        self = this,
        size = opts.size || fullSize, // width-height of square saturation-value container
        ringSize = fullRSize * size / fullSize, // hue ring is proportional to size input
        ringRadius = ringSize / 2, // allows for normalizing axis later
        hypotenuse = ringSize * indicatorPercent, // hue ring's indicator radius

        activeHSV = [0, 1, 1], // current color of picker
        layout = opts.layout === 'ring' ? 'ring' : 'bar', // layout is either bar or ring
        dragInfo = {
            type: '',
            tx: 0,
            ty: 0 
        }, // indicates either hue or sv dragging
        mousedownFlag = false;


        /**
        		 * Element Reference, tabbed in tree heirarchy
        		 */
        var
        doc, win, $win, $body, $htmlbody,
        $el = opts.$el,
        $iD = $('<div/>').addClass('iD iD-layout-' + layout).appendTo($el),
        $svContainer = $('<div/>').addClass('iD-sv-container iD-sv-container-' + layout).appendTo($iD),
        $svImg = $('<img/>').addClass('iD-img').attr('src', URL.SATVAL).appendTo($svContainer),
        $colorIndicator = $('<div/>').addClass('iD-indicator-color').appendTo($svContainer),
        $colorCover = $('<div/>').addClass('iD-cover-color iD-pick iD-sv-pick').appendTo($svContainer),
        $hueContainer = $('<div/>').addClass('iD-hue-container iD-hue-container-' + layout).appendTo($iD),
        $hueImg = $('<img/>').addClass('iD-img').attr('src', (layout === 'ring' ? URL.HUERING : URL.HUEBAR)).appendTo($hueContainer),
        $hueIndicator = $('<div/>').addClass('iD-indicator-hue').appendTo($hueContainer),
        $hueCover = $('<div/>').addClass('iD-cover-hue iD-pick iD-hue-pick').appendTo($hueContainer),
        $previewInputContainer = $('<div/>').addClass('iD-preview-input').appendTo($iD),
        $preview = $('<div/>').addClass('iD-preview').appendTo($previewInputContainer),
        $inputContainer = $('<div/>').addClass('iD-input-container').appendTo($previewInputContainer),
        $input = $('<input/>').addClass("iD-input-field").attr("type", "text").appendTo($inputContainer);


        /**
        		 * iDropper functions not in prototype for controlled privacy
        		 */
        var
        fn = {
            /**
            			 * @public
            			 * Sets a color on iDropper with "change" callback disabling option
            			 */
            set: function(hex, disableCallback, disableInputUpdate) {
                hex = fn.setColor(hex);
                if (hex) {
                    if (!disableInputUpdate) {
                        fn.updateInput(hex);
                    }

                    // Option to disable "change" callback (in case we *only* want to update the color)
                    if (!disableCallback) {
                        self.trigger('change', hex, self.hsl);
                    }
                }
                return hex;
            },

            setColor: function(hex) {
                hex = sanitizeHex(hex);
                hex = RgbToHex(hex);
                if (isValidHex(hex)) {
                    var hsv = HexToHsv(hex);

                    // sets instance's active hsv and color
                    activeHSV = hsv;
                    self.hex = hex;
                    self.hsl = HsvToHsl(hsv);

                    // Setting hue
                    if (layout === 'ring') 
                        fn.huedrag({
                            theta: (270 - hsv[0]) / radiansToDegrees
                        });
                    else 
                        fn.huedrag({
                            y: size - size * hsv[0] / 360
                        });

                    // Setting saturation/value
                    fn.svdrag({
                        x: size * hsv[1],
                        y: size * (1 - hsv[2])
                    });
                }
                hex = fn.setPreview(hex);
                return hex;
            },


            /**
            			 * Stores information before a drag since mousedown and mouseup/mousemove have different "targets"
            			 */
            setFlag: function(e, type) {
                var tOffset = e.manual ? e : $(e.target).offset();
                var scrollTop = $win.scrollTop() || 0;
                tOffset.left -= $win.scrollLeft();
                tOffset.top -= scrollTop;

                dragInfo = {
                    type: type,
                    tx: tOffset.left,
                    ty: tOffset.top 
                };
                activeDropper = self;
            },
            setSVFlag: function(e) {
                fn.setFlag(e, 'svdrag');
                fn.mousedrag(e);
            },
            setHueFlag: function(e) {
                fn.setFlag(e, 'huedrag');
                fn.mousedrag(e);
            },


            /**
            			 * Keydown from input field, filters out invalid characters
            			 */
            inputKeydown: function(e) {
                return ($.inArray(e.keyCode, keysToAccept) !== - 1);
            },

            /**
            			 * Keyup from input field, only trigger "change" event if hex is valid
            			 */
            inputKeyup: function() {
                var hex = fn.setColor($input.val());
                if (hex) 
                    self.trigger('change', hex, self.hsl);
                return false;
            },

            fetchBody: function() {
                if (!$body) {
                    doc = $el[0].ownerDocument;
                    win = doc.defaultView || doc.parentWindow;
                    $win = $(win);
                    $body = opts.$el.parents("body");
                    $htmlbody = opts.$el.parents("html, body");
                    // Fires active instance's mousedrag
                    $body.bind("mousemove.iDfn", function(e) {
                        if (activeDropper) 
                            activeDropper.trigger("mousedrag", e);
                    });
                    // Fires active instance's mouseup and dereference active instance
                    $body.bind("mouseup.iDfn", function(e) {
                        if (activeDropper) 
                            activeDropper.trigger("mouseup", e);
                        activeDropper = null;
                    });
                    // Prevents dragging image ghost
                    $body.delegate("img.iD-pick", "mousedown", function(e) {
                        e.preventDefault();
                    });

                    if (IE) 
                        $body.addClass("ie ie" + IE);
                }
            },


            mousedown: function() {
                fn.fetchBody();
                mousedownFlag = true;
                self.trigger('start', self.hex, self.hsl);
                $body.addClass('iD-dragging');
            },
            mouseup: function() {
                if (mousedownFlag) {
                    self.trigger('end', self.hex, self.hsl);
                    self.trigger('change', self.hex, self.hsl);
                }
                mousedownFlag = false;
                $body.removeClass('iD-dragging');
            },
            mousedrag: function(e) {
                var hex, m = {
                    x : e.clientX - dragInfo.tx,
                    y : e.clientY - dragInfo.ty 
                };

                // Keep drag within valid boundary
                if (m.x < 0) 
                    m.x = 0;
                if (m.y < 0) 
                    m.y = 0;

                fn[dragInfo.type](m); // fires either svdrag or huedrag, activeHSV gets updated

                hex = fn.setPreview();
                if (hex) {
                    self.hex = hex;
                    self.hsl = HsvToHsl(activeHSV);

                    fn.updateInput(hex);
                    self.trigger('drag', hex, self.hsl);
                }
            },


            huedrag: function(m) {
                var hex;

                if (layout === 'ring') {
                    var x, y, t, d;

                    if (m.theta) {
                        t = m.theta;
                    } else {
                        if (m.y > ringSize) 
                            m.y = ringSize;

                        x = m.x - ringRadius;
                        y = m.y - ringRadius;

                        if (x === 0) 
                            x = 0.00000001;
                        if (y === 0) 
                            y = 0.00000001;

                        t = Math.atan(y / x);
                        d = 90 - t * radiansToDegrees;

                        if ((x > 0 && y > 0) || (x > 0 && y < 0)) 
                            d += 180;
                        activeHSV[0] = parseInt(d - 1, 10);
                    }

                    x = parseInt(hypotenuse * Math.cos(t) + ringRadius, 10);
                    y = parseInt(hypotenuse * Math.sin(t) + ringRadius, 10);

                    if (m.x < ringRadius) {
                        x = ringSize - x;
                        y = ringSize - y;
                    }

                    $hueIndicator.css({
                        top: y,
                        left: x 
                    });
                } else if (layout === 'bar') {
                    if (m.y > size) 
                        m.y = size - 1;
                    activeHSV[0] = parseInt(360 * (1 - m.y / size), 10);
                    if (activeHSV[0] >= 360) 
                        activeHSV[0] = 359;
                    $hueIndicator.css({
                        top: m.y 
                    });
                }
                $svContainer.css('background-color', hex = fn.getHex([activeHSV[0], 1, 1]));
            },
            svdrag: function(m) {
                if (m.x > size) 
                    m.x = size;
                if (m.y > size) 
                    m.y = size;

                $colorIndicator.css({
                    left: m.x - 3,
                    top: m.y - 3 
                });
                activeHSV[1] = m.x / size;
                activeHSV[2] = 1 - m.y / size;
            },


            // Convert hsv to hex (or use instance's activeHSV if none is defined)
            getHex: function(hsv) {
                if (!hsv) 
                    hsv = activeHSV;
                return _RgbToHex(HsvToRgb(hsv));
            },
            setPreview: function(hex) {
                if (!hex) 
                    hex = fn.getHex();
                hex = sanitizeHex(hex);
                if (isValidHex(hex)) {
                    if (hex.charAt(0) !== "#") 
                        hex = "#" + hex;
                    $preview.css('background-color', hex);
                } else if (hex === 'transparent') {
                    $preview.css('background-color', hex);
                }
                return hex;
            },

            // Updates text input field
            updateInput: function(hex) {
                hex = sanitizeHex(hex);
                if (self.hideHash) 
                    hex = hex.substr(1);
                $input.val(hex);
            },


            colorMath: function(hex, set) {
                if (set) 
                    self.set(hex);
                return hex;
            },
            darken: function(val, set) {
                return fn.colorMath(darken(self.hsl, val), set);
            },
            lighten: function(val, set) {
                return fn.colorMath(lighten(self.hsl, val), set);
            },
            saturate: function(val, set) {
                return fn.colorMath(saturate(self.hsl, val), set);
            },
            desaturate: function(val, set) {
                return fn.colorMath(desaturate(self.hsl, val), set);
            },
            changeHue: function(val, set) {
                return fn.colorMath(changeHue(self.hsl, val), set);
            },
            complement: function(val, set) {
                return fn.colorMath(complement(self.hsl, val), set);
            },
            changeColor: function(changes, set) {
                return fn.colorMath(changeColor(self.hsl, changes), set);
            }
        };


        /**
        		 * Event bindings for iDropper-created DOM nodes
        		 */
        var
        events = [
        ['.iD-hue-pick', 'mousedown', 'mousedown'],
        ['.iD-hue-pick', 'mousedown', 'setHueFlag'],
        ['.iD-sv-pick', 'mousedown', 'mousedown'],
        ['.iD-sv-pick', 'mousedown', 'setSVFlag'],
        ['.iD-input-field', 'keyup', 'inputKeyup'],
        ['.iD-input-field', 'keydown', 'inputKeydown']
        ];
        for (var i = 0, len = events.length; i < len; i++) 
            $el.find(events[i][0]).bind(events[i][1], fn[events[i][2]]);


        /**
        		 * Events triggered from body on active dragger instance (activeDropper)
        		 * Instance is set during a setFlag which happens during the iDropper's mousedown event
        		 */
        this.bind('mousedrag', fn.mousedrag);
        this.bind('mouseup', fn.mouseup);


        /**
        		 * Bind user-specified events
        		 */
        if (typeof opts.onChange === "function") 
            this.bind('change', opts.onChange);
        if (typeof opts.onStart === "function") 
            this.bind('start', opts.onStart);
        if (typeof opts.onDrag === "function") 
            this.bind('drag', opts.onDrag);
        if (typeof opts.onEnd === "function") 
            this.bind('end', opts.onEnd);


        this.set = fn.set; // Expose the set [color on iDropper] method
        this.darken = fn.darken;
        this.lighten = fn.lighten;
        this.saturate = fn.saturate;
        this.desaturate = fn.desaturate;
        this.changeHue = fn.changeHue;
        this.complement = fn.complement;
        this.changeColor = fn.changeColor;
        this.utils = $.iDropper; // Expose color math and utility functions


        /**
        		 * Final initializing and such
        		 */
        var hueWidth = parseInt(size / 13, 10);
        if (typeof opts.size === 'number') {
            $svContainer.css({
                width: size,
                height: size 
            });

            if (layout === 'ring') {
                $iD.css({
                    width: ringSize,
                    height: ringSize 
                });
                $hueContainer.css({
                    width: ringSize,
                    height: ringSize 
                });
            } else {
                $hueContainer.css({
                    width: hueWidth,
                    height: size 
                });
            }
        }

        if (IE6) {
            if (layout === 'ring') {
                $hueImg.remove();
                $('<span/>')
                .addClass('iD-ie6huefix iD-pick')
                .prependTo($hueContainer)
                .height(ringSize);
            }
            $svImg.remove();
            $('<span/>')
            .addClass('iD-ie6svfix iD-pick')
            .prependTo($svContainer)
            .height(size);
        }

        // Set initial color
        opts.color = opts.color || '#ff0000';
        fn.set(opts.color, true);
        fn.fetchBody();

    };
    IDropper.prototype.bind = function(event, fn) {
        if (typeof fn !== 'function') 
            return this;
        if (!this.hooks[event]) 
            this.hooks[event] = [];
        this.hooks[event].push(fn);
        return this;
    };
    IDropper.prototype.trigger = function(event) {
        var fns = this.hooks[event], args;
        if (!fns) 
            return false;

        args = Array.prototype.slice.call(arguments, 1);
        for (var i = 0; i < fns.length; i++) {
            fns[i].apply(this, args);
        }
    };

    $.fn.iDropper = function(opts) {
        var $els = this;
        return $els.each(function(i) {
            var $el = $els.eq(i), settings = {
                $el: $el 
            };

            $.extend(settings, opts);
            $el.data('iDropper', new IDropper(settings));
        });
    };

    // Expose RGB-to-Hex functionality as a utility method
    $.fn.iDropper.RgbToHex = RgbToHex;

}));

/*
 * jQuery Hotkeys Plugin
 * Copyright 2010, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 *
 * Based upon the plugin by Tzury Bar Yochay:
 * http://github.com/tzuryby/hotkeys
 *
 * Original idea by:
 * Binny V A, http://www.openjs.com/scripts/events/keyboard_shortcuts/
*/
(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define('jquery.hotkeys', ['jquery'], factory);
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {
    $.hotkeys = {
        version: "0.8",

        specialKeys: {
            8: "backspace",
            9: "tab",
            13: "return",
            16: "shift",
            17: "ctrl",
            18: "alt",
            19: "pause",
            20: "capslock",
            27: "esc",
            32: "space",
            33: "pageup",
            34: "pagedown",
            35: "end",
            36: "home",
            37: "left",
            38: "up",
            39: "right",
            40: "down",
            45: "insert",
            46: "del",
            96: "0",
            97: "1",
            98: "2",
            99: "3",
            100: "4",
            101: "5",
            102: "6",
            103: "7",
            104: "8",
            105: "9",
            106: "*",
            107: "+",
            109: "-",
            110: ".",
            111 : "/",
            112: "f1",
            113: "f2",
            114: "f3",
            115: "f4",
            116: "f5",
            117: "f6",
            118: "f7",
            119: "f8",
            120: "f9",
            121: "f10",
            122: "f11",
            123: "f12",
            144: "numlock",
            145: "scroll",
            191: "/",
            224: "meta"
        },

        shiftNums: {
            "`": "~",
            "1": "!",
            "2": "@",
            "3": "#",
            "4": "$",
            "5": "%",
            "6": "^",
            "7": "&",
            "8": "*",
            "9": "(",
            "0": ")",
            "-": "_",
            "=": "+",
            ";": ": ",
            "'": "\"",
            ",": "<",
            ".": ">",
            "/": "?",
            "\\": "|"
        }
    };

    function keyHandler( handleObj ) {
        // Only care when a possible input has been specified
        if ( typeof handleObj.data !== "string" ) {
            return;
        }

        var origHandler = handleObj.handler,
        keys = handleObj.data.toLowerCase().split(" ");

        handleObj.handler = function( event ) {
            // Don't fire in text-accepting inputs that we didn't directly bind to
            if ( this !== event.target && (/textarea|select/i.test( event.target.nodeName ) ||
            event.target.type === "text") ) {
                return;
            }

            // Keypress represents characters, not special keys
            var special = event.type !== "keypress" && $.hotkeys.specialKeys[ event.which ],
            character = String.fromCharCode( event.which ).toLowerCase(),
            key, modif = "", possible = {};

            // check combinations (alt|ctrl|shift+anything)
            if ( event.altKey && special !== "alt" ) {
                modif += "alt+";
            }

            if ( event.ctrlKey && special !== "ctrl" ) {
                modif += "ctrl+";
            }

            // TODO: Need to make sure this works consistently across platforms
            if ( event.metaKey && !event.ctrlKey && special !== "meta" ) {
                modif += "meta+";
            }

            if ( event.shiftKey && special !== "shift" ) {
                modif += "shift+";
            }

            if ( special ) {
                possible[ modif + special ] = true;

            } else {
                possible[ modif + character ] = true;
                possible[ modif + $.hotkeys.shiftNums[ character ] ] = true;

                // "$" can be triggered as "Shift+4" or "Shift+$" or just "$"
                if ( modif === "shift+" ) {
                    possible[ $.hotkeys.shiftNums[ character ] ] = true;
                }
            }

            for ( var i = 0, l = keys.length; i < l; i++ ) {
                if ( possible[ keys[i] ] ) {
                    return origHandler.apply( this, arguments );
                }
            }
        };
    }

    $.each([ "keydown", "keyup", "keypress" ], function() {
        $.event.special[ this ] = {
            add: keyHandler 
        };
    });
}));
define('internal/sitebuilder/builderChrome/undoer', [
'jquery',
'internal/sitebuilder/common/log',
'jquery.hotkeys'
], function($, log) {
    var make_action = function(f, args, ctx) {
        if (!f) 
            throw "in Soviet Russia, function call you!";
        return {
            f: f,
            args: args,
            ctx: ctx,
            call: function() {
                return f.apply(ctx, args);
            }
        };
    };

    var make_action_stack = function() {
        var stack = [];

        return {
            call: function() {
                for (var i = stack.length - 1; i >= 0; i--)
                    stack[i].call();
            },
            push: function(action) {
                stack.push(action);
            },
            pop: function() {
                return stack.pop();
            },
            empty: function() {
                return stack.length === 0;
            },
            stack: stack
        };
    };

    var make_undo_manager = function() {
        var undoStack = make_action_stack(),
        redoStack = make_action_stack(),
        undoing = false,
        redoing = false,
        clear = function() {
            undoStack = make_action_stack();
            redoStack = make_action_stack();
        },
        startGroup = function(name) {
            log.group("new group: " + name);
            var group = make_action_stack();
            push(group);

            if (undoing) {
                group.parent = redoStack;
                redoStack = group;
            } else {
                group.parent = undoStack;
                undoStack = group;
            }
            return group;
        },
        endGroup = function(name) {
            log.groupEnd("end group: " + name);
            if (undoing) {
                if (redoStack.empty()) 
                    redoStack.parent.pop();
                redoStack = redoStack.parent;
            } else {
                if (undoStack.empty()) 
                    undoStack.parent.pop();
                undoStack = undoStack.parent;
            }
        },
        push = function(action) {
            // Clear redo stack when first undoable action is taken
            if (!undoing && !redoing)
                redoStack = make_action_stack();

            (undoing ? redoStack : undoStack).push(action);
            informAll();
        },
        pushAction = function() {
            push(make_action.apply(null, $.makeArray(arguments)));
        },
        hasUndo = function() {
            return !undoStack.empty();
        },
        hasRedo = function() {
            return !redoStack.empty();
        },
        hadUndo = false,
        hadRedo = false,
        informAll = function() {
            if (hadUndo != hasUndo())
                inform("hasUndo", (hadUndo = !hadUndo));
            if (hadRedo != hasRedo())
                inform("hasRedo", (hadRedo = !hadRedo));
        },
        observers = [],
        observe = function(observer) {
            return observers.push(observer);
        },
        inform = function(key, val) {
            $.each(observers, function(i, o) {
                o.call(null, key, val);
            });
        },
        undo = function() {
            if (!hasUndo()) 
                return false;

            var action = undoStack.pop();

            undoing = true;
            startGroup("undoing");
            var r = action.call();
            endGroup("undoing");
            undoing = false;

            if (!hasUndo() && undoStack.parent)
                undoStack = undoStack.parent;

            informAll();
            return r;
        },
        redo = function() {
            if (!hasRedo()) 
                return false;

            var action = redoStack.pop();

            redoing = true;
            startGroup("redoing");
            var r = action.call();
            endGroup("redoing");
            redoing = false;

            if (redoStack.empty() && redoStack.parent)
                redoStack = redoStack.parent;

            informAll();
            return r;
        };

        return {
            clear: clear,
            push: push,
            pushAction: pushAction,

            startGroup: startGroup,
            endGroup: endGroup,

            undo: undo,
            redo: redo,

            hasUndo: hasUndo,
            hasRedo: hasRedo,

            observe: observe
        };
    };

    var undoer = make_undo_manager();

    var undoController = function() {
        setTimeout(function() {
            var undoButton = $("#tb_undo a"),
            redoButton = $("#tb_redo a"),
            undo = function() {
                undoer.undo();
                return false;
            },
            redo = function() {
                undoer.redo();
                return false;
            },
            undoManagerChange = function(k, v) {
                if (k == "hasUndo")
                    return undoButton[ v ? "removeClass" : "addClass"]("inactive");
                if (k == "hasRedo")
                    return redoButton[ v ? "removeClass" : "addClass"]("inactive");
            },
            attachEvents = function() {
                undoButton.unbind("click").click(undo);
                redoButton.unbind("click").click(redo);

                if (undoer.hasUndo()) {
                    undoButton.removeClass("inactive");
                }
                if (undoer.hasRedo()) {
                    redoButton.removeClass("inactive");
                }
            },
            attachPageEvents = function() {
                $.each([$("body"), bldr.pageController.$("body")], function addKeyEvents(i, body) {
                    if (body.constructor.hotkeys) {
                        body.bind('keydown', 'meta+z', undo)
                        .bind('keydown', 'ctrl+z', undo)
                        .bind('keydown', 'meta+shift+z', redo)
                        .bind('keydown', 'ctrl+shift+z', redo);
                    } else {
                        setTimeout(function() {
                            addKeyEvents(i, body);
                        }, 200);
                    }
                });
            };

            undoer.observe(undoManagerChange);
            attachEvents();
            $("body").bind("bldr:page:load", attachPageEvents);
        }, 100);
    };

    // Initialize it
    undoController();

    return undoer;
});
// Global event buffer
//
// Collects global events from Spine models and things specifically-triggered
// on it. Useful for highly-decoupled information-passing.
//
//
// Example use:
//
// In tracking.js, which knows nothing about modules:
//     eventBuffer.bind("dropped:text", function(){ /* report to mixpanel */});
// In nodeControllers.js, which knows nothing about tracking:
//     eventBuffer.trigger("dropped:text");

define('internal/sitebuilder/common/eventBuffer', [
'spine'
], function(Spine) {

    var eventBuffer = {};

    if (window.Spine) {
        for (var k in Spine.Events) {
            if (Spine.Events.hasOwnProperty(k)) {
                eventBuffer[k] = Spine.Events[k];
            }
        }
    }

    eventBuffer.justTrigger = eventBuffer.trigger || function() {};

    eventBuffer.trigger = function() {
        var args = arguments;
        this.justTrigger.apply(this, arguments);
        try {
            if (window.parent != window) {
                var requirejs = window.parent.requirejs;

                requirejs(["internal/sitebuilder/common/eventBuffer"], function(eb) {
                    eventBuffer = eb;

                    eventBuffer.trigger.apply(eventBuffer, args);
                });
            }
        } catch (e) {}
    };

    return eventBuffer;

});

(function() {
    var id = this.webs && this.webs.site && this.webs.site.id;
    var entitlementsDependency;

    if (typeof id === 'undefined') {
        try {
            id = top.webs && top.webs.site && top.webs.site.id;
        } catch (e) {}
    }

    if (typeof id !== "undefined") {
        entitlementsDependency = 'json!' + "/api/sites/" + id + "/entitlements";
    }

    define('instance/site/entitlements', [
    entitlementsDependency,
    'underscore'
    ], function(entitlements, _) {
        if (typeof entitlements === "undefined") 
            entitlements = [];

        // Including the entitlement map here because otherwise we'd have to
        // off the entitlement type string, as that is what we get from the
        // key API. One sweet day we will fix the API, at which time we should
        // fix it here
        var entitlementMap = {
            RENAME: "Site Rename",
            FORMMAIL: "Form Submissions",
            WEBZOOM: "Webzoom",
            MULTIUPLOAD: "Multi-Uploads",
            WEBSALBUM: "Unlimited Photos in WebsAlbum",
            FTP: "FTP",
            ADREMOVAL: "Ad Removal",
            BANDWIDTH: "Bandwidth",
            STORAGE: "Storage",
            EMAIL: "E-mail",
            EMAILFORWARDING: "E-mail Forwarding",
            EMAILSPACE: "E-mail Space",
            ADWORDS: "Adwords Coupon",
            DNS: "DNS Hosting",
            PASSWORD: "Master Password",
            UNKNOWN: "Miscellaneous",
            DOMAINCOUPON: "Domain Coupon",
            PREMIUMTEMPLATES: "Premium Templates",
            UNLMTDPAGES: "Unlimited Pages",
            SINGLEVIDEO: "Single Video Length",
            TOTALVIDEO: "Total Video Storage",
            HDVIDEO: "HD Video",
            LIVECHAT: "Live Chat Support",
            WEBSTORE: "Additional Webstore Items",
            WEBSTORE_INSTALL: "Webstore Install",
            DOMAIN: "DNS",
            RICHEMAILBLASTS: "Rich Email Blasts",
            APP: "App",
            IN_APP_PURCHASE: "In-App Purchase",
            PAGEMETATAGS: "Meta Tag Customization on a Per Page Basis",
            BANDWIDTHPROTECTION: "Bandwidth Protection",
            CGI: "CGI/Perl Capabilities",
            FACEBOOKCOUPON: "Facebook Coupon",
            BUILDITFORME: "Build It For Me",
            MOBILE_SITE: "Mobile Website",
            DOMAIN_REGISTRATION: "Domain Registration",
            PRIVACY_PROTECTION: "Privacy Protection",
            SEO: "Search Engine Optimization",
            STATS: "New Stats",
            // values: 1-Webs Basic. 2-Webs Premium, 3-VP Basic, 4-VP Premium
            SEARCH_ENGINE_SUBMISSION: "Search Engine Submission",
            WEBS_MOBILE: "Webs Mobile",
            DOMAIN_ERP_RENEWAL: "ERP Domain renewal",
            WEBS_MOBILE_LANDING: "Webs Mobile Landing Page",
            MEMBERS_PASSWORD: "Members Password Protection",
            GOOGLE_TOOLS: "Google Analytics and Webmaster Tools Usage"
        };

        function getEntitlements(entitlementType) {
            return _.filter(entitlements, function(e) {
                return e.entitlement_type === getDisplayName(entitlementType);
            });
        }

        function getDisplayName(entitlementType) {
            return entitlementMap[entitlementType];
        }

        return {
            hasEntitlement : function (entitlementType) {
                var entitlementList = getEntitlements(entitlementType);
                return (!_.isUndefined(entitlementList) && entitlementList.length > 0);
            },
            getMaxEntitlementValue : function(entitlementType) {
                var entitlementList = getEntitlements(entitlementType);
                if (!_.isUndefined(entitlementList) && entitlementList.length > 0) {
                    return _.max(entitlementList, function(e) {
                        return e.entitlement_value;
                    }).entitlement_value;
                }
                return undefined;
            }

        };
    });
})();

define('internal/apps/webstore', [
'instance/site/entitlements'
], function(entitlements) {
    return {
        shouldDisallowInstall: function() {
            // FWB-39194: 'missingWebstoreEntitlement' query param is for QA.
            // when this story launches we can safely remove this condition:
            return top.location.search.indexOf("missingWebstoreEntitlement=1") > - 1 || !entitlements.hasEntitlement('WEBSTORE_INSTALL');
        },
        showUpsell: function() {
            top.webs.showPremiumDialog('webstore');
        }
    };
});

// Usage:

// <ul class="tabs">
//  <li data-name="users">Users</li>
//  <li data-name="groups">Groups</li>
// </ul>
//

// var users = Users.init();
// var groups = Groups.init();
// Manager.init(users, groups);
//
// var tabs = Spine.Tabs.init({el: $(".tabs")});
// tabs.connect("users", users);
// tabs.connect("groups", groups);
//
// // Select first tab.
// tabs.render();

define('spine.tabs', ['spine', 'jquery'], function(Spine, $) {

    Spine.Tabs = Spine.Controller.create({
        events: {
            "click [data-name]": "click"
        },

        proxied: ["change"],

        init: function() {
            this.bind("change", this.change);
        },

        change: function(name) {
            if ( !name ) 
                return;
            this.current = name;

            this.children().removeClass("active");
            this.children("[data-name='" + this.current + "']").addClass("active");
        },

        render: function() {
            this.change(this.current);
            if ( !this.children(".active").length || !this.current )
                this.children(":first").click();
        },

        children: function(sel) {
            return this.el.children(sel);
        },

        click: function(e) {
            var target = $(e.target),
            name = target.attr("data-name");

            if (typeof name === 'undefined') 
                name = target.parents("[data-name]").attr("data-name");
            this.trigger("change", name);
        },

        connect: function(tabName, controller) {
            this.bind("change", function(name) {
                if (name === tabName)
                    controller.active();
            });
        }
    });

    return Spine.Tabs;
});

// Spine routing, based on Backbone's implementation.
//  Backbone.js 0.3.3
//  (c) 2010 Jeremy Ashkenas, DocumentCloud Inc.
//  Backbone may be freely distributed under the MIT license.
//  For all details and documentation:
//  http://documentcloud.github.com/backbone
//
// For usage, see examples/route.html

require(["jquery", "spine"], function($) {
    var Route = Spine.Route = Spine.Class.create();

    var hashStrip = /^#*/;

    Route.extend({
        routes: [],

        historySupport: ("history" in window),
        history: false,

        add: function(path, callback) {
            if (typeof path === "object")
                for (var p in path) 
                    this.add(p, path[p]);
            else
                this.routes.push(this.init(path, callback));
        },

        setup: function(options) {
            if (options && options.history)
                this.history = this.historySupport && options.history;

            if ( this.history )
                $(window).bind("popstate", this.change);
            else
                $(window).bind("hashchange", this.change);
            this.change();
        },

        unbind: function() {
            if (this.history)
                $(window).unbind("popstate", this.change);
            else
                $(window).unbind("hashchange", this.change);
        },

        navigate: function() {
            var args = Spine.makeArray(arguments);
            var triggerRoutes = true;

            if (typeof args[args.length - 1] === "boolean") {
                triggerRoutes = args.pop();
            }

            var path = args.join("/");
            if (this.path === path) 
                return;

            if ( !triggerRoutes )
                this.path = path;

            if (this.history)
                history.pushState({},
                document.title,
                this.getHost() + path
                );
            else
                window.location.hash = path;
        },

        // Private

        getPath: function() {
            return window.location.pathname;
        },

        getHash: function() {
            return window.location.hash;
        },

        getHost: function() {
            return ((document.location + "").replace(
            this.getPath() + this.getHash(), ""
            ));
        },

        getFragment: function() {
            return this.getHash().replace(hashStrip, "");
        },

        change: function(e) {
            var path = (this.history ? this.getPath() : this.getFragment());
            if (path === this.path) 
                return;
            this.path = path;
            for (var i = 0; i < this.routes.length; i++)
                if (this.routes[i].match(path)) 
                    return;
        }
    });

    Route.proxyAll("change");

    var namedParam = /:([\w\d]+)/g;
    var splatParam = /\*([\w\d]+)/g;
    var escapeRegExp = /[-[\]{}()+?.,\\^$|#\s]/g;

    Route.include({
        init: function(path, callback) {
            this.callback = callback;
            if (typeof path === "string") {
                path = path.replace(escapeRegExp, "\\$&")
                .replace(namedParam, "([^\/]*)")
                .replace(splatParam, "(.*?)");

                this.route = new RegExp('^' + path + '$');
            } else {
                this.route = path;
            }
        },

        match: function(path) {
            var match = this.route.exec(path)
            if ( !match ) 
                return false;
            var params = match.slice(1);
            this.callback.apply(this.callback, params);
            return true;
        }
    });

    Spine.Controller.fn.route = function(path, callback) {
        Spine.Route.add(path, this.proxy(callback));
    };

    Spine.Controller.fn.routes = function(routes) {
        for (var path in routes)
            this.route(path, routes[path]);
    };

    Spine.Controller.fn.navigate = function() {
        Spine.Route.navigate.apply(Spine.Route, arguments);
    };

    return Spine.Route;
});

define("spine.route", function() {});

////
// A Manager is basically a state machine that controls a set of controller's 'active' state.
// In other words, you feed a manager controllers, and it'll make sure that only controller has an 'active' state at any one time.
// This is useful whenever you're implementing tabs or separate views inside an application.
//
// By default, whenever a controller is activated, it's element receives a 'active' class.
// You can use this class to show/hide views and tabs via CSS.
// For example:
//
//  var users = Users.init();
//  var groups = Groups.init();
//  Manager.init(users, groups);
//
//  users.active();
//  assert( users.isActive() );
//  assert( users.el.hasClass("active") );
//  assert( ! groups.el.hasClass("active") );
//
//  groups.active();
//  assert( groups.el.hasClass("active") );
//  assert( ! users.el.hasClass("active") );

define('spine.manager', ['spine', 'jquery'], function(Spine, $) {

    var Manager = Spine.Manager = Spine.Class.create();
    Manager.include(Spine.Events);

    Manager.include({
        init: function() {
            this.add.apply(this, arguments);
        },

        add: function(controller) {
            if (arguments.length > 1) {
                var args = Spine.makeArray(arguments);
                for (var i = 0; i < args.length; i++) 
                    this.add(args[i]);
                return;
            }

            if ( !controller ) 
                throw ("Controller required");

            this.bind("change", function(current) {
                if (controller === current)
                    controller.activate();
                else
                    controller.deactivate();
            });

            controller.active(this.proxy(function() {
                this.trigger("change", controller);
            }));
        }
    });

    Spine.Controller.include({
        active: function(callback) {
            if (typeof callback === "function")
                this.bind("active", callback)
            else {
                var args = Spine.makeArray(arguments);
                args.unshift("active");
                this.trigger.apply(this, args);
            }
            return this;
        },

        isActive: function() {
            return this.el.hasClass("active");
        },

        activate: function() {
            this.el.addClass("active");
            return this;
        },

        deactivate: function() {
            this.el.removeClass("active");
            return this;
        }
    });

    return Spine.Manager;
});
define('internal/sitebuilder/builderChrome/Helptip', [
"jquery",
"spine"
], function($, Spine) {
    var Helptip = Spine.Controller.create({

        /**
        		 * Options:
        		 *      @detachable     boolean     helptip hides onmousedown
        		 */
        init: function() {
            var self = this;

            this.$body = $("body");
            this.el = $("<div/>").addClass("w-helptip");

            if (this.detachable) {
                this.$body.mousedown(function(e) {
                    self.destroy();
                });
            }
            return this;
        },

        /**
        		 * Set Helptip Message
        		 */
        setMessage: function(msg) {
            if (msg) 
                this.el.html(msg);
            return this;
        },

        /**
        		 * Set Helptip container width
        		 */
        setWidth: function(width) {
            if (typeof width === "number") 
                this.el.css("width", width);
            return this;
        },

        /**
        		 * Shows the helptip on the page in relation to an element
        		 * options:
        		 *      @ref        object      refrence to align helptip with
        		 *      @width      number      width of helptip
        		 *      @offsetLeft number      offset from @ref position
        		 *      @offsetTop  number      offset from @ref position
        		 *      @arrow      string      adds top/bottom/left/right class
        		 *      @bounce     boolean     bouncing tooltip
        		 */
        show: function(opts) {
            var ref = opts.ref;
            var offset = ref.offset();

            if (!ref) 
                return false;
            if (!ref.jquery) 
                ref = $(ref);
            if (opts.arrow) 
                this.el.addClass("w-helptip-arrow-" + opts.arrow);

            this.setMessage(opts.msg).setWidth(opts.width);
            this.el.appendTo(this.$body).css(offset);

            this.el.css({
                left: "+=" + opts.offsetLeft || 0,
                top: "+=" + opts.offsetTop || 0
            });

            if (opts.bounce) {
                var arr = opts.arrow;
                var bounceDir = arr === "left" || arr === "right" ? "horizontal" : (arr == "top" ? "down" : "vertical");
                this.el.addClass("w-helptip-bounce-" + bounceDir);
                if ($("html").hasClass("no-cssanimations")) {
                    this.animateWithJs();
                }
            }

            return this;
        },

        animateWithJs: function(bounce) {
            var self = this;
            if (typeof bounce == 'undefined') 
                bounce = 0;
            this.el.animate({
                top: "-=10" 
            }, function() {
                if (self.el) {
                    self.el.animate({
                        top: "+=10" 
                    }, function() {
                        if (self.el) {
                            if (bounce < 3) 
                                self.animateWithJs(bounce + 1);
                        }
                    });
                }
            });
        },

        /**
        		 * Removes helptip container from the DOM
        		 */
        hide: function() {
            if (this.el) 
                this.el.remove();
            return this;
        },

        /**
        		 * Removes helptip container, deference everything
        		 */
        destroy: function() {
            this.hide();
            this.el = null;
            this.$body = null;
            return this;
        }
    });
    return Helptip;
});


// locale loader -> create locales, adds strings to them
// locale -> contains strings and formatting functions
// localize -> localize, execute, interpolate


define('localize', [], function() {
    function trim(string) {
        return string.replace(/^\s+|\s+$/g, "");
    }

    function execute_command(command, locale) {
        var commandItems = trim(command).split(/\s+/);
        var commandName = commandItems[0];

        if (typeof locale[commandName] === "function")
            return locale[commandName].call(locale, commandItems, locale);
    }

    function lookup(key, locale) {
        return locale[key];
    }

    function interpolate(string, locale) {
        return string.replace(/{([^}]*)}/g, function(match, content) {
            return ret.localize(trim(content), locale);
        });
    }

    var ret = {
        localize: function localize(key, locale) {
            if (typeof(location) !== 'undefined' && location.search && location.search.indexOf('notranslate=1') > 0) {
                // In case you want to see the keys... put notranslate=1 in the queryString
                return key;
            }

            var translation = lookup(key, locale);
            if (typeof(translation) !== "undefined")
                return interpolate(String(translation), locale);

            translation = execute_command(key, locale);
            if (translation)
                return interpolate(translation, locale);

            // Didn't find key!
            this.logMissingLocalization(key, locale);
            translation = key;

            return translation;
        },

        logMissingLocalization: function logMissingLocalization(key, locale) {
            if (typeof(console) !== 'undefined' && console.warn) 
                console.warn("No localized string for", key, locale.name);
            if (typeof(mpq) !== 'undefined' && mpq.push) 
                mpq.push(['track', 'localizationMissing', {
                    key: key,
                    locale: locale.name
                }
                ]);
        }
    };

    return ret;

});

/*
 * Locale system
 *
 */
/*
 * Locale
 *
 * A locale is a language/culture group that has a standard grammar for
 * pluralizing words, and standard ways to format numbers and dates.
 *
 * TODO: use the globalize jquery library to do things other than plurals
 *   Register plurals as another piece of data for globalize
 *   https://github.com/jquery/globalize/blob/master/lib/globalize.js
 */

define('locale', ["localize"], function(localize) {
    function extend(o, extensions) {
        function F() {}
        F.prototype = o;
        var obj = new F();

        for (var k in extensions) {
            obj[k] = extensions[k];
        }
        return obj;
    }

    var baseLocale = {
        name: 'base',
        pluralize: function(items, locale) {
            var number = localize.localize(items[2], locale);
            var pluralSuffix = locale.pluralTypes[locale.pluralType](number);
            var key = items[1] + "." + pluralSuffix;
            return localize.localize(key, locale);
        },
        pluralTypes: {
            // 1, 0 and many
            "1": function(n) {
                return n == "1" ? "1" : "other";
            },
            // 0 and 1, many
            "2": function(n) {
                return n == "0" || n == "1" ? "1" : "other";
            }
        },
        formatDate: function(items, locale) {
            var date = locale[items[1]];

            date = new Date(date);

            if (!(date instanceof Date)) 
                return "";
            var day = date.getDate();
            var month = date.getMonth() + 1;
            var year = date.getFullYear();

            return month + "/" + day + "/" + year;
        }
    },
    locales = {};

    // Simple Locale factory
    function addLocale(name, pluralType) {
        // default to pluralType 1
        if (typeof(pluralType) === 'undefined') 
            pluralType = 1;

        locales[name] = extend(baseLocale, {
            pluralType: '' + pluralType,
            name: name
        });
    }

    addLocale('da-DK', 1);
    addLocale('de-DE', 1);
    addLocale('en-GB', 1);
    addLocale('en-AU', 1);
    addLocale('en-US', 1);
    addLocale('es-ES', 1);
    addLocale('es-MX', 1);
    addLocale('es-US', 1);
    addLocale('fr-CA', 2);
    addLocale('fr-FR', 2);
    addLocale('it-IT', 1);
    addLocale('nb-NO', 1);
    addLocale('nl-NL', 1);
    addLocale('sv-SE', 1);
    addLocale('zz-ZZ', 1);

    function logMissingLocale(name) {
        if (typeof(console) !== 'undefined' && console.warn) 
            console.warn("No such locale", name);
        if (typeof(mpq) !== 'undefined' && mpq.push) 
            mpq.push(['track', 'localeMissing', {
                locale: name
            }
            ]);
    }

    return function(name) {
        var locale = locales[name];
        if (locale) 
            return locale;

        logMissingLocale(name);

        return extend(baseLocale, {});
    };
});

/*
 * RequireJS plugin to load Webs translation resources
 *
 * (c) Webs, 2011, written by Adam Solove.
 *
 * Specs:
 *   - If translate is defined by require in the parent window, that instance will be returned instead of a new one.
 *   - If translate is not available from the parent window, the following documentation applies:
 *     - If you want non-English, the page needs a webs.locale
 *     - If you want to load resources from a separate domain (e.g. dynamic.websimages.com)
 *       webs.props.dynamicAssetServer must be defined.
 *     - If you want certain namespaces to be preloaded, define prefetchTranslationNamespaces as an array of
 *       resource namespaces to fetch. This can be useful if the order of generic namespaces and specific
 *       subnamespaces cannot be guaranteed (e.g. webs.bldr.chrome.settings and webs.bldr). It is important that this
 *       require-managed resource is available immediately, otherwise there is no guarantee that the namespaces
 *       will be fetched before requests for more specific subnamespaces (which would be skipped when the more
 *       generic namespace has already been preloaded).
 */
/* global define:false, require:false, webs:false, window:false*/
define('translate', ['localize', 'locale', 'jquery'], function(localize, getLocale, $) {
    "use strict";
    // First, try to grab translate from the parent frame, so that we can share translation resources
    // across the entire app, instead of re-loading translations in each frame.
    if (typeof(window) !== "undefined" && window.parent && window.parent !== window) {
        // We're going to try to reach into the parent frame, which won't work if it's on a different domain
        // (iframe apps in the VP dashboard), so we need to wrap this in a try to prevent cross-domain scripting
        // protections from killing us.
        try {
            return window.parent.require("translate");
        } catch (e) {
            // Oops, fall through and define it the normal way.
        }
    }

    var loadedNamespaces = {},
    localeName = typeof(webs) !== 'undefined' && webs.locale || "en-US",
    resourceUrl,
    locale = getLocale(localeName),
    NOOP_NAMESPACE = "none"; // To allow "translate!none" to just grab the translate function

    resourceUrl = "/s/resources/" + localeName + "/";
    if (typeof(webs) !== 'undefined' && webs.props && webs.props.dynamicAssetServer) {
        resourceUrl = webs.props.dynamicAssetServer + resourceUrl;
    }

    // If namespace or its parent is already loading/loaded,
    // returns a deferred representing when that is done.
    // Otherwise returns false.
    var namespaceLoading = function(toTest) {
        var parts = toTest.split(".");
        for (var i = 0; i < parts.length; i++) {
            var ns = loadedNamespaces[parts.slice(0, i + 1).join(".")];
            if (ns) {
                return ns;
            }
        }
        return false;
    };

    // Returns a deferred representing that the namespace has loaded.
    var loadNamespace = function(namespace) {
        var loading = namespaceLoading(namespace);
        if (loading) {
            return loading;
        } else {
            var url = resourceUrl + namespace + "/",
            deferred = $.Deferred(),
            promise = deferred.promise();

            require([url + '?callback=define'], function(resources) {
                add(resources);
                deferred.resolve(resources);
            });

            loadedNamespaces[namespace] = promise;
            return promise;
        }
    };

    var add = function(data) {
        for (var k in data) {
            if (data.hasOwnProperty(k)) {
                locale[k] = data[k];
            }
        }
    };

    function extend(o, extensions) {
        function F() {}
        F.prototype = o;
        var obj = new F();

        for (var k in extensions) {
            obj[k] = extensions[k];
        }
        return obj;
    }
    var translate = function(key, vals) {
        var resources = extend(locale, vals);
        return localize.localize(key, resources);
    };

    try {
        // We need to upgrade to the newer require so that we can just ask require.specified("...")
        if (require.s.contexts._.specified.prefetchTranslationNamespaces) {
            require(["prefetchTranslationNamespaces"], function(namespaces) {
                $.each(namespaces, function(i, namespace) {
                    loadNamespace(namespace);
                });
            });
        }
    } catch (e) {
        // failure is totally an option
    }

    return {
        load: function(name, req, load, config) {
            // Make sure that name exists as a string in the current JS context (so that if an iframe
            // is blown away, the name strings it provided continue to behave properly).
            // See: http://msdn.microsoft.com/en-us/library/gg622929%28v=VS.85%29.aspx?ppud=4
            name = String(name).toString();
            if (!config.isBuild) {
                if (name === NOOP_NAMESPACE) {
                    load(translate);
                } else {
                    loadNamespace(name).then(function() {
                        load(translate);
                    });
                }
            } else {
                // We currently don't include these in builds so they can be
                // updated dynamically. But we could include them and require
                // a rebuild to get updated translations.
                load();
            }
        },

        translate: translate,
        add: add
    };
});

define('internal/sitebuilder/common/dockPane.behavior', [
'require',
'jquery',
'spine',
'spine.tabs',
'translate!webs.bldr.modules'
], function(require, $, Spine, spineTabs, translate) {
    var dockPaneBehavior = {
        attachDockPane: function() {
            if ($('#pagesFrame').length || $('#appsFrame').length) {
                return;
            } else {
                var pagesFrame = $('<iframe name="pagesFrame" id="pagesFrame" />').attr('src', "/sites/" + webs.site.id + "/pages").appendTo('#leaf_wrap');
                var loaded = this.pagesFrameLoaded = new $.Deferred();
                pagesFrame.load(function() {
                    loaded.resolve();
                });

                $('#controls_nav, #tabs-nav_container').append(this.buildDockTabs().hide());
            }
        },

        buildDockTabs: function() {
            var $dockTabs = $('<menu id="dockTabs" class="tabs-nav"/>');
            var tabsList = ['Pages'];

            if (webs.partner.showAppStoreLinks) {
                tabsList.push('Apps');
            }

            $.each(tabsList, function(index, pageType) {
                $dockTabs.append($('<li class="pagesFrame" />').attr('data-name', pageType)
                .append($('<a href="#" />').addClass('leaf_type_btn tab_btn')
                .append($('<span/>').html(translate('webs.bldr.modules.container.' + pageType)))
                )
                );
            });

            return $dockTabs;
        },

        tabEvents: function() {
            $('#dockTabs li[data-name="Pages"]').click(function(event) {
                Spine.Route.navigate("/pages/");
                return false;
            });

            $('#dockTabs li[data-name="Apps"]').click(function(event) {
                Spine.Route.navigate("/apps/");
                return false;
            });
        },

        showDockPane: function($pagesFrame) {
            $('body').addClass('dockPaneOn');

            $('#pagesFrame, #toaster').show();
            $('#appStoreFrame').hide();
            $("#right_tools_container").hide();

            if (!webs.site.appPage) {
                require(['internal/sitebuilder/builderChrome/chromeController'], function(chromeController) {
                    if (chromeController && !webs.site.appPage) {
                        chromeController.toggleControls(false);
                        chromeController.dockController.controlsAnchor.find('#toggle_grid').hide();
                        chromeController.dockController.controlsAnchor
                        .find('#hide_controls').addClass('w-btn-minus w-icon-minus').removeClass('w-icon-plus');

                        $pagesFrame.clearQueue().animate({
                            bottom: 0
                        });
                    }

                    $('#sd-save').hide();
                });
            }


        },

        hideDockPane: function($pagesFrame) {
            $('body').removeClass('dockPaneOn');
            $('#toaster').show();

            if (!webs.site.appPage) {
                require(['internal/sitebuilder/builderChrome/chromeController'], function(chromeController) {
                    if (chromeController && !webs.site.appPage) {
                        $pagesFrame.clearQueue().animate({
                            bottom: '-440px'
                        }, function() {
                            chromeController.toggleControls(true);
                        });
                    }
                });
            }


        }
    };

    return dockPaneBehavior;
});

define('internal/sitebuilder/common/dockPane.routes', [
'require',
'internal/sitebuilder/common/dockPane.behavior',
'jquery',
'spine',
'spine.route'
], function(require, dockPaneBehavior, $, Spine) {

    var dockPaneRoutes = {
        isDesigner: !!document.location.pathname.match(/design/)
    };


    Spine.Route.add({
        '/pages/*': function() {
            $(function() {
                dockPaneBehavior.attachDockPane();
                topNav.highlightPages();
                bottomTabs.highlightPages();
                dockFrame.showPages();
            });
        },

        '/apps/*': function() {
            $(function() {
                dockPaneBehavior.attachDockPane();
                topNav.highlightPages();
                bottomTabs.highlightApps();
                dockFrame.showApps();
            });
        },

        '': function() {
            topNav.dehighlightPages();
            $('#pagesFrame, #pages > a').removeClass('active');
            $('body').removeClass('dockPaneOn');
            $('#toggle_grid, #leaf_types, #tabs-nav').show();
            $('#dockTabs').hide();
            $("#right_tools_container").show();
        }
    });


    // managing state of the top nav bar: builder, designer, pages, panel
    var topNav = {
        highlightPages: function() {
            $('#w-main-nav-menu a, .header-nav a').removeClass('active');

            // App pages hijack this and apply a different location.hash;
            // no sense in marking the Pages pane as active if we've been deactivated.
            // also: if we're on a Designer page, just assume that it's
            // okay to highlight Pages here in this method.

            if (location.hash.match(/#\/(pages|apps)/) || dockPaneRoutes.isDesigner) {
                $('#pages > a').addClass('active');
            }

            $('#pagesFrame').addClass('active');
            $('#interface_bottom').removeClass('variableDock');
            $('body').addClass('dockPaneOn');
            $("#right_tools_container").hide();

            if (dockPaneRoutes.isDesigner) {
                $('#container').attr('style', '');
            }
        },

        dehighlightPages: function() {
            if (dockPaneRoutes.isDesigner) {
                $('#designer > a, #interface_dock .tab_view, #tabs-nav > li').removeClass('active');
                $('#designer > a, #interface_dock .tab_view:first, #tabs-nav > li:first').addClass('active');
                $('#interface_bottom').removeClass('variableDock');
            } else {
                $('#builder > a').addClass('active');
            }
        }
    };

    // managing state of the bottom tabs: pages, apps
    var bottomTabs = {
        highlightPages: function() {
            this.dehighlightAll();
            $("#dockTabs li[data-name=Pages]").addClass("active");
        },
        highlightApps: function() {
            this.dehighlightAll();
            $("#dockTabs li[data-name=Apps]").addClass("active");
        },
        dehighlightAll: function() {
            $("#dockTabs li").removeClass("active");
        }
    };

    // manage the display of the actual popup frame
    var dockFrame = {
        show: function() {
            $('#leaf_types, #tabs-nav, #sd-save, #toggle_grid').hide();
            $('#dockTabs').show();
        },

        showPages: function() {
            this.show();
            this.triggerOnFrame("dock:tab", {
                name: "pageList" 
            });
        },

        showApps: function() {
            this.show();
            this.triggerOnFrame("dock:tab", {
                name: "AppStore" 
            });
        },

        triggerOnFrame: function(name, data) {
            dockPaneBehavior.pagesFrameLoaded.then(function() {
                var frameWindow = frames["pagesFrame"];
                if (!frameWindow) 
                    frameWindow = $("#pagesFrame")[0].contentWindow;
                frameWindow.$("body").trigger(name, data);
            });
        }
    };

    Spine.Route.setup();

    return dockPaneRoutes;
});

define('internal/sitebuilder/common/dockPane', [
'require',
'internal/sitebuilder/common/dockPane.behavior',
'internal/sitebuilder/common/dockPane.routes',
'jquery',
'spine',
'spine.route'
], function(require, dockPaneBehavior, dockPaneRoutes, $, Spine) {

    $(function() {
        var $pagesFrame,
        usePagesFrame = webs && webs.useIR,
        visible = true;

        if (usePagesFrame) {
            // Preload dock pane if we're going to use it
            dockPaneBehavior.attachDockPane();
        }
        dockPaneBehavior.tabEvents();

        $dockPane = $('#pagesFrame, #appStoreFrame');

        if (usePagesFrame) {
            $('#pages').click(function(event) {
                event.preventDefault();
                dockPaneBehavior.showDockPane($dockPane);
                Spine.Route.navigate('/pages');

                setDockControlsVisible(visible);
            });

            // See listPages.jsp for triggering of this event
            $(document).on('pagesDone', function() {
                goToBuilder(visible);
            });
        }

        $("#designer").click(function(event) {
            if (!dockPaneRoutes.isDesigner) {
                return;
            }
            event.preventDefault();
            goToBuilder(visible);
        });

        var oldHeight = NaN;
        $('#hide_controls').on('click', function(event) {
            var method = visible ? "hide" : "show",
            isBuilder = $('#builder a').hasClass('active'),
            $targetEls = $("#toaster, #pagesFrame, #header, #dockTabs, #leaf_types");

            if (isBuilder) {
                $targetEls = $targetEls.not('#dockTabs');
            } else {
                $targetEls = $targetEls.not('#leaf_types');
            }


            $targetEls[method]();
            visible = !visible;

            if (!visible) {
                oldHeight = $("#container").height();
                $("#container").height($(window).height() - 36);
            } else {
                $("#container").height(oldHeight);
            }
        });
    });

    var goToBuilder = function(visible) {
        dockPaneBehavior.hideDockPane($dockPane);
        $('#leaf_types, #tabs-wrap, #sd-save').show();
        $('#dockTabs').hide();
        Spine.Route.navigate('');

        setDockControlsVisible(visible);

    };

    var setDockControlsVisible = function(visible) {
        if (!webs.site.appPage) {
            require(['internal/sitebuilder/builderChrome/chromeController'], function(chromeController) {
                if (chromeController && !webs.site.appPage) {
                    chromeController.dockController.controlsVisible = visible;

                    chromeController.dom.leafContainer.css('bottom', visible ? - 18 : - 86);

                    visible = !visible;
                }
            });
        }
    };
});

if (!window.webs) 
    window.webs = {};

define('internal/sitebuilder/common/creativeCommons', [
'jquery',
'translate!webs.creativecommons.attribution'
], function ($, translateCC) {
    /**
    	 * Creative Commons Attribution
    	 * Modules simply need to call webs.page.addCCImage,
    	 * passing in a creative commons image object consisting of:
    	 *   url - URL where the source image can be found
    	 *   artist - Name of the original artist
    	 */
    webs.page = webs.page || {};
    webs.page.addCCImage = function (ccImage, selector, toggleEvent) {
        var ccImages = webs.page.ccImages;
        if (!ccImages) {
            ccImages = webs.page.ccImages = [];

            $(function () {
                var createAttributionLink = function (img) {
                    return '<a target="_blank" href="' + img.url + '">' + img.artist + '</a>';
                };

                var cc = $('<div/>')
                .attr('id', 'webs-cc')
                .append($('<div/>', {
                    'id': 'webs-cc-mark'
                }))
                .appendTo(selector || 'body');

                cc.on(toggleEvent || 'mouseenter', function () {
                    if ($('#webs-cc-full').length === 0) {
                        var attrList = $.map(ccImages, createAttributionLink).join(' ');

                        $('<div/>')
                        .attr('id', 'webs-cc-full')
                        .append($('<p/>').html(translateCC('webs.creativecommons.attribution.message')))
                        .append($('<p/>').html(translateCC('webs.creativecommons.attribution.photosby') + ' ' + attrList))
                        .appendTo(cc);
                        cc.addClass('over');

                    }
                });
            });
        }

        ccImages.push(ccImage);
    };
});
/**
 * Copyright (c) 2010 unscriptable.com
 */

(function (global) {
    "use strict";

    /*
     * curl link! plugin
     * This plugin will load css files as <link> elements.  It does not wait for
     * css file to finish loading / evaluating before executing dependent modules.
     * This plugin also does not handle IE's 31-stylesheet limit.
     * If you need any of the above behavior, use curl's css! plugin instead.
     *
     * All this plugin does is insert <link> elements in a non-blocking manner.
     *
     * usage:
     * 		// load myproj/comp.css and myproj/css2.css
     *      require(['link!myproj/comp,myproj/css2']);
     *      // load some/folder/file.css
     *      define('link',['css!some/folder/file'], {});
     *
     * Tested in:
     *      Firefox 1.5, 2.0, 3.0, 3.5, 3.6, and 4.0b6
     *      Safari 3.0.4, 3.2.1, 5.0
     *      Chrome 7+
     *      Opera 9.52, 10.63, and Opera 11.00
     *      IE 6, 7, and 8
     *      Netscape 7.2 (WTF? SRSLY!)
     * Does not work in Safari 2.x :(
    */


    var
    // compressibility shortcuts
    createElement = 'createElement',
    // doc will be undefined during a build
    doc = global.document,
    // regexp to find url protocol for IE7/8 fix (see fixProtocol)
    isProtocolRelativeRx = /^\/\//,
    // find the head element and set it to it's standard property if nec.
    head;

    if (doc) {
        head = doc.head || (doc.head = doc.getElementsByTagName('head')[0]);
    }

    function nameWithExt (name, defaultExt) {
        return name.lastIndexOf('.') <= name.lastIndexOf('/') ?
        name + '.' + defaultExt : name;
    }

    function createLink (doc, href) {
        var link = doc[createElement]('link');
        link.rel = "stylesheet";
        link.type = "text/css";
        link.href = href;
        return link;
    }

    function fixProtocol (url, protocol) {
        // IE 7 & 8 can't handle protocol-relative urls:
        // http://www.stevesouders.com/blog/2010/02/10/5a-missing-schema-double-download/
        return url.replace(isProtocolRelativeRx, protocol + '//');
    }

    define('link', {

        'load': function (resourceId, require, callback, config) {
            var url, link, fix;

            url = require['toUrl'](nameWithExt(resourceId, 'css'));
            fix = 'fixSchemalessUrls' in config ? config['fixSchemalessUrls'] : doc && doc.location.protocol;
            url = fix ? fixProtocol(url, fix) : url;

            if (!doc) {
                callback(url);
            } else {
                link = createLink(doc, url);
                head.appendChild(link);
                callback(link.sheet || link.styleSheet);
            }
        }

    });

})(this);


/* global define:false, require:false */
define('internal/common/tooltip', [
'jquery',
'link'
], function($) {
    "use strict";

    // Don't include this in the top-level define block so the build doesn't break.
    require(['link!../../static/projects/finch/css/tooltip'], function() {});

    $.tooltip = $.fn.tooltip = function tooltip(opts) {

        if (this.jquery) {
            var tooltips = $([]);
            this.each(function(i, e) {
                tooltips.push(tooltip($.extend({}, opts, {
                    "anchor": e
                }))[0]);
            });
            return tooltips;
        }

        opts = $.extend({}, {
            "content": "&nbsp;",
            "style": "info",
            "position": "southeast",
            "offset": [5, 5],
            "anchor": "cursor"
        }, opts);

        if (typeof opts.anchor === "string" && opts.anchor !== "cursor") {
            return $(opts.anchor).tooltip(opts);
        }

        // if anchor is a DOM Element
        if (opts.anchor.nodeType) {
            opts.anchor = $(opts.anchor);
        }

        var $tt = $("<div></div>").addClass("w-tooltip").html(opts.content).appendTo($("body"));
        var $tooltipPoint = $("<div class=\"tooltip-tip\"><span class=\"tip\">&nbsp;</span><span class=\"overlay\">&nbsp;</span></div>");


        if (opts.style) {
            $tt.addClass("w-tooltip-" + opts.style);
        }

        if (opts.hideicon) {
            $tt.addClass("w-tooltip-noicon");
        }


        if (opts.anchor === "cursor") {
            $tt.css({
                "position": "fixed"
            });
            $("body").bind("mousemove", function(e) {
                if (!$tt.hasClass("active")) {
                    return;
                }

                // First, check if we should change position.
                var tooltipRightEdge = parseInt(e.clientX + $tt.width(), 10);

                // If this tooltip will go off the right of the screen, change its direction.
                // Give a decent buffer amount based on the width of the tooltip so it isn't
                // right up against the egde of the screen.
                var current_position = opts.position;
                if (tooltipRightEdge > $("body").width() - $tt.width() * 1.5) {
                    current_position = "southwest";
                }

                if (current_position.match(/(top|north)/i)) {
                    $tt.css({
                        bottom: ($(window).height() - e.clientY + opts.offset[1]) + "px",
                        top: ""
                    });
                } else {
                    $tt.css({
                        top: (e.clientY + opts.offset[1]) + "px",
                        bottom: ""
                    });
                }
                if (current_position.match(/(left|west)/i)) {
                    $tt.css({
                        right: ($(window).width() - e.clientX + opts.offset[0]) + "px",
                        left: ""
                    });
                } else {
                    $tt.css({
                        left: (e.clientX + opts.offset[0]) + "px",
                        right: ""
                    });
                }
            });
        }
 else if (opts.showTip) {
            $tt.append($tooltipPoint);
            opts.tipOffset = opts.tipOffset || [0, 0];
        }

        $tt.reposition = function reposition() {
            var newPosition = 0;
            var oldPosition = 0;

            if (opts.anchor === "cursor") {
                // nothing to do
                return;
            } else if (opts.anchor && opts.anchor.constructor === Array) {
                $tt.css({
                    "position": "absolute"
                });
                if (opts.position.match(/(top|north)/i)) {
                    $tt.css("bottom", ($("body").height() - opts.anchor[1] + opts.offset[1]) + "px");
                } else {
                    $tt.css("top", (opts.anchor[1] + opts.offset[1]) + "px");
                }
                if (opts.position.match(/(left|west)/i)) {
                    $tt.css("right", ($("body").width() - opts.anchor[0] + opts.offset[0]) + "px");
                } else {
                    $tt.css("left", (opts.anchor[0] + opts.offset[0]) + "px");
                }

                if (opts.showTip) {
                    repositionTip(0, opts);
                }

            } else if (opts.anchor && opts.anchor.jquery) {
                $tt.css({
                    "position": "absolute"
                });
                var anchorPosition = opts.anchor.offset();
                if (opts.position.match(/(top|north)/i)) {
                    $tt.css("bottom", ($("body").height() - anchorPosition.top + opts.anchor.outerHeight() + opts.offset[1]) + "px");
                } else {
                    $tt.css("top", (anchorPosition.top + opts.anchor.outerHeight() + opts.offset[1]) + "px");
                }
                if (opts.position.match(/(left|west)/i)) {
                    $tt.css("right", $("body").width() - anchorPosition.left + opts.offset[0] + "px");
                } else if (opts.position.match(/center/i)) {
                    $tt.css("left", anchorPosition.left - ($tt.outerWidth() / 2) + opts.offset[0] + "px");
                } else {
                    // Define minimum and maximum pixel location for bubble left.
                    var minLeft = Math.abs(parseInt($tt.css("margin-left"), 10));
                    var maxLeft = $("body").width() - minLeft;

                    // Calculate the new position of the tooltip and save a copy for later.
                    newPosition = anchorPosition.left + opts.anchor.outerWidth() + opts.offset[0];
                    oldPosition = newPosition;

                    // If need be, reposition.
                    if (newPosition < minLeft) {
                        newPosition = minLeft;
                    } else if (newPosition > maxLeft) {
                        newPosition = maxLeft;
                    }

                    // Apply the positioning to the tooltip.
                    $tt.css("left", newPosition + "px");
                }
                if (opts.showTip) {
                    repositionTip(newPosition - oldPosition, opts);
                }
            } else {
                throw (["Unsupported tooltip definition", opts]);
            }

        };

        $tt.updateOffset = function updateOffset(offset) {
            if (opts.offset !== offset) {
                opts.offset = offset;
                $tt.reposition();
            }
        };

        var repositionTip = function (shiftAmount, opts) {
            var ttWidth = $tt.width(),
            ttPaddingLeft = parseInt($tt.css("padding-left"), 10),
            anchorLeft = opts.anchor.offset().left,
            ttLeft = parseInt($tt.css("left"), 10),
            iconWidth = opts.anchor.width(),
            tipPosition = anchorLeft - ttLeft + (iconWidth / 4);

            // If the tooltip is too far to the right, make it point on the corner.
            if (tipPosition > ttWidth + ttPaddingLeft) {
                tipPosition = ttWidth + ttPaddingLeft;
            }

            // Apply the positioning to the tooltip tip.
            $tooltipPoint.css("left", tipPosition + "px");
        };

        var windowResizeHandler = function() {
            $tt.reposition();
        };

        $(window).resize(windowResizeHandler);

        $tt.reposition();

        return $tt;
    };

    return $.tooltip;
});

define('nodeDataTooltip', [
'jquery',
'underscore',
'internal/common/tooltip'],
function nodeDataTooltip($, _) {

    var existingTooltips = [],
    tooltipCount = 0,
    $tt,
    defaults = {
        content: "",
        style: "mini"
    };

    // Merge the default options with any data-tooltip-* options specified in markup
    var parseOptions = function($el) {
        var data = _.reduce($el.parents(), function(el, par) {
            return _.extend(el, $(par).data());
        }, $el.data());
        var opts = _.reduce(_.keys(data), function(opts, key) {
            if (key.substr(0, 7) === "tooltip") {
                opts[key.substr(7).toLowerCase()] = data[key];
            }
            return opts;
        }, _.clone(defaults));

        if (opts.offsetleft || opts.offsettop) {
            opts.offset = [parseInt(opts.offsetleft, 10), parseInt(opts.offsettop, 10)];
        }

        if (opts.anchor === "this") {
            opts.anchor = $el;
        }

        return opts;
    };

    var showTooltipFor = function($el) {
        hideTooltip();
        if (!$el.data('existingTooltip')) {
            $tt = $.tooltip(parseOptions($el));
            $tt.prepend($el.data("tooltip"));
            if ($el.data('tooltip-title')) {
                $tt.prepend("<h6>" + $el.data('tooltip-title') + "</h6>");
            }
            existingTooltips[tooltipCount] = $tt;
            $el.data({
                existingTooltip: tooltipCount
            });
            tooltipCount++;
        } else {
            $tt = existingTooltips[$el.data('existingTooltip')];
        }
        $tt.addClass("active");
        $tt.show();
    };

    var hideTooltip = function() {
        if ($tt) {
            $tt.removeClass("active");
            $tt.hide();
        }
    };

    $(function() {
        $("body").on("mouseover", "*[data-tooltip]", function() {
            showTooltipFor($(this));
        }).on("mouseout", "*[data-tooltip]", function() {
            hideTooltip();
        });

        $("body").on("showTooltip", function(e, el) {
            showTooltipFor($(el));
        }).on("hideTooltip", function(e, el) {
            hideTooltip();
        });
    });

});

/**
* These classes are used both in the editor and on the user's site
* In edit mode, functionality is added to these classes in bldr.modules.js
* Therefore, this file should only contain SHARED methods
*/

define('internal/sitebuilder/common/webs.modules', [
'require',
'jquery',
'internal/sitebuilder/common/log',
'spine',
'internal/common/tooltip',
'nodeDataTooltip'
], function(require, $, log, Spine) {
    var Module = Spine.Controller.create({
        init: function(options) {
            this.data = options.data;
        },

        oneLoaded: function() {
            // modules should override this
        },

        // We're overriding Spine.Event.trigger so that buggy callbacks don't mess up the call stack
        trigger: function() {
            var args = Spine.makeArray(arguments);
            var ev = args.shift();

            var list, calls, i, l;
            if (!(calls = this.hasOwnProperty("_callbacks") && this._callbacks)) 
                return false;
            if (!(list = this._callbacks[ev])) 
                return false;

            for (i = 0, l = list.length; i < l; i++) {
                try {
                    if (list[i].apply(this, args) === false)
                        return false;
                } catch (error) {
                    log.trigger("Modules", "error", "Module:" + this.parent.slug + ", Event:" + ev, error);
                }
            }

            return true;
        }
    }),
    CustomModule = Module.create(),
    CompositeModule = CustomModule.create(),
    WidgetModule = Module.create(),
    IframeModule = Module.create(),
    AppModule = Module.create();

    // Class Methods
    Module.extend({
        styles: []
    });

    CompositeModule.include({
        /**
        			 * Subclasses of CompositeModule SHOULD override this method if there is
        			 * any submodule *SLUG* where data.*SLUG* is not the module data for the submodule,
        			 * it should return an array of objects describing each submodule, e.g.:
        			 * [
        			 *   {
        			 *     name: "unique identifier (within the scope of this composite module) for the submodule",
        			 *     el: "root container for the submodule",
        			 *     slug: "name of module class",
        			 *     data: {data: "for", the: "submodule"},
        			 *   },
        			 *   {
        			 *     ...
        			 *   },
        			 * ]
        			 */
        describeSubmodules: function() {
            var self = this,
            $top = self.el.children(".webs-composite-module").eq(0),
            submoduleContainers = $top.find(".webs-submodule"),
            submoduleDescriptions = [];
            $.each(submoduleContainers, function(index) {
                var container = submoduleContainers.eq(index);
                if (container.parents(".webs-composite-module")[0] === $top[0]) {
                    var slug = container.attr("webs-submodule-slug");
                    submoduleDescriptions.push({
                        name: slug,
                        el: container,
                        slug: container.attr("webs-submodule-slug"),
                        data: self.data[slug]
                    });
                }
            });
            return submoduleDescriptions;
        },


        bindSubmodules: function() {
            var self = this,
            descriptions = this.describeSubmodules(),
            loadedDeferreds = [];

            self.submoduleInstances = {};
            require(['internal/sitebuilder/common/ModuleClassLoader'], function(ModuleClassLoader) {
                $.each(descriptions, function(i) {
                    var desc = descriptions[i];
                    var deferred = new $.Deferred();
                    loadedDeferreds.push(deferred);
                    ModuleClassLoader.create(desc.slug, {
                        el: desc.el,
                        data: desc.data
                    }).done(function(submodule) {
                        self.submoduleInstances[desc.name] = submodule;
                        desc.el.data("controller", submodule);
                        deferred.resolve();
                    });
                });
            });
            return $.when.apply($, loadedDeferreds);
        },

        oneLoaded: function() {
            this.bindSubmodules().done($.proxy(function() {
                $.each(this.submoduleInstances, function(name, submodule) {
                    submodule.oneLoaded();
                });
            }, this));
        }
    });

    webs.modules = {
        Module: Module,
        CustomModule: CustomModule,
        IframeModule: IframeModule,
        WidgetModule: WidgetModule,
        AppModule: AppModule,
        CompositeModule: CompositeModule
    };

    return webs.modules;
});

define('internal/sitebuilder/common/ModuleClassLoader', [
'jquery',
'moduleVersions',
'internal/sitebuilder/common/log',
'spine',
'internal/sitebuilder/common/webs.modules',
'internal/sitebuilder/common/creativeCommons'
], function($, moduleVersions, log, Spine, webs_modules) {
    var MODULE_LOAD_TIMEOUT = 30000;
    var RESOLVED_PROMISE = $.Deferred().resolve().promise();

    var ModuleClassLoader = Spine.Class.create({
        init: function(options) {
            this.MODULES_URL = options.MODULES_URL;
            this.MODULES_VERSION = options.MODULES_VERSION;

            /**
            			* Map of module slugs to classes
            			*/
            this.classes = {};

            /**
            			* Map from module slugs to a promises for when it loads
            			*/
            this.modulePromises = {};

            /**
            			 * Map from module slugs to promises for when the JS file loads
            			 */
            this.moduleJSPromises = {};

        },

        getClass: function(moduleSlug) {
            return this.classes[moduleSlug];
        },

        /**
        		* Called from the module definition file. Each module type is only registered once.
        		*/
        register: function(moduleSlug, include, extend) {
            var superClass;
            extend.slug = moduleSlug;

            if (extend.iframe) {
                superClass = webs_modules.IframeModule;
            } else if (extend.isWidget) {
                superClass = webs_modules.WidgetModule;
            } else if (extend.submodules) {
                superClass = webs_modules.CompositeModule;
            } else {
                superClass = webs_modules.CustomModule;
            }

            this.classes[moduleSlug] = superClass.create(include, extend);
            if (!this.moduleJSPromises[moduleSlug]) {
                this.moduleJSPromises[moduleSlug] = new $.Deferred();
            }
            this.moduleJSPromises[moduleSlug].resolve();
        },

        /**
        		 * This create method is used when we KNOW that we have already loaded the module
        		 * @param moduleClass
        		 * @param options
        		 * @param deferred
        		 * @returns {*}
        		 * @private
        		 */
        _create: function(moduleClass, options, deferred) {
            var moduleSlug = moduleClass.slug,
            proto = $.extend({}, moduleClass),
            data = $.extend(true, {}, moduleClass.defaultData, options.data),
            style = moduleClass.styles[data._style] || moduleClass.defaultStyle;

            // TODO: HACK for buckets. jQuery deep extend also does arrays :(
            if (data.bucketContents && options.data && options.data.bucketContents) {
                data.bucketContents = options.data.bucketContents;
                // Hack for SITEBUILDER-2017 and SITEBUILDER-2025
                // Sometimes the image values were stored as NaN which caused image to come back as null
                // So we need to default it
                for (var i = 0, len = data.cols.length; i < len; i++) {
                    if (!data.cols[i].image) {
                        log.error("An image within buckets was null");
                        data.cols[i].image = moduleClass.defaultData.cols[0].image;
                    }
                }
            }
            if (moduleSlug == "contact_form" && options.data && options.data.fields) 
                data.fields = options.data.fields;

            var obj = this.getClassForStyle(moduleClass, style).init({
                el: options.container || options.el,
                data: data
            });

            deferred.resolve(obj);

            this.trigger('created', obj);

            return obj;
        },

        /**
        		 * Essentially the same as create, but for appModules.
        		 * Sidebar modules are different. We don't call "load" on them.
        		 */
        createAppModule: function(moduleSlug, options) {
            var moduleClass = this.getClass(moduleSlug),
            deferred = $.Deferred();

            if (!moduleClass) {
                // If module is not registered, register a fake one and log an error
                moduleClass = this.classes[moduleSlug] = webs_modules.AppModule.create({
                    id: moduleSlug.substring(12)
                });
                log.error("Unable to load appmodule", moduleSlug);
            }

            this._create(moduleClass, options, deferred);
            return deferred.promise();
        },

        create: function(moduleSlug, options) {
            if (moduleSlug.indexOf('app-sidebar-') === 0) 
                return this.createAppModule(moduleSlug, options);

            var self = this,
            moduleClass = this.getClass(moduleSlug),
            deferred = $.Deferred();

            self.load(moduleSlug).done(function() {
                self._create(self.getClass(moduleSlug), options, deferred);
            }).fail(deferred.reject);

            return deferred.promise();
        },

        /**
        		* Given a module class and a style, return the proper class to init
        		* Styles have their own subclasses of the moduleClass, because they can add methods
        		* TODO: This should probably move to Module.getClassForStyle
        		*/
        getClassForStyle: function(moduleClass, style) {
            if (style) {
                /* jshint ignore:start */
                // Collect all styles (because styles can inherit from other styles)
                var styles = [];
                do {
                    styles.push(style);
                }
                while (style = moduleClass.styles[style.inherit]);
                /* jshint ignore:end */

                // Iterate through the styles in reverse, so that the base style is first, and the specified style is last
                var superClass = moduleClass,
                subClass,
                s;
                for (var i = styles.length - 1; i >= 0; i--) {
                    s = styles[i];
                    subClass = s.klass;
                    if (!subClass) {
                        delete s.defaultStyle;

                        if (s.global.js) {
                            // Extend the super class
                            var include = {}, extend = {};
                            s.global.js(include, extend);
                            s.klass = subClass = superClass.create(include, extend);
                        } else {
                            // This happens when a style doesn't change the JS, but does change the CSS
                            // No JS to add. Just use the super class
                            s.klass = subClass = superClass;
                        }
                    }
                    superClass = subClass;
                }

                return superClass;
            } else {
                // How!?!?
                // TODO: In the future, not all modules will need a style
                if (log) 
                    log.trigger("Modules", "info", 'No style found for ' + moduleClass.slug + ' module!', moduleClass);
                return moduleClass;
            }
        },

        getModuleSlugFromUrl: function(url) {
            var urlParts = url.split("/");
            var moduleSlug;
            if (urlParts[2] == "modules") {
                moduleSlug = urlParts[3];
            } else {
                moduleSlug = urlParts[3] + "_" + urlParts[urlParts.length - 1].replace(".less", "");
            }
            return moduleSlug;
        },

        getModuleVersion: function(slug) {
            var version;
            if (moduleVersions && slug in moduleVersions) {
                version = "v" + moduleVersions[slug];
            } else {
                log.warn("WARNING: Retrieving unversioned asset for module " + slug);
                version = this.MODULES_VERSION;
            }
            return version;
        },

        getModuleAssetURL: function(slug, path) {
            return this.MODULES_URL + slug + '/' + this.getModuleVersion(slug) + '/' + path;
        },

        cssPath: function(slug) {
            return this.getModuleAssetURL(slug, 'view.packaged.less');
        },

        /**
        		* Load a module class from the backend
        		*/
        load: function(slug) {
            if (this.modulePromises[slug]) 
                return this.modulePromises[slug];

            var self = this,
            cssLoadedPromise = this.loadCss(this.cssPath(slug)),
            dependenciesLoadedPromise = $.Deferred();
            this.modulePromises[slug] = $.Deferred();

            if (!this.moduleJSPromises[slug]) {
                this.moduleJSPromises[slug] = new $.Deferred();
            }

            this.loadJs(slug);

            this.moduleJSPromises[slug].done(function() {
                self.loadModuleDependencies(slug).done(dependenciesLoadedPromise.resolve).fail(dependenciesLoadedPromise.reject);
            }).fail(dependenciesLoadedPromise.reject);

            // Module is loaded when css and js are all loaded.
            $.when(cssLoadedPromise, dependenciesLoadedPromise)
            .done(self.modulePromises[slug].resolve)
            .fail(self.modulePromises[slug].reject);

            // Trigger error callbacks if not laoded quickly.
            setTimeout(this.modulePromises[slug].reject, MODULE_LOAD_TIMEOUT);

            return this.modulePromises[slug];
        },

        loadAll: function(types) {
            var deferredBulkLoad = $.Deferred(),
            typePromises = [];
            for (var i = 0, len = types.length; i < len; i++) {
                typePromises.push(this.load(types[i]));
            }
            $.when.apply($, typePromises).done(deferredBulkLoad.resolve).fail(deferredBulkLoad.reject);
            return deferredBulkLoad.promise();
        },

        loadCss: function(url) {
            // In view mode, all the CSS is already loaded
            return RESOLVED_PROMISE;
        },

        loadJs: function(moduleSlug) {
            var deferred = $.Deferred();
            require([this.getModuleAssetURL(moduleSlug, moduleSlug + '_view.js')], null);
            return deferred;
        },

        /* Loads theme style css and returns a list of theme style js files */
        themeStyleFileList: function(moduleSlug) {
            // Per-Theme Module Styles
            var self = this,
            moduleClass = this.getClass(moduleSlug),
            theme = webs.theme,
            files = [],
            cssPromises = [];
            if (theme.moduleStyles && theme.moduleStyles[moduleSlug]) {
                $.each(theme.moduleStyles[moduleSlug], function(styleSlug, def) {
                    if (log) 
                        log.trigger("Modules", "debug", 'Loading theme style ' + styleSlug + ' for ' + moduleSlug);
                    moduleClass.styles[styleSlug] = def;
                    def.slug = styleSlug;
                    if (def.global.js) 
                        files.push(theme.url + "/" + def.global.js);
                    if (def.global.css) 
                        cssPromises.push(self.loadCss(theme.url + '/' + def.global.css));

                    // Set this as the default style
                    if (def['default']) 
                        moduleClass.defaultStyle = def;
                });
            }
            return [files, $.when.apply($, cssPromises)];
        },

        /* A list of module names the given module depends on */
        moduleDependencyList: function(moduleSlug) {
            var submodules = [],
            moduleClass = this.getClass(moduleSlug);

            // Module js dependencies
            if (moduleClass.submodules) {
                $.each(moduleClass.submodules, function(slug, sm) {
                    submodules.push(slug);
                });
            }

            return submodules;
        },

        shouldConsolidateAssets: function(moduleSlug) {
            return moduleSlug.indexOf("zumba") === - 1 && moduleSlug.indexOf("app-sidebar") === - 1;
        },

        /* Loads both theme styles and module dependencies for the given module. */
        loadModuleDependencies: function(moduleSlug) {
            var self = this,
            dependencies = this.themeStyleFileList(moduleSlug),
            jsFiles = dependencies[0],
            cssPromise = dependencies[1],
            modules = this.moduleDependencyList(moduleSlug),
            total = jsFiles.length + modules.length,
            loaded = 0;

            if (total === 0) {
                return cssPromise;
            } else {
                var deferred = $.Deferred(),
                allRequiredPromises = [cssPromise];
                $.each(modules, function(index, moduleSlug) {
                    allRequiredPromises.push(self.load(moduleSlug));
                });
                $.each(jsFiles, function(index, file) {
                    var jsPromise = $.Deferred();
                    allRequiredPromises.push(jsPromise);
                    require([script(file)], jsPromise.resolve);
                });
                $.when.apply($, allRequiredPromises).done(deferred.resolve).fail(deferred.reject);
                return deferred.promise();
            }
        }

    });
    ModuleClassLoader.include(Spine.Events);

    var mcl = ModuleClassLoader.init({
        MODULES_URL: webs.props.dynamicAssetServer + '/s/modules/',
        MODULES_VERSION: webs.props.modulesVersion
    });

    var deferredModules = $.Deferred();
    mcl.renderedModulesPromise = deferredModules.promise();
    $(function() {
        $.when.apply($, webs.renderedModulesPromises || []).done(deferredModules.resolve).fail(deferredModules.reject);
    });

    webs_modules.ModuleClassLoader = mcl;

    return mcl;
});


/* jshint ignore:start */
/*
 Rangy, a cross-browser JavaScript range and selection library
 http://code.google.com/p/rangy/

 Copyright 2012, Tim Down
 Licensed under the MIT license.
 Version: 1.2.3
 Build date: 26 February 2012
*/
window.rangy = function() {
    function l(p, u) {
        var w = typeof p[u];
        return w == "function"||!!(w == "object" && p[u]) || w == "unknown"
    }
    function K(p, u) {
        return !!(typeof p[u] == "object" && p[u])
    }
    function H(p, u) {
        return typeof p[u] != "undefined"
    }
    function I(p) {
        return function(u, w) {
            for (var B = w.length; B--;)
                if (!p(u, w[B]))
                    return false;
            return true
        }
    }
    function z(p) {
        return p && A(p, x) && v(p, t)
    }
    function C(p) {
        window.alert("Rangy not supported in your browser. Reason: " + p);
        c.initialized = true;
        c.supported = false
    }
    function N() {
        if (!c.initialized) {
            var p,
            u = false, w = false;
            if (l(document, "createRange")) {
                p = document.createRange();
                if (A(p, n) && v(p, i))
                    u = true;
                p.detach()
            }
            if ((p = K(document, "body") ? document.body : document.getElementsByTagName("body")[0]) && l(p, "createTextRange")) {
                p = p.createTextRange();
                if (z(p))
                    w = true
            }
            !u&&!w && C("Neither Range nor TextRange are implemented");
            c.initialized = true;
            c.features = {
                implementsDomRange: u,
                implementsTextRange: w
            };
            u = k.concat(f);
            w = 0;
            for (p = u.length; w < p; ++w)
                try {
                    u[w](c)
                } catch (B) {
                K(window, "console") && l(window.console, "log") && window.console.log("Init listener threw an exception. Continuing.",
                B)
            }
        }
    }
    function O(p) {
        this.name = p;
        this.supported = this.initialized = false
    }
    var i = ["startContainer", "startOffset", "endContainer", "endOffset", "collapsed", "commonAncestorContainer", "START_TO_START", "START_TO_END", "END_TO_START", "END_TO_END"], n = ["setStart", "setStartBefore", "setStartAfter", "setEnd", "setEndBefore", "setEndAfter", "collapse", "selectNode", "selectNodeContents", "compareBoundaryPoints", "deleteContents", "extractContents", "cloneContents", "insertNode", "surroundContents", "cloneRange", "toString", "detach"],
    t = ["boundingHeight", "boundingLeft", "boundingTop", "boundingWidth", "htmlText", "text"], x = ["collapse", "compareEndPoints", "duplicate", "getBookmark", "moveToBookmark", "moveToElementText", "parentElement", "pasteHTML", "select", "setEndPoint", "getBoundingClientRect"], A = I(l), q = I(K), v = I(H), c = {
        version: "1.2.3",
        initialized: false,
        supported: true,
        util: {
            isHostMethod: l,
            isHostObject: K,
            isHostProperty: H,
            areHostMethods: A,
            areHostObjects: q,
            areHostProperties: v,
            isTextRange: z
        },
        features: {},
        modules: {},
        config: {
            alertOnWarn: false,
            preferTextRange: false
        }
    };
    c.fail = C;
    c.warn = function(p) {
        p = "Rangy warning: " + p;
        if (c.config.alertOnWarn)
            window.alert(p);
        else 
            typeof window.console != "undefined" && typeof window.console.log != "undefined" && window.console.log(p)
    };
    if ({}.hasOwnProperty)
        c.util.extend = function(p, u) {
            for (var w in u)
                if (u.hasOwnProperty(w))
                    p[w] = u[w]
                };
            else 
                C("hasOwnProperty not supported");
    var f = [], k = [];
    c.init = N;
    c.addInitListener = function(p) {
        c.initialized ? p(c) : f.push(p)
    };
    var r = [];
    c.addCreateMissingNativeApiListener = function(p) {
        r.push(p)
    };
    c.createMissingNativeApi =
    function(p) {
        p = p || window;
        N();
        for (var u = 0, w = r.length; u < w; ++u)
            r[u](p)
    };
    O.prototype.fail = function(p) {
        this.initialized = true;
        this.supported = false;
        throw Error("Module '" + this.name + "' failed to load: " + p);
    };
    O.prototype.warn = function(p) {
        c.warn("Module " + this.name + ": " + p)
    };
    O.prototype.createError = function(p) {
        return Error("Error in Rangy " + this.name + " module: " + p)
    };
    c.createModule = function(p, u) {
        var w = new O(p);
        c.modules[p] = w;
        k.push(function(B) {
            u(B, w);
            w.initialized = true;
            w.supported = true
        })
    };
    c.requireModules = function(p) {
        for (var u =
        0, w = p.length, B, V; u < w; ++u) {
            V = p[u];
            B = c.modules[V];
            if (!B ||!(B instanceof O))
                throw Error("Module '" + V + "' not found");
            if (!B.supported)
                throw Error("Module '" + V + "' not supported");
        }
    };
    var L = false;
    q = function() {
        if (!L) {
            L = true;
            c.initialized || N()
        }
    };
    if (typeof window == "undefined")
        C("No window found");
    else if (typeof document == "undefined")
        C("No document found");
    else {
        l(document, "addEventListener") && document.addEventListener("DOMContentLoaded", q, false);
        if (l(window, "addEventListener"))
            window.addEventListener("load",
            q, false);
        else 
            l(window, "attachEvent") ? window.attachEvent("onload", q) : C("Window does not have required addEventListener or attachEvent method");
        return c
    }
}();
rangy.createModule("DomUtil", function(l, K) {
    function H(c) {
        for (var f = 0; c = c.previousSibling;)
            f++;
        return f
    }
    function I(c, f) {
        var k = [], r;
        for (r = c; r; r = r.parentNode)
            k.push(r);
        for (r = f; r; r = r.parentNode)
            if (v(k, r))
                return r;
        return null
    }
    function z(c, f, k) {
        for (k = k ? c : c.parentNode; k;) {
            c = k.parentNode;
            if (c === f)
                return k;
            k = c
        }
        return null
    }
    function C(c) {
        c = c.nodeType;
        return c == 3 || c == 4 || c == 8
    }
    function N(c, f) {
        var k = f.nextSibling, r = f.parentNode;
        k ? r.insertBefore(c, k) : r.appendChild(c);
        return c
    }
    function O(c) {
        if (c.nodeType == 9)
            return c;
        else if (typeof c.ownerDocument != "undefined")
            return c.ownerDocument;
        else if (typeof c.document != "undefined")
            return c.document;
        else if (c.parentNode)
            return O(c.parentNode);
        else 
            throw Error("getDocument: no document found for node");
    }
    function i(c) {
        if (!c)
            return "[No node]";
        return C(c) ? '"' + c.data + '"' : c.nodeType == 1 ? "<" + c.nodeName + (c.id ? ' id="' + c.id + '"' : "") + ">[" + c.childNodes.length + "]" : c.nodeName
    }
    function n(c) {
        this._next = this.root = c
    }
    function t(c, f) {
        this.node = c;
        this.offset = f
    }
    function x(c) {
        this.code = this[c];
        this.codeName = c;
        this.message = "DOMException: " + this.codeName
    }
    var A = l.util;
    A.areHostMethods(document, ["createDocumentFragment", "createElement", "createTextNode"]) || K.fail("document missing a Node creation method");
    A.isHostMethod(document, "getElementsByTagName") || K.fail("document missing getElementsByTagName method");
    var q = document.createElement("div");
    A.areHostMethods(q, ["insertBefore", "appendChild", "cloneNode"]) || K.fail("Incomplete Element implementation");
    A.isHostProperty(q, "innerHTML") || K.fail("Element is missing innerHTML property");
    q = document.createTextNode("test");
    A.areHostMethods(q, ["splitText", "deleteData", "insertData", "appendData", "cloneNode"]) || K.fail("Incomplete Text Node implementation");
    var v = function(c, f) {
        for (var k = c.length; k--;)
            if (c[k] === f)
                return true;
        return false
    };
    n.prototype = {
        _current: null,
        hasNext: function() {
            return !!this._next
        },
        next: function() {
            var c = this._current = this._next, f;
            if (this._current)
                if (f = c.firstChild)
                    this._next = f;
                else {
                    for (f = null; c !== this.root&&!(f = c.nextSibling);)
                        c = c.parentNode;
                        this._next = f
                }
            return this._current
        },
        detach: function() {
            this._current = this._next = this.root = null
        }
    };
    t.prototype = {
        equals: function(c) {
            return this.node === c.node & this.offset == c.offset
        },
        inspect: function() {
            return "[DomPosition(" + i(this.node) + ":" + this.offset + ")]"
        }
    };
    x.prototype = {
        INDEX_SIZE_ERR: 1,
        HIERARCHY_REQUEST_ERR: 3,
        WRONG_DOCUMENT_ERR: 4,
        NO_MODIFICATION_ALLOWED_ERR: 7,
        NOT_FOUND_ERR: 8,
        NOT_SUPPORTED_ERR: 9,
        INVALID_STATE_ERR: 11
    };
    x.prototype.toString = function() {
        return this.message
    };
    l.dom = {
        arrayContains: v,
        isHtmlNamespace: function(c) {
            var f;
            return typeof c.namespaceURI ==
            "undefined" || (f = c.namespaceURI) === null || f == "http://www.w3.org/1999/xhtml"
        },
        parentElement: function(c) {
            c = c.parentNode;
            return c.nodeType == 1 ? c : null
        },
        getNodeIndex: H,
        getNodeLength: function(c) {
            var f;
            return C(c) ? c.length : (f = c.childNodes) ? f.length : 0
        },
        getCommonAncestor: I,
        isAncestorOf: function(c, f, k) {
            for (f = k ? f : f.parentNode; f;)
                if (f === c)
                    return true;
                else 
                    f = f.parentNode;
            return false
        },
        getClosestAncestorIn: z,
        isCharacterDataNode: C,
        insertAfter: N,
        splitDataNode: function(c, f) {
            var k = c.cloneNode(false);
            k.deleteData(0, f);
            c.deleteData(f, c.length - f);
            N(k, c);
            return k
        },
        getDocument: O,
        getWindow: function(c) {
            c = O(c);
            if (typeof c.defaultView != "undefined")
                return c.defaultView;
            else if (typeof c.parentWindow != "undefined")
                return c.parentWindow;
            else 
                throw Error("Cannot get a window object for node");
        },
        getIframeWindow: function(c) {
            if (typeof c.contentWindow != "undefined")
                return c.contentWindow;
            else if (typeof c.contentDocument != "undefined")
                return c.contentDocument.defaultView;
            else 
                throw Error("getIframeWindow: No Window object found for iframe element");
        },
        getIframeDocument: function(c) {
            if (typeof c.contentDocument != "undefined")
                return c.contentDocument;
            else if (typeof c.contentWindow != "undefined")
                return c.contentWindow.document;
            else 
                throw Error("getIframeWindow: No Document object found for iframe element");
        },
        getBody: function(c) {
            return A.isHostObject(c, "body") ? c.body : c.getElementsByTagName("body")[0]
        },
        getRootContainer: function(c) {
            for (var f; f = c.parentNode;)
                c = f;
            return c
        },
        comparePoints: function(c, f, k, r) {
            var L;
            if (c == k)
                return f === r ? 0 : f < r?-1 : 1;
            else if (L = z(k,
            c, true))
                return f <= H(L)?-1 : 1;
            else if (L = z(c, k, true))
                return H(L) < r?-1 : 1;
            else {
                f = I(c, k);
                c = c === f ? f : z(c, f, true);
                k = k === f ? f : z(k, f, true);
                if (c === k)
                    throw Error("comparePoints got to case 4 and childA and childB are the same!");
                else {
                    for (f = f.firstChild; f;) {
                        if (f === c)
                            return - 1;
                        else if (f === k)
                            return 1;
                        f = f.nextSibling
                    }
                    throw Error("Should not be here!");
                }
            }
        },
        inspectNode: i,
        fragmentFromNodeChildren: function(c) {
            for (var f = O(c).createDocumentFragment(), k; k = c.firstChild;)
                f.appendChild(k);
            return f
        },
        createIterator: function(c) {
            return new n(c)
        },
        DomPosition: t
    };
    l.DOMException = x
});
rangy.createModule("DomRange", function(l) {
    function K(a, e) {
        return a.nodeType != 3 && (g.isAncestorOf(a, e.startContainer, true) || g.isAncestorOf(a, e.endContainer, true))
    }
    function H(a) {
        return g.getDocument(a.startContainer)
    }
    function I(a, e, j) {
        if (e = a._listeners[e])
            for (var o = 0, E = e.length; o < E; ++o)
                e[o].call(a, {
                    target: a,
                    args: j
                })
    }
    function z(a) {
        return new Z(a.parentNode, g.getNodeIndex(a))
    }
    function C(a) {
        return new Z(a.parentNode, g.getNodeIndex(a) + 1)
    }
    function N(a, e, j) {
        var o = a.nodeType == 11 ? a.firstChild: a;
        if (g.isCharacterDataNode(e))
            j ==
            e.length ? g.insertAfter(a, e) : e.parentNode.insertBefore(a, j == 0 ? e : g.splitDataNode(e, j));
        else 
            j >= e.childNodes.length ? e.appendChild(a) : e.insertBefore(a, e.childNodes[j]);
        return o
    }
    function O(a) {
        for (var e, j, o = H(a.range).createDocumentFragment(); j = a.next();) {
            e = a.isPartiallySelectedSubtree();
            j = j.cloneNode(!e);
            if (e) {
                e = a.getSubtreeIterator();
                j.appendChild(O(e));
                e.detach(true)
            }
            if (j.nodeType == 10)
                throw new S("HIERARCHY_REQUEST_ERR");
            o.appendChild(j)
        }
        return o
    }
    function i(a, e, j) {
        var o, E;
        for (j = j || {
            stop: false
        }; o = a.next();)
            if (a.isPartiallySelectedSubtree())
                if (e(o) ===
                false) {
                    j.stop = true;
                    return 
                } else {
                    o = a.getSubtreeIterator();
                    i(o, e, j);
                    o.detach(true);
                    if (j.stop)
                        return 
                } else 
                    for (o = g.createIterator(o); E = o.next();)
                        if (e(E) === false) {
                            j.stop = true;
                            return 
                        }
    }
    function n(a) {
        for (var e; a.next();)
            if (a.isPartiallySelectedSubtree()) {
                e = a.getSubtreeIterator();
                n(e);
                e.detach(true)
            } else 
                a.remove()
    }
    function t(a) {
        for (var e, j = H(a.range).createDocumentFragment(), o; e = a.next();) {
            if (a.isPartiallySelectedSubtree()) {
                e = e.cloneNode(false);
                o = a.getSubtreeIterator();
                e.appendChild(t(o));
                o.detach(true)
            } else 
                a.remove();
            if (e.nodeType == 10)
                throw new S("HIERARCHY_REQUEST_ERR");
            j.appendChild(e)
        }
        return j
    }
    function x(a, e, j) {
        var o=!!(e && e.length), E, T=!!j;
        if (o)
            E = RegExp("^(" + e.join("|") + ")$");
        var m = [];
        i(new q(a, false), function(s) {
            if ((!o || E.test(s.nodeType)) && (!T || j(s)))
                m.push(s)
        });
        return m
    }
    function A(a) {
        return "[" + (typeof a.getName == "undefined" ? "Range" : a.getName()) + "(" + g.inspectNode(a.startContainer) + ":" + a.startOffset + ", " + g.inspectNode(a.endContainer) + ":" + a.endOffset + ")]"
    }
    function q(a, e) {
        this.range = a;
        this.clonePartiallySelectedTextNodes =
        e;
        if (!a.collapsed) {
            this.sc = a.startContainer;
            this.so = a.startOffset;
            this.ec = a.endContainer;
            this.eo = a.endOffset;
            var j = a.commonAncestorContainer;
            if (this.sc === this.ec && g.isCharacterDataNode(this.sc)) {
                this.isSingleCharacterDataNode = true;
                this._first = this._last = this._next = this.sc
            } else {
                this._first = this._next = this.sc === j&&!g.isCharacterDataNode(this.sc) ? this.sc.childNodes[this.so] : g.getClosestAncestorIn(this.sc, j, true);
                this._last = this.ec === j&&!g.isCharacterDataNode(this.ec) ? this.ec.childNodes[this.eo - 1] : g.getClosestAncestorIn(this.ec,
                j, true)
            }
        }
    }
    function v(a) {
        this.code = this[a];
        this.codeName = a;
        this.message = "RangeException: " + this.codeName
    }
    function c(a, e, j) {
        this.nodes = x(a, e, j);
        this._next = this.nodes[0];
        this._position = 0
    }
    function f(a) {
        return function(e, j) {
            for (var o, E = j ? e : e.parentNode; E;) {
                o = E.nodeType;
                if (g.arrayContains(a, o))
                    return E;
                E = E.parentNode
            }
            return null
        }
    }
    function k(a, e) {
        if (G(a, e))
            throw new v("INVALID_NODE_TYPE_ERR");
    }
    function r(a) {
        if (!a.startContainer)
            throw new S("INVALID_STATE_ERR");
    }
    function L(a, e) {
        if (!g.arrayContains(e, a.nodeType))
            throw new v("INVALID_NODE_TYPE_ERR");
    }
    function p(a, e) {
        if (e < 0 || e > (g.isCharacterDataNode(a) ? a.length : a.childNodes.length))
            throw new S("INDEX_SIZE_ERR");
    }
    function u(a, e) {
        if (h(a, true) !== h(e, true))
            throw new S("WRONG_DOCUMENT_ERR");
    }
    function w(a) {
        if (D(a, true))
            throw new S("NO_MODIFICATION_ALLOWED_ERR");
    }
    function B(a, e) {
        if (!a)
            throw new S(e);
    }
    function V(a) {
        return !!a.startContainer&&!!a.endContainer&&!(!g.arrayContains(ba, a.startContainer.nodeType)&&!h(a.startContainer, true))&&!(!g.arrayContains(ba, a.endContainer.nodeType)&&!h(a.endContainer,
        true)) && a.startOffset <= (g.isCharacterDataNode(a.startContainer) ? a.startContainer.length : a.startContainer.childNodes.length) && a.endOffset <= (g.isCharacterDataNode(a.endContainer) ? a.endContainer.length : a.endContainer.childNodes.length)
    }
    function J(a) {
        r(a);
        if (!V(a))
            throw Error("Range error: Range is no longer valid after DOM mutation (" + a.inspect() + ")");
    }
    function ca() {}
    function Y(a) {
        a.START_TO_START = ia;
        a.START_TO_END = la;
        a.END_TO_END = ra;
        a.END_TO_START = ma;
        a.NODE_BEFORE = na;
        a.NODE_AFTER = oa;
        a.NODE_BEFORE_AND_AFTER =
        pa;
        a.NODE_INSIDE = ja
    }
    function W(a) {
        Y(a);
        Y(a.prototype)
    }
    function da(a, e) {
        return function() {
            J(this);
            var j = this.startContainer, o = this.startOffset, E = this.commonAncestorContainer, T = new q(this, true);
            if (j !== E) {
                j = g.getClosestAncestorIn(j, E, true);
                o = C(j);
                j = o.node;
                o = o.offset
            }
            i(T, w);
            T.reset();
            E = a(T);
            T.detach();
            e(this, j, o, j, o);
            return E
        }
    }
    function fa(a, e, j) {
        function o(m, s) {
            return function(y) {
                r(this);
                L(y, $);
                L(d(y), ba);
                y = (m ? z : C)(y);
                (s ? E : T)(this, y.node, y.offset)
            }
        }
        function E(m, s, y) {
            var F = m.endContainer, Q = m.endOffset;
            if (s !== m.startContainer || y !== m.startOffset) {
                if (d(s) != d(F) || g.comparePoints(s, y, F, Q) == 1) {
                    F = s;
                    Q = y
                }
                e(m, s, y, F, Q)
            }
        }
        function T(m, s, y) {
            var F = m.startContainer, Q = m.startOffset;
            if (s !== m.endContainer || y !== m.endOffset) {
                if (d(s) != d(F) || g.comparePoints(s, y, F, Q)==-1) {
                    F = s;
                    Q = y
                }
                e(m, F, Q, s, y)
            }
        }
        a.prototype = new ca;
        l.util.extend(a.prototype, {
            setStart: function(m, s) {
                r(this);
                k(m, true);
                p(m, s);
                E(this, m, s)
            },
            setEnd: function(m, s) {
                r(this);
                k(m, true);
                p(m, s);
                T(this, m, s)
            },
            setStartBefore: o(true, true),
            setStartAfter: o(false, true),
            setEndBefore: o(true,
            false),
            setEndAfter: o(false, false),
            collapse: function(m) {
                J(this);
                m ? e(this, this.startContainer, this.startOffset, this.startContainer, this.startOffset) : e(this, this.endContainer, this.endOffset, this.endContainer, this.endOffset)
            },
            selectNodeContents: function(m) {
                r(this);
                k(m, true);
                e(this, m, 0, m, g.getNodeLength(m))
            },
            selectNode: function(m) {
                r(this);
                k(m, false);
                L(m, $);
                var s = z(m);
                m = C(m);
                e(this, s.node, s.offset, m.node, m.offset)
            },
            extractContents: da(t, e),
            deleteContents: da(n, e),
            canSurroundContents: function() {
                J(this);
                w(this.startContainer);
                w(this.endContainer);
                var m = new q(this, true), s = m._first && K(m._first, this) || m._last && K(m._last, this);
                m.detach();
                return !s
            },
            detach: function() {
                j(this)
            },
            splitBoundaries: function() {
                J(this);
                var m = this.startContainer, s = this.startOffset, y = this.endContainer, F = this.endOffset, Q = m === y;
                g.isCharacterDataNode(y) && F > 0 && F < y.length && g.splitDataNode(y, F);
                if (g.isCharacterDataNode(m) && s > 0 && s < m.length) {
                    m = g.splitDataNode(m, s);
                    if (Q) {
                        F -= s;
                        y = m
                    } else 
                        y == m.parentNode && F >= g.getNodeIndex(m) && F++;
                    s = 0
                }
                e(this, m, s, y, F)
            },
            normalizeBoundaries: function() {
                J(this);
                var m = this.startContainer, s = this.startOffset, y = this.endContainer, F = this.endOffset, Q = function(U) {
                    var R = U.nextSibling;
                    if (R && R.nodeType == U.nodeType) {
                        y = U;
                        F = U.length;
                        U.appendData(R.data);
                        R.parentNode.removeChild(R)
                    }
                }, qa = function(U) {
                    var R = U.previousSibling;
                    if (R && R.nodeType == U.nodeType) {
                        m = U;
                        var sa = U.length;
                        s = R.length;
                        U.insertData(0, R.data);
                        R.parentNode.removeChild(R);
                        if (m == y) {
                            F += s;
                            y = m
                        } else if (y == U.parentNode) {
                            R = g.getNodeIndex(U);
                            if (F == R) {
                                y = U;
                                F = sa
                            } else 
                                F > R && F--
                        }
                    }
                }, ga = true;
                if (g.isCharacterDataNode(y))
                    y.length ==
                    F && Q(y);
                else {
                    if (F > 0)(ga = y.childNodes[F - 1]) && g.isCharacterDataNode(ga) && Q(ga);
                    ga=!this.collapsed
                }
                if (ga)
                    if (g.isCharacterDataNode(m))
                        s == 0 && qa(m);
                    else {
                        if (s < m.childNodes.length)(Q = m.childNodes[s]) && g.isCharacterDataNode(Q) && qa(Q)
                        } else {
                            m = y;
                            s = F
                        }
                        e(this, m, s, y, F)
                }, collapseToPoint: function(m, s) {
                r(this);
                k(m, true);
                p(m, s);
                if (m !== this.startContainer || s !== this.startOffset || m !== this.endContainer || s !== this.endOffset)
                    e(this, m, s, m, s)
            }
        });
        W(a)
    }
    function ea(a) {
        a.collapsed = a.startContainer === a.endContainer && a.startOffset ===
        a.endOffset;
        a.commonAncestorContainer = a.collapsed ? a.startContainer : g.getCommonAncestor(a.startContainer, a.endContainer)
    }
    function ha(a, e, j, o, E) {
        var T = a.startContainer !== e || a.startOffset !== j, m = a.endContainer !== o || a.endOffset !== E;
        a.startContainer = e;
        a.startOffset = j;
        a.endContainer = o;
        a.endOffset = E;
        ea(a);
        I(a, "boundarychange", {
            startMoved: T,
            endMoved: m
        })
    }
    function M(a) {
        this.startContainer = a;
        this.startOffset = 0;
        this.endContainer = a;
        this.endOffset = 0;
        this._listeners = {
            boundarychange: [],
            detach: []
        };
        ea(this)
    }
    l.requireModules(["DomUtil"]);
    var g = l.dom, Z = g.DomPosition, S = l.DOMException;
    q.prototype = {
        _current: null,
        _next: null,
        _first: null,
        _last: null,
        isSingleCharacterDataNode: false,
        reset: function() {
            this._current = null;
            this._next = this._first
        },
        hasNext: function() {
            return !!this._next
        },
        next: function() {
            var a = this._current = this._next;
            if (a) {
                this._next = a !== this._last ? a.nextSibling : null;
                if (g.isCharacterDataNode(a) && this.clonePartiallySelectedTextNodes) {
                    if (a === this.ec)(a = a.cloneNode(true)).deleteData(this.eo, a.length - this.eo);
                    if (this._current === this.sc)(a =
                    a.cloneNode(true)).deleteData(0, this.so)
                    }
            }
            return a
        }, remove: function() {
            var a = this._current, e, j;
            if (g.isCharacterDataNode(a) && (a === this.sc || a === this.ec)) {
                e = a === this.sc ? this.so : 0;
                j = a === this.ec ? this.eo : a.length;
                e != j && a.deleteData(e, j - e)
            } else 
                a.parentNode && a.parentNode.removeChild(a)
        }, isPartiallySelectedSubtree: function() {
            return K(this._current, this.range)
        }, getSubtreeIterator: function() {
            var a;
            if (this.isSingleCharacterDataNode) {
                a = this.range.cloneRange();
                a.collapse()
            } else {
                a = new M(H(this.range));
                var e = this._current,
                j = e, o = 0, E = e, T = g.getNodeLength(e);
                if (g.isAncestorOf(e, this.sc, true)) {
                    j = this.sc;
                    o = this.so
                }
                if (g.isAncestorOf(e, this.ec, true)) {
                    E = this.ec;
                    T = this.eo
                }
                ha(a, j, o, E, T)
            }
            return new q(a, this.clonePartiallySelectedTextNodes)
        }, detach: function(a) {
            a && this.range.detach();
            this.range = this._current = this._next = this._first = this._last = this.sc = this.so = this.ec = this.eo = null
        }
    };
    v.prototype = {
        BAD_BOUNDARYPOINTS_ERR: 1,
        INVALID_NODE_TYPE_ERR: 2
    };
    v.prototype.toString = function() {
        return this.message
    };
    c.prototype = {
        _current: null,
        hasNext: function() {
            return !!this._next
        },
        next: function() {
            this._current = this._next;
            this._next = this.nodes[++this._position];
            return this._current
        },
        detach: function() {
            this._current = this._next = this.nodes = null
        }
    };
    var $ = [1, 3, 4, 5, 7, 8, 10], ba = [2, 9, 11], aa = [1, 3, 4, 5, 7, 8, 10, 11], b = [1, 3, 4, 5, 7, 8], d = g.getRootContainer, h = f([9, 11]), D = f([5, 6, 10, 12]), G = f([6, 10, 12]), P = document.createElement("style"), X = false;
    try {
        P.innerHTML = "<b>x</b>";
        X = P.firstChild.nodeType == 3
    } catch (ta) {}
    l.features.htmlParsingConforms = X;
    var ka = ["startContainer", "startOffset", "endContainer", "endOffset",
    "collapsed", "commonAncestorContainer"], ia = 0, la = 1, ra = 2, ma = 3, na = 0, oa = 1, pa = 2, ja = 3;
    ca.prototype = {
        attachListener: function(a, e) {
            this._listeners[a].push(e)
        },
        compareBoundaryPoints: function(a, e) {
            J(this);
            u(this.startContainer, e.startContainer);
            var j = a == ma || a == ia ? "start": "end", o = a == la || a == ia ? "start": "end";
            return g.comparePoints(this[j + "Container"], this[j + "Offset"], e[o + "Container"], e[o + "Offset"])
        },
        insertNode: function(a) {
            J(this);
            L(a, aa);
            w(this.startContainer);
            if (g.isAncestorOf(a, this.startContainer, true))
                throw new S("HIERARCHY_REQUEST_ERR");
            this.setStartBefore(N(a, this.startContainer, this.startOffset))
        },
        cloneContents: function() {
            J(this);
            var a, e;
            if (this.collapsed)
                return H(this).createDocumentFragment();
            else {
                if (this.startContainer === this.endContainer && g.isCharacterDataNode(this.startContainer)) {
                    a = this.startContainer.cloneNode(true);
                    a.data = a.data.slice(this.startOffset, this.endOffset);
                    e = H(this).createDocumentFragment();
                    e.appendChild(a);
                    return e
                } else {
                    e = new q(this, true);
                    a = O(e);
                    e.detach()
                }
                return a
            }
        },
        canSurroundContents: function() {
            J(this);
            w(this.startContainer);
            w(this.endContainer);
            var a = new q(this, true), e = a._first && K(a._first, this) || a._last && K(a._last, this);
            a.detach();
            return !e
        },
        surroundContents: function(a) {
            L(a, b);
            if (!this.canSurroundContents())
                throw new v("BAD_BOUNDARYPOINTS_ERR");
            var e = this.extractContents();
            if (a.hasChildNodes())
                for (; a.lastChild;)
                    a.removeChild(a.lastChild);
            N(a, this.startContainer, this.startOffset);
            a.appendChild(e);
            this.selectNode(a)
        },
        cloneRange: function() {
            J(this);
            for (var a = new M(H(this)), e = ka.length, j; e--;) {
                j = ka[e];
                a[j] = this[j]
            }
            return a
        },
        toString: function() {
            J(this);
            var a = this.startContainer;
            if (a === this.endContainer && g.isCharacterDataNode(a))
                return a.nodeType == 3 || a.nodeType == 4 ? a.data.slice(this.startOffset, this.endOffset) : "";
            else {
                var e = [];
                a = new q(this, true);
                i(a, function(j) {
                    if (j.nodeType == 3 || j.nodeType == 4)
                        e.push(j.data)
                });
                a.detach();
                return e.join("")
            }
        },
        compareNode: function(a) {
            J(this);
            var e = a.parentNode, j = g.getNodeIndex(a);
            if (!e)
                throw new S("NOT_FOUND_ERR");
            a = this.comparePoint(e, j);
            e = this.comparePoint(e, j + 1);
            return a < 0 ? e > 0 ? pa : na : e > 0 ?
            oa : ja
        },
        comparePoint: function(a, e) {
            J(this);
            B(a, "HIERARCHY_REQUEST_ERR");
            u(a, this.startContainer);
            if (g.comparePoints(a, e, this.startContainer, this.startOffset) < 0)
                return - 1;
            else if (g.comparePoints(a, e, this.endContainer, this.endOffset) > 0)
                return 1;
            return 0
        },
        createContextualFragment: X ? function(a) {
            var e = this.startContainer, j = g.getDocument(e);
            if (!e)
                throw new S("INVALID_STATE_ERR");
            var o = null;
            if (e.nodeType == 1)
                o = e;
            else if (g.isCharacterDataNode(e))
                o = g.parentElement(e);
            o = o === null || o.nodeName == "HTML" && g.isHtmlNamespace(g.getDocument(o).documentElement) &&
            g.isHtmlNamespace(o) ? j.createElement("body") : o.cloneNode(false);
            o.innerHTML = a;
            return g.fragmentFromNodeChildren(o)
        }
        : function(a) {
            r(this);
            var e = H(this).createElement("body");
            e.innerHTML = a;
            return g.fragmentFromNodeChildren(e)
        },
        toHtml: function() {
            J(this);
            var a = H(this).createElement("div");
            a.appendChild(this.cloneContents());
            return a.innerHTML
        },
        intersectsNode: function(a, e) {
            J(this);
            B(a, "NOT_FOUND_ERR");
            if (g.getDocument(a) !== H(this))
                return false;
            var j = a.parentNode, o = g.getNodeIndex(a);
            B(j, "NOT_FOUND_ERR");
            var E = g.comparePoints(j, o, this.endContainer, this.endOffset);
            j = g.comparePoints(j, o + 1, this.startContainer, this.startOffset);
            return e ? E <= 0 && j >= 0 : E < 0 && j > 0
        },
        isPointInRange: function(a, e) {
            J(this);
            B(a, "HIERARCHY_REQUEST_ERR");
            u(a, this.startContainer);
            return g.comparePoints(a, e, this.startContainer, this.startOffset) >= 0 && g.comparePoints(a, e, this.endContainer, this.endOffset) <= 0
        },
        intersectsRange: function(a, e) {
            J(this);
            if (H(a) != H(this))
                throw new S("WRONG_DOCUMENT_ERR");
            var j = g.comparePoints(this.startContainer,
            this.startOffset, a.endContainer, a.endOffset), o = g.comparePoints(this.endContainer, this.endOffset, a.startContainer, a.startOffset);
            return e ? j <= 0 && o >= 0 : j < 0 && o > 0
        },
        intersection: function(a) {
            if (this.intersectsRange(a)) {
                var e = g.comparePoints(this.startContainer, this.startOffset, a.startContainer, a.startOffset), j = g.comparePoints(this.endContainer, this.endOffset, a.endContainer, a.endOffset), o = this.cloneRange();
                e==-1 && o.setStart(a.startContainer, a.startOffset);
                j == 1 && o.setEnd(a.endContainer, a.endOffset);
                return o
            }
            return null
        },
        union: function(a) {
            if (this.intersectsRange(a, true)) {
                var e = this.cloneRange();
                g.comparePoints(a.startContainer, a.startOffset, this.startContainer, this.startOffset)==-1 && e.setStart(a.startContainer, a.startOffset);
                g.comparePoints(a.endContainer, a.endOffset, this.endContainer, this.endOffset) == 1 && e.setEnd(a.endContainer, a.endOffset);
                return e
            } else 
                throw new v("Ranges do not intersect");
        },
        containsNode: function(a, e) {
            return e ? this.intersectsNode(a, false) : this.compareNode(a) == ja
        },
        containsNodeContents: function(a) {
            return this.comparePoint(a,
            0) >= 0 && this.comparePoint(a, g.getNodeLength(a)) <= 0
        },
        containsRange: function(a) {
            return this.intersection(a).equals(a)
        },
        containsNodeText: function(a) {
            var e = this.cloneRange();
            e.selectNode(a);
            var j = e.getNodes([3]);
            if (j.length > 0) {
                e.setStart(j[0], 0);
                a = j.pop();
                e.setEnd(a, a.length);
                a = this.containsRange(e);
                e.detach();
                return a
            } else 
                return this.containsNodeContents(a)
        },
        createNodeIterator: function(a, e) {
            J(this);
            return new c(this, a, e)
        },
        getNodes: function(a, e) {
            J(this);
            return x(this, a, e)
        },
        getDocument: function() {
            return H(this)
        },
        collapseBefore: function(a) {
            r(this);
            this.setEndBefore(a);
            this.collapse(false)
        },
        collapseAfter: function(a) {
            r(this);
            this.setStartAfter(a);
            this.collapse(true)
        },
        getName: function() {
            return "DomRange"
        },
        equals: function(a) {
            return M.rangesEqual(this, a)
        },
        isValid: function() {
            return V(this)
        },
        inspect: function() {
            return A(this)
        }
    };
    fa(M, ha, function(a) {
        r(a);
        a.startContainer = a.startOffset = a.endContainer = a.endOffset = null;
        a.collapsed = a.commonAncestorContainer = null;
        I(a, "detach", null);
        a._listeners = null
    });
    l.rangePrototype = ca.prototype;
    M.rangeProperties = ka;
    M.RangeIterator = q;
    M.copyComparisonConstants = W;
    M.createPrototypeRange = fa;
    M.inspect = A;
    M.getRangeDocument = H;
    M.rangesEqual = function(a, e) {
        return a.startContainer === e.startContainer && a.startOffset === e.startOffset && a.endContainer === e.endContainer && a.endOffset === e.endOffset
    };
    l.DomRange = M;
    l.RangeException = v
});
rangy.createModule("WrappedRange", function(l) {
    function K(i, n, t, x) {
        var A = i.duplicate();
        A.collapse(t);
        var q = A.parentElement();
        z.isAncestorOf(n, q, true) || (q = n);
        if (!q.canHaveHTML)
            return new C(q.parentNode, z.getNodeIndex(q));
        n = z.getDocument(q).createElement("span");
        var v, c = t ? "StartToStart": "StartToEnd";
        do {
            q.insertBefore(n, n.previousSibling);
            A.moveToElementText(n)
        }
        while ((v = A.compareEndPoints(c, i)) > 0 && n.previousSibling);
        c = n.nextSibling;
        if (v==-1 && c && z.isCharacterDataNode(c)) {
            A.setEndPoint(t ? "EndToStart" : "EndToEnd",
            i);
            if (/[\r\n]/.test(c.data)) {
                q = A.duplicate();
                t = q.text.replace(/\r\n/g, "\r").length;
                for (t = q.moveStart("character", t); q.compareEndPoints("StartToEnd", q)==-1;) {
                    t++;
                    q.moveStart("character", 1)
                }
            } else 
                t = A.text.length;
            q = new C(c, t)
        } else {
            c = (x ||!t) && n.previousSibling;
            q = (t = (x || t) && n.nextSibling) && z.isCharacterDataNode(t) ? new C(t, 0) : c && z.isCharacterDataNode(c) ? new C(c, c.length) : new C(q, z.getNodeIndex(n))
        }
        n.parentNode.removeChild(n);
        return q
    }
    function H(i, n) {
        var t, x, A = i.offset, q = z.getDocument(i.node), v = q.body.createTextRange(),
        c = z.isCharacterDataNode(i.node);
        if (c) {
            t = i.node;
            x = t.parentNode
        } else {
            t = i.node.childNodes;
            t = A < t.length ? t[A] : null;
            x = i.node
        }
        q = q.createElement("span");
        q.innerHTML = "&#feff;";
        t ? x.insertBefore(q, t) : x.appendChild(q);
        v.moveToElementText(q);
        v.collapse(!n);
        x.removeChild(q);
        if (c)
            v[n ? "moveStart": "moveEnd"]("character", A);
        return v
    }
    l.requireModules(["DomUtil", "DomRange"]);
    var I, z = l.dom, C = z.DomPosition, N = l.DomRange;
    if (l.features.implementsDomRange && (!l.features.implementsTextRange ||!l.config.preferTextRange)) {
        (function() {
            function i(f) {
                for (var k =
                t.length, r; k--;) {
                    r = t[k];
                    f[r] = f.nativeRange[r]
                }
            }
            var n, t = N.rangeProperties, x, A;
            I = function(f) {
                if (!f)
                    throw Error("Range must be specified");
                this.nativeRange = f;
                i(this)
            };
            N.createPrototypeRange(I, function(f, k, r, L, p) {
                var u = f.endContainer !== L || f.endOffset != p;
                if (f.startContainer !== k || f.startOffset != r || u) {
                    f.setEnd(L, p);
                    f.setStart(k, r)
                }
            }, function(f) {
                f.nativeRange.detach();
                f.detached = true;
                for (var k = t.length, r; k--;) {
                    r = t[k];
                    f[r] = null
                }
            });
            n = I.prototype;
            n.selectNode = function(f) {
                this.nativeRange.selectNode(f);
                i(this)
            };
            n.deleteContents = function() {
                this.nativeRange.deleteContents();
                i(this)
            };
            n.extractContents = function() {
                var f = this.nativeRange.extractContents();
                i(this);
                return f
            };
            n.cloneContents = function() {
                return this.nativeRange.cloneContents()
            };
            n.surroundContents = function(f) {
                this.nativeRange.surroundContents(f);
                i(this)
            };
            n.collapse = function(f) {
                this.nativeRange.collapse(f);
                i(this)
            };
            n.cloneRange = function() {
                return new I(this.nativeRange.cloneRange())
            };
            n.refresh = function() {
                i(this)
            };
            n.toString = function() {
                return this.nativeRange.toString()
            };
            var q = document.createTextNode("test");
            z.getBody(document).appendChild(q);
            var v = document.createRange();
            v.setStart(q, 0);
            v.setEnd(q, 0);
            try {
                v.setStart(q, 1);
                x = true;
                n.setStart = function(f, k) {
                    this.nativeRange.setStart(f, k);
                    i(this)
                };
                n.setEnd = function(f, k) {
                    this.nativeRange.setEnd(f, k);
                    i(this)
                };
                A = function(f) {
                    return function(k) {
                        this.nativeRange[f](k);
                        i(this)
                    }
                }
            } catch (c) {
                x = false;
                n.setStart = function(f, k) {
                    try {
                        this.nativeRange.setStart(f, k)
                    } catch (r) {
                        this.nativeRange.setEnd(f, k);
                        this.nativeRange.setStart(f, k)
                    }
                    i(this)
                };
                n.setEnd = function(f, k) {
                    try {
                        this.nativeRange.setEnd(f, k)
                    } catch (r) {
                        this.nativeRange.setStart(f, k);
                        this.nativeRange.setEnd(f, k)
                    }
                    i(this)
                };
                A = function(f, k) {
                    return function(r) {
                        try {
                            this.nativeRange[f](r)
                        } catch (L) {
                            this.nativeRange[k](r);
                            this.nativeRange[f](r)
                        }
                        i(this)
                    }
                }
            }
            n.setStartBefore = A("setStartBefore", "setEndBefore");
            n.setStartAfter = A("setStartAfter", "setEndAfter");
            n.setEndBefore = A("setEndBefore", "setStartBefore");
            n.setEndAfter = A("setEndAfter", "setStartAfter");
            v.selectNodeContents(q);
            n.selectNodeContents =
            v.startContainer == q && v.endContainer == q && v.startOffset == 0 && v.endOffset == q.length ? function(f) {
                this.nativeRange.selectNodeContents(f);
                i(this)
            } : function(f) {
                this.setStart(f, 0);
                this.setEnd(f, N.getEndOffset(f))
            };
            v.selectNodeContents(q);
            v.setEnd(q, 3);
            x = document.createRange();
            x.selectNodeContents(q);
            x.setEnd(q, 4);
            x.setStart(q, 2);
            n.compareBoundaryPoints = v.compareBoundaryPoints(v.START_TO_END, x)==-1 & v.compareBoundaryPoints(v.END_TO_START, x) == 1 ? function(f, k) {
                k = k.nativeRange || k;
                if (f == k.START_TO_END)
                    f = k.END_TO_START;
                else if (f == k.END_TO_START)
                    f = k.START_TO_END;
                return this.nativeRange.compareBoundaryPoints(f, k)
            } : function(f, k) {
                return this.nativeRange.compareBoundaryPoints(f, k.nativeRange || k)
            };
            if (l.util.isHostMethod(v, "createContextualFragment"))
                n.createContextualFragment = function(f) {
                    return this.nativeRange.createContextualFragment(f)
                };
            z.getBody(document).removeChild(q);
            v.detach();
            x.detach()
        })();
        l.createNativeRange = function(i) {
            i = i || document;
            return i.createRange()
        }
    } else if (l.features.implementsTextRange) {
        I = function(i) {
            this.textRange =
            i;
            this.refresh()
        };
        I.prototype = new N(document);
        I.prototype.refresh = function() {
            var i, n, t = this.textRange;
            i = t.parentElement();
            var x = t.duplicate();
            x.collapse(true);
            n = x.parentElement();
            x = t.duplicate();
            x.collapse(false);
            t = x.parentElement();
            n = n == t ? n : z.getCommonAncestor(n, t);
            n = n == i ? n : z.getCommonAncestor(i, n);
            if (this.textRange.compareEndPoints("StartToEnd", this.textRange) == 0)
                n = i = K(this.textRange, n, true, true);
            else {
                i = K(this.textRange, n, true, false);
                n = K(this.textRange, n, false, false)
            }
            this.setStart(i.node, i.offset);
            this.setEnd(n.node, n.offset)
        };
        N.copyComparisonConstants(I);
        var O = function() {
            return this
        }();
        if (typeof O.Range == "undefined")
            O.Range = I;
        l.createNativeRange = function(i) {
            i = i || document;
            return i.body.createTextRange()
        }
    }
    if (l.features.implementsTextRange)
        I.rangeToTextRange = function(i) {
            if (i.collapsed)
                return H(new C(i.startContainer, i.startOffset), true);
            else {
                var n = H(new C(i.startContainer, i.startOffset), true), t = H(new C(i.endContainer, i.endOffset), false);
                i = z.getDocument(i.startContainer).body.createTextRange();
                i.setEndPoint("StartToStart", n);
                i.setEndPoint("EndToEnd", t);
                return i
            }
        };
    I.prototype.getName = function() {
        return "WrappedRange"
    };
    l.WrappedRange = I;
    l.createRange = function(i) {
        i = i || document;
        return new I(l.createNativeRange(i))
    };
    l.createRangyRange = function(i) {
        i = i || document;
        return new N(i)
    };
    l.createIframeRange = function(i) {
        return l.createRange(z.getIframeDocument(i))
    };
    l.createIframeRangyRange = function(i) {
        return l.createRangyRange(z.getIframeDocument(i))
    };
    l.addCreateMissingNativeApiListener(function(i) {
        i = i.document;
        if (typeof i.createRange == "undefined")
            i.createRange = function() {
                return l.createRange(this)
            };
        i = i = null
    })
});
rangy.createModule("WrappedSelection", function(l, K) {
    function H(b) {
        return (b || window).getSelection()
    }
    function I(b) {
        return (b || window).document.selection
    }
    function z(b, d, h) {
        var D = h ? "end": "start";
        h = h ? "start" : "end";
        b.anchorNode = d[D + "Container"];
        b.anchorOffset = d[D + "Offset"];
        b.focusNode = d[h + "Container"];
        b.focusOffset = d[h + "Offset"]
    }
    function C(b) {
        b.anchorNode = b.focusNode = null;
        b.anchorOffset = b.focusOffset = 0;
        b.rangeCount = 0;
        b.isCollapsed = true;
        b._ranges.length = 0
    }
    function N(b) {
        var d;
        if (b instanceof k) {
            d = b._selectionNativeRange;
            if (!d) {
                d = l.createNativeRange(c.getDocument(b.startContainer));
                d.setEnd(b.endContainer, b.endOffset);
                d.setStart(b.startContainer, b.startOffset);
                b._selectionNativeRange = d;
                b.attachListener("detach", function() {
                    this._selectionNativeRange = null
                })
            }
        } else if (b instanceof r)
            d = b.nativeRange;
        else if (l.features.implementsDomRange && b instanceof c.getWindow(b.startContainer).Range)
            d = b;
        return d
    }
    function O(b) {
        var d = b.getNodes(), h;
        a: if (!d.length || d[0].nodeType != 1)
            h = false;
        else {
            h = 1;
            for (var D = d.length; h < D; ++h)
                if (!c.isAncestorOf(d[0],
                d[h])) {
                    h = false;
                    break a
                }
            h = true
        }
        if (!h)
            throw Error("getSingleElementFromRange: range " + b.inspect() + " did not consist of a single element");
        return d[0]
    }
    function i(b, d) {
        var h = new r(d);
        b._ranges = [h];
        z(b, h, false);
        b.rangeCount = 1;
        b.isCollapsed = h.collapsed
    }
    function n(b) {
        b._ranges.length = 0;
        if (b.docSelection.type == "None")
            C(b);
        else {
            var d = b.docSelection.createRange();
            if (d && typeof d.text != "undefined")
                i(b, d);
            else {
                b.rangeCount = d.length;
                for (var h, D = c.getDocument(d.item(0)), G = 0; G < b.rangeCount; ++G) {
                    h = l.createRange(D);
                    h.selectNode(d.item(G));
                    b._ranges.push(h)
                }
                b.isCollapsed = b.rangeCount == 1 && b._ranges[0].collapsed;
                z(b, b._ranges[b.rangeCount - 1], false)
            }
        }
    }
    function t(b, d) {
        var h = b.docSelection.createRange(), D = O(d), G = c.getDocument(h.item(0));
        G = c.getBody(G).createControlRange();
        for (var P = 0, X = h.length; P < X; ++P)
            G.add(h.item(P));
        try {
            G.add(D)
        } catch (ta) {
            throw Error("addRange(): Element within the specified Range could not be added to control selection (does it have layout?)");
        }
        G.select();
        n(b)
    }
    function x(b, d, h) {
        this.nativeSelection =
        b;
        this.docSelection = d;
        this._ranges = [];
        this.win = h;
        this.refresh()
    }
    function A(b, d) {
        var h = c.getDocument(d[0].startContainer);
        h = c.getBody(h).createControlRange();
        for (var D = 0, G; D < rangeCount; ++D) {
            G = O(d[D]);
            try {
                h.add(G)
            } catch (P) {
                throw Error("setRanges(): Element within the one of the specified Ranges could not be added to control selection (does it have layout?)");
            }
        }
        h.select();
        n(b)
    }
    function q(b, d) {
        if (b.anchorNode && c.getDocument(b.anchorNode) !== c.getDocument(d))
            throw new L("WRONG_DOCUMENT_ERR");
    }
    function v(b) {
        var d =
        [], h = new p(b.anchorNode, b.anchorOffset), D = new p(b.focusNode, b.focusOffset), G = typeof b.getName == "function" ? b.getName(): "Selection";
        if (typeof b.rangeCount != "undefined")
            for (var P = 0, X = b.rangeCount; P < X; ++P)
                d[P] = k.inspect(b.getRangeAt(P));
        return "[" + G + "(Ranges: " + d.join(", ") + ")(anchor: " + h.inspect() + ", focus: " + D.inspect() + "]"
    }
    l.requireModules(["DomUtil", "DomRange", "WrappedRange"]);
    l.config.checkSelectionRanges = true;
    var c = l.dom, f = l.util, k = l.DomRange, r = l.WrappedRange, L = l.DOMException, p = c.DomPosition, u, w,
    B = l.util.isHostMethod(window, "getSelection"), V = l.util.isHostObject(document, "selection"), J = V && (!B || l.config.preferTextRange);
    if (J) {
        u = I;
        l.isSelectionValid = function(b) {
            b = (b || window).document;
            var d = b.selection;
            return d.type != "None" || c.getDocument(d.createRange().parentElement()) == b
        }
    } else if (B) {
        u = H;
        l.isSelectionValid = function() {
            return true
        }
    } else 
        K.fail("Neither document.selection or window.getSelection() detected.");
    l.getNativeSelection = u;
    B = u();
    var ca = l.createNativeRange(document), Y = c.getBody(document),
    W = f.areHostObjects(B, f.areHostProperties(B, ["anchorOffset", "focusOffset"]));
    l.features.selectionHasAnchorAndFocus = W;
    var da = f.isHostMethod(B, "extend");
    l.features.selectionHasExtend = da;
    var fa = typeof B.rangeCount == "number";
    l.features.selectionHasRangeCount = fa;
    var ea = false, ha = true;
    f.areHostMethods(B, ["addRange", "getRangeAt", "removeAllRanges"]) && typeof B.rangeCount == "number" && l.features.implementsDomRange && function() {
        var b = document.createElement("iframe");
        b.frameBorder = 0;
        b.style.position = "absolute";
        b.style.left =
        "-10000px";
        Y.appendChild(b);
        var d = c.getIframeDocument(b);
        d.open();
        d.write("<html><head></head><body>12</body></html>");
        d.close();
        var h = c.getIframeWindow(b).getSelection(), D = d.documentElement.lastChild.firstChild;
        d = d.createRange();
        d.setStart(D, 1);
        d.collapse(true);
        h.addRange(d);
        ha = h.rangeCount == 1;
        h.removeAllRanges();
        var G = d.cloneRange();
        d.setStart(D, 0);
        G.setEnd(D, 2);
        h.addRange(d);
        h.addRange(G);
        ea = h.rangeCount == 2;
        d.detach();
        G.detach();
        Y.removeChild(b)
    }();
    l.features.selectionSupportsMultipleRanges = ea;
    l.features.collapsedNonEditableSelectionsSupported = ha;
    var M = false, g;
    if (Y && f.isHostMethod(Y, "createControlRange")) {
        g = Y.createControlRange();
        if (f.areHostProperties(g, ["item", "add"]))
            M = true
    }
    l.features.implementsControlRange = M;
    w = W ? function(b) {
        return b.anchorNode === b.focusNode && b.anchorOffset === b.focusOffset
    } : function(b) {
        return b.rangeCount ? b.getRangeAt(b.rangeCount - 1).collapsed : false
    };
    var Z;
    if (f.isHostMethod(B, "getRangeAt"))
        Z = function(b, d) {
            try {
                return b.getRangeAt(d)
            } catch (h) {
                return null
            }
        };
    else if (W)
        Z =
        function(b) {
            var d = c.getDocument(b.anchorNode);
            d = l.createRange(d);
            d.setStart(b.anchorNode, b.anchorOffset);
            d.setEnd(b.focusNode, b.focusOffset);
            if (d.collapsed !== this.isCollapsed) {
                d.setStart(b.focusNode, b.focusOffset);
                d.setEnd(b.anchorNode, b.anchorOffset)
            }
            return d
        };
    l.getSelection = function(b) {
        b = b || window;
        var d = b._rangySelection, h = u(b), D = V ? I(b): null;
        if (d) {
            d.nativeSelection = h;
            d.docSelection = D;
            d.refresh(b)
        } else {
            d = new x(h, D, b);
            b._rangySelection = d
        }
        return d
    };
    l.getIframeSelection = function(b) {
        return l.getSelection(c.getIframeWindow(b))
    };
    g = x.prototype;
    if (!J && W && f.areHostMethods(B, ["removeAllRanges", "addRange"])) {
        g.removeAllRanges = function() {
            this.nativeSelection.removeAllRanges();
            C(this)
        };
        var S = function(b, d) {
            var h = k.getRangeDocument(d);
            h = l.createRange(h);
            h.collapseToPoint(d.endContainer, d.endOffset);
            b.nativeSelection.addRange(N(h));
            b.nativeSelection.extend(d.startContainer, d.startOffset);
            b.refresh()
        };
        g.addRange = fa ? function(b, d) {
            if (M && V && this.docSelection.type == "Control")
                t(this, b);
            else if (d && da)
                S(this, b);
            else {
                var h;
                if (ea)
                    h = this.rangeCount;
                else {
                    this.removeAllRanges();
                    h = 0
                }
                this.nativeSelection.addRange(N(b));
                this.rangeCount = this.nativeSelection.rangeCount;
                if (this.rangeCount == h + 1) {
                    if (l.config.checkSelectionRanges)
                        if ((h = Z(this.nativeSelection, this.rangeCount - 1))&&!k.rangesEqual(h, b))
                            b = new r(h);
                    this._ranges[this.rangeCount - 1] = b;
                    z(this, b, aa(this.nativeSelection));
                    this.isCollapsed = w(this)
                } else 
                    this.refresh()
            }
        } : function(b, d) {
            if (d && da)
                S(this, b);
            else {
                this.nativeSelection.addRange(N(b));
                this.refresh()
            }
        };
        g.setRanges = function(b) {
            if (M && b.length >
            1)
                A(this, b);
            else {
                this.removeAllRanges();
                for (var d = 0, h = b.length; d < h; ++d)
                    this.addRange(b[d])
            }
        }
    } else if (f.isHostMethod(B, "empty") && f.isHostMethod(ca, "select") && M && J) {
        g.removeAllRanges = function() {
            try {
                this.docSelection.empty();
                if (this.docSelection.type != "None") {
                    var b;
                    if (this.anchorNode)
                        b = c.getDocument(this.anchorNode);
                    else if (this.docSelection.type == "Control") {
                        var d = this.docSelection.createRange();
                        if (d.length)
                            b = c.getDocument(d.item(0)).body.createTextRange()
                        }
                    if (b) {
                        b.body.createTextRange().select();
                        this.docSelection.empty()
                    }
                }
            } catch (h) {}
            C(this)
        };
        g.addRange = function(b) {
            if (this.docSelection.type == "Control")
                t(this, b);
            else {
                r.rangeToTextRange(b).select();
                this._ranges[0] = b;
                this.rangeCount = 1;
                this.isCollapsed = this._ranges[0].collapsed;
                z(this, b, false)
            }
        };
        g.setRanges = function(b) {
            this.removeAllRanges();
            var d = b.length;
            if (d > 1)
                A(this, b);
            else 
                d && this.addRange(b[0])
        }
    } else {
        K.fail("No means of selecting a Range or TextRange was found");
        return false
    }
    g.getRangeAt = function(b) {
        if (b < 0 || b >= this.rangeCount)
            throw new L("INDEX_SIZE_ERR");
        else 
            return this._ranges[b]
    };
    var $;
    if (J)
        $ = function(b) {
            var d;
            if (l.isSelectionValid(b.win))
                d = b.docSelection.createRange();
            else {
                d = c.getBody(b.win.document).createTextRange();
                d.collapse(true)
            }
            if (b.docSelection.type == "Control")
                n(b);
            else 
                d && typeof d.text != "undefined" ? i(b, d) : C(b)
            };
    else if (f.isHostMethod(B, "getRangeAt") && typeof B.rangeCount == "number")
        $ = function(b) {
            if (M && V && b.docSelection.type == "Control")
                n(b);
            else {
                b._ranges.length = b.rangeCount = b.nativeSelection.rangeCount;
                if (b.rangeCount) {
                    for (var d = 0, h = b.rangeCount; d < h; ++d)
                        b._ranges[d] =
                        new l.WrappedRange(b.nativeSelection.getRangeAt(d));
                        z(b, b._ranges[b.rangeCount - 1], aa(b.nativeSelection));
                        b.isCollapsed = w(b)
                    } else 
                        C(b)
            }
        };
    else if (W && typeof B.isCollapsed == "boolean" && typeof ca.collapsed == "boolean" && l.features.implementsDomRange)
        $ = function(b) {
            var d;
            d = b.nativeSelection;
            if (d.anchorNode) {
                d = Z(d, 0);
                b._ranges = [d];
                b.rangeCount = 1;
                d = b.nativeSelection;
                b.anchorNode = d.anchorNode;
                b.anchorOffset = d.anchorOffset;
                b.focusNode = d.focusNode;
                b.focusOffset = d.focusOffset;
                b.isCollapsed = w(b)
            } else 
                C(b)
            };
    else {
        K.fail("No means of obtaining a Range or TextRange from the user's selection was found");
        return false
    }
    g.refresh = function(b) {
        var d = b ? this._ranges.slice(0): null;
        $(this);
        if (b) {
            b = d.length;
            if (b != this._ranges.length)
                return false;
            for (; b--;)
                if (!k.rangesEqual(d[b], this._ranges[b]))
                    return false;
            return true
        }
    };
    var ba = function(b, d) {
        var h = b.getAllRanges(), D = false;
        b.removeAllRanges();
        for (var G = 0, P = h.length; G < P; ++G)
            if (D || d !== h[G])
                b.addRange(h[G]);
            else 
                D = true;
        b.rangeCount || C(b)
    };
    g.removeRange = M ? function(b) {
        if (this.docSelection.type == "Control") {
            var d = this.docSelection.createRange();
            b = O(b);
            var h = c.getDocument(d.item(0));
            h = c.getBody(h).createControlRange();
            for (var D, G = false, P = 0, X = d.length; P < X; ++P) {
                D = d.item(P);
                if (D !== b || G)
                    h.add(d.item(P));
                else 
                    G = true
            }
            h.select();
            n(this)
        } else 
            ba(this, b)
    } : function(b) {
        ba(this, b)
    };
    var aa;
    if (!J && W && l.features.implementsDomRange) {
        aa = function(b) {
            var d = false;
            if (b.anchorNode)
                d = c.comparePoints(b.anchorNode, b.anchorOffset, b.focusNode, b.focusOffset) == 1;
            return d
        };
        g.isBackwards = function() {
            return aa(this)
        }
    } else 
        aa = g.isBackwards = function() {
            return false
        };
    g.toString = function() {
        for (var b = [], d = 0, h = this.rangeCount; d <
        h; ++d)
            b[d] = "" + this._ranges[d];
        return b.join("")
    };
    g.collapse = function(b, d) {
        q(this, b);
        var h = l.createRange(c.getDocument(b));
        h.collapseToPoint(b, d);
        this.removeAllRanges();
        this.addRange(h);
        this.isCollapsed = true
    };
    g.collapseToStart = function() {
        if (this.rangeCount) {
            var b = this._ranges[0];
            this.collapse(b.startContainer, b.startOffset)
        } else 
            throw new L("INVALID_STATE_ERR");
    };
    g.collapseToEnd = function() {
        if (this.rangeCount) {
            var b = this._ranges[this.rangeCount - 1];
            this.collapse(b.endContainer, b.endOffset)
        } else 
            throw new L("INVALID_STATE_ERR");
    };
    g.selectAllChildren = function(b) {
        q(this, b);
        var d = l.createRange(c.getDocument(b));
        d.selectNodeContents(b);
        this.removeAllRanges();
        this.addRange(d)
    };
    g.deleteFromDocument = function() {
        if (M && V && this.docSelection.type == "Control") {
            for (var b = this.docSelection.createRange(), d; b.length;) {
                d = b.item(0);
                b.remove(d);
                d.parentNode.removeChild(d)
            }
            this.refresh()
        } else if (this.rangeCount) {
            b = this.getAllRanges();
            this.removeAllRanges();
            d = 0;
            for (var h = b.length; d < h; ++d)
                b[d].deleteContents();
            this.addRange(b[h - 1])
        }
    };
    g.getAllRanges =
    function() {
        return this._ranges.slice(0)
    };
    g.setSingleRange = function(b) {
        this.setRanges([b])
    };
    g.containsNode = function(b, d) {
        for (var h = 0, D = this._ranges.length; h < D; ++h)
            if (this._ranges[h].containsNode(b, d))
                return true;
        return false
    };
    g.toHtml = function() {
        var b = "";
        if (this.rangeCount) {
            b = k.getRangeDocument(this._ranges[0]).createElement("div");
            for (var d = 0, h = this._ranges.length; d < h; ++d)
                b.appendChild(this._ranges[d].cloneContents());
            b = b.innerHTML
        }
        return b
    };
    g.getName = function() {
        return "WrappedSelection"
    };
    g.inspect =
    function() {
        return v(this)
    };
    g.detach = function() {
        this.win = this.anchorNode = this.focusNode = this.win._rangySelection = null
    };
    x.inspect = v;
    l.Selection = x;
    l.selectionPrototype = g;
    l.addCreateMissingNativeApiListener(function(b) {
        if (typeof b.getSelection == "undefined")
            b.getSelection = function() {
                return l.getSelection(this)
            };
        b = null
    })
});



/*
 CSS Class Applier module for Rangy.
 Adds, removes and toggles CSS classes on Ranges and Selections

 Part of Rangy, a cross-browser JavaScript range and selection library
 http://code.google.com/p/rangy/

 Depends on Rangy core.

 Copyright 2012, Tim Down
 Licensed under the MIT license.
 Version: 1.2.3
 Build date: 26 February 2012
*/
rangy.createModule("CssClassApplier", function(i, v) {
    function r(a, b) {
        return a.className && RegExp("(?:^|\\s)" + b + "(?:\\s|$)").test(a.className)
    }
    function s(a, b) {
        if (a.className)
            r(a, b) || (a.className += " " + b);
        else 
            a.className = b
    }
    function o(a) {
        return a.split(/\s+/).sort().join(" ")
    }
    function w(a, b) {
        return o(a.className) == o(b.className)
    }
    function x(a) {
        for (var b = a.parentNode; a.hasChildNodes();)
            b.insertBefore(a.firstChild, a);
        b.removeChild(a)
    }
    function y(a, b) {
        var c = a.cloneRange();
        c.selectNodeContents(b);
        var d = c.intersection(a);
        d = d ? d.toString() : "";
        c.detach();
        return d != ""
    }
    function z(a) {
        return a.getNodes([3], function(b) {
            return y(a, b)
        })
    }
    function A(a, b) {
        if (a.attributes.length != b.attributes.length)
            return false;
        for (var c = 0, d = a.attributes.length, e, f; c < d; ++c) {
            e = a.attributes[c];
            f = e.name;
            if (f != "class") {
                f = b.attributes.getNamedItem(f);
                if (!f || (e.specified != f.specified))
                    return false;
                if (e.specified && e.nodeValue !== f.nodeValue)
                    return false
            }
        }
        return true
    }
    function B(a, b) {
        for (var c = 0, d = a.attributes.length, e; c < d; ++c) {
            e = a.attributes[c].name;
            if (!(b &&
            h.arrayContains(b, e)) && a.attributes[c].specified && e != "class")
                return true
        }
        return false
    }
    function C(a) {
        var b;
        return a && a.nodeType == 1 && ((b = a.parentNode) && b.nodeType == 9 && b.designMode == "on" || k(a)&&!k(a.parentNode))
    }
    function D(a) {
        return (k(a) || a.nodeType != 1 && k(a.parentNode))&&!C(a)
    }
    function E(a) {
        return a && a.nodeType == 1&&!M.test(p(a, "display"))
    }
    function N(a) {
        if (a.data.length == 0)
            return true;
        if (O.test(a.data))
            return false;
        switch (p(a.parentNode, "whiteSpace")) {
        case "pre":
        case "pre-wrap":
        case "-moz-pre-wrap":
            return false;
        case "pre-line":
            if (/[\r\n]/.test(a.data))
                return false
        }
        return E(a.previousSibling) || E(a.nextSibling)
    }
    function m(a, b, c, d) {
        var e, f = c == 0;
        if (h.isAncestorOf(b, a))
            return a;
        if (h.isCharacterDataNode(b))
            if (c == 0) {
                c = h.getNodeIndex(b);
                b = b.parentNode
            } else if (c == b.length) {
                c = h.getNodeIndex(b) + 1;
                b = b.parentNode
            } else 
                throw v.createError("splitNodeAt should not be called with offset in the middle of a data node (" + c + " in " + b.data);
        var g;
        g = b;
        var j = c;
        g = h.isCharacterDataNode(g) ? j == 0?!!g.previousSibling : j == g.length?!!g.nextSibling :
        true : j > 0 && j < g.childNodes.length;
        if (g) {
            if (!e) {
                e = b.cloneNode(false);
                for (e.id && e.removeAttribute("id"); f = b.childNodes[c];)
                    e.appendChild(f);
                h.insertAfter(e, b)
            }
            return b == a ? e : m(a, e.parentNode, h.getNodeIndex(e), d)
        } else if (a != b) {
            e = b.parentNode;
            b = h.getNodeIndex(b);
            f || b++;
            return m(a, e, b, d)
        }
        return a
    }
    function F(a) {
        var b = a ? "nextSibling": "previousSibling";
        return function(c, d) {
            var e = c.parentNode, f = c[b];
            if (f) {
                if (f && f.nodeType == 3)
                    return f
            } else if (d)
                if ((f = e[b]) && f.nodeType == 1 && e.tagName == f.tagName && w(e, f) && A(e, f) && p(e, 'display') == 'inline' && p(f, 'display') == 'inline')
                    return f[a ?
                    "firstChild": "lastChild"];
            return null
        }
    }
    function t(a) {
        this.firstTextNode = (this.isElementMerge = a.nodeType == 1) ? a.lastChild : a;
        this.textNodes = [this.firstTextNode]
    }
    function q(a, b, c) {
        this.cssClass = a;
        var d, e, f = null;
        if (typeof b == "object" && b !== null) {
            c = b.tagNames;
            f = b.elementProperties;
            for (d = 0; e = P[d++];)
                if (b.hasOwnProperty(e))
                    this[e] = b[e];
            d = b.normalize
        } else 
            d = b;
        this.normalize = typeof d == "undefined" ? true : d;
        this.attrExceptions = [];
        d = document.createElement(this.elementTagName);
        this.elementProperties = {};
        for (var g in f)
            if (f.hasOwnProperty(g)) {
                if (G.hasOwnProperty(g))
                    g =
                    G[g];
                    d[g] = f[g];
                    this.elementProperties[g] = d[g];
                    this.attrExceptions.push(g)
            }
        this.elementSortedClassName = this.elementProperties.hasOwnProperty("className") ? o(this.elementProperties.className + " " + a) : a;
        this.applyToAnyTagName = false;
        a = typeof c;
        if (a == "string")
            if (c == "*")
                this.applyToAnyTagName = true;
            else 
                this.tagNames = c.toLowerCase().replace(/^\s\s*/, "").replace(/\s\s*$/, "").split(/\s*,\s*/);
        else if (a == "object" && typeof c.length == "number") {
            this.tagNames = [];
            d = 0;
            for (a = c.length; d < a; ++d)
                if (c[d] == "*")
                    this.applyToAnyTagName =
                    true;
                else 
                    this.tagNames.push(c[d].toLowerCase())
        } else 
            this.tagNames = [this.elementTagName]
    }
    i.requireModules(["WrappedSelection", "WrappedRange"]);
    var h = i.dom, H = function() {
        function a(b, c, d) {
            return c && d ? " " : ""
        }
        return function(b, c) {
            if (b.className)
                b.className = b.className.replace(RegExp("(?:^|\\s)" + c + "(?:\\s|$)"), a)
        }
    }(), p;
    if (typeof window.getComputedStyle != "undefined")
        p = function(a, b) {
            return h.getWindow(a).getComputedStyle(a, null)[b]
        };
    else if (typeof document.documentElement.currentStyle != "undefined")
        p = function(a,
        b) {
            return a.currentStyle[b]
        };
    else 
        v.fail("No means of obtaining computed style properties found");
    var k;
    (function() {
        k = typeof document.createElement("div").isContentEditable == "boolean" ? function(a) {
            return a && a.nodeType == 1 && a.isContentEditable
        } : function(a) {
            if (!a || a.nodeType != 1 || a.contentEditable == "false")
                return false;
            return a.contentEditable == "true" || k(a.parentNode)
        }
    })();
    var M = /^inline(-block|-table)?$/i, O = /[^\r\n\t\f \u200B]/, Q = F(false), R = F(true);
    t.prototype = {
        doMerge: function() {
            for (var a = [], b, c, d = 0,
            e = this.textNodes.length; d < e; ++d) {
                b = this.textNodes[d];
                c = b.parentNode;
                a[d] = b.data;
                if (d) {
                    c.removeChild(b);
                    c.hasChildNodes() || c.parentNode.removeChild(c)
                }
            }
            return this.firstTextNode.data = a = a.join("")
        },
        getLength: function() {
            for (var a = this.textNodes.length, b = 0; a--;)
                b += this.textNodes[a].length;
            return b
        },
        toString: function() {
            for (var a = [], b = 0, c = this.textNodes.length; b < c; ++b)
                a[b] = "'" + this.textNodes[b].data + "'";
            return "[Merge(" + a.join(",") + ")]"
        }
    };
    var P = ["elementTagName", "ignoreWhiteSpace", "applyToEditableOnly"],
    G = {
        "class": "className"
    };
    q.prototype = {
        elementTagName: "span",
        elementProperties: {},
        ignoreWhiteSpace: true,
        applyToEditableOnly: false,
        hasClass: function(a) {
            return a.nodeType == 1 && h.arrayContains(this.tagNames, a.tagName.toLowerCase()) && r(a, this.cssClass)
        },
        getSelfOrAncestorWithClass: function(a) {
            for (; a;) {
                if (this.hasClass(a, this.cssClass))
                    return a;
                a = a.parentNode
            }
            return null
        },
        isModifiable: function(a) {
            return !this.applyToEditableOnly || D(a)
        },
        isIgnorableWhiteSpaceNode: function(a) {
            return this.ignoreWhiteSpace && a &&
            a.nodeType == 3 && N(a)
        },
        postApply: function(a, b, c) {
            if (a.length == 0)
                return;
            for (var d = a[0], e = a[a.length - 1], f = [], g, j = d, I = e, J = 0, K = e.length, n, L, l = 0, u = a.length; l < u; ++l) {
                n = a[l];
                if (L = Q(n, !c)) {
                    if (!g) {
                        g = new t(L);
                        f.push(g)
                    }
                    g.textNodes.push(n);
                    if (n === d) {
                        j = g.firstTextNode;
                        J = j.length
                    }
                    if (n === e) {
                        I = g.firstTextNode;
                        K = g.getLength()
                    }
                } else 
                    g = null
            }
            if (a = R(e, !c)) {
                if (!g) {
                    g = new t(e);
                    f.push(g)
                }
                g.textNodes.push(a)
            }
            if (f.length) {
                l = 0;
                for (u = f.length; l < u; ++l)
                    f[l].doMerge();
                b.setStart(j, J);
                b.setEnd(I, K)
            }
        },
        createContainer: function(a) {
            a = a.createElement(this.elementTagName);
            i.util.extend(a, this.elementProperties);
            s(a, this.cssClass);
            return a
        },
        applyToTextNode: function(a) {
            var b = a.parentNode;
            if (b.childNodes.length == 1 && h.arrayContains(this.tagNames, b.tagName.toLowerCase()))
                s(b, this.cssClass);
            else {
                b = this.createContainer(h.getDocument(a));
                a.parentNode.insertBefore(b, a);
                b.appendChild(a)
            }
        },
        isRemovable: function(a) {
            var b;
            if (b = a.tagName.toLowerCase() == this.elementTagName) {
                if (b = o(a.className) == this.elementSortedClassName) {
                    var c;
                    a:
                    {
                        b = this.elementProperties;
                        for (c in b)
                            if (b.hasOwnProperty(c) &&
                            a[c] !== b[c]) {
                                c = false;
                                break a
                            }
                        c = true
                    }
                    b = c&&!B(a, this.attrExceptions) && this.isModifiable(a)
                }
                b = b
            }
            return b
        },
        undoToTextNode: function(a, b, c) {
            if (!b.containsNode(c)) {
                a = b.cloneRange();
                a.selectNode(c);
                if (a.isPointInRange(b.endContainer, b.endOffset)) {
                    m(c, b.endContainer, b.endOffset, [b]);
                    b.setEndAfter(c)
                }
                if (a.isPointInRange(b.startContainer, b.startOffset))
                    c = m(c, b.startContainer, b.startOffset, [b])
            }
            this.isRemovable(c) ? x(c) : H(c, this.cssClass)
        },
        applyToRange: function(a) {
            a.splitBoundaries();
            var b = z(a);
            if (b.length) {
                for (var c,
                d = 0, e = b.length; d < e; ++d) {
                    c = b[d];
                    !this.isIgnorableWhiteSpaceNode(c)&&!this.getSelfOrAncestorWithClass(c) && this.isModifiable(c) && this.applyToTextNode(c)
                }
                a.setStart(b[0], 0);
                c = b[b.length - 1];
                a.setEnd(c, c.length);
                this.normalize && this.postApply(b, a, false)
            }
        },
        applyToSelection: function(a) {
            a = a || window;
            a = i.getSelection(a);
            var b, c = a.getAllRanges();
            a.removeAllRanges();
            for (var d = c.length; d--;) {
                b = c[d];
                this.applyToRange(b);
                a.addRange(b)
            }
        },
        undoToRange: function(a) {
            a.splitBoundaries();
            var b = z(a), c, d, e = b[b.length - 1];
            if (b.length) {
                for (var f =
                0, g = b.length; f < g; ++f) {
                    c = b[f];
                    (d = this.getSelfOrAncestorWithClass(c)) && this.isModifiable(c) && this.undoToTextNode(c, a, d);
                    a.setStart(b[0], 0);
                    a.setEnd(e, e.length)
                }
                this.normalize && this.postApply(b, a, true)
            }
        },
        undoToSelection: function(a) {
            a = a || window;
            a = i.getSelection(a);
            var b = a.getAllRanges(), c;
            a.removeAllRanges();
            for (var d = 0, e = b.length; d < e; ++d) {
                c = b[d];
                this.undoToRange(c);
                a.addRange(c)
            }
        },
        getTextSelectedByRange: function(a, b) {
            var c = b.cloneRange();
            c.selectNodeContents(a);
            var d = c.intersection(b);
            d = d ? d.toString() :
            "";
            c.detach();
            return d
        },
        isAppliedToRange: function(a) {
            if (a.collapsed)
                return !!this.getSelfOrAncestorWithClass(a.commonAncestorContainer);
            else {
                for (var b = a.getNodes([3]), c = 0, d; d = b[c++];)
                    if (!this.isIgnorableWhiteSpaceNode(d) && y(a, d) && this.isModifiable(d)&&!this.getSelfOrAncestorWithClass(d))
                        return false;
                return true
            }
        },
        isAppliedToSelection: function(a) {
            a = a || window;
            a = i.getSelection(a).getAllRanges();
            for (var b = a.length; b--;)
                if (!this.isAppliedToRange(a[b]))
                    return false;
            return true
        },
        toggleRange: function(a) {
            this.isAppliedToRange(a) ?
            this.undoToRange(a) : this.applyToRange(a)
        },
        toggleSelection: function(a) {
            this.isAppliedToSelection(a) ? this.undoToSelection(a) : this.applyToSelection(a)
        },
        detach: function() {}
    };
    q.util = {
        hasClass: r,
        addClass: s,
        removeClass: H,
        hasSameClasses: w,
        replaceWithOwnChildren: x,
        elementsHaveSameNonClassAttributes: A,
        elementHasNonClassAttributes: B,
        splitNodeAt: m,
        isEditableElement: k,
        isEditingHost: C,
        isEditable: D
    };
    i.CssClassApplier = q;
    i.createCssClassApplier = function(a, b, c) {
        return new q(a, b, c)
    }
});




/*
 Selection save and restore module for Rangy.
 Saves and restores user selections using marker invisible elements in the DOM.

 Part of Rangy, a cross-browser JavaScript range and selection library
 http://code.google.com/p/rangy/

 Depends on Rangy core.

 Copyright 2012, Tim Down
 Licensed under the MIT license.
 Version: 1.2.3
 Build date: 26 February 2012
*/
rangy.createModule("SaveRestore", function(h, m) {
    function n(a, g) {
        var e = "selectionBoundary_" + + new Date + "_" + ("" + Math.random()).slice(2), c, f = p.getDocument(a.startContainer), d = a.cloneRange();
        d.collapse(g);
        c = f.createElement("span");
        c.id = e;
        c.style.lineHeight = "0";
        c.style.display = "none";
        c.className = "rangySelectionBoundary";
        c.appendChild(f.createTextNode(q));
        d.insertNode(c);
        d.detach();
        return c
    }
    function o(a, g, e, c) {
        if (a = (a || document).getElementById(e)) {
            g[c ? "setStartBefore": "setEndBefore"](a);
            a.parentNode.removeChild(a)
        } else 
            m.warn("Marker element has been removed. Cannot restore selection.")
    }
    function r(a, g) {
        return g.compareBoundaryPoints(a.START_TO_START, a)
    }
    function k(a, g) {
        var e = (a || document).getElementById(g);
        e && e.parentNode.removeChild(e)
    }
    h.requireModules(["DomUtil", "DomRange", "WrappedRange"]);
    var p = h.dom, q = "\ufeff";
    h.saveSelection = function(a) {
        a = a || window;
        var g = a.document;
        if (h.isSelectionValid(a)) {
            var e = h.getSelection(a), c = e.getAllRanges(), f = [], d, j;
            c.sort(r);
            for (var b = 0, i = c.length; b < i; ++b) {
                d = c[b];
                if (d.collapsed) {
                    j = n(d, false);
                    f.push({
                        markerId: j.id,
                        collapsed: true
                    })
                } else {
                    j = n(d, false);
                    d = n(d, true);
                    f[b] = {
                        startMarkerId: d.id,
                        endMarkerId: j.id,
                        collapsed: false,
                        backwards: c.length == 1 && e.isBackwards()
                    }
                }
            }
            for (b = i - 1; b >= 0; --b) {
                d = c[b];
                if (d.collapsed)
                    d.collapseBefore((g || document).getElementById(f[b].markerId));
                else {
                    d.setEndBefore((g || document).getElementById(f[b].endMarkerId));
                    d.setStartAfter((g || document).getElementById(f[b].startMarkerId))
                }
            }
            e.setRanges(c);
            return {
                win: a,
                doc: g,
                rangeInfos: f,
                restored: false
            }
        } else 
            m.warn("Cannot save selection. This usually happens when the selection is collapsed and the selection document has lost focus.")
    };
    h.restoreSelection = function(a, g) {
        if (!a.restored) {
            for (var e = a.rangeInfos, c = h.getSelection(a.win), f = [], d = e.length, j = d - 1, b, i; j >= 0; --j) {
                b = e[j];
                i = h.createRange(a.doc);
                if (b.collapsed)
                    if (b = (a.doc || document).getElementById(b.markerId)) {
                        b.style.display = "inline";
                        var l = b.previousSibling;
                        if (l && l.nodeType == 3) {
                            b.parentNode.removeChild(b);
                            i.collapseToPoint(l, l.length)
                        } else {
                            i.collapseBefore(b);
                            b.parentNode.removeChild(b)
                        }
                    } else 
                        m.warn("Marker element has been removed. Cannot restore selection.");
                else {
                    o(a.doc, i, b.startMarkerId,
                    true);
                    o(a.doc, i, b.endMarkerId, false)
                }
                d == 1 && i.normalizeBoundaries();
                f[j] = i
            }
            if (d == 1 && g && h.features.selectionHasExtend && e[0].backwards) {
                c.removeAllRanges();
                c.addRange(f[0], true)
            } else 
                c.setRanges(f);
            a.restored = true
        }
    };
    h.removeMarkerElement = k;
    h.removeMarkers = function(a) {
        for (var g = a.rangeInfos, e = 0, c = g.length, f; e < c; ++e) {
            f = g[e];
            if (f.collapsed)
                k(a.doc, f.markerId);
            else {
                k(a.doc, f.startMarkerId);
                k(a.doc, f.endMarkerId)
            }
        }
    }
});




/*
 Serializer module for Rangy.
 Serializes Ranges and Selections. An example use would be to store a user's selection on a particular page in a
 cookie or local storage and restore it on the user's next visit to the same page.

 Part of Rangy, a cross-browser JavaScript range and selection library
 http://code.google.com/p/rangy/

 Depends on Rangy core.

 Copyright 2012, Tim Down
 Licensed under the MIT license.
 Version: 1.2.3
 Build date: 26 February 2012
*/
rangy.createModule("Serializer", function(g, n) {
    function o(c, a) {
        a = a || [];
        var b = c.nodeType, e = c.childNodes, d = e.length, f = [b, c.nodeName, d].join(":"), h = "", k = "";
        switch (b) {
        case 3:
            h = c.nodeValue.replace(/</g, "&lt;").replace(/>/g, "&gt;");
            break;
        case 8:
            h = "<!--" + c.nodeValue.replace(/</g, "&lt;").replace(/>/g, "&gt;") + "--\>";
            break;
        default:
            h = "<" + f + ">";
            k = "</>";
            break
        }
        h && a.push(h);
        for (b = 0; b < d; ++b)
            o(e[b], a);
        k && a.push(k);
        return a
    }
    function j(c) {
        c = o(c).join("");
        return u(c).toString(16)
    }
    function l(c, a, b) {
        var e = [], d = c;
        for (b =
        b || i.getDocument(c).documentElement; d && d != b;) {
            e.push(i.getNodeIndex(d, true));
            d = d.parentNode
        }
        return e.join("/") + ":" + a
    }
    function m(c, a, b) {
        if (a)
            b || i.getDocument(a);
        else {
            b = b || document;
            a = b.documentElement
        }
        c = c.split(":");
        a = a;
        b = c[0] ? c[0].split("/") : [];
        for (var e = b.length, d; e--;) {
            d = parseInt(b[e], 10);
            if (d < a.childNodes.length)
                a = a.childNodes[parseInt(b[e], 10)];
            else 
                throw n.createError("deserializePosition failed: node " + i.inspectNode(a) + " has no child with index " + d + ", " + e);
        }
        return new i.DomPosition(a, parseInt(c[1],
        10))
    }
    function p(c, a, b) {
        b = b || g.DomRange.getRangeDocument(c).documentElement;
        if (!i.isAncestorOf(b, c.commonAncestorContainer, true))
            throw Error("serializeRange: range is not wholly contained within specified root node");
        c = l(c.startContainer, c.startOffset, b) + "," + l(c.endContainer, c.endOffset, b);
        a || (c += "{" + j(b) + "}");
        return c
    }
    function q(c, a, b) {
        if (a)
            b = b || i.getDocument(a);
        else {
            b = b || document;
            a = b.documentElement
        }
        c = /^([^,]+),([^,\{]+)({([^}]+)})?$/.exec(c);
        var e = c[4], d = j(a);
        if (e && e !== j(a))
            throw Error("deserializeRange: checksums of serialized range root node (" +
            e + ") and target root node (" + d + ") do not match");
        e = m(c[1], a, b);
        a = m(c[2], a, b);
        b = g.createRange(b);
        b.setStart(e.node, e.offset);
        b.setEnd(a.node, a.offset);
        return b
    }
    function r(c, a, b) {
        if (a)
            b || i.getDocument(a);
        else {
            b = b || document;
            a = b.documentElement
        }
        c = /^([^,]+),([^,]+)({([^}]+)})?$/.exec(c)[3];
        return !c || c === j(a)
    }
    function s(c, a, b) {
        c = c || g.getSelection();
        c = c.getAllRanges();
        for (var e = [], d = 0, f = c.length; d < f; ++d)
            e[d] = p(c[d], a, b);
        return e.join("|")
    }
    function t(c, a, b) {
        if (a)
            b = b || i.getWindow(a);
        else {
            b = b || window;
            a = b.document.documentElement
        }
        c =
        c.split("|");
        for (var e = g.getSelection(b), d = [], f = 0, h = c.length; f < h; ++f)
            d[f] = q(c[f], a, b.document);
        e.setRanges(d);
        return e
    }
    g.requireModules(["WrappedSelection", "WrappedRange"]);
    if (typeof encodeURIComponent == "undefined" || typeof decodeURIComponent == "undefined")
        n.fail("Global object is missing encodeURIComponent and/or decodeURIComponent method");
    var u = function() {
        var c = null;
        return function(a) {
            for (var b = [], e = 0, d = a.length, f; e < d; ++e) {
                f = a.charCodeAt(e);
                if (f < 128)
                    b.push(f);
                else 
                    f < 2048 ? b.push(f>>6 | 192, f & 63 | 128) :
                    b.push(f>>12 | 224, f>>6 & 63 | 128, f & 63 | 128)
            }
            a =- 1;
            if (!c) {
                e = [];
                d = 0;
                for (var h; d < 256; ++d) {
                    h = d;
                    for (f = 8; f--;)
                        if ((h & 1) == 1)
                            h = h>>>1^3988292384;
                        else 
                            h>>>=1;
                    e[d] = h>>>0
                }
                c = e
            }
            e = c;
            d = 0;
            for (f = b.length; d < f; ++d) {
                h = (a^b[d]) & 255;
                a = a>>>8^e[h]
            }
            return (a^-1)>>>0
        }
    }(), i = g.dom;
    g.serializePosition = l;
    g.deserializePosition = m;
    g.serializeRange = p;
    g.deserializeRange = q;
    g.canDeserializeRange = r;
    g.serializeSelection = s;
    g.deserializeSelection = t;
    g.canDeserializeSelection = function(c, a, b) {
        var e;
        if (a)
            e = b ? b.document : i.getDocument(a);
        else {
            b = b || window;
            a = b.document.documentElement
        }
        c = c.split("|");
        b = 0;
        for (var d = c.length; b < d; ++b)
            if (!r(c[b], a, e))
                return false;
        return true
    };
    g.restoreSelectionFromCookie = function(c) {
        c = c || window;
        var a;
        a: {
            a = c.document.cookie.split(/[;,]/);
            for (var b = 0, e = a.length, d; b < e; ++b) {
                d = a[b].split("=");
                if (d[0].replace(/^\s+/, "") == "rangySerializedSelection")
                    if (d = d[1]) {
                        a = decodeURIComponent(d.replace(/\s+$/, ""));
                        break a
                    }
            }
            a = null
        }
        a && t(a, c.doc)
    };
    g.saveSelectionCookie = function(c, a) {
        c = c || window;
        a = typeof a == "object" ? a : {};
        var b = a.expires ? ";expires=" +
        a.expires.toUTCString(): "", e = a.path ? ";path=" + a.path: "", d = a.domain ? ";domain=" + a.domain: "", f = a.secure ? ";secure": "", h = s(g.getSelection(c));
        c.document.cookie = encodeURIComponent("rangySerializedSelection") + "=" + encodeURIComponent(h) + b + e + d + f
    };
    g.getElementChecksum = j
});
/* jshint ignore:end */
;
define("internal/sitebuilder/builder/rangy", function() {});

define('internal/sitebuilder/builder/wizzy', [
'jquery',
'internal/sitebuilder/common/log',
'internal/sitebuilder/builder/rangy',
'jquery.hotkeys'
], function($, log) {
    $(function() {
        rangy.init();
        /**
        		 * Surrounds range with a certain tag if possible, returns new element
        		 */
        rangy.rangePrototype.surroundWithTag = function(tag) {
            if (this.canSurroundContents()) {
                var el = document.createElement(tag);
                this.surroundContents(el);
                return el;
            }
            return null;
        };
    });

    var
    /**
    	 * Logs Wizzy
    	 */
    _log = function() {
        if (log && log.trigger) {
            var arr = Array.prototype.slice.call(arguments, 0, arguments.length);

            // if type of log isn't passed in (or matches log type), assume info
            if (typeof log[arr[0]] !== "function") 
                arr.splice(0, 0, "info");

            arr.splice(0, 0, "Wizzy");
            log.trigger.apply(null, arr);
        }
    },

    ELEMENT_NODE = 1,
    TEXT_NODE = 3,
    KEY = {
        LEFT : 37,
        UP : 38,
        RIGHT : 39,
        DOWN : 40,
        RETURN : 13
    },
    CLASSES = {
        BOLD: "wz-bold",
        ITALIC: "wz-italic",
        UNDERLINE: "wz-underline",
        STRIKETHROUGH: "wz-strikethrough"
    },


    utils = {
        /**
        		 * checks to see if char is whitespace, assume &nbsp; (charCode 160) is not whitespace
        		 */
        isWhitespace: function(c) {
            return c && c.charCodeAt(0) !== 160 && c.match(/^\s+|\s+$/);
        },

        /**
        		 * Trim whitespaces from string
        		 */
        trim: function(str) {
            return str.replace(/^\s+|\s+$/g, '');
        },

        /**
        		 * nodeType checker
        		 */
        isTNode: function(node) {
            return node.nodeType === TEXT_NODE;
        },
        isENode: function(node) {
            return node.nodeType === ELEMENT_NODE;
        },

        /**
        		 * Checks whether b is descendant of a, keep traversing up a's ancestors
        		 * Will effectively check which element is more "royal" from an ancestor's perspective
        		 */
        elementContains: function(a, b, escapeEl) {
            if (typeof a.jquery !== "string") 
                a = $(a);

            if (a[0] === escapeEl) 
                return false;
            if (a.find(b)[0]) {
                return true;
            } else {
                utils.elementContains(a.parent(), b, escapeEl);
            }
        },

        /**
        		 * Sibling type is either "nextSibling" or "previousSibling"
        		 * Returns element if found, null otherwise;
        		 */
        getSiblingElement: function(direction, node) {
            if (!node || !utils.isTNode(node)) 
                return null;
            var siblingType = direction === "forward" ? "nextSibling" : "previousSibling";
            while (node[siblingType]) {
                if (!utils.isTNode(node[siblingType])) 
                    return node[siblingType];
                node = node[siblingType];
            }
            return null;
        },

        /**
        		 * Gets the last text node before either an element node or null sibling
        		 */
        getLastTextnode: function(direction, node) {
            var siblingType = direction === "forward" ? "nextSibling" : "previousSibling";
            while (node[siblingType]) {
                if (!utils.isTNode(node[siblingType])) 
                    break;
                node = node[siblingType];
            }
            return node;
        },

        /**
        		 * Selects the node contents, returns endOffset (startOffset should always be zero for els
        		 */
        getNodeEndOffset: function(node) {
            if (typeof node === "undefined") 
                return null;
            var range = rangy.createRange();
            range.selectNodeContents(node);
            return range.endOffset;
        }
    },


    /**
    	 * Allows plugins to register with Wizzy
    	 * In order to utilize this plugin later, the instance of wizzy must call .extend(id, param) - look below
    	 *
    	 * {param} object - id of plugin to register
    	 * {param} object - function at gets called to register plugin
    	 */
    plugins = {},
    register = function(id, fn) {
        _log("Registered Wizzy plugin with ID: " + id);
        plugins[id] = fn;
    },


    /**
    	 * Wizzy creates instance of WizzyRange to handle range. Ideally, there should be only one instance
    	 * of WizzyRange to go with Wizzy since you can set a different range to WizzyRange. We're responsible
    	 * for managing different Rangy ranges and setting it to our WizzyRange instance as necessary.
    	 */
    Wizzy = {
        //==================================++++++++++++++++++++======================================
        /**
        		 * Initializing Wizzy
        		 * {param} {$el} jQuery reference to the content-editable DOM element
        		 */
        init: function($el, data) {
            var self = this;

            // references to content-editable container
            self.$el = $el;
            self.el = $el[0];

            // Holds certain data associated with wizzy (eg. linkInfo)
            self.data = data || {};
            self.data.linksData = self.data.linksData || {};

            self.document = self.el.ownerDocument;
            self.$body = $el.parents('body');

            // Every Wizzy has a WizzyRange, a range traversal adapter
            self.wizzyRange = Object.create(WizzyRange);

            // Indicates that wizzyRange hasn't been set with the current operating range yet
            // This usually means the current selection. At the appropriate time (during exec call),
            self._dirty = true;
            self.bind("rangeChange", function() {
                self._dirty = true;
            });

            // Content-changed delegation
            self.bind("rangeChange", function() {
                var newData, newRange, _applyRange;
                if (!self.currentRange || !self.currentRange.startContainer.parentElement) {
                    self.currentRange = self.getSelectionRange();
                    self.currentData = self.getData();
                    self.getRangeFontSize();
                    return;
                }

                newData = self.getData();
                newRange = self.getSelectionRange();

                if (self.currentData !== newData) {
                    self.trigger("contentChanged", self.currentData);
                    if (self.currentData.length < newData.length) {
                        self.trigger("contentAdded");
                    } else {
                        self.trigger("contentRemoved");
                    }

                    if (self.isCollapsed()) {
                        _applyRange = self.currentRange.cloneRange();
                        if (_applyRange.comparePoint(newRange.endContainer, newRange.endOffset) > 0) {
                            _applyRange.setEnd(newRange.endContainer, newRange.endOffset);
                        } else {
                            _applyRange.setStart(newRange.endContainer, newRange.endOffset);
                        }
                        self.trigger("contentChangedWithRange", _applyRange);
                    }
                }
                self.currentData = newData;
                self.currentRange = newRange;
                self.getRangeFontSize();

            });


            self.utils = utils;
            self.CLASSES = CLASSES;

            self.on = false;

            self.hasHotkeys = $el.constructor.hotkeys;
        },

        getRangeFontSize: function(getDeepestSize) {
            var self = this;
            window.setTimeout(function() {
                var currentRange = self.getSelectionRange(),
                onlyOneFontSize = true,
                fontSize;

                if (currentRange.endContainer !== currentRange.startContainer) {
                    //Determine the font size of the selected text.
                    self.forInRange(function(el) {

                        $el = el.nodeName === '#text' ? $(el.parentNode) : $(el);
                        var style = $el.css("font-size");
                        if (style) {
                            if (!fontSize) {
                                fontSize = parseInt(style, 10);
                            } else {
                                if (fontSize != parseInt(style, 10)) {
                                    onlyOneFontSize = false;
                                }
                            }
                        }
                    }, false);
                }

                //If the selection is contained within a single element, select the node surrounding the cursor to determine the font size.
                if (!fontSize) {
                    var node = currentRange.startContainer.nodeName === '#text' ? $(currentRange.startContainer.parentNode) : $(currentRange.startContainer);
                    // don't get font size from module container if there are child elements
                    // TODO: this is a temp fix for IE
                    if (node.attr('class') && node.attr('class').indexOf('webs-') >= 0 && node.children().length) {
                        node = node.children().first();
                    }
                    fontSize = parseInt(node.css('font-size'), 10);
                }
                //Reset the font size in the tool bar. If the text contains more than 1 font size, set the
                //initial value of the dropdown to ''.
                if (self.data.setFontSize) {
                    self.data.setFontSize(onlyOneFontSize ? fontSize ? fontSize : self.data.defaultFontSize : '');
                }
            }, 1);
        },

        setElement: function(el) {
            if (el.jquery) 
                el = el[0];
            this.el = el;
            this.$el = $(el);
        },

        isDirty: function() {
            return this._dirty;
        },

        /**
        		 * Enables wizzy
        		 */
        show: function() {
            var self = this;
            self.$el.attr('contenteditable', true);
            self.on = true;
            self._bindCore();
            self.trigger('show');
            return self;
        },


        /**
        		 * Disables wizzy
        		 */
        hide: function() {
            var self = this;
            self.$el.attr('contenteditable', false);
            self.on = false;
            self._unbindCore();
            self.trigger('hide');
            self.postProcess();
            return self;
        },


        /**
        		 * Destroys this instance of wizzy, dereference everything for GC
        		 */
        destroy: function() {
            var self = this;
            self.trigger('destroy');
            self.postProcess();
            if (self.$el) {
                self._unbindCore();
                self.$el.data('wizzy', null);
                self.$el = null;
            }
            return true;
        },


        /**
        		 * Returns the HTML data for Wizzy
        		 */
        getData: function() {
            var $clone = this.$el.clone(), $nest, idx = 0;
            $clone.find("ol>span,ul>span").remove();
            while (($nest = $clone.find("ol>ol,ol>ul,ul>ol,ul>ul").eq(0)).length) {
                if ($nest.prev().length === 0) {
                    $("<li><span><br/></span></li>").insertBefore($nest).append($nest);
                } else {
                    $nest.prev().append($nest);
                }
            }
            var self = this, text = utils.trim($clone.html());
            if (text === "<br>") {
                self.$el.html("");
                self.selectNode(self.el);
                text = "";
            }
            return text;
        },
        getLinksData: function() {
            return this.data.linksData;
        },



        //================================== Event Bindings ======================================

        _bindCore: function() {
            var self = this, $el = self.$el;

            $el
            .bind('dblclick.wizzy', function(e) {
                return self._wzDoubleClick(e);
            })
            .bind('click.wizzy', function(e) {
                return self._wzClick(e);
            })
            .bind('mouseup.wizzy', function(e) {
                return self._wzMouseup(e);
            })
            .bind('keyup.wizzy', function(e) {
                return self._wzKeyup(e);
            })
            .bind('keydown.wizzy', function(e) {
                return self._wzKeydown(e);
            });

            if (self.hasHotkeys) {
                $el
                .bind("keydown.wizzy", "tab", function() {
                    return self._hkTab();
                })
                .bind("keydown.wizzy", "shift+tab", function() {
                    return self._hkShiftTab();
                });
            }
        },
        _unbindCore: function() {
            this.$el.unbind('.wizzy');
        },


        _wzDoubleClick: function(e) {
            try {
                this.trigger('rangeChange');
            } catch (err) {
                _log("warn", err);
            }
            return true;
        },
        _wzMouseup: function(e) {
            try {
                this.trigger('rangeChange');
            } catch (err) {
                _log("warn", err);
            }
            return true;
        },
        _wzClick: function(e) {
            try {
                this.trigger('rangeChange');
            } catch (err) {
                _log("warn", err);
            }
            return true;
        },
        _wzKeydown: function(e) {
            var k = e.keyCode;
            if (k === KEY.RETURN) 
                this._wzKeydownReturn();
            return true;
        },
        _wzKeyup: function(e) {
            try {
                this.trigger('rangeChange');
                this.trigger("keyUp", e);
            } catch (err) {
                _log("warn", err);
            }
            return true;
        },


        /**
        		 * Return key capture is used to add a line break if user is in the middle of a line
        		 * and a paragraph if the caret is directly before or after a line break
        		 */
        _wzKeydownReturn: function() {
            /*
            			  Disabling breaks on pressing return key for now.
            			  Will revisit for the cross-browser rich-text editing task
            			 */
            if (0) {
                var s = rangy.getSelection(),
                r = s.getRangeAt(0),
                ancestor = r.commonAncestorContainer,
                prev = ancestor.previousSibling,
                next = ancestor.nextSibling;

                if (r.startOffset === 0 && r.endOffset === 0 && prev && prev.tagName === 'BR') {
                    // Caret is at first position after line break
                    // allow contenteditable to take it's natural course
                    prev.parentNode.removeChild(prev);
                    return true;
                } else if (r.endOffset === ancestor.length && next && next.tagName === 'BR') {
                    // Caret is at last position before line break
                    next.parentNode.removeChild(next);
                    return true;
                } else {
                    var br = document.createElement('br'),
                    endContainer = r.endContainer,
                    n = this.getNode(),
                    newTextNode;


                    // If the caret is at the last position inside a paragraph and the next node is a paragraph
                    // we need to add 2 <br> because the caret doesn't know how to sit in between a <br> and a closing </p>
                    if (r.endOffset === ancestor.length) {
                        if (n.nextElementSibling && n.nextElementSibling.tagName === 'P' && n.tagName === 'P') {
                            this.insertNode(document.createElement('br'));
                        } else {
}
                    }

                    this.insertNode(br);

                    // endContainer's next sibbling is now <br>, br's next sibbling will be new textNode
                    newTextNode = endContainer.nextSibling.nextSibling;
                    r = rangy.createRange();
                    r.setStart(newTextNode, 0);
                    r.setEnd(newTextNode, 0);

                    this.selectRange(r.nativeRange, s);

                    return false;
                }
            }
        },


        _hkTab: function() {
            this.getWizzyRange().init();
            return false;
        },


        _hkShiftTab: function() {
            this.wizzyRange.init();
            return false;
        },





        //================================== Utilities and such ======================================

        /**
        		 * Converts all characters in a string that area above the codepoint 127 into numerical html entities (e.g. &#8220;)
        		 */
        extendedCharsToEntities: function(text) {
            var i, c, cc, newText = "";
            for (i = 0; i < text.length; ++i) {
                cc = text.charCodeAt(i);
                c = cc > 127 ? "&#" + cc + ";" : text.charAt(i);
                newText += c;
            }
            return newText;
        },


        /**
        		 * Generates a "random" string to be used as DOM id
        		 */
        generateId: function() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0,
                v = c === 'x' ? r : r & 3 | 8;
                return v.toString(16);
            }).toUpperCase();
        },


        /**
        		 * IE queryCommandValue returns hex number instead of hex string, needs conversion
        		 */
        queryColorFix: function(value) {
            if ($.browser.msie) {
                value = ((value & 0x0000ff) << 16) | (value & 0x00ff00) | ((value & 0xff0000) >>> 16);
                value = value.toString(16);
                value = "#000000".slice(0, 7 - value.length) + value;
            }
            return value;
        },


        /**
        		 * Grabs the em value if one exist. If not, compute one
        		 */
        getFontSize: function(el) {
            if (!el) {
                _log("warn", "No element defined to get font size");
                return false;
            }

            var size, $el, fz, pfz;
            if (el.style) {
                if (el.style.getPropertyValue) {
                    size = el.style.getPropertyValue('font-size');
                } else if (el.style.fontSize) {
                    size = el.style.fontSize;
                }
            }

            if (size && size.substr( - 2) === 'em') {
                size = parseFloat(size);
            } else {
                $el = $(el);
                fz = parseInt($el.css('font-size'), 10);
                pfz = parseInt($el.parent().css('font-size'), 10);
                size = fz / pfz;
            }
            return size;
        },


        /**
        		 * Sets font size on element with value. If isStep is set, value is an increment
        		 */
        setFontSize: function(el, value, isStep) {
            var self = this,
            applyFontSize = function($el, value, isStep) {
                var size;
                if (isStep) {
                    size = this.getFontSize(el, false);
                    size = parseInt(size * 100 + value * 100, 10) / 100 + 'em';
                } else {
                    size = value + 'px';
                }
                $el.css('font-size', size);
            },
            $el = $(el);

            // Apply the new font size to the element
            applyFontSize($el, value, isStep);

            $el.children().each(function() {
                self.setFontSize($(this), value, isStep);
            });

            return $el;
        },


        /**
        		 * Recursive deletes empty or singular block-level (P and DIV) nodes
        		 */
        clearSurroundingMarkup: function(el) {
            var n, tmp, next = el, prev = el, parent = el;
            var tagsToRemove = ["P", "DIV", "SPAN"];

            do {
                do {
                    tmp = next;
                    next = tmp.next();
                    n = next[0];
                    if (n && ($.inArray(n.tagName, tagsToRemove)) && next.html() === "") {
                        next.remove();
                        next = tmp;
                        continue;
                    }
                }
                while (next[0]);

                do {
                    tmp = prev;
                    prev = tmp.prev();
                    n = prev[0];
                    if (n && $.inArray(n.tagName, tagsToRemove) && next.html() === "") {
                        prev.remove();
                        prev = tmp;
                        continue;
                    }
                }
                while (prev[0]);

                tmp = parent;
                parent = tmp.parent();
                n = parent[0];
                if (n && n === this.el || parent.find(this.el)[0]) 
                    return;
                if (parent.children().length === 1 && $.inArray(n.tagName, tagsToRemove)) {
                    parent.before(tmp);
                    parent.remove();
                    parent = tmp;
                }
            }
            while (parent[0]);
        },




        //================================ SELECTION & RANGES ====================================
        getWizzyRange: function() {
            return this.wizzyRange;
        },
        getRange: function(r) {
            return this.getWizzyRange().getRange();
        },
        getSelectionRange: function(r) {
            var range;
            try {
                range = this.getSelection().getRangeAt(0);
            } catch (e) {
                _log("warn", "Error grabbing rangy range, using root element instead", e);
                range = rangy.createRange();
                range.selectNodeContents(this.el);
            }
            return range;
        },
        getSelection: function() {
            return rangy.getSelection();
        },
        clearSelection: function() {
            this.getSelection().removeAllRanges();
            return this;
        },


        getElement: function() {
            var n = this.getNode();
            if (n && n.nodeType !== ELEMENT_NODE) 
                n = n.parentNode;
            if (this.el !== n && !this.$el.find(n)[0]) 
                return null;
            return n;
        },
        getNode: function() {
            return this.getSelectionRange().commonAncestorContainer;
        },


        insertNode: function(node, replace) {
            var s = this.getSelection(), r = s.getRangeAt(0);
            if (replace) 
                s.deleteFromDocument();
            return r.insertNode(node);
        },


        insertHTML: function(html, replace) {
            var r = this.getSelectionRange(), node = r.createContextualFragment(html);
            var oldR = this.getSelectionRange();
            return r.insertNode(node, replace);
        },


        collapse: function(node, offset) {
            if (typeof node === 'undefined') 
                node = this.el;
            if (typeof offset !== 'number') 
                offset = 0;
            return this.getSelection().collapse(node, offset);
        },
        isCollapsed: function() {
            return this.getSelection().isCollapsed;
        },


        // sets range on wizzyRange
        setRange: function(r) {
            _log("Range was dirty, setting and cleaning range");
            this.getWizzyRange().setRange(r);
            this._dirty = false;
            return this;
        },

        // sets range (saves rave to wizzyRange) only if dirty
        setDirtyRange: function() {
            if (this.isDirty())
                this.setRange();
        },

        // selects current wizzyRange
        select: function(fn) {
            var self = this;
            setTimeout(function() {
                self.selectRange(self.getRange());
                if (typeof fn === "function") 
                    fn.call(self);
            }, 0.01);
            return self;
        },

        selectWord: function() {
            var range, backwards, sel = this.getSelection().nativeSelection;
            if ((window.getSelection) && (sel = window.getSelection()).modify) {

                // Detect if selection is backwards
                sel = window.getSelection();
                range = this.getSelectionRange();
                range.setStart(sel.anchorNode, sel.anchorOffset);
                range.setEnd(sel.focusNode, sel.focusOffset);
                backwards = range.collapsed;
                range.detach();

                // modify() works on the focus of the selection
                var endNode = sel.focusNode, endOffset = sel.focusOffset;
                sel.collapse(sel.anchorNode, sel.anchorOffset);
                if (backwards) {
                    sel.modify("move", "forward", "word");
                    sel.extend(endNode, endOffset);
                    sel.modify("extend", "backward", "word");

                } else {
                    sel.modify("move", "backward", "word");
                    sel.extend(endNode, endOffset);
                    sel.modify("extend", "forward", "word");
                }
            } else if (document.selection) {
                range = document.selection.createRange().duplicate();
                range.moveStart("word", - 1);
                range.moveEnd("word", 1);
                range.select();
            }
        },

        selectRange: function(r) {
            if (r.isValid()) 
                this.getSelection().setSingleRange(r);
        },
        selectAll: function() {
            var range = rangy.createRange();
            range.selectNodeContents(this.el);
            this.selectRange(range);
            return range;
        },
        selectNode: function(node) {
            this.getSelection().selectAllChildren(node);
        },
        saveRange: function() {
            this.savedRange = this.getSelectionRange();
            return this.savedRange;
        },
        restoreRange: function() {
            if (this.savedRange) {
                this.selectRange(this.savedRange);
            }
        },

        //================================== EXTENDING PLUGIN AND EVENTS ======================================

        /**
        		 * Allows the current instance of wizzy to extend functionality
        		 * The plugin callback function is given the instance of wizzy along with necessary parameters
        		 *
        		 * {param} string - ID of the plugin that was registered through Wizzy.register
        		 * {param} object - Object with all parameters for plugin function callback to use
        		 * {return} Boolean - False if there were problems, True if sucessfull. Return is largely dependent on plugin developer
        		 */
        extend: function(id, arg) {
            return plugins[id].call(this, arg);
        },

        /**
        		 * Allows registered plugin to register callbacks that can hook into common callbacks & events in Wizzy
        		 * Piggybacks on jQuery. You can define a binding as follows
        		 *      w.bind("event_name", function(e, params) {  });
        		 */
        bind: function(event, fn) {
            var self = this;
            event = "wizzy-" + event;
            self.$el.bind(event, fn);
            return self;
        },
        trigger: function(event, param) {
            var self = this;
            event = "wizzy-" + event;
            self.$el.trigger(event, param);
            return self;
        }

    },
    /**
    	 * Class which wraps rangy's range. A rangy range instance is associated with WizzyRange.
    	 * Use setRange to update it with a new range
    	 */
    WizzyRange = {

        /**
        		 * Initializting WizzyRange is just setting a range on it
        		 */
        init: function(r) {
            return this.setRange(r);
        },

        /**
        		 * "r" is a rangy range. If none is passed in, we use the selection's range
        		 */
        setRange: function(r) {
            if (r) 
                this.r = r.cloneRange();
            else 
                this.setSelectionRange();
            return this;
        },

        /**
        		 * Sets current range with browser selection
        		 */
        setSelectionRange: function() {
            this.r = rangy.getSelection().getRangeAt(0);
        },

        /**
        		 * Grabs rangy range associated wtih WizzyRange
        		 */
        getRange: function() {
            return this.r;
        },

        /**
        		 * Returns an instance of WizzyRange with a unique copy of the rangy range
        		 */
        clone: function() {
            return Object.create(WizzyRange).init(this.r.cloneRange());
        },

        /**
        		 * Returns a clone of the rangy range
        		 */
        cloneRange: function() {
            return this.getRange().cloneRange();
        },

        /**
        		 * Creates a selection (highlight) with the rangy range instance
        		 */
        select: function() {
            return rangy.getSelection().setSingleRange(this.r);
        },

        /**
        		 * Getters, 's' for anything start (startContainer, startOffset), 'e' for anything end
        		 */
        get: function(which) {
            return this.r[which === "s" ? "startContainer" : "endContainer"];
        },

        /**
        		 * Fires callback on all top-level elements within range
        		 */
        forInRange: function(callback, wrapTextNodes) {
            if (typeof wrapTextNodes === 'undefined') {
                wrapTextNodes = true;
            }
            var self = this;
            var elsArr = this.getElementsInRange(wrapTextNodes);
            $.each(elsArr, function(i, el) {
                callback.call(self, el);
            });
        },

        /**
        		 * Returns array of top level nodes inside range
        		 * If tieEnds is set, dangling textnode endpoints will be wrapped by a span
        		 */
        getElementsInRange: function(tieEnds) {
            var
            elsArr = [],
            span = null,
            r = this.cloneRange(),
            sc = this.get('s'),
            ec = this.get('e'),
            ancestor = r.commonAncestorContainer;

            // Does range fully contain an element?
            if (this._fullyContainsEl()) {
                elsArr.push(this.r.commonAncestorContainer);
                return elsArr;
            }

            // Does range fully contain text node?
            if (this._containsOnlyText()) {
                if (tieEnds) {
                    span = this.getRange().surroundWithTag('span');
                    this.getRange().selectNodeContents(span);
                    this.select();
                    elsArr.push(span);
                }
                return elsArr;
            }

            // Wrap end nodes (if they're text nodes);
            if (tieEnds) 
                this._wrapEndNodes();

            // Finally grab elements
            elsArr = this._getRangeElements(true);

            // Elements could have been created from textnodes in _getRangeElements, needs reselect
            this.select();

            return elsArr;
        },

        /**
        		 * Gets all ancestral elements within range
        		 * If textnode doesn't have ancestral element, wrap with span
        		 */
        _getRangeElements: function(wrapTextNodes) {
            var
            self = this,
            sc = this.get("s"),
            ec = this.get("e"),
            ancestor = this.r.commonAncestorContainer,
            elements = [sc, ec],
            _range, _parent, _siblings;

            this.getRange().getNodes([TEXT_NODE], function(node) {
                // Not interested in empty text nodes
                if (node.data === "") 
                    return;

                while (node) {
                    // We already have this node
                    if ($.inArray(node, elements) !== - 1) 
                        return;

                    _parent = node.parentNode;
                    _siblings = _parent.childNodes;

                    if (_parent === ancestor || self._isNodeInCollection([sc, ec], _siblings)) {
                        if (utils.isTNode(node)) {
                            if (!wrapTextNodes) 
                                return;

                            _range = rangy.createRange();
                            _range.selectNode(node);
                            node = _range.surroundWithTag("span");
                        }
                        elements.push(node);
                        return;
                    }
                    node = node.parentNode;
                }
            });
            return elements;
        },

        /**
        		 * Checks whether a node (or nodes) is in or contained in a nodes collection
        		 */
        _isNodeInCollection: function(node, arr) {
            var i, len;
            if ($.isArray(node)) {
                for (i = 0, len = node.length; i < len; i++) {
                    if (this._isNodeInCollection(node[i], arr)) 
                        return true;
                }
            } else {
                for (i = 0, len = arr.length; i < len; i++) {
                    if (node === arr[i] || $(arr[i]).find(node)[0]) 
                        return true;
                }
            }
            return false;
        },

        /**
        		 * checks to see if a range fully contains an element
        		 * if so, return an array with just that element
        		 */
        _fullyContainsEl: function(el, r) {
            if (!r) 
                r = this.getRange();
            if (!el) 
                el = r.commonAncestorContainer;
            var
            sc = r.startContainer,
            ec = r.endContainer,
            endOff = utils.getNodeEndOffset(ec);

            if (r.endOffset === endOff && r.startOffset === 0 && sc === el && ec === el) {

                // sometimes with a new selection the range only includes text node
                // we need to try to get single-children parent node and use that instead
                if (el.parentNode && el.parentNode.childNodes.length === 1) 
                    el = el.parentNode;
                r.selectNodeContents(el);

                if (!utils.isENode(el)) 
                    r.selectNodeContents(r.surroundWithTag("span"));
                return true;
            }
            return false;
        },

        /**
        		 * Checks to see if the range contains only text nodes and endpoints are sibbling
        		 * if so, *wrap range with span, then return array with just that element
        		 */
        _containsOnlyText: function(r) {
            if (!r) 
                r = this.getRange();
            var sc = r.startContainer, ec = r.endContainer, _node;

            if (utils.isTNode(sc) && utils.isTNode(ec)) {
                if (sc === ec) 
                    return true;

                _node = sc;
                while (_node && utils.isTNode(_node)) {
                    if (_node === ec) {
                        return true;
                    } else {
                        _node = _node.nextSibling;
                    }
                }
            }
            return false;
        },

        /**
        		 * If ends are textnodes, wrap nodes with <span/> up to sibbling's non-textnode
        		 */
        _wrapEndNodes: function() {
            var arr = [];
            var sc = this.get('s'), ec = this.get('e');
            var so = this.r.startOffset, eo = this.r.endOffset;
            var _node, _range, _newStart, _newEnd;

            if (utils.isTNode(sc)) {
                _range = rangy.createRange();
                _range.setStart(sc, so);
                /* jshint ignore:start */
                if (_node = utils.getSiblingElement("forward", sc)) {
                    _range.setEndBefore(_node);
                } else {
                    _node = utils.getLastTextnode("forward", sc);
                    _range.setEnd(_node, _node.length);
                }
                /* jshint ignore:end */
                _newStart = _range.surroundWithTag('span');
                arr.push(_newStart);
            }

            if (utils.isTNode(ec)) {
                _range = rangy.createRange();
                _range.setEnd(ec, eo);
                /* jshint ignore:start */
                if (_node = utils.getSiblingElement("backward", ec)) {
                    _range.setStartAfter(_node);
                } else {
                    _node = utils.getLastTextnode("backward", ec);
                    _range.setStart(_node, 0);
                }
                /* jshint ignore:end */
                _newEnd = _range.surroundWithTag('span');
                arr.push(_newEnd);
            }

            if (!_newStart) 
                _newStart = sc;
            if (!_newEnd) 
                _newEnd = ec;

            _range = rangy.createRange();
            _range.selectNodeContents(_newEnd);
            _range.setStart(_newStart, 0);
            this.r = _range;
            this.select();

            return arr;
        }

    };


    //========================= PLUGIN FOR RANGES AND EXEC[COMMAND] CALLS ======================
    register("RangeExec", function() {
        // Extending Wizzy Methods
        $.extend(this, {
            _styleStringToMap: function(str) {
                var result = {}, entry, attr;
                if (str && str.split) {
                    entry = str.split(';');
                    for (var i = 0, len = entry.length; i < len; i++) {
                        attr = entry[i].split(':');
                        if (attr[0] && attr[1]) 
                            result[attr[0]] = attr[1];
                    }
                }
                return result;
            },
            _styleMapToString: function(map) {
                var str = "";
                for (var attr in map) {
                    if (map.hasOwnProperty(attr)) 
                        str += attr + ":" + map[attr] + "; ";
                }
                return str;
            },
            _extendElementStyles: function(el1, el2) {
                if (!el1.jquery) 
                    el1 = $(el1);
                if (!el2.jquery) 
                    el2 = $(el2);

                return $.extend(this._styleStringToMap(el1.attr("style")), this._styleStringToMap(el2.attr("style")));
            },
            _fixNestedSpans: function(parentNode) {
                if (typeof parentNode === "undefined") 
                    parentNode = this.el;
                var frag, arr = [], span, child, spans = parentNode.getElementsByTagName('span');
                var $child, $parent;

                // Some older IEs may not like createDocumentFragment
                if (!document.createDocumentFragment) 
                    return;

                // Stabilise spans collection in array
                for (var i = 0, iLen = spans.length; i < iLen; i++) 
                    arr[i] = spans[i];

                for (i = 0; i < iLen; i++) {
                    span = arr[i];

                    // if element has only one child and that child is a span, we can replace the node with child node
                    child = span.firstChild;
                    $parent = $(span);
                    if (span.childNodes.length === 0) {
                        $parent.remove();
                        continue;
                    } else if (span.children.length === 1 && child.nodeName === "SPAN") {


                        // To be safe, we'll only replace nodes that either doesn't have any attribute
                        if (span.attributes.length > 0) 
                            continue;

                        $child = $(child);

                        // We just need to extend current node style with child node style
                        if (span.getAttribute("style") !== null) {
                            // if current node has a font size, we override it with absolute (px) size
                            if (span.style.fontSize.length) 
                                child.style.fontSize = $child.css("font-size");

                            // extend parent style with child style, throw style on child
                            $child.attr("style", this._styleMapToString(this._extendElementStyles($parent, $child)));
                        }

                        frag = document.createDocumentFragment();
                        frag.appendChild(span.firstChild);

                        // Replace span with its content in the fragment
                        span.parentNode.replaceChild(frag, span);
                    }
                }
                return parentNode.innerHTML;
            },
            preProcess: function() {
                this._fixNestedSpans();
                this.$el.find("span").each(function(i, el) {
                    var style;
                    el = $(el);

                    style = el.css("font-weight");
                    if (typeof style !== "string") 
                        style = style.toString();
                    if (style.match(/bold|700/)) {
                        el.css("font-weight", "").addClass(CLASSES.BOLD);
                    }

                    style = el.css("font-style");
                    if (style.match(/italic/)) 
                        el.css("font-style", "").addClass(CLASSES.ITALIC);

                    style = el.css("text-decoration");
                    if (style.match(/underline/)) 
                        el.addClass(CLASSES.UNDERLINE);
                    if (style.match(/line-through/)) 
                        el.addClass(CLASSES.STRIKETHROUGH);
                    el.css("text-decoration", "");
                    if (el.attr("style") === "") 
                        el.removeAttr("style");
                });

                this._cssNormalizer = this._createApplier("NULL");
            },

            /**
            			 * Use rangy's cssClassApplier's postApply method to normalize nodes
            			 */
            postProcess: function() {
                if (this.$el.parents('body').length === 0) 
                    return;
                var r = rangy.createRange();
                r.selectNodeContents(this.el);
                this._cssNormalizer.postApply(r.getNodes([TEXT_NODE]), r, false);
                this._fixNestedSpans();
            },

            /**
            			 * This method gets called externally and acts as a preprocessor for many
            			 * [contenteditable] built-in functionality.
            			 */
            exec: function(cmd, value) {
                _log("Execute Command:  " + cmd + "  " + value);

                switch (cmd) {
                case 'IncreaseFontSize':
                case 'wzIncreaseFontSize':
                    this.wzChangeFontSize('grow');
                    break;
                case 'DecreaseFontSize':
                case 'wzDecreaseFontSize':
                    this.wzChangeFontSize('shrink');
                    break;
                case 'wzSetFontSize':
                    this.wzChangeFontSize(value);
                    break;
                case 'ForeColor':
                case 'wzForeColor':
                    this.wzForeColor(value);
                    break;
                case 'Link':
                case 'wzLink':
                    this.wzCreateLink(value);
                    break;
                case 'Unlink':
                case 'wzUnlink':
                    this.wzRemoveLink();
                    break;
                case 'List':
                case 'wzList':
                    this.wzList(value);
                    break;
                case 'Bold':
                case 'bold':
                    this.wzBold();
                    break;
                case 'Italic':
                case 'italic':
                    this.wzItalic();
                    break;
                case 'Underline':
                case 'underline':
                    this.wzUnderline();
                    break;
                case 'Strikethrough':
                case 'strikethrough':
                    this.wzStrikethrough();
                    break;
                case 'Indent':
                case 'Outdent':
                case 'indent':
                case 'outdent':
                    this.wzBlockquote(cmd);
                    break;
                case 'RemoveFormat':
                    this.wzRemoveFormat();
                    break;

                default:
                    document.execCommand(cmd, false, value);
                }
            },


            forInRange: function(fn, wrapTextNodes) {
                var self = this;
                var el = this.el;
                var wizzyRange = this.getWizzyRange();

                if (typeof wrapTextNodes === 'undefined') {
                    wrapTextNodes = true;
                }

                // In case wizzyRange doesn't have the most updated range, set (and normalize)
                this.setDirtyRange();

                // select range just in case its not highlighted
                if (this.isCollapsed()) 
                    this.select();

                if (this.getRange().collapsed) 
                    return this;

                wizzyRange.forInRange(function(_el) {
                    if ($.contains(_el, el)) {
                        // For some reason, wizzy is setting the color on a parent of the
                        // content-editable div, which results in the color not being persisted because
                        // it isn't part of the extracted html.
                        var children = self.$el.children();
                        _el = children.length === 1 ? children[0] : el;
                    }
                    // Filter for the case when element to process is instatiated element
                    if (_el === el && wrapTextNodes) {
                        // Can't find an element, so just surround contents of el with a span
                        self.getRange().selectNodeContents(el);
                        _el = self.getRange().surroundWithTag('span');
                    }
                    fn.call(self, _el);
                }, wrapTextNodes);
                self.select();

                return this;
            },


            getListType: function(style) {
                return (style === 'circle' || style === 'disc' || style === 'square') ? 'Unordered' : 'Ordered';
            },

            wzList: function(style) {
                this.setDirtyRange();
                this.select(function() {
                    var
                    currentStyle,
                    range = this.getRange(),
                    startContainer = range.startContainer,
                    $start = $(startContainer),
                    parentLists = $start.parents('ol,ul'),
                    parentList = parentLists.first(),
                    listType = this.getListType(style);

                    // it's possible that the user has the whole container selected
                    // we need to look at the only child to see if there's a list
                    if (parentList.length === 0 && startContainer === this.el) {
                        var childList = $start.children("ul, ol");
                        if (childList.length === 1) 
                            parentList = childList;
                    }

                    if (style === 'none') {

                        // Applying the same list style will remove the list
                        if (parentList.length === 1) {
                            listType = this.getListType(parentList.css("list-style-type"));
                            this.exec('Insert' + listType + 'List');
                        }
                        this.setRange();
                    } else if (parentList.length > 0) {
                        if (((listType === 'Ordered' && parentList[0].tagName === 'UL') ||
                        (listType === 'Unordered' && parentList[0].tagName === 'OL'))) {
                            // They were in a list of a different type. Change the type and style.
                            this.exec('Insert' + listType + 'List');
                        }
                        currentStyle = parentList.eq(0).css('list-style-type');
                        parentList.eq(0).removeClass('style-' + currentStyle).addClass('style-' + style);
                        this.setRange();
                    } else {
                        // They were not in a list
                        this.exec('Insert' + listType + 'List');
                        var currNode = this.getNode();
                        if (currNode !== this.el) {
                            parentList = $(currNode).parents('ol,ul').first();
                        } else {
                            parentList = $(currNode).children('ol,ul').eq(0);
                        }
                        currentStyle = parentList.css('list-style-type');
                        parentList.removeClass('style-' + currentStyle).addClass('style-' + style);
                        this.setRange();
                        this.clearSurroundingMarkup(parentList);
                    }
                });
            },


            wzChangeFontSize: function(val) {
                if (typeof val === 'undefined') 
                    return false;
                if (typeof val === 'string') {
                    if (val === 'grow') 
                        val = 0.1;
                    else if (val === 'shrink') 
                        val = - 0.1;
                }

                this.forInRange(function(el) {
                    this.setFontSize(el, val, val < 1.0);
                });

                return false;
            },


            wzForeColor: function(hex) {
                this.forInRange(function(el) {

                    // Recursively ensure this property is set for all children.
                    // Without this, IE doesn't seem to cope.
                    var setColorRecursive = function(el, color) {
                        $el = $(el);
                        $el.css("color", color);
                        $el.children().each(function() {
                            setColorRecursive(this, color);
                        });
                    };

                    setColorRecursive(el, hex);
                });
            },

            wzRemoveFormat: function() {
                var wizzyFontSize = parseInt(this.$el.css("font-size"), 10);
                var wizzyColor = this.$el.css("color");
                // Removes all style and reset font size and color
                this.forInRange(function(el) {
                    if (!utils.isENode(el)) 
                        return;

                    var
                    $el = $(el).removeAttr("style"),
                    fontSize = parseInt($el.css("font-size"), 10),
                    color = $el.css("color");
                    $el.find("span").removeAttr("style");

                    if (wizzyFontSize !== fontSize) 
                        this.setFontSize($el[0], wizzyFontSize / fontSize);
                    if (color !== wizzyColor) 
                        $el.css("color", wizzyColor);
                });

                // Removes all wizzy classes
                if (this.appliers) {
                    for (var klass in this.appliers) {
                        if (this.appliers.hasOwnProperty(klass)) {
                            this.appliers[klass].undoToRange(this.getRange());
                        }
                    }
                }
            },


            /**
            			 * Creates and executes class applier
            			 */
            _createApplier: function(klass) {
                return rangy.createCssClassApplier(klass, {
                    normalize: true,
                    applyToEditableOnly: true
                });
            },
            _exec: function(klass) {
                try {
                    var self = this, nullChar;
                    var selRange = self.getSelectionRange();
                    var range = selRange.cloneRange();
                    var collapsed = self.isCollapsed();

                    var applier = self.appliers = self.appliers || {};
                    applier[klass] = applier[klass] || self._createApplier(klass);

                    // creates range bookmark for IE
                    self.$el.focus();
                    var ieRange = document.selection && document.selection.createRange().duplicate();
                    var bookmark;

                    // If selection is collapsed, we want to apply bold to the next character the user inserts
                    // This is done by creating a null-character textnode, selecting it, and calling class applier
                    // However, in IE, we can't select a null character, therefore the class applier will be
                    // performed on the current word (this is how gmail does it)
                    if (collapsed) {
                        if (!$.browser.msie) {
                            nullChar = document.createTextNode(String.fromCharCode(0));
                            if ($.browser.mozilla) 
                                nullChar = document.createTextNode(" ");
                            self.insertNode(nullChar);
                            range.selectNodeContents(nullChar);
                        } else {
                            bookmark = ieRange.getBookmark();
                            self.selectWord();
                            range = self.getSelectionRange();
                        }
                        self.selectRange(range);
                    }
                    applier[klass].toggleSelection();
                    self._dirty = true;
                    self.$el.focus();

                    // IE loses selection information after the toggle, needs to reselect
                    if ($.browser.msie) {
                        setTimeout(function() {
                            try {
                                self.$el.focus();
                                ieRange.moveToBookmark(bookmark);
                                ieRange.select();
                                self.trigger("rangeChange");
                            } catch (err) {}
                        }, 1);
                    } else if ($.browser.mozilla && collapsed) {
                        range = self.getSelectionRange();
                        range.deleteContents();
                    }
                } catch (err) {}
            },
            wzBold: function() {
                this._exec(CLASSES.BOLD);
            },
            wzItalic: function() {
                this._exec(CLASSES.ITALIC);
            },
            wzUnderline: function() {
                this._exec(CLASSES.UNDERLINE);
            },
            wzStrikethrough: function() {
                this._exec(CLASSES.STRIKETHROUGH);
            },

            wzClick: function() {
                this._wzClick(null);
            },



            wzCreateLink: function(linkObj) {
                this.setDirtyRange();
                this.select(function() {
                    var linkId, node = this.getElement(), isCollapsed = this.isCollapsed();

                    if (isCollapsed) {
                        if (!node || node.tagName !== 'A') 
                            return false;
                        this.selectNode(node);
                    }
                    var href = typeof linkObj.url === "string" && linkObj.url ? linkObj.url : "#";
                    this.exec('CreateLink', href);

                    // Firefox doesn't wrap link inside range properly after CreateLink
                    node = this.getElement();
                    if (node.nodeName !== "A") {
                        var r = this.getSelectionRange();
                        if (r.endContainer.nodeName === "A") {
                            node = r.endContainer;
                        } else if (r.endContainer.parentNode.nodeName === "A") {
                            node = r.endContainer.parentNode;
                        } else {
                            node = $(node).find('a');
                            if (node.length === 0) {
                                return false;
                            }
                            node = node.get(0);
                        }
                    }

                    // stores link information with its id in the markup as the key
                    // linkID is either passed in, preexisting, or generated (in that order)
                    linkId = linkObj.id || (node && node.tagName === 'A' && node.id) || this.generateId();
                    node.id = linkId;
                    this.data.linksData[linkId] = linkObj;

                    this.selectNode(node);
                    this.trigger("linkCreated", {
                        node: node,
                        data: linkObj
                    });

                    try {
                        this.trigger('linkChange', linkObj);
                        this.trigger('rangeChange');
                    } catch (err) {
                        _log("warn", err);
                    }
                });
            },


            wzRemoveLink: function() {
                var node = this.getElement();

                try {
                    if (node.tagName === 'A') {
                        var nodeId = node.id;
                        if (nodeId && this.data.linksData[nodeId]) {
                            delete this.data.linksData[nodeId];
                        }

                        this.selectNode(node);
                        this.exec('unlink');
                        this.trigger('linkChange');
                        this.trigger('rangeChange');
                    }
                } catch (err) {
                    _log("warn", err);
                }
            },


            wzBlockquote: function(which) {
                var $n = $(this.getNode()), $list = $n.parents('ol,ul').first(), $block;

                if ($list.length) {
                    // if we're in a list, let contenteditable handle list creation
                    document.execCommand(which, true, true);
                } else {
                    var selection = rangy.saveSelection();
                    if (which === "indent") {
                        $block = $n.parents('p,div').first();
                        if ($block[0] === this.el) {
                            $block.html("<p>" + $block.html() + "</p>");
                            $block = $block.children('p');
                        }
                        $block.wrap("<blockquote/>");
                    } else if (which === "outdent") {
                        $block = $n.parents('blockquote').first();
                        $block.before($block.html());
                        $block.remove();
                    }
                    rangy.restoreSelection(selection);
                    rangy.removeMarkers(selection);
                }
            }
        });

        this.preProcess();
    });






    /* Object.create is native, but not in older browsers */
    if (typeof Object.create !== "function") {
        Object.create = (function () {
            var F = function() {};
            return function (o) {
                F.prototype = o;
                return new F();
            };
        })();
    }

    // The jQuery plugin
    $.fn.wizzy = function(method) {
        return this.each(function() {
            var $this = $(this),
            w = $this.data('wizzy');

            if (w) {
                _log("warn", "Wizzy called on an element that already has wizzy!");
            } else {
                w = Object.create(Wizzy);
                w.init($this, method);
                w.extend("RangeExec"); // Add the RangeExec plugin

                $this.data('wizzy', w);
            }
        });
    };


    return {
        register: register,
        plugins: plugins,
        utils: utils
    };
});

define('internal/sitebuilder/builder/wizzy.ui', [
'jquery',
'internal/sitebuilder/builder/wizzy'
], function($, Wizzy) {

    // Link tooltip
    var $linkHoverText = $('<a/>').addClass('w-wizzy-anchor-text').html("http://"),
    $linkHoverChange = $('<a/>').addClass('w-wizzy-anchor-change').html("Change").attr("title", "Change Link"),
    $linkHoverRemove = $('<a/>').addClass('w-wizzy-anchor-remove').html("Remove").attr("title", "Remove Link"),
    $linkHover = $('<div/>').addClass('w-wizzy-anchor').append(
    "Go to link: ", $linkHoverText, ' - ',
    $linkHoverChange, ' - ', $linkHoverRemove
    );


    /**
     * Plugin to hook UI into Wizzy editor
     * {param} object - instance of wizzy
     * {param} object {
     *    toolbar:    required toolbar instance
     * }
     */
    Wizzy.register('ui', function(arg) {
        var
        w = this,
        tb = [],
        toolbar = arg.toolbar,
        $toolbar = arg.ui ? arg.ui : arg.toolbar.get$Toolbar(),
        // Flags
        enableTypefaceUpdate = arg.enableTypefaceUpdate || false,
        enableAlignment = typeof arg.enableAlignment !== "undefined" ? arg.enableAlignment : true,
        iDropper = toolbar.find('.w-tbui-wzForeColor').data('iDropper'),
        colorState = toolbar.find('.w-icon-text_color .w-colorstate'),
        linkGroup = toolbar.find('.w-wizzy-linkgroup'),
        linkButton = linkGroup.find('.w-wizzy-linkbutton'),
        unlinkButton = linkGroup.find('.w-icon-unlink'),
        fontsDropdown = toolbar.getElement('Fonts Dropdown'),
        fontsController = fontsDropdown.data('dropdown'),
        chromeController = parent.require('internal/sitebuilder/builderChrome/chromeController'),
        $canvasDoc = parent.bldr.pageController.dom.$doc,
        $chromeDoc,
        insideIframe = true,
        range;

        if (chromeController.dom) 
            $chromeDoc = chromeController.dom.doc;
        else 
            $chromeDoc = $(document);

        /**
        	 * For exec commands triggered by the UI that requires more than one click
        	 * Color picker, for example, requires a click to open menu and another to select color.
        	 * The first click will clear the selection in IE. We need to manually setRange when
        	 * we lose focus to the iframe as to preserve our most recent selection
        	 */
        $chromeDoc.bind('mousedown.wizzyui', function() {
            w.setDirtyRange();
            w.select();
        });

        // Handles link creation
        // cloned from handlebars.helpers.js
        var renderLinkAttributes = function(linkInfo) {
            var href, classes = [], attributes = '';

            if (linkInfo.lightbox) {
                if (linkInfo.enabled)
                    href = "#";
            } else if (linkInfo.url) {
                href = linkInfo.url;
            } else if (linkInfo.email) {
                href = "mailto:" + linkInfo.email;
            }

            if (href && typeof Handlebars !== "undefined") 
                href = Handlebars.Utils.escapeExpression(href);
            if (linkInfo.newWindow) 
                classes.push("w-link-new-window");

            if (href) 
                attributes += ' href="' + href + '"';

            return {
                href: href,
                classes: classes
            };
        };
        var linkCreated = function(e, linkObj) {
            var linkInfo = linkObj.data;
            var linkAttrs = renderLinkAttributes(linkInfo);
            var $node = $(linkObj.node);
            $node.attr("href", linkAttrs.href).addClass(linkAttrs.classes.join(" "));
            $node.data("disableLink", true);
        };
        this.$el.find(".w-link-new-window").data("disableLink", true);

        // Link and Unlink buttons and tooltip
        $linkHover.appendTo(w.$body).removeClass("active").unbind('mousedown').mousedown(function() {
            return false;
        });
        var updateLinkIndicator = function(node) {
            if (linkGroup.length) {
                var isOverAnchor = node && node.tagName && node.tagName.toLowerCase() === "a";
                if (!isOverAnchor) 
                    isOverAnchor = node = $(node).parents('a')[0];
                if (isOverAnchor) {
                    toolbar.show({
                        "wzLink": w.data.linksData[node.id]
                    });
                    linkGroup.removeClass('canceled');

                    var $node = $(node),
                    nodeOffset = $node.offset(),
                    anchorUrl = node.href.length < 45 ? node.href : node.href.substr(0, 43) + '...',
                    left = nodeOffset.left - 10, top = nodeOffset.top + $node.height(),
                    linkHoverWidth, LinkHoverOffset, boundaryWidth;

                    $linkHoverText
                    .html(anchorUrl)
                    .attr('title', node.href)
                    .unbind('mousedown').mousedown(function() {
                        window.open(anchorUrl, node.id || '_new');
                    });

                    // Place linkHover in view to calculate correct width and viewport boundaries
                    $linkHover.addClass('active'); // This causes linkHover to flicker on cursor changes .css({ left: 0, top: 0});
                    (function() {
                        linkHoverWidth = $linkHover.width();
                        linkHoverOffset = nodeOffset.left;
                        boundaryWidth = parent.require('internal/sitebuilder/builderChrome/chromeController').pageBoundary.width;
                        if (boundaryWidth && linkHoverWidth + linkHoverOffset > boundaryWidth) {
                            left = boundaryWidth - linkHoverWidth - $node.width();
                        }
                        $linkHover.css({
                            left: left,
                            top: top
                        });
                    }).deferFn();
                } else {
                    toolbar.show({
                        "wzLink": {}
                    });
                    linkGroup.addClass('canceled');

                    $linkHover.removeClass('active');
                }
                linkButton.removeClass('active');
            }
        };

        // setting the correct typeface in the dropdown
        var updateDropdownTypeface = function(node) {
            if (enableTypefaceUpdate && fontsDropdown && fontsController) {
                if (node && node.tagName.toLowerCase() === "font") {
                    var face = node.getAttribute("face");

                    if (face) {
                        fontsController.setOption(face.replace(/'/g, ''));
                    } else {
                        updateDropdownTypeface(node.parentElement);
                    }
                } else {
                    fontsController.setOption('inherit');
                }
            }
        };

        // Filters out icons that have bidirectional relationship with content-editable
        $toolbar.find('a.w-btn-icon').each(function() {
            var $self = $(this),
            prefix = 'w-icon-';

            if ($self.hasClass(prefix + 'bold')) {
                tb['bold'] = $self;
            } else if ($self.hasClass(prefix + 'italic')) {
                tb['italic'] = $self;
            } else if ($self.hasClass(prefix + 'underline')) {
                tb['underline'] = $self;
            } else if ($self.hasClass(prefix + 'strike')) {
                tb['Strikethrough'] = $self;
            }

            if (enableAlignment) {
                if ($self.hasClass(prefix + 'align_left')) {
                    tb['JustifyLeft'] = $self;
                } else if ($self.hasClass(prefix + 'align_center')) {
                    tb['JustifyCenter'] = $self;
                } else if ($self.hasClass(prefix + 'align_right')) {
                    tb['JustifyRight'] = $self;
                } else if ($self.hasClass(prefix + 'align_justify')) {
                    tb['JustifyFull'] = $self;
                }
            }
        });

        var rangeChange = function() {
            $linkHoverChange.unbind('mousedown').mousedown( function() {
                linkButton.click();
            });
            $linkHoverRemove.unbind('mousedown').mousedown( function() {
                unlinkButton.click();
            });

            var node = w.getElement();

            // Font Color
            var color = w.queryColorFix(document.queryCommandValue("ForeColor"));
            iDropper.set(color, true);
            colorState.css('background-color', color);

            updateLinkIndicator(node);

            updateDropdownTypeface(node);

            // Updates UI with proper statead
            var states = ['bold', 'italic', 'underline', 'Strikethrough', 'JustifyLeft', 'JustifyCenter', 'JustifyRight', 'JustifyFull'];
            for (var id in states) {
                if (tb[states[id]]) {
                    if (document.queryCommandState(states[id])) {
                        tb[states[id]].addClass('active');
                    } else {
                        tb[states[id]].removeClass('active');
                    }
                }
            }
        };

        var trackCursor = $('<span style="display:inline !important;"></span>');
        var rangeFocus = function(e) {
            var $win = parent.bldr.pageController.dom.$win;
            var cc = parent.require('internal/sitebuilder/builderChrome/chromeController');
            var range;
            try {
                range = w.getSelectionRange();
                if (range && cc) {
                    range.collapse(false);
                    range.insertNode(trackCursor[0]);

                    var caretTop = cc.iframeAbsY(trackCursor.offset().top);
                    var iframeHeight = cc.pageBoundary.bottom;
                    var caretMaxY = iframeHeight - 100;
                    trackCursor.remove();

                    if (caretTop > caretMaxY) {
                        $win.scrollTop($win.scrollTop() + (caretTop - caretMaxY));
                    }
                }
            } catch (err) {}
        };

        w.bind('show', rangeChange);
        w.bind('rangeChange', rangeChange);
        w.bind('linkCreated', linkCreated);
        w.bind('keyUp', rangeFocus);
        w.bind('hide', function() {
            $linkHover.removeClass('active');
        });
        w.bind('destroy', function() {
            $linkHover.removeClass('active');
            $canvasDoc.unbind('mousedown.wizzyui');
            $chromeDoc.unbind('mousedown.wizzyui');
        });

        return true;
    });

});
/* jshint ignore:start */
define('internal/sitebuilder/builder/htmlParser', [
'spine',
'internal/sitebuilder/common/log'
], function(Spine, log) {

    var HtmlParser = Spine.Class.create({
        init: function(source, options) {
            this.source = this.originalSource = source;
            this.options = options;
            this.queue = [];
        },

        readTree: function() {
            var token = this.next();
            if (!token) 
                return null;
            if (token.endTag) {
                this.requeue(token);
                return null;
            }
            var continueParsing;
            if (!(token.type === "text" || token.type === "comment" || token.selfClosing)) {
                token.children = [];
                var child;
                var closing;
                continueParsing = true;
                while (continueParsing) {
                    while (child = this.readTree()) {
                        token.children.push(child);
                    }
                    closing = this.next();
                    if (!closing || !(closing.endTag) || !(closing.tagName === token.tagName)) {
                        if (closing) {
                            if (!this.canIgnoreClosingTag(token, closing)) {
                                this.requeue(closing);
                                continueParsing = false;
                            }
                        } else {
                            continueParsing = false;
                        }
                    } else {
                        continueParsing = false;
                    }
                }
            }
            if (this.options.supportLists && token.type === "comment" && token.content === "<![if !supportLists]>") {
                // Ignore everything until <![endif]>
                // Perhaps we should be keeping account of the nesting of <![if ???]><![endif]> tags?
                while (token = this.next()) {
                    if (token.type === "comment" && token.content === "<![endif]>")
                        return this.readTree();
                }
            }
            return token;
        },

        requeue: function(token) {
            this.queue.push(token);
        },

        parseStyleRules: function(text) {
            var matches, styles = {};
            while (text && (matches = text.match(/^\s*([^:\s]*)\s*:\s*([^;]*)\s*;?\s*([\s\S]*)$/))) {
                text = matches[3];
                styles[matches[1]] = matches[2];
            }
            return styles;
        },

        next: function() {
            if (this.queue.length > 0) {
                token = this.queue.shift();
                return token;
            }
            if (this.source == "") 
                return null;
            var token = null, matches;
            if (matches = this.source.match(this.patterns.tag)) {
                var tag = matches[1];
                this.source = matches[2];
                matches = tag.match(/^<(\/?)((?:(?:\w|\-)+:)?\w+)([\s\S]*)\s*(\/?)\s*>$/);
                var endTag = matches[1] === "/";
                var selfClosing = matches[4] === "/";
                var tagName = matches[2].toLowerCase();
                var tagAttrs = matches[3];
                var attrs = {};
                while (matches = tagAttrs.match(/^\s*((?:(?:\w|\-)*:)?(?:\w|\-)+)(?:\s*=\s*((?:(?:\"[^\"]*\")|(?:\'[^\']*\')|(?:[^\s\/\>]*))))?([\s\S]*)$/)) {
                    var value = matches[2] || "";
                    value = value.replace(/\"(.*)\"/, "$1").replace(/'(.*)\'/, "$1");
                    attrs[matches[1]] = value;
                    tagAttrs = matches[3];
                }
                if ("style" in attrs) {
                    var styleSource = attrs.style;
                    if (matches = styleSource.match(/^\"([\s\S]*)\"$/)) 
                        styleSource = matches[1];
                    if (matches = styleSource.match(/^\'([\s\S]*)\'$/)) 
                        styleSource = matches[1];
                    attrs.style = this.parseStyleRules(styleSource);
                }
                if (this.selfClosingTags.indexOf(tagName) != - 1) 
                    selfClosing = true;
                token = {
                    type: "tag",
                    tagName: tagName,
                    selfClosing: selfClosing,
                    endTag: endTag,
                    attrs: attrs,
                    originalSource: tag
                };
            } else if (matches = this.source.match(this.patterns.comment)) {
                this.source = matches[2];
                token = {
                    type: "comment",
                    content: matches[1],
                    originalSource: matches[1]
                };
            } else if (matches = this.source.match(this.patterns.text)) {
                this.source = matches[2];
                token = {
                    type: "text",
                    content: matches[1],
                    originalSource: matches[1]
                };
            } else if (matches = this.source.match(this.patterns.xml)) {
                this.source = matches[2];
                return this.next();
            } else {
                log.trigger("htmlParser", "error", "Error parsing: " + this.source);
                this.source = "";
            }
            return token;
        },

        /*
        	 * Using REGEX for HTML parsing, even though someone felt the need to write the following:
        	 * http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454
        	 */
        patterns: {
            xml: /^(<\?xml[^>]*>)([\s\S]*)$/,
            tag: /^(<\/?(?:(?:\w|\-)*:)?\w+(?:\s+(?:(?:\w|\-)+:)?(?:\w|\-)+(?:\s*=\s*(?:(?:\"[^\"]*\")|(?:\'[^\']*\')|(?:[^\s\/\>]*))))*\s*(?:\/?)\s*>)([\s\S]*)$/,
            comment: /^(<!(?:(?:--(?:[^-]|(?:-[^-]))*--)|(?:[^>-]|(?:-[^->]))|(?:\[[\w]+]--))*>)([\s\S]*)$/,
            text: /^([^<]+)([\s\S]*)$/
        },

        selfClosingTags: ["img", "br", "wbr", "hr", "meta", "link", "input", "area", "base", "basefont", "col", "frame", "param"],

        canIgnoreClosingTag: function(parent, child) {
            if (child.tagName === "font") 
                return true;
            return false;
        }

    });

    return HtmlParser;

});
/* jshint ignore:end */
;
/* jshint ignore:start */
define('internal/sitebuilder/builder/wizzy.paste', [
'jquery',
'spine',
'internal/sitebuilder/builder/htmlParser',
'internal/sitebuilder/builder/wizzy'
], function($, Spine, htmlParser, Wizzy) {

    var PasteFromWord = Spine.Class.create({
        init: function(source, linksData) {
            this.listRules = {};
            this.linksData = linksData;
            this.originalSource = source;
            this.tokenizer = htmlParser.init(source, {
                supportLists: true
            });
        },

        pasteToWizzy: function(wizzy) {
            var range = wizzy.getRange(),
            self = this;
            var pasteDeferred = $.Deferred();
            this.process(function(generatedHtml) {
                if (generatedHtml === "") {
                    pasteDeferred.resolve();
                    return;
                }
                range.deleteContents();
                wizzy.insertHTML(generatedHtml + "<span id='pasteKaret'></span>", true);
                range.selectNode($("#pasteKaret").removeAttr("id")[0]);
                wizzy.selectRange(range);
                pasteDeferred.resolve();
            });
            return pasteDeferred.promise();
        },

        process: function(callback) {
            this.list = {
                l: 0,
                level: 0,
                closers: []
            };
            var tree,
            text = "",
            keepGoing = true,
            token;
            while (keepGoing) {
                while (keepGoing && (tree = this.tokenizer.readTree())) {
                    text += this.treeToHtml(tree, "");
                    if (tree.type == "tag" && tree.tagName == "html") {
                        keepGoing = false;
                    }
                }
                if (keepGoing) {
                    token = this.tokenizer.next();
                    while (token && token.endTag)
                        token = this.tokenizer.next();
                    if (token)
                        this.tokenizer.requeue(token);
                    else
                        keepGoing = false;
                }
            }
            if (typeof callback === "function")
                callback(text);
            return text;
        },

        treeToHtml: function(tree, parentClasses) {
            var self = this;
            if (tree.type == "text") {
                if (tree.content.match(/^\s*$/)) 
                    return " ";
                return tree.content;
            }
            if (tree.type == "comment") 
                return "";
            var buffer = "";
            var clazz = "";
            var fontSize, fontColor;
            var childHTML = "";
            var tagHTML = "";
            switch (tree.tagName) {
            case "style":
                this.processStyleTag(tree);
            case "meta":
            case "link":
            case "o:p":
                return "";
            case "br":
                return "<br/>";
            case "table":
                // TODO: do this
                return "[[PASTING TABLES IS NOT SUPPORTED]]";
            case "b":
            case "i":
            case "u":
            case "s":
                clazz = this.tagReplacementClasses[tree.tagName];
                if (parentClasses.indexOf(clazz) != - 1)
                    clazz = "";
                childHTML = this.childrenToHtml(tree, parentClasses + " " + clazz);
                if (childHTML != "")
                    return '<span class="' + clazz + '">' + childHTML + "</span>";
                else
                    return "";
            case "p":
                // check if we're dealing with a list element
                if ("style" in tree.attrs && "mso-list" in tree.attrs.style) {
                    buffer = "";
                    var listLevel = this.list.level;
                    if (matches = tree.attrs.style["mso-list"].match(/^\s*l(\d+)\s+level(\d+)\s+\w+$/)) {
                        listL = matches[1];
                        listLevel = matches[2];
                    }
                    if (listL != this.list.l) {
                        var closer;
                        while (closer = this.list.closers.pop())
                            buffer += closer;
                        this.list.l = listL;
                        this.list.level = 0;
                    }
                    while (listLevel > this.list.level) {
                        ++this.list.level;
                        var opener, closer;
                        opener = '<ol class="style-decimal">';
                        closer = '</ol>';
                        var listRule = this.listRules[this.list.l] && this.listRules[this.list.l][this.list.level];
                        if (!listRule) {} else if (listRule["mso-level-text"] === "o") {
                            opener = '<ul class="style-circle">';
                            closer = "</ul>";
                        } else if (listRule["mso-level-text"]) {
                            opener = "<ul class='style-decimal'>";
                            closer = "</ul>";
                        } else if (listRule["mso-level-number-format"]) {
                            switch (listRule["mso-level-number-format"]) {
                            case "roman-upper":
                                opener = '<ol class="style-upper-roman">';
                                closer = '</ol>';
                                break;
                            case "roman-lower":
                                opener = '<ol class="style-lower-roman">';
                                closer = '</ol>';
                                break;
                            case "alpha-upper":
                                opener = '<ol class="style-upper-alpha">';
                                closer = '</ol>';
                                break;
                            case "alpha-lower":
                                opener = '<ol class="style-lower-alpha">';
                                closer = '</ol>';
                                break;
                            }
                        }
                        buffer += opener;
                        this.list.closers.push(closer);
                    }
                    while (listLevel < this.list.level) {
                        --this.list.level;
                        buffer += this.list.closers.pop();
                    }
                    childHTML = this.childrenToHtml(tree, parentClasses);
                    return buffer + "<li>" + childHTML + "</li>";
                }

            case "ul":
            case "ol":
                if (tree.attrs["class"] && tree.attrs["class"].match(this.allowedListClasses)) {
                    clazz = tree.attrs["class"];
                } else if (tree.tagName == "ul" || tree.tagName == "ol") {
                    clazz = tree.tagName == "ul" ? "style-circle" : "style-text";
                }

                var closer;
                while (closer = this.list.closers.pop())
                    buffer += closer;
                this.list.level = 0;

            case "li":
            case "span":
                if (tree.attrs["style"] && tree.attrs["style"]["mso-list"] == 'Ignore')
                    return "";
            case "div":
            case "blockquote":
                tagHTML = "";
                if (tree.attrs["class"]) {
                    $.each(tree.attrs["class"].split(/\s+/), function(i, clazzItem) {
                        if (clazzItem.match(self.wizzyClassNames) && parentClasses.indexOf(clazzItem) == - 1)
                            clazz += " " + clazzItem;
                    });
                }
                var styles = "";
                if ("style" in tree.attrs) {
                    $.each(tree.attrs.style, function(key, value) {
                        if (key == "font-weight") {
                            if (value == "bold" && clazz.indexOf("wz-bold") == - 1 && parentClasses.indexOf("wz-bold") == - 1) {
                                clazz += " wz-bold";
                            }
                        } else if (key == "font-style") {
                            if (value == "italic" && clazz.indexOf("wz-italic") == - 1 && parentClasses.indexOf("wz-italic") == - 1) {
                                clazz += " wz-italic";
                            }
                        } else if (key == "text-decoration") {
                            if (value.indexOf("underline") != - 1 && clazz.indexOf("wz-underline") == - 1 && parentClasses.indexOf("wz-underline") == - 1) {
                                clazz += " wz-underline";
                            }
                            if (value.indexOf("line-through") != - 1 && clazz.indexOf("wz-strikethrough") == - 1 && parentClasses.indexOf("wz-strikethrough") == - 1) {
                                clazz += " wz-ztrikethrough";
                            }
                        } else if (key.match(self.allowedStyleRules)) {
                            styles += key + ": " + value + "; ";
                        }
                    });
                }
                var startTag, endTag;
                startTag = "", endTag = "";
                if (tree.tagName != "span" || styles != "" || clazz != "" || tree.attrs["id"]) {
                    startTag = '<' + tree.tagName;
                    if (tree.attrs["id"])
                        startTag += " id='" + tree.attrs["id"] + "'";
                    if (styles != "") {
                        if (styles.match(/\"/))
                            startTag += " style='" + styles + "'";
                        else
                            startTag += " style=\"" + styles + "\"";
                    }
                    if (clazz != "")
                        startTag += " class='" + clazz + "'";
                    startTag += ">";
                    endTag = "</" + tree.tagName + ">";
                }
                childHTML = this.childrenToHtml(tree, parentClasses + " " + clazz);
                if ((typeof childHTML === "string" && childHTML.length > 0) || tree.attrs["id"]) {
                    tagHTML += startTag + childHTML + endTag;
                }
                return buffer + tagHTML;

            case "a":
                var url = tree.attrs.href;

                // Whitelist for classes we will allow to be pasted.
                var allowedLinkClasses = [
                "w-link-new-window"
                ];

                // We want to maintain the classes if they are there.
                var linkClasses = (tree.attrs['class'] || "").split(" "),
                newClasses = "",
                classAttr = "";

                // Loop through the whitelist and keep classes we allow.
                for (var i = 0; i < allowedLinkClasses.length; i++) {
                    if (linkClasses.indexOf(allowedLinkClasses[i]) != - 1) {
                        newClasses += allowedLinkClasses[i] + " ";
                    }
                }

                // If any of the classes were whitelisted, construct the class attribute.
                if (newClasses != "") {
                    classAttr = 'class="' + newClasses + '"';
                }

                // If we know abotu this link, reconstruct it, otherwise, make a new
                // linksData entry and construct it.
                if (tree.attrs.id && tree.attrs.id in this.linksData) {
                    return buffer + '<a ' + classAttr + ' id="' + tree.attrs.id + '" href="' + url + '">' + this.childrenToHtml(tree, parentClasses) + "</a>";
                } else if (url && !url.match(/^javascript:/)) {
                    var linkId = Spine.guid();
                    this.linksData[linkId] = {
                        tab: "webpage",
                        subtab: "other-site",
                        url: url
                    };

                    // Maintain the new window property for the editor.
                    if (linkClasses.indexOf("w-link-new-window") != - 1) {
                        this.linksData[linkId].newWindow = true;
                    }
                    return buffer + '<a ' + classAttr + ' href="' + url + '" id="' + linkId + '">' + this.childrenToHtml(tree, parentClasses) + "</a>";
                } else {
                    return buffer + this.childrenToHtml(tree, parentClasses);
                }
                break;
            case "font":
                return this.childrenToHtml(tree, parentClasses);
            default:
                // Keep the children, but don't spit out this unknown tag
                return buffer + this.childrenToHtml(tree, parentClasses);
            }
        },

        childrenToHtml: function(tree, parentClasses) {
            if (!tree || !tree.children || tree.children.length < 1) 
                return "";
            var self = this;
            return $.map(tree.children, function(child) {
                return self.treeToHtml(child, parentClasses);
            }).join("");
        },

        tagReplacementClasses: {
            'b': "wz-bold",
            'i': "wz-italic",
            "u": "wz-underline",
            "s": "wz-strikethrough;"
        },

        allowedListClasses: /^style-(disc|circle|square|decimal|upper-alpha|lower-alpha|upper-roman|lower-roman)$/,
        allowedStyleRules: /^(text-align)$/,
        wizzyClassNames: /^wz-/,

        processStyleTag: function(tree) {
            var self = this;
            $.each(tree.children, function(index, tag) {
                if (!tag || !tag.content) 
                    return;
                var content = tag.content.substr(tag.content.indexOf("@list"));
                var matches;
                while (matches = content.match(/@list\s*l(\d+)(?::level(\d+))?\s*{([^}]*)}\s*([\s\S]*)$/)) {
                    content = matches[4];
                    var l = matches[1],
                    level = matches[2],
                    style = htmlParser.fn.parseStyleRules(matches[3]);
                    (self.listRules[l] || (self.listRules[l] = {}))[level] = style;
                }
            });
        }

    });

    Wizzy.register('paste', function(opts) {
        var w = this;
        function tidyUp() {
            setTimeout(function() {
                w.setDirtyRange();
                w.select(function() {
                    var id = "w-p-id-" + parseInt( + new Date());
                    var range = w.getRange();
                    w.insertHTML("<span id=" + id + "></span>");
                    PasteFromWord.init($(w.el).html(), w.data.linksData).process(function(generatedHTML) {
                        $(w.el).html(generatedHTML);
                        var karet = $(w.el).find("#" + id);
                        range = w.getRange();
                        range.selectNode(karet[0]);
                        w.selectRange(range);
                        w.setDirtyRange();
                        w.select(function() {
                            karet.attr("id", "");
                        });
                    });
                });
            }, 1);
        };
        // Post-process after drop events.
        $(this.el).bind("dragdrop drop", tidyUp);
        if ($.browser.mozilla) {
            // Firefox doesn't give you access to the clipboard, nor does it let you redirect a paste event
            // We should let the paste proceed, and then clean up the entire wizzy.
            $(this.el).bind("paste", tidyUp);
        } else {
            $(w.el).bind("beforepaste", function(e) {
                return false;
            });
            $(w.el).bind("paste", function(e) {
                var sourceHtml = null;
                var range;
                if (e.originalEvent.clipboardData && e.originalEvent.clipboardData.getData) {
                    if (opts.plainText) {
                        sourceHtml = e.originalEvent.clipboardData.getData('text/plain').replace(/\n/g, "<br/>");
                    } else {
                        sourceHtml = e.originalEvent.clipboardData.getData('text/html');
                    }
                    if (sourceHtml && sourceHtml.length > 0) {
                        w.setDirtyRange();
                        w.select(function() {
                            range = w.getRange();
                            PasteFromWord.init(sourceHtml, w.data.linksData).pasteToWizzy(w).done(tidyUp);
                        });
                        return false;
                    }
                }

                var iframe = $("<iframe/>").css({
                    "position": "absolute",
                    "left": "-9999px"
                });
                $(w.el).before(iframe);
                ifrm = iframe[0]
                var pasteTarget = undefined;
                var idoc = ((ifrm.contentWindow) ?
                ifrm.contentWindow :
                (ifrm.contentDocument.document) ?
                ifrm.contentDocument.document :
                ifrm.contentDocument
                ).document;
                idoc.open();
                idoc.write('<body contenteditable="true" designMode="on"></body>');
                idoc.close();
                pasteTarget = idoc.body;

                w.setDirtyRange();
                range = w.getRange();
                pasteTarget.innerHTML = "";
                pasteTarget.focus();
                setTimeout(function() {
                    w.setDirtyRange();
                    w.select(function() {
                        $(w.el).focus();
                        w.selectRange(range);
                        if (opts.plainText) {
                            sourceHtml = pasteTarget.innerText.replace(/\n/g, "<br/>");
                        } else {
                            sourceHtml = pasteTarget.innerHTML;
                        }
                        iframe.remove();
                        PasteFromWord.init(sourceHtml, w.data.linksData).pasteToWizzy(w).done(tidyUp);
                    });
                }, 1);

            });
        }
    });

});
/* jshint ignore:end */
;
define('webs/props', [], function () {

    var props = window.webs && window.webs.props;

    if (!props) {
        try {
            if (typeof top.webs.props !== "undefined") {
                props = top.webs.props;
            } else {
                props = {}; // initialize to an empty object if it doesn't exist
            }
        } catch (error) {
            props = {}; // initialize to an empty object if it doesn't exist
        }
    }

    props.imageProcessorServer = props.imageProcessorServer || 'http://imageprocessor.websimages.com';

    return props;
});

define('internal/sitebuilder/builderChrome/imageManipulation', [
'webs/props'],
function(props) {

    var url = 'http://imageprocessor.websimages.com';
    if (props.imageProcessorServer) {
        url = props.imageProcessorServer;
    }

    var width = 1920,
    height = 1920;

    return {
        getImageUrl: function(imageObj) {
            var imageUrl = imageObj.url;
            if (imageObj.imageType == 'webs') {
                imageUrl = url + "/fit/" + width + "x" + height + imageObj.url.replace(/https?:\/\//i, '/');
            }
            return imageUrl;
        }
    };
});

define('internal/sitebuilder/common/fontsController', [
'/s/sitebuilder/api/fonts?callback=define',
'jquery',
'spine'
], function(fonts, $, Spine) {
    var FontsController = Spine.Controller.create({
        init: function(opts) {
            /* jshint ignore:start */
            this.fonts = fonts.fonts,
            this.fontsBySlug;
            /* jshint ignore:end */
        },

        fixEl: function() {
            var doc = this.el[0].ownerDocument;
            var win = 'defaultView' in doc ? doc.defaultView : doc.parentWindow;
            if (win === top) {
                if (frames['website'] && frames['website'].$) {
                    this.el = frames['website'].$('head');
                }

                // Retrieving this.el(head) for firefox.
                var editFrame = document.getElementById("website");
                if (editFrame && editFrame.nodeName === "IFRAME") {
                    if (editFrame.contentWindow && editFrame.contentWindow.jQuery) {
                        this.el = editFrame.contentWindow.jQuery("head");
                    }
                }
            }
        },

        getFontsBySlug: function() {
            if (typeof(this.fontsBySlug) === 'undefined') {
                var fonts = this.fonts,
                len = fonts.length,
                fontsBySlug = {};

                for (var i = 0; i < len; i++) {
                    var font = fonts[i];
                    fontsBySlug[font.slug] = font;
                }
                this.fontsBySlug = fontsBySlug;
            }
            return this.fontsBySlug;
        },

        getFont: function(fontSlug) {
            return this.getFontsBySlug()[fontSlug];
        },

        loadFont: function(fontSlug) {
            var font = this.getFont(fontSlug);
            //Font doesn't exist
            if (!font) {
                return false;
            }
            this._loadFont(font);
            return true;
        },

        _loadFont: function(font) {
            this.fixEl();
            if (font.source === 'google') {
                this.el.append(
                '<link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=' +
                font.name.replace(' ', '+') + ':' + font.weights.join(',') + '"/>');
            }
            this.el.append('<style type="text/css">' + font.css + '</style>');
            font.loaded = true;
            this.trigger("fontLoaded", font);

            return true;
        },

        isFontPublic: function(slug) {
            var font = this.getFont(slug),
            ret = false;

            if (typeof(font) !== "undefined" && font["public"]) {
                ret = true;
            }

            return ret;
        }
    });

    return FontsController.init({
        el: (frames['website'] && frames['website'].$ ? frames['website'].$('head') : $('head')) 
    });
});
define('internal/sitebuilder/common/ThemeVariable', [
'internal/sitebuilder/designerChrome/Backgrounds',
'internal/sitebuilder/common/VariableArea',
'jquery',
'spine',
'iDropper',
'internal/sitebuilder/common/fontsController'
], function(Backgrounds, VariableArea, $, Spine) {

    var dsnr = window.dsnr ? window.dsnr : (window.dsnr = {});

    /*
     * THEME VARIABLE
     *
     * Models a changeable style on the user's site. Each theme defines
     * a set of allowed variables (and default values), and this class
     * represents the variable from the theme, and the current value
     * for this user's site.
     *
     * NOTE: Spine models don't deal with subclassing very well. The
     * parent class is just code shared between the two children. You
     * can't get instances of the child classes by querying the parent.
     */
    dsnr.ThemeVariable = Spine.Model.setup("ThemeVariable", ["theme", "type", "area", "slug", "name", "hidden"]);

    dsnr.ThemeVariable.extend({
        findBySlug: function(slug) {
            return this.select(function(tv) {
                return tv.slug == slug;
            });
        },

        // Persistence: we don't quite follow Spine's ajax strategy.
        // We save things locally when changed, and only fetch once
        // and only saved when the user explicitly clicks the button.
        url: "/s/sitebuilder/design/variables",

        fetchFromRemote: function(themeSlug, callback) {
            var self = this,
            url = this.url,
            query = {};

            if (themeSlug) 
                query["theme"] = themeSlug;

            $.getJSON(url, query, function(data) {
                self.loadFromRemote(data, callback);
            });
        },
        fetchFromRemoteWithStyle: function(themeSlug, styleSlug, callback) {
            var self = this,
            url = this.url,
            query = {};
            if (themeSlug) 
                query["theme"] = themeSlug;
            if (styleSlug) 
                query["style"] = styleSlug;

            $.getJSON(url, query, function(data) {
                self.loadFromRemote(data, callback);
            });
        },
        saveToRemote: function() {
},

        typeToConstructor: {
            color: dsnr.ColorThemeVariable,
            background: dsnr.BackgroundThemeVariable
        },

        findOrFetchByTheme: function(themeSlug, callback) {
            var variables = this.findByTheme(themeSlug);
            if (variables.length > 0)
                callback(variables);
            else
                this.fetchFromRemote(themeSlug, callback);
        },

        findOrFetchByThemeAndStyle: function(themeSlug, styleSlug, callback) {
            var variables = this.findByThemeAndStyle(themeSlug, styleSlug);
            if (variables.length > 0)
                callback(variables);
            else
                this.fetchFromRemoteWithStyle(themeSlug, styleSlug, callback);
        },

        findByTheme: function(themeSlug) {
            var res = [];
            this.each(function(variable) {
                if (variable.themeSlug == themeSlug) 
                    res.push(variable);
            });
            return res;
        },
        findByThemeAndStyle: function(themeSlug, styleSlug) {
            var res = [];
            this.each(function(variable) {
                if (variable.themeSlug == themeSlug && variable.styleSlug == styleSlug) 
                    res.push(variable);
            });
            return res;
        },

        loadFromRemote: function(data, callback) {
            var self = this,
            themeSlug = data.theme,
            res = [];
            $.each(data.variables, function(i, record) {
                var fn = record.type == "background" ? dsnr.BackgroundThemeVariable : dsnr.ColorThemeVariable,
                model = fn.create(record);

                model.theme = themeSlug;
                res.push(model);

            });
            if (callback) 
                callback(res);
            return res;
        }
    });

    dsnr.ThemeVariable.include({
        // backward compatibility with 0.6
        initialize: function(opts) {
            this.load(opts);
        },

        init: function(opts) {
            if (opts.hidden) {
                this.areaModel = null;
            } else {
                this.areaModel = VariableArea.findOrCreate(opts.area, opts.type);
            }
        },

        defaultAttributes: function() {
            if (!App) 
                return {};
            else 
                return $.extend({}, App.site.style.variables[this.slug]);
        },

        userChanged: function() {
            var current = this.attributes(),
            defaults = this.defaultAttributes(),
            currentVal, defaultVal;
            for (var k in defaults) {
                if (defaults.hasOwnProperty(k)) {
                    currentVal = current[k];
                    defaultVal = defaults[k];

                    // If we are dealing with colors, make sure
                    // both values are in the same format before comparing
                    if (k === 'color') {
                        currentVal = $.fn.iDropper.RgbToHex(currentVal);
                        defaultVal = $.fn.iDropper.RgbToHex(defaultVal);
                    }

                    if (defaultVal && (currentVal != defaultVal)) {
                        return true;
                    }
                }
            }
            return false;
        }
    });

    dsnr.ColorThemeVariable = dsnr.ThemeVariable.setup("ColorThemeVariable",
    ["theme", "type", "area", "slug", "name",
    "color", "linkColor", "hoverColor", "lineHeight", "size", "font"]);



    dsnr.ColorThemeVariable.include({
        // For a theme variable, return an object of parsed less variables.
        // Optionally, merge these into an existing object.
        toLess: function(result) {
            if (typeof result != "object") 
                result = {};

            var slug = this.slug;

            if (this.type == "color")
                result[slug] = lessColor(this.color);

            if (this.color) 
                result[slug + '_color'] = lessColor(this.color);
            if (this.linkColor) 
                result[slug + '_link_color'] = lessColor(this.linkColor);
            if (this.hoverColor) 
                result[slug + '_hover_color'] = lessColor(this.hoverColor);
            if (this.font) 
                result[slug + '_font_family'] = lessFont(this.font);
            if (this.size) 
                result[slug + '_font_size'] = lessDimension(this.size);
            if (this.lineHeight) 
                result[slug + '_line_height'] = lessDimension(this.lineHeight);

            return result;
        }
    });

    dsnr.BackgroundThemeVariable = dsnr.ThemeVariable.setup("BackgroundThemeVariable",
    ["theme", "type", "area", "slug", "name",
    "color", "image", "imageType", "pattern", "texture"]);

    dsnr.BackgroundThemeVariable.include({
        toLess: function(result) {
            if (typeof result != "object") 
                result = {};

            var slug = this.slug;

            if (this.color) {
                result[slug + '_background_color'] = lessColor(this.color);
                result[slug + '_color'] = lessColor(this.color);
            }

            if (this.pattern || this.texture) {
                var type = this.pattern ? "pattern" : "texture",
                bgSlug = this.pattern || this.texture,
                bg = Backgrounds[type](bgSlug),
                url = bg ? bg.fullPath : "";

                result[slug + '_background_image'] = lessPath(url);
                result[slug + '_background_repeat'] = lessKeyword("repeat");
                result[slug + '_background_attachment'] = lessKeyword("scroll");
            } else if (this.image) {
                result[slug + '_background_image'] = lessPath(this.image.path || "");
                result[slug + '_background_repeat'] = lessKeyword(this.image.repeat || "repeat");
                // this should be the keyword "fixed" or "scroll"
                result[slug + '_background_attachment'] = lessKeyword(this.image.attachment || "scroll");
            } else {
                result[slug + '_background_image'] = lessPath("");
                result[slug + '_background_repeat'] = lessKeyword("repeat");
                result[slug + '_background_attachment'] = lessKeyword("scroll");
            }
            // FIXME: this was in the old code. Seems like it might be settable?
            result[slug + '_background_position_x'] = lessDimension("0");
            result[slug + '_background_position_y'] = lessDimension("0");
        },

        setPattern: function(slug) {
            this.updateAttributes({
                image: null,
                texture: null,
                pattern: slug 
            });
        },

        setTexture: function(slug) {
            this.updateAttributes({
                image: null,
                pattern: null,
                texture: slug 
            });
        },

        setImage: function(data) {
            this.updateAttributes({
                pattern: null,
                texture: null,
                image: data 
            });
        }

    });

    // Less helpers
    function lessPath(path) {
        // Backend has promised to give us an absolute url
        return new (less.tree.URL)(lessQuoted(path), []);
    }

    function lessColor(color) {
        if (color == "transparent") 
            return lessKeyword("transparent");

        // check for rgb/rgba
        var rgbMatch = color.match(/rgb(?:a?)\((.*)\)/);
        if (rgbMatch) {
            color = $.map(rgbMatch[1].split(','), parseFloat);
            var alpha = (color.length === 4) ? color.pop() : 1;
            return new (less.tree.Color)(color, alpha);
        }
        return new (less.tree.Color)(color.substring(1));
    }

    function lessQuoted(string) {
        return new (less.tree.Quoted)('"' + string + '"', string);
    }

    if (typeof(String.prototype.trim) === "undefined")
    {
        String.prototype.trim = function()
        {
            return String(this).replace(/^\s+|\s+$/g, '');
        };
    }

    function lessKeyword(string) {
        return new (less.tree.Keyword)(string);
    }

    // look up font slug, parse font names into less quoted values
    function lessFont(fontSlug) {
        var fontsController = require("internal/sitebuilder/common/fontsController"),
        fontDef = fontsController.getFont(fontSlug),
        fonts = fontDef && fontDef.fontFamily ? fontDef.fontFamily : "sans-serif",
        fontNames = $.map(fonts.split(","), function(fontName) {
            var trimmedName = fontName.trim(),
            quoted = trimmedName[0] == "'" || trimmedName[0] == '"',
            unquoted = quoted && trimmedName.substr(1, trimmedName.length - 2);

            if (quoted)
                return new (less.tree.Quoted)(trimmedName, unquoted);
            else
                return lessKeyword(trimmedName);
        });
        return new (less.tree.Value)(fontNames);
    }

    function lessDimension(val) {
        return new (less.tree.Dimension)(val, "px");
    }

    return dsnr.ThemeVariable;

});

//
// LESS - Leaner CSS v1.3.0
// http://lesscss.org
// 
// Copyright (c) 2009-2011, Alexis Sellier
// Licensed under the Apache 2.0 License.
//
(function(a, b) {
    function c(b) {
        return a.less[b.split("/")[1]]
    }
    function l() {
        var a = document.getElementsByTagName("style");
        for (var b = 0; b < a.length; b++)
            a[b].type.match(j) && (new d.Parser).parse(a[b].innerHTML || "", function(c, d) {
                var e = d.toCSS(), f = a[b];
                f.type = "text/css", f.styleSheet ? f.styleSheet.cssText = e : f.innerHTML = e
            })
    }
    function m(a, b) {
        for (var c = 0; c < d.sheets.length; c++)
            n(d.sheets[c], a, b, d.sheets.length - (c + 1))
    }
    function n(b, c, e, f) {
        var h = a.location.href.replace(/[#?].*$/, ""), i = b.href.replace(/\?.*$/, ""), j = g && g.getItem(i), k = g && g.getItem(i + ":timestamp"), l = {
            css: j,
            timestamp: k
        };
        /^(https?|file):/.test(i) || (i.charAt(0) == "/" ? i = a.location.protocol + "//" + a.location.host + i : i = h.slice(0, h.lastIndexOf("/") + 1) + i);
        var m = i.match(/([^\/]+)$/)[1];
        q(b.href, b.type, function(a, g) {
            if (!e && l && g && (new Date(g)).valueOf() === (new Date(l.timestamp)).valueOf())
                p(l.css, b), c(null, null, a, b, {
                    local: !0,
                    remaining: f
                });
            else 
                try {
                    (new d.Parser({
                        optimization: d.optimization,
                        paths: [i.replace(/[\w\.-]+$/, "")],
                        mime: b.type,
                        filename: m
                    })).parse(a, function(d, e) {
                        if (d)
                            return u(d, i);
                            try {
                                c(d, e, a, b, {
                                    local: !1,
                                    lastModified: g,
                                    remaining: f
                                }), s(document.getElementById("less-error-message:" + o(i)))
                            } catch (d) {
                                u(d, i)
                            }
                        })
            } catch (h) {
                u(h, i)
            }
        }, function(a, b) {
            throw new Error("Couldn't load " + b + " (" + a + ")")
        })
    }
    function o(a) {
        return a.replace(/^[a-z]+:\/\/?[^\/]+/, "").replace(/^\//, "").replace(/\?.*$/, "").replace(/\.[^\.\/]+$/, "").replace(/[^\.\w-]+/g, "-").replace(/\./g, ":")
    }
    function p(a, b, c) {
        var d, e = b.href ? b.href.replace(/\?.*$/, ""): "", f = "less:" + (b.title || o(e));
        (d = document.getElementById(f)) === null && (d = document.createElement("style"), d.type = "text/css", d.media = b.media || "screen", d.id = f, document.getElementsByTagName("head")[0].appendChild(d));
        if (d.styleSheet)
            try {
                d.styleSheet.cssText = a
        } catch (h) {
            throw new Error("Couldn't reassign styleSheet.cssText.")
        } else (function(a) {
            d.childNodes.length > 0 ? d.firstChild.nodeValue !== a.nodeValue && d.replaceChild(a, d.firstChild) : d.appendChild(a)
        })(document.createTextNode(a)
            );
        c && g && (t("saving " + e + " to cache."), g.setItem(e, a), g.setItem(e + ":timestamp", c))
    }
    function q(a, b, c, e) {
        function i(b, c, d) {
            b.status >= 200 && b.status < 300 ? c(b.responseText, b.getResponseHeader("Last-Modified")) : typeof d == "function" && d(b.status, a)
        }
        var g = r(), h = f?!1 : d.async;
        typeof g.overrideMimeType == "function" && g.overrideMimeType("text/css"), g.open("GET", a, h), g.setRequestHeader("Accept", b || "text/x-less, text/css; q=0.9, */*; q=0.5"), g.send(null), f ? g.status === 0 || g.status >= 200 && g.status < 300 ? c(g.responseText) : e(g.status, a) : h ? g.onreadystatechange = function() {
            g.readyState == 4 && i(g, c, e)
        } : i(g, c, e)
    }
    function r() {
        if (a.XMLHttpRequest)
            return new XMLHttpRequest;
        try {
            return new ActiveXObject("MSXML2.XMLHTTP.3.0")
        } catch (b) {
            return t("browser doesn't support AJAX."), null
        }
    }
    function s(a) {
        return a && a.parentNode.removeChild(a)
    }
    function t(a) {
        d.env == "development" && typeof console != "undefined" && console.log("less: " + a)
    }
    function u(a, b) {
        var c = "less-error-message:" + o(b), e = '<li><label>{line}</label><pre class="{class}">{content}</pre></li>', f = document.createElement("div"), g, h, i = [], j = a.filename || b;
        f.id = c, f.className = "less-error-message", h = "<h3>" + (a.message || "There is an error in your .less file") + "</h3>" + '<p>in <a href="' + j + '">' + j + "</a> ";
        var k = function(a, b, c) {
            a.extract[b] && i.push(e.replace(/\{line\}/, parseInt(a.line) + (b - 1)).replace(/\{class\}/, c).replace(/\{content\}/, a.extract[b]))
        };
        a.stack ? h += "<br/>" + a.stack.split("\n").slice(1).join("<br/>") : a.extract && (k(a, 0, ""), k(a, 1, "line"), k(a, 2, ""), h += "on line " + a.line + ", column " + (a.column + 1) + ":</p>" + "<ul>" + i.join("") + "</ul>"), f.innerHTML = h, p([".less-error-message ul, .less-error-message li {", "list-style-type: none;", "margin-right: 15px;", "padding: 4px 0;", "margin: 0;", "}", ".less-error-message label {", "font-size: 12px;", "margin-right: 15px;", "padding: 4px 0;", "color: #cc7777;", "}", ".less-error-message pre {", "color: #dd6666;", "padding: 4px 0;", "margin: 0;", "display: inline-block;", "}", ".less-error-message pre.line {", "color: #ff0000;", "}", ".less-error-message h3 {", "font-size: 20px;", "font-weight: bold;", "padding: 15px 0 5px 0;", "margin: 0;", "}", ".less-error-message a {", "color: #10a", "}", ".less-error-message .error {", "color: red;", "font-weight: bold;", "padding-bottom: 2px;", "border-bottom: 1px dashed red;", "}"].join("\n"), {
            title: "error-message"
        }), f.style.cssText = ["font-family: Arial, sans-serif", "border: 1px solid #e00", "background-color: #eee", "border-radius: 5px", "-webkit-border-radius: 5px", "-moz-border-radius: 5px", "color: #e00", "padding: 15px", "margin-bottom: 15px"].join(";"), d.env == "development" && (g = setInterval(function() {
            document.body && (document.getElementById(c) ? document.body.replaceChild(f, document.getElementById(c)) : document.body.insertBefore(f, document.body.firstChild), clearInterval(g))
        }, 10))
    }
    typeof define == "function" && define.amd && define("less", [], function() {
        return d
    }), Array.isArray || (Array.isArray = function(a) {
        return Object.prototype.toString.call(a) === "[object Array]" || a instanceof Array
    }), Array.prototype.forEach || (Array.prototype.forEach = function(a, b) {
        var c = this.length>>>0;
        for (var d = 0; d < c; d++)
            d in this && a.call(b, this[d], d, this)
    }), Array.prototype.map || (Array.prototype.map = function(a) {
        var b = this.length>>>0, c = new Array(b), d = arguments[1];
        for (var e = 0; e < b; e++)
            e in this && (c[e] = a.call(d, this[e], e, this));
        return c
    }), Array.prototype.filter || (Array.prototype.filter = function(a) {
        var b = [], c = arguments[1];
        for (var d = 0; d < this.length; d++)
            a.call(c, this[d]) && b.push(this[d]);
        return b
    }), Array.prototype.reduce || (Array.prototype.reduce = function(a) {
        var b = this.length>>>0, c = 0;
        if (b === 0 && arguments.length === 1)
            throw new TypeError;
        if (arguments.length >= 2)
            var d = arguments[1];
        else 
            do {
                if (c in this) {
                    d = this[c++];
                    break
                }
                if (++c >= b)
                    throw new TypeError
            }
        while (!0);
        for (; c < b; c++)
            c in this && (d = a.call(null, d, this[c], c, this));
        return d
    }), Array.prototype.indexOf || (Array.prototype.indexOf = function(a) {
        var b = this.length, c = arguments[1] || 0;
        if (!b)
            return - 1;
        if (c >= b)
            return - 1;
        c < 0 && (c += b);
        for (; c < b; c++) {
            if (!Object.prototype.hasOwnProperty.call(this, c))
                continue;
            if (a === this[c])
                return c
        }
        return - 1
    }), Object.keys || (Object.keys = function(a) {
        var b = [];
        for (var c in a)
            Object.prototype.hasOwnProperty.call(a, c) && b.push(c);
        return b
    }), String.prototype.trim || (String.prototype.trim = function() {
        return String(this).replace(/^\s\s*/, "").replace(/\s\s*$/, "")
    });
    var d, e;
    typeof environment == "object" && {}.toString.call(environment) === "[object Environment]" ? (typeof a == "undefined" ? d = {} : d = a.less = {}, e = d.tree = {}, d.mode = "rhino") : typeof a == "undefined" ? (d = exports, e = c("./tree"), d.mode = "node") : (typeof a.less == "undefined" && (a.less = {}), d = a.less, e = a.less.tree = {}, d.mode = "browser"), d.Parser = function v(a) {
        function q() {
            h = k[g], i = f, l = f
        }
        function r() {
            k[g] = h, f = i, l = f
        }
        function s() {
            f > l && (k[g] = k[g].slice(f - l), l = f)
        }
        function t(a) {
            var c, d, e, h, i, j, n, o;
            if (a instanceof Function)
                return a.call(m.parsers);
            if (typeof a == "string")
                c = b.charAt(f) === a ? a : null, e = 1, s();
            else {
                s();
                if (c = a.exec(k[g]))
                    e = c[0].length;
                else 
                    return null
            }
            if (c) {
                o = f += e, j = f + k[g].length - e;
                while (f < j) {
                    h = b.charCodeAt(f);
                    if (h !== 32 && h !== 10 && h !== 9)
                        break;
                    f++
                }
                return k[g] = k[g].slice(e + (f - o)), l = f, k[g].length === 0 && g < k.length - 1 && g++, typeof c == "string" ? c : c.length === 1 ? c[0] : c
            }
        }
        function u(a, c) {
            var d = t(a);
            if (!d)
                v(c || (typeof a == "string" ? "expected '" + a + "' got '" + b.charAt(f) + "'" : "unexpected token"));
            else 
                return d
        }
        function v(a, b) {
            throw {
                index: f,
                type: b || "Syntax",
                message: a
            }
        }
        function w(a) {
            return typeof a == "string" ? b.charAt(f) === a : a.test(k[g])?!0 : !1
        }
        function x(a) {
            return d.mode === "node" ? c("path").basename(a) : a.match(/[^\/]+$/)[0]
        }
        function y(a, c) {
            return a.filename && c.filename && a.filename !== c.filename ? m.imports.contents[x(a.filename)] : b
        }
        function z(a, b) {
            for (var c = a, d =- 1; c >= 0 && b.charAt(c) !== "\n"; c--)
                d++;
            return {
                line: typeof a == "number" ? (b.slice(0, a).match(/\n/g) || "").length: null,
                column: d
            }
        }
        function A(a, b) {
            var c = y(a, b), d = z(a.index, c), e = d.line, f = d.column, g = c.split("\n");
            this.type = a.type || "Syntax", this.message = a.message, this.filename = a.filename || b.filename, this.index = a.index, this.line = typeof e == "number" ? e + 1 : null, this.callLine = a.call && z(a.call, c).line + 1, this.callExtract = g[z(a.call, c).line], this.stack = a.stack, this.column = f, this.extract = [g[e - 1], g[e], g[e + 1]]
        }
        var b, f, g, h, i, j, k, l, m, n = this, o = function() {}, p = this.imports = {
            paths: a && a.paths || [],
            queue: [],
            files: {},
            contents: {},
            mime: a && a.mime,
            error: null,
            push: function(b, c) {
                var e = this;
                this.queue.push(b), d.Parser.importer(b, this.paths, function(a, d, f) {
                    e.queue.splice(e.queue.indexOf(b), 1), e.files[b] = d, e.contents[b] = f, a&&!e.error && (e.error = a), c(a, d), e.queue.length === 0 && o()
                }, a)
            }
        };
        return this.env = a = a || {}, this.optimization = "optimization"in this.env ? this.env.optimization : 1, this.env.filename = this.env.filename || null, m = {
            imports: p,
            parse: function(h, i) {
                var n, p, q, r, s, u, v = [], w, x = null;
                f = g = l = j = 0, b = h.replace(/\r\n/g, "\n"), k = function(c) {
                    var d = 0, e = /[^"'`\{\}\/\(\)\\]+/g, f = /\/\*(?:[^*]|\*+[^\/*])*\*+\/|\/\/.*/g, g = /"((?:[^"\\\r\n]|\\.)*)"|'((?:[^'\\\r\n]|\\.)*)'|`((?:[^`\\\r\n]|\\.)*)`/g, h = 0, i, j = c[0], k;
                    for (var l = 0, m, n; l < b.length; l++) {
                        e.lastIndex = l, (i = e.exec(b)) && i.index === l && (l += i[0].length, j.push(i[0])), m = b.charAt(l), f.lastIndex = g.lastIndex = l, (i = g.exec(b)) && i.index === l && (l += i[0].length, j.push(i[0]), m = b.charAt(l)), !k && m === "/" && (n = b.charAt(l + 1), (n === "/" || n === "*") && (i = f.exec(b)) && i.index === l && (l += i[0].length, j.push(i[0]), m = b.charAt(l)));
                        switch (m) {
                        case"{":
                            if (!k) {
                                h++, j.push(m);
                                break
                            };
                        case"}":
                            if (!k) {
                                h--, j.push(m), c[++d] = j = [];
                                break
                            };
                        case"(":
                            if (!k) {
                                k=!0, j.push(m);
                                break
                            };
                        case")":
                            if (k) {
                                k=!1, j.push(m);
                                break
                            };
                        default:
                            j.push(m)
                        }
                    }
                    return h > 0 && (x = new A({
                        index: l,
                        type: "Parse",
                        message: "missing closing `}`",
                        filename: a.filename
                    }, a)), c.map(function(a) {
                        return a.join("")
                    })
                }([[]]);
                if (x)
                    return i(x);
                try {
                    n = new e.Ruleset([], t(this.parsers.primary)), n.root=!0
                } catch (y) {
                    return i(new A(y, a))
                }
                n.toCSS = function(b) {
                    var f, g, h;
                    return function(f, g) {
                        var h = [], i;
                        f = f || {}, typeof g == "object"&&!Array.isArray(g) && (g = Object.keys(g).map(function(a) {
                            var b = g[a];
                            return b instanceof e.Value || (b instanceof e.Expression || (b = new e.Expression([b])), b = new e.Value([b])), new e.Rule("@" + a, b, !1, 0)
                        }), h = [new e.Ruleset(null, g)]);
                        try {
                            var j = b.call(this, {
                                frames: h
                            }).toCSS([], {
                                compress: f.compress ||!1
                            })
                        } catch (k) {
                            throw new A(k, a)
                        }
                        if (i = m.imports.error)
                            throw i instanceof A ? i : new A(i, a);
                        return f.yuicompress && d.mode === "node" ? c("./cssmin").compressor.cssmin(j) : f.compress ? j.replace(/(\s)+/g, "$1") : j
                    }
                }(n.eval);
                if (f < b.length - 1) {
                    f = j, u = b.split("\n"), s = (b.slice(0, f).match(/\n/g) || "").length + 1;
                    for (var z = f, B =- 1; z >= 0 && b.charAt(z) !== "\n"; z--)
                        B++;
                    x = {
                        type: "Parse",
                        message: "Syntax Error on line " + s,
                        index: f,
                        filename: a.filename,
                        line: s,
                        column: B,
                        extract: [u[s - 2], u[s - 1], u[s]]
                    }
                }
                this.imports.queue.length > 0 ? o = function() {
                    i(x, n)
                } : i(x, n)
            },
            parsers: {
                primary: function() {
                    var a, b = [];
                    while ((a = t(this.mixin.definition) || t(this.rule) || t(this.ruleset) || t(this.mixin.call) || t(this.comment) || t(this.directive)) || t(/^[\s\n]+/))
                        a && b.push(a);
                    return b
                },
                comment: function() {
                    var a;
                    if (b.charAt(f) !== "/")
                        return;
                    if (b.charAt(f + 1) === "/")
                        return new e.Comment(t(/^\/\/.*/), !0);
                    if (a = t(/^\/\*(?:[^*]|\*+[^\/*])*\*+\/\n?/))
                        return new e.Comment(a)
                },
                entities: {
                    quoted: function() {
                        var a, c = f, d;
                        b.charAt(c) === "~" && (c++, d=!0);
                        if (b.charAt(c) !== '"' && b.charAt(c) !== "'")
                            return;
                        d && t("~");
                        if (a = t(/^"((?:[^"\\\r\n]|\\.)*)"|'((?:[^'\\\r\n]|\\.)*)'/))
                            return new e.Quoted(a[0], a[1] || a[2], d)
                    },
                    keyword: function() {
                        var a;
                        if (a = t(/^[_A-Za-z-][_A-Za-z0-9-]*/))
                            return e.colors.hasOwnProperty(a) ? new e.Color(e.colors[a].slice(1)) : new e.Keyword(a)
                    },
                    call: function() {
                        var b, c, d = f;
                        if (!(b = /^([\w-]+|%|progid:[\w\.]+)\(/.exec(k[g])))
                            return;
                        b = b[1].toLowerCase();
                        if (b === "url")
                            return null;
                        f += b.length;
                        if (b === "alpha")
                            return t(this.alpha);
                        t("("), c = t(this.entities.arguments);
                        if (!t(")"))
                            return;
                        if (b)
                            return new e.Call(b, c, d, a.filename)
                    },
                    arguments: function() {
                        var a = [], b;
                        while (b = t(this.entities.assignment) || t(this.expression)) {
                            a.push(b);
                            if (!t(","))
                                break
                        }
                        return a
                    },
                    literal: function() {
                        return t(this.entities.dimension) || t(this.entities.color) || t(this.entities.quoted)
                    },
                    assignment: function() {
                        var a, b;
                        if ((a = t(/^\w+(?=\s?=)/i)) && t("=") && (b = t(this.entity)))
                            return new e.Assignment(a, b)
                    },
                    url: function() {
                        var a;
                        if (b.charAt(f) !== "u" ||!t(/^url\(/))
                            return;
                        return a = t(this.entities.quoted) || t(this.entities.variable) || t(this.entities.dataURI) || t(/^[-\w%@$\/.&=:;#+?~]+/) || "", u(")"), new e.URL(a.value || a.data || a instanceof e.Variable ? a : new e.Anonymous(a), p.paths)
                    },
                    dataURI: function() {
                        var a;
                        if (t(/^data:/)) {
                            a = {}, a.mime = t(/^[^\/]+\/[^,;)]+/) || "", a.charset = t(/^;\s*charset=[^,;)]+/) || "", a.base64 = t(/^;\s*base64/) || "", a.data = t(/^,\s*[^)]+/);
                            if (a.data)
                                return a
                        }
                    },
                    variable: function() {
                        var c, d = f;
                        if (b.charAt(f) === "@" && (c = t(/^@@?[\w-]+/)))
                            return new e.Variable(c, d, a.filename)
                    },
                    color: function() {
                        var a;
                        if (b.charAt(f) === "#" && (a = t(/^#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})/)))
                            return new e.Color(a[1])
                    },
                    dimension: function() {
                        var a, c = b.charCodeAt(f);
                        if (c > 57 || c < 45 || c === 47)
                            return;
                        if (a = t(/^(-?\d*\.?\d+)(px|%|em|rem|pc|ex|in|deg|s|ms|pt|cm|mm|rad|grad|turn)?/))
                            return new e.Dimension(a[1], a[2])
                    },
                    javascript: function() {
                        var a, c = f, d;
                        b.charAt(c) === "~" && (c++, d=!0);
                        if (b.charAt(c) !== "`")
                            return;
                        d && t("~");
                        if (a = t(/^`([^`]*)`/))
                            return new e.JavaScript(a[1], f, d)
                    }
                },
                variable: function() {
                    var a;
                    if (b.charAt(f) === "@" && (a = t(/^(@[\w-]+)\s*:/)))
                        return a[1]
                },
                shorthand: function() {
                    var a, b;
                    if (!w(/^[@\w.%-]+\/[@\w.-]+/))
                        return;
                    if ((a = t(this.entity)) && t("/") && (b = t(this.entity)))
                        return new e.Shorthand(a, b)
                },
                mixin: {
                    call: function() {
                        var c = [], d, g, h, i = f, j = b.charAt(f), k=!1;
                        if (j !== "." && j !== "#")
                            return;
                        while (d = t(/^[#.](?:[\w-]|\\(?:[a-fA-F0-9]{1,6} ?|[^a-fA-F0-9]))+/))
                            c.push(new e.Element(g, d, f)), g = t(">");
                        t("(") && (h = t(this.entities.arguments)) && t(")"), t(this.important) && (k=!0);
                        if (c.length > 0 && (t(";") || w("}")))
                            return new e.mixin.Call(c, h || [], i, a.filename, k)
                    },
                    definition: function() {
                        var a, c = [], d, g, h, i, j, k=!1;
                        if (b.charAt(f) !== "." && b.charAt(f) !== "#" || w(/^[^{]*(;|})/))
                            return;
                        q();
                        if (d = t(/^([#.](?:[\w-]|\\(?:[a-fA-F0-9]{1,6} ?|[^a-fA-F0-9]))+)\s*\(/)) {
                            a = d[1];
                            do {
                                if (b.charAt(f) === "." && t(/^\.{3}/)) {
                                    k=!0;
                                    break
                                }
                                if (!(h = t(this.entities.variable) || t(this.entities.literal) || t(this.entities.keyword)))
                                    break;
                                if (h instanceof e.Variable)
                                    if (t(":"))
                                        i = u(this.expression, "expected expression"), c.push({
                                            name: h.name,
                                            value: i
                                        });
                                    else {
                                        if (t(/^\.{3}/)) {
                                            c.push({
                                                name: h.name,
                                                variadic: !0
                                            }), k=!0;
                                            break
                                        }
                                        c.push({
                                            name: h.name
                                        })
                                    } else 
                                        c.push({
                                            value: h
                                        })
                                    }
                            while (t(","));
                            u(")"), t(/^when/) && (j = u(this.conditions, "expected condition")), g = t(this.block);
                            if (g)
                                return new e.mixin.Definition(a, c, g, j, k);
                            r()
                        }
                    }
                },
                entity: function() {
                    return t(this.entities.literal) || t(this.entities.variable) || t(this.entities.url) || t(this.entities.call) || t(this.entities.keyword) || t(this.entities.javascript) || t(this.comment)
                },
                end: function() {
                    return t(";") || w("}")
                },
                alpha: function() {
                    var a;
                    if (!t(/^\(opacity=/i))
                        return;
                    if (a = t(/^\d+/) || t(this.entities.variable))
                        return u(")"), new e.Alpha(a)
                    },
                element: function() {
                    var a, b, c, d;
                    c = t(this.combinator), a = t(/^(?:\d+\.\d+|\d+)%/) || t(/^(?:[.#]?|:*)(?:[\w-]|\\(?:[a-fA-F0-9]{1,6} ?|[^a-fA-F0-9]))+/) || t("*") || t(this.attribute) || t(/^\([^)@]+\)/), a || t("(") && (d = t(this.entities.variable)) && t(")") && (a = new e.Paren(d));
                    if (a)
                        return new e.Element(c, a, f);
                    if (c.value && c.value.charAt(0) === "&")
                        return new e.Element(c, null, f)
                },
                combinator: function() {
                    var a, c = b.charAt(f);
                    if (c === ">" || c === "+" || c === "~") {
                        f++;
                        while (b.charAt(f) === " ")
                            f++;
                        return new e.Combinator(c)
                    }
                    if (c === "&") {
                        a = "&", f++, b.charAt(f) === " " && (a = "& ");
                        while (b.charAt(f) === " ")
                            f++;
                        return new e.Combinator(a)
                    }
                    return b.charAt(f - 1) === " " ? new e.Combinator(" ") : new e.Combinator(null)
                },
                selector: function() {
                    var a, c, d = [], g, h;
                    if (t("("))
                        return a = t(this.entity), u(")"), new e.Selector([new e.Element("", a, f)]);
                    while (c = t(this.element)) {
                        g = b.charAt(f), d.push(c);
                        if (g === "{" || g === "}" || g === ";" || g === ",")
                            break
                    }
                    if (d.length > 0)
                        return new e.Selector(d)
                },
                tag: function() {
                    return t(/^[a-zA-Z][a-zA-Z-]*[0-9]?/) || t("*")
                },
                attribute: function() {
                    var a = "", b, c, d;
                    if (!t("["))
                        return;
                    if (b = t(/^[a-zA-Z-]+/) || t(this.entities.quoted))(d = t(/^[|~*$^]?=/)) && (c = t(this.entities.quoted) || t(/^[\w-]+/)) ? a = [b, d, c.toCSS ? c.toCSS()
                        : c].join(""): a = b;
                    if (!t("]"))
                        return;
                    if (a)
                        return "[" + a + "]"
                },
                block: function() {
                    var a;
                    if (t("{") && (a = t(this.primary)) && t("}"))
                        return a
                },
                ruleset: function() {
                    var b = [], c, d, g;
                    q();
                    while (c = t(this.selector)) {
                        b.push(c), t(this.comment);
                        if (!t(","))
                            break;
                        t(this.comment)
                    }
                    if (b.length > 0 && (d = t(this.block)))
                        return new e.Ruleset(b, d, a.strictImports);
                    j = f, r()
                },
                rule: function() {
                    var a, c, d = b.charAt(f), h, l;
                    q();
                    if (d === "." || d === "#" || d === "&")
                        return;
                    if (a = t(this.variable) || t(this.property)) {
                        a.charAt(0) != "@" && (l = /^([^@+\/'"*`(;{}-]*);/.exec(k[g])) ? (f += l[0].length - 1, c = new e.Anonymous(l[1])) : a === "font" ? c = t(this.font) : c = t(this.value), h = t(this.important);
                        if (c && t(this.end))
                            return new e.Rule(a, c, h, i);
                        j = f, r()
                    }
                },
                "import": function() {
                    var a, b, c = f;
                    if (t(/^@import\s+/) && (a = t(this.entities.quoted) || t(this.entities.url))) {
                        b = t(this.mediaFeatures);
                        if (t(";"))
                            return new e.Import(a, p, b, c)
                    }
                },
                mediaFeature: function() {
                    var a, b, c = [];
                    do 
                        if (a = t(this.entities.keyword))
                            c.push(a);
                        else if (t("(")) {
                            b = t(this.property), a = t(this.entity);
                            if (!t(")"))
                                return null;
                                if (b && a)
                                    c.push(new e.Paren(new e.Rule(b, a, null, f, !0)));
                                else if (a)
                                    c.push(new e.Paren(a));
                                else 
                                    return null
                        }
                    while (a);
                    if (c.length > 0)
                        return new e.Expression(c)
                },
                mediaFeatures: function() {
                    var a, b = [];
                    do 
                        if (a = t(this.mediaFeature)) {
                            b.push(a);
                            if (!t(","))
                                break
                        } else if (a = t(this.entities.variable)) {
                            b.push(a);
                            if (!t(","))
                                break
                        }
                    while (a);
                    return b.length > 0 ? b : null
                },
                media: function() {
                    var a, b;
                    if (t(/^@media/)) {
                        a = t(this.mediaFeatures);
                        if (b = t(this.block))
                            return new e.Media(b, a)
                    }
                },
                directive: function() {
                    var a, c, d, g, h, i;
                    if (b.charAt(f) !== "@")
                        return;
                    if (c = t(this["import"]) || t(this.media))
                        return c;
                    if (a = t(/^@page|@keyframes/) || t(/^@(?:-webkit-|-moz-|-o-|-ms-)[a-z0-9-]+/)) {
                        g = (t(/^[^{]+/) || "").trim();
                        if (d = t(this.block))
                            return new e.Directive(a + " " + g, d)
                    } else if (a = t(/^@[-a-z]+/))
                        if (a === "@font-face") {
                            if (d = t(this.block))
                                return new e.Directive(a, d)
                        } else if ((c = t(this.entity)) && t(";"))
                            return new e.Directive(a, c)
                },
                font: function() {
                    var a = [], b = [], c, d, f, g;
                    while (g = t(this.shorthand) || t(this.entity))
                        b.push(g);
                    a.push(new e.Expression(b));
                    if (t(","))
                        while (g = t(this.expression)) {
                            a.push(g);
                            if (!t(","))
                                break
                        }
                    return new e.Value(a)
                },
                value: function() {
                    var a, b = [], c;
                    while (a = t(this.expression)) {
                        b.push(a);
                        if (!t(","))
                            break
                    }
                    if (b.length > 0)
                        return new e.Value(b)
                },
                important: function() {
                    if (b.charAt(f) === "!")
                        return t(/^! *important/)
                },
                sub: function() {
                    var a;
                    if (t("(") && (a = t(this.expression)) && t(")"))
                        return a
                },
                multiplication: function() {
                    var a, b, c, d;
                    if (a = t(this.operand)) {
                        while (!w(/^\/\*/) && (c = t("/") || t("*")) && (b = t(this.operand)))
                            d = new e.Operation(c, [d || a, b]);
                        return d || a
                    }
                },
                addition: function() {
                    var a, c, d, g;
                    if (a = t(this.multiplication)) {
                        while ((d = t(/^[-+]\s+/) || b.charAt(f - 1) != " " && (t("+") || t("-"))) && (c = t(this.multiplication)))
                            g = new e.Operation(d, [g || a, c]);
                        return g || a
                    }
                },
                conditions: function() {
                    var a, b, c = f, d;
                    if (a = t(this.condition)) {
                        while (t(",") && (b = t(this.condition)))
                            d = new e.Condition("or", d || a, b, c);
                        return d || a
                    }
                },
                condition: function() {
                    var a, b, c, d, g = f, h=!1;
                    t(/^not/) && (h=!0), u("(");
                    if (a = t(this.addition) || t(this.entities.keyword) || t(this.entities.quoted))
                        return (d = t(/^(?:>=|=<|[<=>])/)) ? (b = t(this.addition) || t(this.entities.keyword) || t(this.entities.quoted)) ? c = new e.Condition(d, a, b, g, h) : v("expected expression") : c = new e.Condition("=", a, new e.Keyword("true"), g, h), u(")"), t(/^and/) ? new e.Condition("and", c, t(this.condition)) : c
                },
                operand: function() {
                    var a, c = b.charAt(f + 1);
                    b.charAt(f) === "-" && (c === "@" || c === "(") && (a = t("-"));
                    var d = t(this.sub) || t(this.entities.dimension) || t(this.entities.color) || t(this.entities.variable) || t(this.entities.call);
                    return a ? new e.Operation("*", [new e.Dimension( - 1), d]) : d
                },
                expression: function() {
                    var a, b, c = [], d;
                    while (a = t(this.addition) || t(this.entity))
                        c.push(a);
                    if (c.length > 0)
                        return new e.Expression(c)
                },
                property: function() {
                    var a;
                    if (a = t(/^(\*?-?[-a-z_0-9]+)\s*:/))
                        return a[1]
                }
            }
        }
    };
    if (d.mode === "browser" || d.mode === "rhino")
        d.Parser.importer = function(a, b, c, d) {
            !/^([a-z]+:)?\//.test(a) && b.length > 0 && (a = b[0] + a), n({
                href: a,
                title: a,
                type: d.mime
            }, function(e) {
                e && typeof d.errback == "function" ? d.errback.call(null, a, b, c, d) : c.apply(null, arguments)
            }, !0)
        };
    (function(a) {
        function b(b) {
            return a.functions.hsla(b.h, b.s, b.l, b.a)
        }
        function c(b) {
            if (b instanceof a.Dimension)
                return parseFloat(b.unit == "%" ? b.value / 100 : b.value);
            if (typeof b == "number")
                return b;
            throw {
                error: "RuntimeError",
                message: "color functions take numbers as parameters"
            }
        }
        function d(a) {
            return Math.min(1, Math.max(0, a))
        }
        a.functions = {
            rgb: function(a, b, c) {
                return this.rgba(a, b, c, 1)
            },
            rgba: function(b, d, e, f) {
                var g = [b, d, e].map(function(a) {
                    return c(a)
                }), f = c(f);
                return new a.Color(g, f)
            },
            hsl: function(a, b, c) {
                return this.hsla(a, b, c, 1)
            },
            hsla: function(a, b, d, e) {
                function h(a) {
                    return a = a < 0 ? a + 1 : a > 1 ? a - 1 : a, a * 6 < 1 ? g + (f - g) * a * 6 : a * 2 < 1 ? f : a * 3 < 2 ? g + (f - g) * (2 / 3 - a) * 6 : g
                }
                a = c(a)%360 / 360, b = c(b), d = c(d), e = c(e);
                var f = d <= .5 ? d * (b + 1): d + b - d * b, g = d * 2 - f;
                return this.rgba(h(a + 1 / 3) * 255, h(a) * 255, h(a - 1 / 3) * 255, e)
            },
            hue: function(b) {
                return new a.Dimension(Math.round(b.toHSL().h))
            },
            saturation: function(b) {
                return new a.Dimension(Math.round(b.toHSL().s * 100), "%")
            },
            lightness: function(b) {
                return new a.Dimension(Math.round(b.toHSL().l * 100), "%")
            },
            alpha: function(b) {
                return new a.Dimension(b.toHSL().a)
            },
            saturate: function(a, c) {
                var e = a.toHSL();
                return e.s += c.value / 100, e.s = d(e.s), b(e)
            },
            desaturate: function(a, c) {
                var e = a.toHSL();
                return e.s -= c.value / 100, e.s = d(e.s), b(e)
            },
            lighten: function(a, c) {
                var e = a.toHSL();
                return e.l += c.value / 100, e.l = d(e.l), b(e)
            },
            darken: function(a, c) {
                var e = a.toHSL();
                return e.l -= c.value / 100, e.l = d(e.l), b(e)
            },
            fadein: function(a, c) {
                var e = a.toHSL();
                return e.a += c.value / 100, e.a = d(e.a), b(e)
            },
            fadeout: function(a, c) {
                var e = a.toHSL();
                return e.a -= c.value / 100, e.a = d(e.a), b(e)
            },
            fade: function(a, c) {
                var e = a.toHSL();
                return e.a = c.value / 100, e.a = d(e.a), b(e)
            },
            spin: function(a, c) {
                var d = a.toHSL(), e = (d.h + c.value)%360;
                return d.h = e < 0 ? 360 + e : e, b(d)
            },
            mix: function(b, c, d) {
                var e = d.value / 100, f = e * 2 - 1, g = b.toHSL().a - c.toHSL().a, h = ((f * g==-1 ? f : (f + g) / (1 + f * g)) + 1) / 2, i = 1 - h, j = [b.rgb[0] * h + c.rgb[0] * i, b.rgb[1] * h + c.rgb[1] * i, b.rgb[2] * h + c.rgb[2] * i], k = b.alpha * e + c.alpha * (1 - e);
                return new a.Color(j, k)
            },
            greyscale: function(b) {
                return this.desaturate(b, new a.Dimension(100))
            },
            e: function(b) {
                return new a.Anonymous(b instanceof a.JavaScript ? b.evaluated : b)
            },
            escape: function(b) {
                return new a.Anonymous(encodeURI(b.value).replace(/=/g, "%3D").replace(/:/g, "%3A").replace(/#/g, "%23").replace(/;/g, "%3B").replace(/\(/g, "%28").replace(/\)/g, "%29"))
            },
            "%": function(b) {
                var c = Array.prototype.slice.call(arguments, 1), d = b.value;
                for (var e = 0; e < c.length; e++)
                    d = d.replace(/%[sda]/i, function(a) {
                        var b = a.match(/s/i) ? c[e].value: c[e].toCSS();
                        return a.match(/[A-Z]$/) ? encodeURIComponent(b) : b
                    });
                return d = d.replace(/%%/g, "%"), new a.Quoted('"' + d + '"', d)
            },
            round: function(a) {
                return this._math("round", a)
            },
            ceil: function(a) {
                return this._math("ceil", a)
            },
            floor: function(a) {
                return this._math("floor", a)
            },
            _math: function(b, d) {
                if (d instanceof a.Dimension)
                    return new a.Dimension(Math[b](c(d)), d.unit);
                if (typeof d == "number")
                    return Math[b](d);
                throw {
                    type: "Argument",
                    message: "argument must be a number"
                }
            },
            argb: function(b) {
                return new a.Anonymous(b.toARGB())
            },
            percentage: function(b) {
                return new a.Dimension(b.value * 100, "%")
            },
            color: function(b) {
                if (b instanceof a.Quoted)
                    return new a.Color(b.value.slice(1));
                throw {
                    type: "Argument",
                    message: "argument must be a string"
                }
            },
            iscolor: function(b) {
                return this._isa(b, a.Color)
            },
            isnumber: function(b) {
                return this._isa(b, a.Dimension)
            },
            isstring: function(b) {
                return this._isa(b, a.Quoted)
            },
            iskeyword: function(b) {
                return this._isa(b, a.Keyword)
            },
            isurl: function(b) {
                return this._isa(b, a.URL)
            },
            ispixel: function(b) {
                return b instanceof a.Dimension && b.unit === "px" ? a.True : a.False
            },
            ispercentage: function(b) {
                return b instanceof a.Dimension && b.unit === "%" ? a.True : a.False
            },
            isem: function(b) {
                return b instanceof a.Dimension && b.unit === "em" ? a.True : a.False
            },
            _isa: function(b, c) {
                return b instanceof c ? a.True : a.False
            }
        }
    })(c("./tree")), function(a) {
        a.colors = {
            aliceblue: "#f0f8ff",
            antiquewhite: "#faebd7",
            aqua: "#00ffff",
            aquamarine: "#7fffd4",
            azure: "#f0ffff",
            beige: "#f5f5dc",
            bisque: "#ffe4c4",
            black: "#000000",
            blanchedalmond: "#ffebcd",
            blue: "#0000ff",
            blueviolet: "#8a2be2",
            brown: "#a52a2a",
            burlywood: "#deb887",
            cadetblue: "#5f9ea0",
            chartreuse: "#7fff00",
            chocolate: "#d2691e",
            coral: "#ff7f50",
            cornflowerblue: "#6495ed",
            cornsilk: "#fff8dc",
            crimson: "#dc143c",
            cyan: "#00ffff",
            darkblue: "#00008b",
            darkcyan: "#008b8b",
            darkgoldenrod: "#b8860b",
            darkgray: "#a9a9a9",
            darkgrey: "#a9a9a9",
            darkgreen: "#006400",
            darkkhaki: "#bdb76b",
            darkmagenta: "#8b008b",
            darkolivegreen: "#556b2f",
            darkorange: "#ff8c00",
            darkorchid: "#9932cc",
            darkred: "#8b0000",
            darksalmon: "#e9967a",
            darkseagreen: "#8fbc8f",
            darkslateblue: "#483d8b",
            darkslategray: "#2f4f4f",
            darkslategrey: "#2f4f4f",
            darkturquoise: "#00ced1",
            darkviolet: "#9400d3",
            deeppink: "#ff1493",
            deepskyblue: "#00bfff",
            dimgray: "#696969",
            dimgrey: "#696969",
            dodgerblue: "#1e90ff",
            firebrick: "#b22222",
            floralwhite: "#fffaf0",
            forestgreen: "#228b22",
            fuchsia: "#ff00ff",
            gainsboro: "#dcdcdc",
            ghostwhite: "#f8f8ff",
            gold: "#ffd700",
            goldenrod: "#daa520",
            gray: "#808080",
            grey: "#808080",
            green: "#008000",
            greenyellow: "#adff2f",
            honeydew: "#f0fff0",
            hotpink: "#ff69b4",
            indianred: "#cd5c5c",
            indigo: "#4b0082",
            ivory: "#fffff0",
            khaki: "#f0e68c",
            lavender: "#e6e6fa",
            lavenderblush: "#fff0f5",
            lawngreen: "#7cfc00",
            lemonchiffon: "#fffacd",
            lightblue: "#add8e6",
            lightcoral: "#f08080",
            lightcyan: "#e0ffff",
            lightgoldenrodyellow: "#fafad2",
            lightgray: "#d3d3d3",
            lightgrey: "#d3d3d3",
            lightgreen: "#90ee90",
            lightpink: "#ffb6c1",
            lightsalmon: "#ffa07a",
            lightseagreen: "#20b2aa",
            lightskyblue: "#87cefa",
            lightslategray: "#778899",
            lightslategrey: "#778899",
            lightsteelblue: "#b0c4de",
            lightyellow: "#ffffe0",
            lime: "#00ff00",
            limegreen: "#32cd32",
            linen: "#faf0e6",
            magenta: "#ff00ff",
            maroon: "#800000",
            mediumaquamarine: "#66cdaa",
            mediumblue: "#0000cd",
            mediumorchid: "#ba55d3",
            mediumpurple: "#9370d8",
            mediumseagreen: "#3cb371",
            mediumslateblue: "#7b68ee",
            mediumspringgreen: "#00fa9a",
            mediumturquoise: "#48d1cc",
            mediumvioletred: "#c71585",
            midnightblue: "#191970",
            mintcream: "#f5fffa",
            mistyrose: "#ffe4e1",
            moccasin: "#ffe4b5",
            navajowhite: "#ffdead",
            navy: "#000080",
            oldlace: "#fdf5e6",
            olive: "#808000",
            olivedrab: "#6b8e23",
            orange: "#ffa500",
            orangered: "#ff4500",
            orchid: "#da70d6",
            palegoldenrod: "#eee8aa",
            palegreen: "#98fb98",
            paleturquoise: "#afeeee",
            palevioletred: "#d87093",
            papayawhip: "#ffefd5",
            peachpuff: "#ffdab9",
            peru: "#cd853f",
            pink: "#ffc0cb",
            plum: "#dda0dd",
            powderblue: "#b0e0e6",
            purple: "#800080",
            red: "#ff0000",
            rosybrown: "#bc8f8f",
            royalblue: "#4169e1",
            saddlebrown: "#8b4513",
            salmon: "#fa8072",
            sandybrown: "#f4a460",
            seagreen: "#2e8b57",
            seashell: "#fff5ee",
            sienna: "#a0522d",
            silver: "#c0c0c0",
            skyblue: "#87ceeb",
            slateblue: "#6a5acd",
            slategray: "#708090",
            slategrey: "#708090",
            snow: "#fffafa",
            springgreen: "#00ff7f",
            steelblue: "#4682b4",
            tan: "#d2b48c",
            teal: "#008080",
            thistle: "#d8bfd8",
            tomato: "#ff6347",
            turquoise: "#40e0d0",
            violet: "#ee82ee",
            wheat: "#f5deb3",
            white: "#ffffff",
            whitesmoke: "#f5f5f5",
            yellow: "#ffff00",
            yellowgreen: "#9acd32"
        }
    }(c("./tree")), function(a) {
        a.Alpha = function(a) {
            this.value = a
        }, a.Alpha.prototype = {
            toCSS: function() {
                return "alpha(opacity=" + (this.value.toCSS ? this.value.toCSS() : this.value) + ")"
            },
            eval: function(a) {
                return this.value.eval && (this.value = this.value.eval(a)), this
            }
        }
    }(c("../tree")), function(a) {
        a.Anonymous = function(a) {
            this.value = a.value || a
        }, a.Anonymous.prototype = {
            toCSS: function() {
                return this.value
            },
            eval: function() {
                return this
            }
        }
    }(c("../tree")), function(a) {
        a.Assignment = function(a, b) {
            this.key = a, this.value = b
        }, a.Assignment.prototype = {
            toCSS: function() {
                return this.key + "=" + (this.value.toCSS ? this.value.toCSS() : this.value)
            },
            eval: function(a) {
                return this.value.eval && (this.value = this.value.eval(a)), this
            }
        }
    }(c("../tree")), function(a) {
        a.Call = function(a, b, c, d) {
            this.name = a, this.args = b, this.index = c, this.filename = d
        }, a.Call.prototype = {
            eval: function(b) {
                var c = this.args.map(function(a) {
                    return a.eval(b)
                });
                if (!(this.name in a.functions))
                    return new a.Anonymous(this.name + "(" + c.map(function(a) {
                        return a.toCSS()
                    }).join(", ") + ")");
                try {
                    return a.functions[this.name].apply(a.functions, c)
                } catch (d) {
                    throw {
                        type: d.type || "Runtime",
                        message: "error evaluating function `" + this.name + "`" + (d.message ? ": " + d.message : ""),
                        index: this.index,
                        filename: this.filename
                    }
                }
            },
            toCSS: function(a) {
                return this.eval(a).toCSS()
            }
        }
    }(c("../tree")), function(a) {
        a.Color = function(a, b) {
            Array.isArray(a) ? this.rgb = a : a.length == 6 ? this.rgb = a.match(/.{2}/g).map(function(a) {
                return parseInt(a, 16)
            }) : this.rgb = a.split("").map(function(a) {
                return parseInt(a + a, 16)
            }), this.alpha = typeof b == "number" ? b : 1
        }, a.Color.prototype = {
            eval: function() {
                return this
            },
            toCSS: function() {
                return this.alpha < 1 ? "rgba(" + this.rgb.map(function(a) {
                    return Math.round(a)
                }).concat(this.alpha).join(", ") + ")" : "#" + this.rgb.map(function(a) {
                    return a = Math.round(a), a = (a > 255 ? 255 : a < 0 ? 0 : a).toString(16), a.length === 1 ? "0" + a : a
                }).join("")
            },
            operate: function(b, c) {
                var d = [];
                c instanceof a.Color || (c = c.toColor());
                for (var e = 0; e < 3; e++)
                    d[e] = a.operate(b, this.rgb[e], c.rgb[e]);
                return new a.Color(d, this.alpha + c.alpha)
            },
            toHSL: function() {
                var a = this.rgb[0] / 255, b = this.rgb[1] / 255, c = this.rgb[2] / 255, d = this.alpha, e = Math.max(a, b, c), f = Math.min(a, b, c), g, h, i = (e + f) / 2, j = e - f;
                if (e === f)
                    g = h = 0;
                else {
                    h = i > .5 ? j / (2 - e - f) : j / (e + f);
                    switch (e) {
                    case a:
                        g = (b - c) / j + (b < c ? 6 : 0);
                        break;
                    case b:
                        g = (c - a) / j + 2;
                        break;
                    case c:
                        g = (a - b) / j + 4
                    }
                    g/=6
                }
                return {
                    h: g * 360,
                    s: h,
                    l: i,
                    a: d
                }
            },
            toARGB: function() {
                var a = [Math.round(this.alpha * 255)].concat(this.rgb);
                return "#" + a.map(function(a) {
                    return a = Math.round(a), a = (a > 255 ? 255 : a < 0 ? 0 : a).toString(16), a.length === 1 ? "0" + a : a
                }).join("")
            }
        }
    }(c("../tree")), function(a) {
        a.Comment = function(a, b) {
            this.value = a, this.silent=!!b
        }, a.Comment.prototype = {
            toCSS: function(a) {
                return a.compress ? "" : this.value
            },
            eval: function() {
                return this
            }
        }
    }(c("../tree")), function(a) {
        a.Condition = function(a, b, c, d, e) {
            this.op = a.trim(), this.lvalue = b, this.rvalue = c, this.index = d, this.negate = e
        }, a.Condition.prototype.eval = function(a) {
            var b = this.lvalue.eval(a), c = this.rvalue.eval(a), d = this.index, e, e = function(a) {
                switch (a) {
                case"and":
                    return b && c;
                case"or":
                    return b || c;
                default:
                    if (b.compare)
                        e = b.compare(c);
                    else if (c.compare)
                        e = c.compare(b);
                    else 
                        throw {
                            type: "Type",
                            message: "Unable to perform comparison",
                            index: d
                        };
                    switch (e) {
                    case - 1:
                        return a === "<" || a === "=<";
                    case 0:
                        return a === "=" || a === ">=" || a === "=<";
                    case 1:
                        return a === ">" || a === ">="
                    }
                }
            }(this.op);
            return this.negate?!e : e
        }
    }(c("../tree")), function(a) {
        a.Dimension = function(a, b) {
            this.value = parseFloat(a), this.unit = b || null
        }, a.Dimension.prototype = {
            eval: function() {
                return this
            },
            toColor: function() {
                return new a.Color([this.value, this.value, this.value])
            },
            toCSS: function() {
                var a = this.value + this.unit;
                return a
            },
            operate: function(b, c) {
                return new a.Dimension(a.operate(b, this.value, c.value), this.unit || c.unit)
            },
            compare: function(b) {
                return b instanceof a.Dimension ? b.value > this.value?-1 : b.value < this.value ? 1 : 0 : - 1
            }
        }
    }(c("../tree")), function(a) {
        a.Directive = function(b, c, d) {
            this.name = b, Array.isArray(c) ? (this.ruleset = new a.Ruleset([], c), this.ruleset.allowImports=!0) : this.value = c
        }, a.Directive.prototype = {
            toCSS: function(a, b) {
                return this.ruleset ? (this.ruleset.root=!0, this.name + (b.compress ? "{" : " {\n  ") + this.ruleset.toCSS(a, b).trim().replace(/\n/g, "\n  ") + (b.compress ? "}" : "\n}\n")) : this.name + " " + this.value.toCSS() + ";\n"
            },
            eval: function(a) {
                return a.frames.unshift(this), this.ruleset = this.ruleset && this.ruleset.eval(a), a.frames.shift(), this
            },
            variable: function(b) {
                return a.Ruleset.prototype.variable.call(this.ruleset, b)
            },
            find: function() {
                return a.Ruleset.prototype.find.apply(this.ruleset, arguments)
            },
            rulesets: function() {
                return a.Ruleset.prototype.rulesets.apply(this.ruleset)
            }
        }
    }(c("../tree")), function(a) {
        a.Element = function(b, c, d) {
            this.combinator = b instanceof a.Combinator ? b : new a.Combinator(b), typeof c == "string" ? this.value = c.trim() : c ? this.value = c : this.value = "", this.index = d
        }, a.Element.prototype.eval = function(b) {
            return new a.Element(this.combinator, this.value.eval ? this.value.eval(b) : this.value, this.index)
        }, a.Element.prototype.toCSS = function(a) {
            return this.combinator.toCSS(a || {}) + (this.value.toCSS ? this.value.toCSS(a) : this.value)
        }, a.Combinator = function(a) {
            a === " " ? this.value = " " : a === "& " ? this.value = "& " : this.value = a ? a.trim() : ""
        }, a.Combinator.prototype.toCSS = function(a) {
            return {
                "": "",
                " ": " ",
                "&": "",
                "& ": " ",
                ":": " :",
                "+": a.compress ? "+": " + ",
                "~": a.compress ? "~": " ~ ",
                ">": a.compress ? ">": " > "
            }
            [this.value]
        }
    }(c("../tree")), function(a) {
        a.Expression = function(a) {
            this.value = a
        }, a.Expression.prototype = {
            eval: function(b) {
                return this.value.length > 1 ? new a.Expression(this.value.map(function(a) {
                    return a.eval(b)
                })) : this.value.length === 1 ? this.value[0].eval(b) : this
            },
            toCSS: function(a) {
                return this.value.map(function(b) {
                    return b.toCSS ? b.toCSS(a) : ""
                }).join(" ")
            }
        }
    }(c("../tree")), function(a) {
        a.Import = function(b, c, d, e) {
            var f = this;
            this.index = e, this._path = b, this.features = d && new a.Value(d), b instanceof a.Quoted ? this.path = /\.(le?|c)ss(\?.*)?$/.test(b.value) ? b.value : b.value + ".less" : this.path = b.value.value || b.value, this.css = /css(\?.*)?$/.test(this.path), this.css || c.push(this.path, function(b, c) {
                b && (b.index = e), f.root = c || new a.Ruleset([], [])
            })
        }, a.Import.prototype = {
            toCSS: function(a) {
                var b = this.features ? " " + this.features.toCSS(a): "";
                return this.css ? "@import " + this._path.toCSS() + b + ";\n" : ""
            },
            eval: function(b) {
                var c, d = this.features && this.features.eval(b);
                if (this.css)
                    return this;
                c = new a.Ruleset([], this.root.rules.slice(0));
                for (var e = 0; e < c.rules.length; e++)
                    c.rules[e]instanceof a.Import && Array.prototype
                    .splice.apply(c.rules, [e, 1].concat(c.rules[e].eval(b)));
                return this.features ? new a.Media(c.rules, this.features.value) : c.rules
            }
        }
    }(c("../tree")), function(a) {
        a.JavaScript = function(a, b, c) {
            this.escaped = c, this.expression = a, this.index = b
        }, a.JavaScript.prototype = {
            eval: function(b) {
                var c, d = this, e = {}, f = this.expression.replace(/@\{([\w-]+)\}/g, function(c, e) {
                    return a.jsify((new a.Variable("@" + e, d.index)).eval(b))
                });
                try {
                    f = new Function("return (" + f + ")")
                } catch (g) {
                    throw {
                        message: "JavaScript evaluation error: `" + f + "`",
                        index: this.index
                    }
                }
                for (var h in b.frames[0].variables())
                    e[h.slice(1)] = {
                        value: b.frames[0].variables()[h].value,
                        toJS: function() {
                            return this.value.eval(b).toCSS()
                        }
                    };
                try {
                    c = f.call(e)
                } catch (g) {
                    throw {
                        message: "JavaScript evaluation error: '" + g.name + ": " + g.message + "'",
                        index: this.index
                    }
                }
                return typeof c == "string" ? new a.Quoted('"' + c + '"', c, this.escaped, this.index) : Array.isArray(c) ? new a.Anonymous(c.join(", ")) : new a.Anonymous(c)
            }
        }
    }(c("../tree")), function(a) {
        a.Keyword = function(a) {
            this.value = a
        }, a.Keyword.prototype = {
            eval: function() {
                return this
            },
            toCSS: function() {
                return this.value
            },
            compare: function(b) {
                return b instanceof a.Keyword ? b.value === this.value ? 0 : 1 : - 1
            }
        }, a.True = new a.Keyword("true"), a.False = new a.Keyword("false")
    }(c("../tree")), function(a) {
        a.Media = function(b, c) {
            var d = new a.Element("&", null, 0), e = [new a.Selector([d])];
            this.features = new a.Value(c), this.ruleset = new a.Ruleset(e, b), this.ruleset.allowImports=!0
        }, a.Media.prototype = {
            toCSS: function(a, b) {
                var c = this.features.toCSS(b);
                return this.ruleset.root = a.length === 0 || a[0].multiMedia, "@media " + c + (b.compress ? "{" : " {\n  ") + this.ruleset.toCSS(a, b).trim().replace(/\n/g, "\n  ") + (b.compress ? "}" : "\n}\n")
            },
            eval: function(b) {
                b.mediaBlocks || (b.mediaBlocks = [], b.mediaPath = []);
                var c = b.mediaBlocks.length;
                b.mediaPath.push(this), b.mediaBlocks.push(this);
                var d = new a.Media([], []);
                return d.features = this.features.eval(b), b.frames.unshift(this.ruleset), d.ruleset = this.ruleset.eval(b), b.frames.shift(), b.mediaBlocks[c] = d, b.mediaPath.pop(), b.mediaPath.length === 0 ? d.evalTop(b) : d.evalNested(b)
            },
            variable: function(b) {
                return a.Ruleset.prototype.variable.call(this.ruleset, b)
            },
            find: function() {
                return a.Ruleset.prototype.find.apply(this.ruleset, arguments)
            },
            rulesets: function() {
                return a.Ruleset.prototype.rulesets.apply(this.ruleset)
            },
            evalTop: function(b) {
                var c = this;
                if (b.mediaBlocks.length > 1) {
                    var d = new a.Element("&", null, 0), e = [new a.Selector([d])];
                    c = new a.Ruleset(e, b.mediaBlocks), c.multiMedia=!0
                }
                return delete b.mediaBlocks, delete b.mediaPath, c
            },
            evalNested: function(b) {
                var c, d, e = b.mediaPath.concat([this]);
                for (c = 0; c < e.length; c++)
                    d = e[c].features instanceof a.Value ? e[c].features.value : e[c].features, e[c] = Array.isArray(d) ? d : [d];
                return this.features = new a.Value(this.permute(e).map(function(b) {
                    b = b.map(function(b) {
                        return b.toCSS ? b : new a.Anonymous(b)
                    });
                    for (c = b.length - 1; c > 0; c--)
                        b.splice(c, 0, new a.Anonymous("and"));
                    return new a.Expression(b)
                })), new a.Ruleset([], [])
            },
            permute: function(a) {
                if (a.length === 0)
                    return [];
                if (a.length === 1)
                    return a[0];
                var b = [], c = this.permute(a.slice(1));
                for (var d = 0; d < c.length; d++)
                    for (var e = 0; e < a[0].length; e++)
                        b.push([a[0][e]].concat(c[d]));
                return b
            }
        }
    }(c("../tree")), function(a) {
        a.mixin = {}, a.mixin.Call = function(b, c, d, e, f) {
            this.selector = new a.Selector(b), this.arguments = c, this.index = d, this.filename = e, this.important = f
        }, a.mixin.Call.prototype = {
            eval: function(a) {
                var b, c, d = [], e=!1;
                for (var f = 0; f < a.frames.length; f++)
                    if ((b = a.frames[f].find(this.selector)).length > 0) {
                        c = this.arguments && this.arguments.map(function(b) {
                            return b.eval(a)
                        });
                        for (var g = 0; g < b.length; g++)
                            if (b[g].match(c, a))
                                try {
                                    Array.prototype.push.apply(d, b[g].eval(a, this.arguments, this.important).rules), e=!0
                                } catch (h) {
                                    throw {
                                        message: h.message,
                                        index: this.index,
                                        filename: this.filename,
                                        stack: h.stack
                                    }
                                }
                                if (e)
                                    return d;
                                    throw {
                                        type: "Runtime",
                                        message: "No matching definition was found for `" + this.selector.toCSS().trim() + "(" + this.arguments.map(function(a) {
                                            return a.toCSS()
                                        }).join(", ") + ")`",
                                        index: this.index,
                                        filename: this.filename
                                    }
                    }
                throw {
                    type: "Name",
                    message: this.selector.toCSS().trim() + " is undefined",
                    index: this.index,
                    filename: this.filename
                }
            }
        }, a.mixin.Definition = function(b, c, d, e, f) {
            this.name = b, this.selectors = [new a.Selector([new a.Element(null, b)])], this.params = c, this.condition = e, this.variadic = f, this.arity = c.length, this.rules = d, this._lookups = {}, this.required = c.reduce(function(a, b) {
                return !b.name || b.name&&!b.value ? a + 1 : a
            }, 0), this.parent = a.Ruleset.prototype, this.frames = []
        }, a.mixin.Definition.prototype = {
            toCSS: function() {
                return ""
            },
            variable: function(a) {
                return this.parent.variable.call(this, a)
            },
            variables: function() {
                return this.parent.variables.call(this)
            },
            find: function() {
                return this.parent.find.apply(this, arguments)
            },
            rulesets: function() {
                return this.parent.rulesets.apply(this)
            },
            evalParams: function(b, c) {
                var d = new a.Ruleset(null, []), e;
                for (var f = 0, g, h; f < this.params.length; f++)
                    if (h = this.params[f].name)
                        if (this.params[f].variadic && c) {
                            e = [];
                            for (var i = f; i < c.length; i++)
                                e.push(c[i].eval(b));
                                d.rules.unshift(new a.Rule(h, (new a.Expression(e)).eval(b)))
                        } else if (g = c && c[f] || this.params[f].value)
                            d.rules.unshift(new a.Rule(h, g.eval(b)));
                        else 
                            throw {
                                type: "Runtime",
                                message: "wrong number of arguments for " + this.name + " (" + c.length + " for " + this.arity + ")"
                            };
                return d
            },
            eval: function(b, c, d) {
                var e = this.evalParams(b, c), f, g = [], h, i;
                for (var j = 0; j < Math.max(this.params.length, c && c.length); j++)
                    g.push(c[j] || this.params[j].value);
                return e.rules.unshift(new a.Rule("@arguments", (new a.Expression(g)).eval(b))), h = d ? this.rules.map(function(b) {
                    return new a.Rule(b.name, b.value, "!important", b.index)
                }) : this.rules.slice(0), (new a.Ruleset(null, h)).eval({
                    frames: [this, e].concat(this.frames, b.frames)
                })
            },
            match: function(a, b) {
                var c = a && a.length || 0, d, e;
                if (!this.variadic) {
                    if (c < this.required)
                        return !1;
                    if (c > this.params.length)
                        return !1;
                    if (this.required > 0 && c > this.params.length)
                        return !1
                }
                if (this.condition&&!this.condition.eval({
                    frames: [this.evalParams(b, a)].concat(b.frames)
                }))
                    return !1;
                d = Math.min(c, this.arity);
                for (var f = 0; f < d; f++)
                    if (!this.params[f].name && a[f].eval(b).toCSS() != this.params[f].value.eval(b).toCSS())
                        return !1;
                return !0
            }
        }
    }(c("../tree")), function(a) {
        a.Operation = function(a, b) {
            this.op = a.trim(), this.operands = b
        }, a.Operation.prototype.eval = function(b) {
            var c = this.operands[0].eval(b), d = this.operands[1].eval(b), e;
            if (c instanceof a.Dimension && d instanceof a.Color)
                if (this.op === "*" || this.op === "+")
                    e = d, d = c, c = e;
                else 
                    throw {
                        name: "OperationError",
                        message: "Can't substract or divide a color from a number"
                    };
            return c.operate(this.op, d)
        }, a.operate = function(a, b, c) {
            switch (a) {
            case"+":
                return b + c;
            case"-":
                return b - c;
            case"*":
                return b * c;
            case"/":
                return b / c
            }
        }
    }(c("../tree")), function(a) {
        a.Paren = function(a) {
            this.value = a
        }, a.Paren.prototype = {
            toCSS: function(a) {
                return "(" + this.value.toCSS(a) + ")"
            },
            eval: function(b) {
                return new a.Paren(this.value.eval(b))
            }
        }
    }(c("../tree")), function(a) {
        a.Quoted = function(a, b, c, d) {
            this.escaped = c, this.value = b || "", this.quote = a.charAt(0), this.index = d
        }, a.Quoted.prototype = {
            toCSS: function() {
                return this.escaped ? this.value : this.quote + this.value + this.quote
            },
            eval: function(b) {
                var c = this, d = this.value.replace(/`([^`]+)`/g, function(d, e) {
                    return (new a.JavaScript(e, c.index, !0)).eval(b).value
                }).replace(/@\{([\w-]+)\}/g, function(d, e) {
                    var f = (new a.Variable("@" + e, c.index)).eval(b);
                    return "value"in f ? f.value : f.toCSS()
                });
                return new a.Quoted(this.quote + d + this.quote, d, this.escaped, this.index)
            }
        }
    }(c("../tree")), function(a) {
        a.Rule = function(b, c, d, e, f) {
            this.name = b, this.value = c instanceof a.Value ? c : new a.Value([c]), this.important = d ? " " + d.trim() : "", this.index = e, this.inline = f ||!1, b.charAt(0) === "@" ? this.variable=!0 : this.variable=!1
        }, a.Rule.prototype.toCSS = function(a) {
            return this.variable ? "" : this.name + (a.compress ? ":" : ": ") + this.value.toCSS(a) + this.important + (this.inline ? "" : ";")
        }, a.Rule.prototype.eval = function(b) {
            return new a.Rule(this.name, this.value.eval(b), this.important, this.index, this.inline)
        }, a.Shorthand = function(a, b) {
            this.a = a, this.b = b
        }, a.Shorthand.prototype = {
            toCSS: function(a) {
                return this.a.toCSS(a) + "/" + this.b.toCSS(a)
            },
            eval: function() {
                return this
            }
        }
    }(c("../tree")), function(a) {
        a.Ruleset = function(a, b, c) {
            this.selectors = a, this.rules = b, this._lookups = {}, this.strictImports = c
        }, a.Ruleset.prototype = {
            eval: function(b) {
                var c = this.selectors && this.selectors.map(function(a) {
                    return a.eval(b)
                }), d = new a.Ruleset(c, this.rules.slice(0), this.strictImports);
                d.root = this.root, d.allowImports = this.allowImports, b.frames.unshift(d);
                if (d.root || d.allowImports ||!d.strictImports)
                    for (var e = 0; e < d.rules.length; e++)
                        d.rules[e]instanceof a.Import && Array.prototype.splice.apply(d.rules, [e, 1].concat(d.rules[e].eval(b)));
                for (var e = 0; e < d.rules.length; e++)
                    d.rules[e]instanceof a.mixin.Definition && (d.rules[e].frames = b.frames.slice(0));
                for (var e = 0; e < d.rules.length; e++)
                    d.rules[e]instanceof a.mixin.Call && Array.prototype.splice.apply(d.rules, [e, 1].concat(d.rules[e].eval(b)));
                for (var e = 0, f; e < d.rules.length; e++)
                    f = d.rules[e], f instanceof a.mixin.Definition || (d.rules[e] = f.eval ? f.eval(b) : f);
                return b.frames.shift(), d
            },
            match: function(a) {
                return !a || a.length === 0
            },
            variables: function() {
                return this._variables ? this._variables : this._variables = this.rules.reduce(function(b, c) {
                    return c instanceof a.Rule && c.variable===!0 && (b[c.name] = c), b
                }, {})
            },
            variable: function(a) {
                return this.variables()[a]
            },
            rulesets: function() {
                return this._rulesets ? this._rulesets : this._rulesets = this.rules.filter(function(b) {
                    return b instanceof a.Ruleset || b instanceof a.mixin.Definition
                })
            },
            find: function(b, c) {
                c = c || this;
                var d = [], e, f, g = b.toCSS();
                return g in this._lookups ? this._lookups[g] : (this.rulesets().forEach(function(e) {
                    if (e !== c)
                        for (var g = 0; g < e.selectors.length; g++)
                            if (f = b.match(e.selectors[g])) {
                                b.elements.length > e.selectors[g].elements.length ? Array.prototype.push.apply(d, e.find(new a.Selector(b.elements.slice(1)), c)) : d.push(e);
                                break
                            }
                }), this._lookups[g] = d)
            },
            toCSS: function(b, c) {
                var d = [], e = [], f = [], g = [], h, i;
                this.root || (b.length === 0 ? g = this.selectors.map(function(a) {
                    return [a]
                }) : this.joinSelectors(g, b, this.selectors));
                for (var j = 0; j < this.rules.length; j++)
                    i = this.rules[j], i.rules || i instanceof a.Directive || i instanceof a.Media ? f.push(i.toCSS(g, c)) : i instanceof a.Comment ? i.silent || (this.root ? f.push(i.toCSS(c)) : e.push(i.toCSS(c))) : i.toCSS&&!i.variable ? e.push(i.toCSS(c)) : i.value&&!i.variable && e.push(i.value.toString());
                return f = f.join(""), this.root ? d.push(e.join(c.compress ? "" : "\n")) : e.length > 0 && (h = g.map(function(a) {
                    return a.map(function(a) {
                        return a.toCSS(c)
                    }).join("").trim()
                }).join(c.compress ? "," : ",\n"), d.push(h, (c.compress ? "{" : " {\n  ") + e.join(c.compress ? "" : "\n  ") + (c.compress ? "}" : "\n}\n"))), d.push(f), d.join("") + (c.compress ? "\n" : "")
            },
            joinSelectors: function(a, b, c) {
                for (var d = 0; d < c.length; d++)
                    this.joinSelector(a, b, c[d])
            },
            joinSelector: function(b, c, d) {
                var e = [], f = [], g = [], h = [], i=!1, j;
                for (var k = 0; k < d.elements.length; k++)
                    j = d.elements[k], j.combinator.value.charAt(0) === "&" && (i=!0), i ? h.push(j) : g.push(j);
                i || (h = g, g = []), g.length > 0 && e.push(new a.Selector(g)), h.length > 0 && f.push(new a.Selector(h));
                for (var l = 0; l < c.length; l++)
                    b.push(e.concat(c[l]).concat(f))
            }
        }
    }(c("../tree")), function(a) {
        a.Selector = function(a) {
            this.elements = a, this.elements[0].combinator.value === "" && (this.elements[0].combinator.value = " ")
        }, a.Selector.prototype.match = function(a) {
            var b = this.elements.length, c = a.elements.length, d = Math.min(b, c);
            if (b < c)
                return !1;
            for (var e = 0; e < d; e++)
                if (this.elements[e].value !== a.elements[e].value)
                    return !1;
            return !0
        }, a.Selector.prototype.eval = function(b) {
            return new a.Selector(this.elements.map(function(a) {
                return a.eval(b)
            }))
        }, a.Selector.prototype.toCSS = function(a) {
            return this._css ? this._css : this._css = this.elements.map(function(b) {
                return typeof b == "string" ? " " + b.trim() : b.toCSS(a)
            }).join("")
        }
    }(c("../tree")), function(b) {
        b.URL = function(b, c) {
            b.data ? this.attrs = b : (this.value = b, this.paths = c)
        }, b.URL.prototype = {
            toCSS: function() {
                return "url(" + (this.attrs ? "data:" + this.attrs.mime + this.attrs.charset + this.attrs.base64 + this.attrs.data : this.value.toCSS()) + ")"
            },
            eval: function(c) {
                var d;
                return (this.attrs) ? this : (d = this.value.eval(c), (!/^(?:https?:\/\/|file:\/\/|data:)?/.test(d.value) && this.paths.length > 0 && typeof(a) !== 'undefined') && (d = paths[0] + d), new (b.URL)(d, this.paths))
            }
        }
    }(c("../tree")), function(a) {
        a.Value = function(a) {
            this.value = a, this.is = "value"
        }, a.Value.prototype = {
            eval: function(b) {
                return this.value.length === 1 ? this.value[0].eval(b) : new a.Value(this.value.map(function(a) {
                    return a.eval(b)
                }))
            },
            toCSS: function(a) {
                return this.value.map(function(b) {
                    return b.toCSS(a)
                }).join(a.compress ? "," : ", ")
            }
        }
    }(c("../tree")), function(a) {
        a.Variable = function(a, b, c) {
            this.name = a, this.index = b, this.file = c
        }, a.Variable.prototype = {
            eval: function(b) {
                var c, d, e = this.name;
                e.indexOf("@@") == 0 && (e = "@" + (new a.Variable(e.slice(1))).eval(b).value);
                if (c = a.find(b.frames, function(a) {
                    if (d = a.variable(e))
                        return d.value.eval(b)
                }))
                    return c;
                throw {
                    type: "Name",
                    message: "variable " + e + " is undefined",
                    filename: this.file,
                    index: this.index
                }
            }
        }
    }(c("../tree")), function(a) {
        a.find = function(a, b) {
            for (var c = 0, d; c < a.length; c++)
                if (d = b.call(a, a[c]))
                    return d;
            return null
        }, a.jsify = function(a) {
            return Array.isArray(a.value) && a.value.length > 1 ? "[" + a.value.map(function(a) {
                return a.toCSS(!1)
            }).join(", ") + "]" : a.toCSS(!1)
        }
    }(c("./tree"));
    var f = location.protocol === "file:" || location.protocol === "chrome:" || location.protocol === "chrome-extension:" || location.protocol === "resource:";
    d.env = d.env || (location.hostname == "127.0.0.1" || location.hostname == "0.0.0.0" || location.hostname == "localhost" || location.port.length > 0 || f ? "development" : "production"), d.async=!1, d.poll = d.poll || (f ? 1e3 : 1500), d.watch = function() {
        return this.watchMode=!0
    }, d.unwatch = function() {
        return this.watchMode=!1
    }, d.env === "development" ? (d.optimization = 0, /!watch/.test(location.hash) && d.watch(), d.watchTimer = setInterval(function() {
        d.watchMode && m(function(a, b, c, d, e) {
            b && p(b.toCSS(), d, e.lastModified)
        })
    }, d.poll)) : d.optimization = 3;
    var g;
    try {
        g = typeof a.localStorage == "undefined" ? null : a.localStorage
    } catch (h) {
        g = null
    }
    var i = document.getElementsByTagName("link"), j = /^text\/(x-)?less$/;
    d.sheets = [];
    for (var k = 0; k < i.length; k++)(i[k].rel === "stylesheet/less" || i[k].rel.match(/stylesheet/) && i[k].type.match(j)
        ) && d.sheets.push(i[k]);
    d.refresh = function(a) {
        var b, c;
        b = c = new Date, m(function(a, d, e, f, g) {
            g.local ? t("loading " + f.href + " from cache.") : (t("parsed " + f.href + " successfully."), p(d.toCSS(), f, g.lastModified)), t("css for " + f.href + " generated in " + (new Date - c) + "ms"), g.remaining === 0 && t("css generated in " + (new Date - b) + "ms"), c = new Date
        }, a), l()
    }, d.refreshStyles = l, d.refresh(d.env === "development")
})(window);
/* global define:false, webs:false */
define('internal/sitebuilder/common/themeService', [
"jquery",
"less",
'internal/sitebuilder/common/ThemeVariable'
], function($, less, ThemeVariable) {
    var themeService = {
        getLessVariables: function(themeRootURL, styleSlug) {
            return {
                theme_root: new (less.tree.Quoted)('"' + themeRootURL + '"', themeRootURL),
                style_slug: new (less.tree.Quoted)('"' + styleSlug + '"', styleSlug),
                webs_static_server: new (less.tree.Quoted)('"' + webs.props.staticServer + '"', webs.props.staticServer),
                webs_members_server: new (less.tree.Quoted)('""', ''),
                webs_dynamic_asset_server: new (less.tree.Quoted)('"' + webs.props.dynamicAssetServer + '"', webs.props.dynamicAssetServer)
            };
        },

        getThemeLessVariables: function(theme) {
            var data = {
                theme: theme.slug,
                variables: $.map(theme.variables, function(v) {
                    return v;
                })
            };
            var variables = ThemeVariable.loadFromRemote(data);

            var lessVariables = themeService.getLessVariables(theme.url, theme.style.slug);

            for (var i = 0, l = variables.length; i < l; i++) {
                variables[i].toLess(lessVariables);
            }
            return lessVariables;
        }
    };
    return themeService;
});
// lib/handlebars/parser.js
/* Jison generated parser */
var handlebars = (function() {
    var parser = {
        trace: function trace() {},
        yy: {},
        symbols_: {
            "error": 2,
            "root": 3,
            "program": 4,
            "EOF": 5,
            "statements": 6,
            "simpleInverse": 7,
            "statement": 8,
            "openInverse": 9,
            "closeBlock": 10,
            "openBlock": 11,
            "mustache": 12,
            "partial": 13,
            "CONTENT": 14,
            "COMMENT": 15,
            "OPEN_BLOCK": 16,
            "inMustache": 17,
            "CLOSE": 18,
            "OPEN_INVERSE": 19,
            "OPEN_ENDBLOCK": 20,
            "path": 21,
            "OPEN": 22,
            "OPEN_UNESCAPED": 23,
            "OPEN_PARTIAL": 24,
            "params": 25,
            "hash": 26,
            "param": 27,
            "STRING": 28,
            "INTEGER": 29,
            "BOOLEAN": 30,
            "hashSegments": 31,
            "hashSegment": 32,
            "ID": 33,
            "EQUALS": 34,
            "pathSegments": 35,
            "SEP": 36,
            "$accept": 0,
            "$end": 1
        },
        terminals_: {
            2: "error",
            5: "EOF",
            14: "CONTENT",
            15: "COMMENT",
            16: "OPEN_BLOCK",
            18: "CLOSE",
            19: "OPEN_INVERSE",
            20: "OPEN_ENDBLOCK",
            22: "OPEN",
            23: "OPEN_UNESCAPED",
            24: "OPEN_PARTIAL",
            28: "STRING",
            29: "INTEGER",
            30: "BOOLEAN",
            33: "ID",
            34: "EQUALS",
            36: "SEP"
        },
        productions_: [0, [3, 2], [4, 3], [4, 1], [4, 0], [6, 1], [6, 2], [8, 3], [8, 3], [8, 1], [8, 1], [8, 1], [8, 1], [11, 3], [9, 3], [10, 3], [12, 3], [12, 3], [13, 3], [13, 4], [7, 2], [17, 3], [17, 2], [17, 2], [17, 1], [25, 2], [25, 1], [27, 1], [27, 1], [27, 1], [27, 1], [26, 1], [31, 2], [31, 1], [32, 3], [32, 3], [32, 3], [32, 3], [21, 1], [35, 3], [35, 1]],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {

            var $0 = $$.length - 1;
            switch (yystate) {
            case 1:
                return $$[$0 - 1]
                break;
            case 2:
                this.$ = new yy.ProgramNode($$[$0 - 2], $$[$0])
                break;
            case 3:
                this.$ = new yy.ProgramNode($$[$0])
                break;
            case 4:
                this.$ = new yy.ProgramNode([])
                break;
            case 5:
                this.$ = [$$[$0]]
                break;
            case 6:
                $$[$0 - 1].push($$[$0]);
                this.$ = $$[$0 - 1]
                break;
            case 7:
                this.$ = new yy.InverseNode($$[$0 - 2], $$[$0 - 1], $$[$0])
                break;
            case 8:
                this.$ = new yy.BlockNode($$[$0 - 2], $$[$0 - 1], $$[$0])
                break;
            case 9:
                this.$ = $$[$0]
                break;
            case 10:
                this.$ = $$[$0]
                break;
            case 11:
                this.$ = new yy.ContentNode($$[$0])
                break;
            case 12:
                this.$ = new yy.CommentNode($$[$0])
                break;
            case 13:
                this.$ = new yy.MustacheNode($$[$0 - 1][0], $$[$0 - 1][1])
                break;
            case 14:
                this.$ = new yy.MustacheNode($$[$0 - 1][0], $$[$0 - 1][1])
                break;
            case 15:
                this.$ = $$[$0 - 1]
                break;
            case 16:
                this.$ = new yy.MustacheNode($$[$0 - 1][0], $$[$0 - 1][1])
                break;
            case 17:
                this.$ = new yy.MustacheNode($$[$0 - 1][0], $$[$0 - 1][1], true)
                break;
            case 18:
                this.$ = new yy.PartialNode($$[$0 - 1])
                break;
            case 19:
                this.$ = new yy.PartialNode($$[$0 - 2], $$[$0 - 1])
                break;
            case 20:
                break;
            case 21:
                this.$ = [[$$[$0 - 2]].concat($$[$0 - 1]), $$[$0]]
                break;
            case 22:
                this.$ = [[$$[$0 - 1]].concat($$[$0]), null]
                break;
            case 23:
                this.$ = [[$$[$0 - 1]], $$[$0]]
                break;
            case 24:
                this.$ = [[$$[$0]], null]
                break;
            case 25:
                $$[$0 - 1].push($$[$0]);
                this.$ = $$[$0 - 1];
                break;
            case 26:
                this.$ = [$$[$0]]
                break;
            case 27:
                this.$ = $$[$0]
                break;
            case 28:
                this.$ = new yy.StringNode($$[$0])
                break;
            case 29:
                this.$ = new yy.IntegerNode($$[$0])
                break;
            case 30:
                this.$ = new yy.BooleanNode($$[$0])
                break;
            case 31:
                this.$ = new yy.HashNode($$[$0])
                break;
            case 32:
                $$[$0 - 1].push($$[$0]);
                this.$ = $$[$0 - 1]
                break;
            case 33:
                this.$ = [$$[$0]]
                break;
            case 34:
                this.$ = [$$[$0 - 2], $$[$0]]
                break;
            case 35:
                this.$ = [$$[$0 - 2], new yy.StringNode($$[$0])]
                break;
            case 36:
                this.$ = [$$[$0 - 2], new yy.IntegerNode($$[$0])]
                break;
            case 37:
                this.$ = [$$[$0 - 2], new yy.BooleanNode($$[$0])]
                break;
            case 38:
                this.$ = new yy.IdNode($$[$0])
                break;
            case 39:
                $$[$0 - 2].push($$[$0]);
                this.$ = $$[$0 - 2];
                break;
            case 40:
                this.$ = [$$[$0]]
                break;
            }
        },
        table: [{
            3: 1,
            4: 2,
            5: [2, 4],
            6: 3,
            8: 4,
            9: 5,
            11: 6,
            12: 7,
            13: 8,
            14: [1, 9],
            15: [1, 10],
            16: [1, 12],
            19: [1, 11],
            22: [1, 13],
            23: [1, 14],
            24: [1, 15]
        }, {
            1: [3]
        }, {
            5: [1, 16]
        }, {
            5: [2, 3],
            7: 17,
            8: 18,
            9: 5,
            11: 6,
            12: 7,
            13: 8,
            14: [1, 9],
            15: [1, 10],
            16: [1, 12],
            19: [1, 19],
            20: [2, 3],
            22: [1, 13],
            23: [1, 14],
            24: [1, 15]
        }, {
            5: [2, 5],
            14: [2, 5],
            15: [2, 5],
            16: [2, 5],
            19: [2, 5],
            20: [2, 5],
            22: [2, 5],
            23: [2, 5],
            24: [2, 5]
        }, {
            4: 20,
            6: 3,
            8: 4,
            9: 5,
            11: 6,
            12: 7,
            13: 8,
            14: [1, 9],
            15: [1, 10],
            16: [1, 12],
            19: [1, 11],
            20: [2, 4],
            22: [1, 13],
            23: [1, 14],
            24: [1, 15]
        }, {
            4: 21,
            6: 3,
            8: 4,
            9: 5,
            11: 6,
            12: 7,
            13: 8,
            14: [1, 9],
            15: [1, 10],
            16: [1, 12],
            19: [1, 11],
            20: [2, 4],
            22: [1, 13],
            23: [1, 14],
            24: [1, 15]
        }, {
            5: [2, 9],
            14: [2, 9],
            15: [2, 9],
            16: [2, 9],
            19: [2, 9],
            20: [2, 9],
            22: [2, 9],
            23: [2, 9],
            24: [2, 9]
        }, {
            5: [2, 10],
            14: [2, 10],
            15: [2, 10],
            16: [2, 10],
            19: [2, 10],
            20: [2, 10],
            22: [2, 10],
            23: [2, 10],
            24: [2, 10]
        }, {
            5: [2, 11],
            14: [2, 11],
            15: [2, 11],
            16: [2, 11],
            19: [2, 11],
            20: [2, 11],
            22: [2, 11],
            23: [2, 11],
            24: [2, 11]
        }, {
            5: [2, 12],
            14: [2, 12],
            15: [2, 12],
            16: [2, 12],
            19: [2, 12],
            20: [2, 12],
            22: [2, 12],
            23: [2, 12],
            24: [2, 12]
        }, {
            17: 22,
            21: 23,
            33: [1, 25],
            35: 24
        }, {
            17: 26,
            21: 23,
            33: [1, 25],
            35: 24
        }, {
            17: 27,
            21: 23,
            33: [1, 25],
            35: 24
        }, {
            17: 28,
            21: 23,
            33: [1, 25],
            35: 24
        }, {
            21: 29,
            33: [1, 25],
            35: 24
        }, {
            1: [2, 1]
        }, {
            6: 30,
            8: 4,
            9: 5,
            11: 6,
            12: 7,
            13: 8,
            14: [1, 9],
            15: [1, 10],
            16: [1, 12],
            19: [1, 11],
            22: [1, 13],
            23: [1, 14],
            24: [1, 15]
        }, {
            5: [2, 6],
            14: [2, 6],
            15: [2, 6],
            16: [2, 6],
            19: [2, 6],
            20: [2, 6],
            22: [2, 6],
            23: [2, 6],
            24: [2, 6]
        }, {
            17: 22,
            18: [1, 31],
            21: 23,
            33: [1, 25],
            35: 24
        }, {
            10: 32,
            20: [1, 33]
        }, {
            10: 34,
            20: [1, 33]
        }, {
            18: [1, 35]
        }, {
            18: [2, 24],
            21: 40,
            25: 36,
            26: 37,
            27: 38,
            28: [1, 41],
            29: [1, 42],
            30: [1, 43],
            31: 39,
            32: 44,
            33: [1, 45],
            35: 24
        }, {
            18: [2, 38],
            28: [2, 38],
            29: [2, 38],
            30: [2, 38],
            33: [2, 38],
            36: [1, 46]
        }, {
            18: [2, 40],
            28: [2, 40],
            29: [2, 40],
            30: [2, 40],
            33: [2, 40],
            36: [2, 40]
        }, {
            18: [1, 47]
        }, {
            18: [1, 48]
        }, {
            18: [1, 49]
        }, {
            18: [1, 50],
            21: 51,
            33: [1, 25],
            35: 24
        }, {
            5: [2, 2],
            8: 18,
            9: 5,
            11: 6,
            12: 7,
            13: 8,
            14: [1, 9],
            15: [1, 10],
            16: [1, 12],
            19: [1, 11],
            20: [2, 2],
            22: [1, 13],
            23: [1, 14],
            24: [1, 15]
        }, {
            14: [2, 20],
            15: [2, 20],
            16: [2, 20],
            19: [2, 20],
            22: [2, 20],
            23: [2, 20],
            24: [2, 20]
        }, {
            5: [2, 7],
            14: [2, 7],
            15: [2, 7],
            16: [2, 7],
            19: [2, 7],
            20: [2, 7],
            22: [2, 7],
            23: [2, 7],
            24: [2, 7]
        }, {
            21: 52,
            33: [1, 25],
            35: 24
        }, {
            5: [2, 8],
            14: [2, 8],
            15: [2, 8],
            16: [2, 8],
            19: [2, 8],
            20: [2, 8],
            22: [2, 8],
            23: [2, 8],
            24: [2, 8]
        }, {
            14: [2, 14],
            15: [2, 14],
            16: [2, 14],
            19: [2, 14],
            20: [2, 14],
            22: [2, 14],
            23: [2, 14],
            24: [2, 14]
        }, {
            18: [2, 22],
            21: 40,
            26: 53,
            27: 54,
            28: [1, 41],
            29: [1, 42],
            30: [1, 43],
            31: 39,
            32: 44,
            33: [1, 45],
            35: 24
        }, {
            18: [2, 23]
        }, {
            18: [2, 26],
            28: [2, 26],
            29: [2, 26],
            30: [2, 26],
            33: [2, 26]
        }, {
            18: [2, 31],
            32: 55,
            33: [1, 56]
        }, {
            18: [2, 27],
            28: [2, 27],
            29: [2, 27],
            30: [2, 27],
            33: [2, 27]
        }, {
            18: [2, 28],
            28: [2, 28],
            29: [2, 28],
            30: [2, 28],
            33: [2, 28]
        }, {
            18: [2, 29],
            28: [2, 29],
            29: [2, 29],
            30: [2, 29],
            33: [2, 29]
        }, {
            18: [2, 30],
            28: [2, 30],
            29: [2, 30],
            30: [2, 30],
            33: [2, 30]
        }, {
            18: [2, 33],
            33: [2, 33]
        }, {
            18: [2, 40],
            28: [2, 40],
            29: [2, 40],
            30: [2, 40],
            33: [2, 40],
            34: [1, 57],
            36: [2, 40]
        }, {
            33: [1, 58]
        }, {
            14: [2, 13],
            15: [2, 13],
            16: [2, 13],
            19: [2, 13],
            20: [2, 13],
            22: [2, 13],
            23: [2, 13],
            24: [2, 13]
        }, {
            5: [2, 16],
            14: [2, 16],
            15: [2, 16],
            16: [2, 16],
            19: [2, 16],
            20: [2, 16],
            22: [2, 16],
            23: [2, 16],
            24: [2, 16]
        }, {
            5: [2, 17],
            14: [2, 17],
            15: [2, 17],
            16: [2, 17],
            19: [2, 17],
            20: [2, 17],
            22: [2, 17],
            23: [2, 17],
            24: [2, 17]
        }, {
            5: [2, 18],
            14: [2, 18],
            15: [2, 18],
            16: [2, 18],
            19: [2, 18],
            20: [2, 18],
            22: [2, 18],
            23: [2, 18],
            24: [2, 18]
        }, {
            18: [1, 59]
        }, {
            18: [1, 60]
        }, {
            18: [2, 21]
        }, {
            18: [2, 25],
            28: [2, 25],
            29: [2, 25],
            30: [2, 25],
            33: [2, 25]
        }, {
            18: [2, 32],
            33: [2, 32]
        }, {
            34: [1, 57]
        }, {
            21: 61,
            28: [1, 62],
            29: [1, 63],
            30: [1, 64],
            33: [1, 25],
            35: 24
        }, {
            18: [2, 39],
            28: [2, 39],
            29: [2, 39],
            30: [2, 39],
            33: [2, 39],
            36: [2, 39]
        }, {
            5: [2, 19],
            14: [2, 19],
            15: [2, 19],
            16: [2, 19],
            19: [2, 19],
            20: [2, 19],
            22: [2, 19],
            23: [2, 19],
            24: [2, 19]
        }, {
            5: [2, 15],
            14: [2, 15],
            15: [2, 15],
            16: [2, 15],
            19: [2, 15],
            20: [2, 15],
            22: [2, 15],
            23: [2, 15],
            24: [2, 15]
        }, {
            18: [2, 34],
            33: [2, 34]
        }, {
            18: [2, 35],
            33: [2, 35]
        }, {
            18: [2, 36],
            33: [2, 36]
        }, {
            18: [2, 37],
            33: [2, 37]
        }
        ],
        defaultActions: {
            16: [2, 1],
            37: [2, 23],
            53: [2, 21]
        },
        parseError: function parseError(str, hash) {
            throw new Error(str);
        },
        parse: function parse(input) {
            var self = this,
            stack = [0],
            vstack = [null], // semantic value stack
            lstack = [], // location stack
            table = this.table,
            yytext = '',
            yylineno = 0,
            yyleng = 0,
            recovering = 0,
            TERROR = 2,
            EOF = 1;

            //this.reductionCount = this.shiftCount = 0;

            this.lexer.setInput(input);
            this.lexer.yy = this.yy;
            this.yy.lexer = this.lexer;
            if (typeof this.lexer.yylloc == 'undefined')
                this.lexer.yylloc = {};
            var yyloc = this.lexer.yylloc;
            lstack.push(yyloc);

            if (typeof this.yy.parseError === 'function')
                this.parseError = this.yy.parseError;

            function popStack (n) {
                stack.length = stack.length - 2 * n;
                vstack.length = vstack.length - n;
                lstack.length = lstack.length - n;
            }

            function lex() {
                var token;
                token = self.lexer.lex() || 1; // $end = 1
                // if token isn't its numeric value, convert
                if (typeof token !== 'number') {
                    token = self.symbols_[token] || token;
                }
                return token;
            };

            var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
            while (true) {
                // retreive state number from top of stack
                state = stack[stack.length - 1];

                // use default actions if available
                if (this.defaultActions[state]) {
                    action = this.defaultActions[state];
                } else {
                    if (symbol == null)
                        symbol = lex();
                    // read action for current state and first input
                    action = table[state] && table[state][symbol];
                }

                // handle parse error
                if (typeof action === 'undefined' || !action.length || !action[0]) {

                    if (!recovering) {
                        // Report error
                        expected = [];
                        for (p in table[state]) 
                            if (this.terminals_[p] && p > 2) {
                                expected.push("'" + this.terminals_[p] + "'");
                            }
                        var errStr = '';
                        if (this.lexer.showPosition) {
                            errStr = 'Parse error on line ' + (yylineno + 1) + ":\n" + this.lexer.showPosition() + '\nExpecting ' + expected.join(', ');
                        } else {
                            errStr = 'Parse error on line ' + (yylineno + 1) + ": Unexpected " +
                            (symbol == 1 /*EOF*/
                            ? "end of input" :
                            ("'" + (this.terminals_[symbol] || symbol) + "'"));
                        }
                        this.parseError(errStr,
                        {
                            text: this.lexer.match,
                            token: this.terminals_[symbol] || symbol,
                            line: this.lexer.yylineno,
                            loc: yyloc,
                            expected: expected
                        });
                    }

                    // just recovered from another error
                    if (recovering == 3) {
                        if (symbol == EOF) {
                            throw new Error(errStr || 'Parsing halted.');
                        }

                        // discard current lookahead and grab another
                        yyleng = this.lexer.yyleng;
                        yytext = this.lexer.yytext;
                        yylineno = this.lexer.yylineno;
                        yyloc = this.lexer.yylloc;
                        symbol = lex();
                    }

                    // try to recover from error
                    while (1) {
                        // check for error recovery rule in this state
                        if ((TERROR.toString()) in table[state]) {
                            break;
                        }
                        if (state == 0) {
                            throw new Error(errStr || 'Parsing halted.');
                        }
                        popStack(1);
                        state = stack[stack.length - 1];
                    }

                    preErrorSymbol = symbol; // save the lookahead token
                    symbol = TERROR; // insert generic error symbol as new lookahead
                    state = stack[stack.length - 1];
                    action = table[state] && table[state][TERROR];
                    recovering = 3; // allow 3 real symbols to be shifted before reporting a new error
                }

                // this shouldn't happen, unless resolve defaults are off
                if (action[0] instanceof Array && action.length > 1) {
                    throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
                }

                switch (action[0]) {

                case 1:
                    // shift
                    //this.shiftCount++;

                    stack.push(symbol);
                    vstack.push(this.lexer.yytext);
                    lstack.push(this.lexer.yylloc);
                    stack.push(action[1]); // push state
                    symbol = null;
                    if (!preErrorSymbol) {
                        // normal execution/no error
                        yyleng = this.lexer.yyleng;
                        yytext = this.lexer.yytext;
                        yylineno = this.lexer.yylineno;
                        yyloc = this.lexer.yylloc;
                        if (recovering > 0)
                            recovering--;
                    } else {
                        // error just occurred, resume old lookahead f/ before error
                        symbol = preErrorSymbol;
                        preErrorSymbol = null;
                    }
                    break;

                case 2:
                    // reduce
                    //this.reductionCount++;

                    len = this.productions_[action[1]][1];

                    // perform semantic action
                    yyval.$ = vstack[vstack.length - len]; // default to $$ = $1
                    // default location, uses first token for firsts, last for lasts
                    yyval._$ = {
                        first_line: lstack[lstack.length - (len || 1)].first_line,
                        last_line: lstack[lstack.length - 1].last_line,
                        first_column: lstack[lstack.length - (len || 1)].first_column,
                        last_column: lstack[lstack.length - 1].last_column
                    };
                    r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);

                    if (typeof r !== 'undefined') {
                        return r;
                    }

                    // pop off stack
                    if (len) {
                        stack = stack.slice(0, - 1 * len * 2);
                        vstack = vstack.slice(0, - 1 * len);
                        lstack = lstack.slice(0, - 1 * len);
                    }

                    stack.push(this.productions_[action[1]][0]); // push nonterminal (reduce)
                    vstack.push(yyval.$);
                    lstack.push(yyval._$);
                    // goto new state = table[STATE][NONTERMINAL]
                    newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                    stack.push(newState);
                    break;

                case 3:
                    // accept
                    return true;
                }

            }

            return true;
        }
    }; /* Jison generated lexer */
    var lexer = (function() {
        var lexer = ({
            EOF: 1,
            parseError: function parseError(str, hash) {
                if (this.yy.parseError) {
                    this.yy.parseError(str, hash);
                } else {
                    throw new Error(str);
                }
            },
            setInput: function (input) {
                this._input = input;
                this._more = this._less = this.done = false;
                this.yylineno = this.yyleng = 0;
                this.yytext = this.matched = this.match = '';
                this.conditionStack = ['INITIAL'];
                this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0
                };
                return this;
            },
            input: function () {
                var ch = this._input[0];
                this.yytext += ch;
                this.yyleng++;
                this.match += ch;
                this.matched += ch;
                var lines = ch.match(/\n/);
                if (lines) 
                    this.yylineno++;
                this._input = this._input.slice(1);
                return ch;
            },
            unput: function (ch) {
                this._input = ch + this._input;
                return this;
            },
            more: function () {
                this._more = true;
                return this;
            },
            pastInput: function () {
                var past = this.matched.substr(0, this.matched.length - this.match.length);
                return (past.length > 20 ? '...' : '') + past.substr( - 20).replace(/\n/g, "");
            },
            upcomingInput: function () {
                var next = this.match;
                if (next.length < 20) {
                    next += this._input.substr(0, 20 - next.length);
                }
                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
            },
            showPosition: function () {
                var pre = this.pastInput();
                var c = new Array(pre.length + 1).join("-");
                return pre + this.upcomingInput() + "\n" + c + "^";
            },
            next: function () {
                if (this.done) {
                    return this.EOF;
                }
                if (!this._input) 
                    this.done = true;

                var token,
                match,
                col,
                lines;
                if (!this._more) {
                    this.yytext = '';
                    this.match = '';
                }
                var rules = this._currentRules();
                for (var i = 0; i < rules.length; i++) {
                    match = this._input.match(this.rules[rules[i]]);
                    if (match) {
                        lines = match[0].match(/\n.*/g);
                        if (lines) 
                            this.yylineno += lines.length;
                        this.yylloc = {
                            first_line: this.yylloc.last_line,
                            last_line: this.yylineno + 1,
                            first_column: this.yylloc.last_column,
                            last_column: lines ? lines[lines.length - 1].length - 1 : this.yylloc.last_column + match[0].length
                        }
                        this.yytext += match[0];
                        this.match += match[0];
                        this.matches = match;
                        this.yyleng = this.yytext.length;
                        this._more = false;
                        this._input = this._input.slice(match[0].length);
                        this.matched += match[0];
                        token = this.performAction.call(this, this.yy, this, rules[i], this.conditionStack[this.conditionStack.length - 1]);
                        if (token) 
                            return token;
                        else 
                            return;
                    }
                }
                if (this._input === "") {
                    return this.EOF;
                } else {
                    this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(),
                    {
                        text: "",
                        token: null,
                        line: this.yylineno
                    });
                }
            },
            lex: function lex() {
                var r = this.next();
                if (typeof r !== 'undefined') {
                    return r;
                } else {
                    return this.lex();
                }
            },
            begin: function begin(condition) {
                this.conditionStack.push(condition);
            },
            popState: function popState() {
                return this.conditionStack.pop();
            },
            _currentRules: function _currentRules() {
                return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
            }
        });
        lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {

            var YYSTATE = YY_START
            switch ($avoiding_name_collisions) {
            case 0:
                this.begin("mu");
                if (yy_.yytext) 
                    return 14;
                break;
            case 1:
                return 14;
                break;
            case 2:
                return 24;
                break;
            case 3:
                return 16;
                break;
            case 4:
                return 20;
                break;
            case 5:
                return 19;
                break;
            case 6:
                return 19;
                break;
            case 7:
                return 23;
                break;
            case 8:
                return 23;
                break;
            case 9:
                yy_.yytext = yy_.yytext.substr(3, yy_.yyleng - 5);
                this.begin("INITIAL");
                return 15;
                break;
            case 10:
                return 22;
                break;
            case 11:
                return 34;
                break;
            case 12:
                return 33;
                break;
            case 13:
                return 33;
                break;
            case 14:
                return 36;
                break;
            case 15:
                /*ignore whitespace*/
                break;
            case 16:
                this.begin("INITIAL");
                return 18;
                break;
            case 17:
                this.begin("INITIAL");
                return 18;
                break;
            case 18:
                yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2).replace(/\\"/g, '"');
                return 28;
                break;
            case 19:
                return 30;
                break;
            case 20:
                return 30;
                break;
            case 21:
                return 29;
                break;
            case 22:
                return 33;
                break;
            case 23:
                return 'INVALID';
                break;
            case 24:
                return 5;
                break;
            }
        };
        lexer.rules = [/^[^\x00]*?(?=(\{\{))/, /^[^\x00]+/, /^\{\{>/, /^\{\{#/, /^\{\{\//, /^\{\{\^/, /^\{\{\s*else\b/, /^\{\{\{/, /^\{\{&/, /^\{\{![\s\S]*?\}\}/, /^\{\{/, /^=/, /^\.(?=[} ])/, /^\.\./, /^[/.]/, /^\s+/, /^\}\}\}/, /^\}\}/, /^"(\\["]|[^"])*"/, /^true(?=[}\s])/, /^false(?=[}\s])/, /^[0-9]+(?=[}\s])/, /^[a-zA-Z0-9_$-]+(?=[=}\s/.])/, /^./, /^$/];
        lexer.conditions = {
            "mu": {
                "rules": [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24],
                "inclusive": false
            },
            "INITIAL": {
                "rules": [0, 1, 24],
                "inclusive": true
            }
        };
        return lexer;
    })()
    parser.lexer = lexer;
    return parser;
})();
if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
    exports.parser = handlebars;
    exports.parse = function () {
        return handlebars.parse.apply(handlebars, arguments);
    }
    exports.main = function commonjsMain(args) {
        if (!args[1])
            throw new Error('Usage: ' + args[0] + ' FILE');
        if (typeof process !== 'undefined') {
            var source = require('fs').readFileSync(require('path').join(process.cwd(), args[1]), "utf8");
        } else {
            var cwd = require("file").path(require("file").cwd());
            var source = cwd.join(args[1]).read({
                charset: "utf-8"
            });
        }
        return exports.parser.parse(source);
    }
    if (typeof module !== 'undefined' && require.main === module) {
        exports.main(typeof process !== 'undefined' ? process.argv.slice(1) : require("system").args);
    }
};;
// lib/handlebars/base.js
var Handlebars = {};

Handlebars.VERSION = "1.0.beta.2";

Handlebars.Parser = handlebars;

Handlebars.parse = function(string) {
    Handlebars.Parser.yy = Handlebars.AST;
    return Handlebars.Parser.parse(string);
};

Handlebars.print = function(ast) {
    return new Handlebars.PrintVisitor().accept(ast);
};

Handlebars.helpers = {};
Handlebars.partials = {};

Handlebars.registerHelper = function(name, fn, inverse) {
    if (inverse) {
        fn.not = inverse;
    }
    this.helpers[name] = fn;
};

Handlebars.registerPartial = function(name, str) {
    this.partials[name] = str;
};

Handlebars.registerHelper('helperMissing', function(arg) {
    if (arguments.length === 2) {
        return undefined;
    } else {
        throw new Error("Could not find property '" + arg + "'");
    }
});

Handlebars.registerHelper('blockHelperMissing', function(context, fn, inverse) {
    inverse = inverse || function() {};

    var ret = "";
    var type = Object.prototype.toString.call(context);

    if (type === "[object Function]") {
        context = context();
    }

    if (context === true) {
        return fn(this);
    } else if (context === false || context == null) {
        return inverse(this);
    } else if (type === "[object Array]") {
        if (context.length > 0) {
            for (var i = 0, j = context.length; i < j; i++) {
                ret = ret + fn(context[i]);
            }
        } else {
            ret = inverse(this);
        }
        return ret;
    } else {
        return fn(context);
    }
}, function(context, fn) {
    return fn(context);
});

Handlebars.registerHelper('each', function(context, fn, inverse) {
    var ret = "";

    if (context && context.length > 0) {
        for (var i = 0, j = context.length; i < j; i++) {
            ret = ret + fn(context[i]);
        }
    } else {
        ret = inverse(this);
    }
    return ret;
});

Handlebars.registerHelper('if', function(context, fn, inverse) {
    if (!context || context == []) {
        return inverse(this);
    } else {
        return fn(this);
    }
});

Handlebars.registerHelper('unless', function(context, fn, inverse) {
    return Handlebars.helpers['if'].call(this, context, inverse, fn);
});

Handlebars.registerHelper('with', function(context, fn) {
    return fn(context);
});

Handlebars.logger = {
    DEBUG: 0,
    INFO: 1,
    WARN: 2,
    ERROR: 3,
    level: 3,

    // override in the host environment
    log: function(level, str) {}
};

Handlebars.log = function(level, str) {
    Handlebars.logger.log(level, str);
};;
// lib/handlebars/ast.js
(function() {

    Handlebars.AST = {};

    Handlebars.AST.ProgramNode = function(statements, inverse) {
        this.type = "program";
        this.statements = statements;
        if (inverse) {
            this.inverse = new Handlebars.AST.ProgramNode(inverse);
        }
    };

    Handlebars.AST.MustacheNode = function(params, hash, unescaped) {
        this.type = "mustache";
        this.id = params[0];
        this.params = params.slice(1);
        this.hash = hash;
        this.escaped = !unescaped;
    };

    Handlebars.AST.PartialNode = function(id, context) {
        this.type = "partial";

        // TODO: disallow complex IDs

        this.id = id;
        this.context = context;
    };

    var verifyMatch = function(open, close) {
        if (open.original !== close.original) {
            throw new Handlebars.Exception(open.original + " doesn't match " + close.original);
        }
    };

    Handlebars.AST.BlockNode = function(mustache, program, close) {
        verifyMatch(mustache.id, close);
        this.type = "block";
        this.mustache = mustache;
        this.program = program;
    };

    Handlebars.AST.InverseNode = function(mustache, program, close) {
        verifyMatch(mustache.id, close);
        this.type = "inverse";
        this.mustache = mustache;
        this.program = program;
    };

    Handlebars.AST.ContentNode = function(string) {
        this.type = "content";
        this.string = string;
    };

    Handlebars.AST.HashNode = function(pairs) {
        this.type = "hash";
        this.pairs = pairs;
    };

    Handlebars.AST.IdNode = function(parts) {
        this.type = "ID";
        this.original = parts.join(".");

        var dig = [], depth = 0;

        for (var i = 0, l = parts.length; i < l; i++) {
            var part = parts[i];

            if (part === "..") {
                depth++;
            } else if (part === "." || part === "this") {
                continue;
            } else {
                dig.push(part);
            }
        }

        this.parts = dig;
        this.string = dig.join('.');
        this.depth = depth;
        this.isSimple = (dig.length === 1) && (depth === 0);
    };

    Handlebars.AST.StringNode = function(string) {
        this.type = "STRING";
        this.string = string;
    };

    Handlebars.AST.IntegerNode = function(integer) {
        this.type = "INTEGER";
        this.integer = integer;
    };

    Handlebars.AST.BooleanNode = function(boolean) {
        this.type = "BOOLEAN";
        this.boolean = boolean;
    };

    Handlebars.AST.CommentNode = function(comment) {
        this.type = "comment";
        this.comment = comment;
    };

})();;
// lib/handlebars/visitor.js

Handlebars.Visitor = function() {};

Handlebars.Visitor.prototype = {
    accept: function(object) {
        return this[object.type](object);
    }
};;
// lib/handlebars/utils.js
Handlebars.Exception = function(message) {
    this.message = message;
};

// Build out our basic SafeString type
Handlebars.SafeString = function(string) {
    this.string = string;
};
Handlebars.SafeString.prototype.toString = function() {
    return this.string.toString();
};

(function() {
    var escape = {
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#x27;",
        "`": "&#x60;"
    };

    var badChars = /&(?!\w+;)|[<>"'`]/g;
    var possible = /[&<>"'`]/;

    var escapeChar = function(chr) {
        return escape[chr] || "&amp;"
    };

    Handlebars.Utils = {
        escapeExpression: function(string) {
            // don't escape SafeStrings, since they're already safe
            if (string instanceof Handlebars.SafeString) {
                return string.toString();
            } else if (string == null || string === false) {
                return "";
            }

            if (!possible.test(string)) {
                return string;
            }
            return string.replace(badChars, escapeChar);
        },

        isEmpty: function(value) {
            if (typeof value === "undefined") {
                return true;
            } else if (value === null) {
                return true;
            } else if (value === false) {
                return true;
            } else if (Object.prototype.toString.call(value) === "[object Array]" && value.length === 0) {
                return true;
            } else {
                return false;
            }
        }
    };
})();;
// lib/handlebars/compiler.js
Handlebars.Compiler = function() {};
Handlebars.JavaScriptCompiler = function() {};

(function(Compiler, JavaScriptCompiler) {
    Compiler.OPCODE_MAP = {
        appendContent: 1,
        getContext: 2,
        lookupWithHelpers: 3,
        lookup: 4,
        append: 5,
        invokeMustache: 6,
        appendEscaped: 7,
        pushString: 8,
        truthyOrFallback: 9,
        functionOrFallback: 10,
        invokeProgram: 11,
        invokePartial: 12,
        push: 13,
        invokeInverse: 14,
        assignToHash: 15,
        pushStringParam: 16
    };

    Compiler.MULTI_PARAM_OPCODES = {
        appendContent: 1,
        getContext: 1,
        lookupWithHelpers: 1,
        lookup: 1,
        invokeMustache: 2,
        pushString: 1,
        truthyOrFallback: 1,
        functionOrFallback: 1,
        invokeProgram: 2,
        invokePartial: 1,
        push: 1,
        invokeInverse: 1,
        assignToHash: 1,
        pushStringParam: 1
    };

    Compiler.DISASSEMBLE_MAP = {};

    for (var prop in Compiler.OPCODE_MAP) {
        var value = Compiler.OPCODE_MAP[prop];
        Compiler.DISASSEMBLE_MAP[value] = prop;
    }

    Compiler.multiParamSize = function(code) {
        return Compiler.MULTI_PARAM_OPCODES[Compiler.DISASSEMBLE_MAP[code]];
    };

    Compiler.prototype = {
        compiler: Compiler,

        disassemble: function() {
            var opcodes = this.opcodes, opcode, nextCode;
            var out = [], str, name, value;

            for (var i = 0, l = opcodes.length; i < l; i++) {
                opcode = opcodes[i];

                if (opcode === 'DECLARE') {
                    name = opcodes[++i];
                    value = opcodes[++i];
                    out.push("DECLARE " + name + " = " + value);
                } else {
                    str = Compiler.DISASSEMBLE_MAP[opcode];

                    var extraParams = Compiler.multiParamSize(opcode);
                    var codes = [];

                    for (var j = 0; j < extraParams; j++) {
                        nextCode = opcodes[++i];

                        if (typeof nextCode === "string") {
                            nextCode = "\"" + nextCode.replace("\n", "\\n") + "\"";
                        }

                        codes.push(nextCode);
                    }

                    str = str + " " + codes.join(" ");

                    out.push(str);
                }
            }

            return out.join("\n");
        },

        guid: 0,

        compile: function(program, options) {
            this.children = [];
            this.depths = {
                list: []
            };
            this.options = options || {};
            return this.program(program);
        },

        accept: function(node) {
            return this[node.type](node);
        },

        program: function(program) {
            var statements = program.statements, statement;
            this.opcodes = [];

            for (var i = 0, l = statements.length; i < l; i++) {
                statement = statements[i];
                this[statement.type](statement);
            }

            this.depths.list = this.depths.list.sort(function(a, b) {
                return a - b;
            });

            return this;
        },

        compileProgram: function(program) {
            var result = new this.compiler().compile(program, this.options);
            var guid = this.guid++;

            this.usePartial = this.usePartial || result.usePartial;

            this.children[guid] = result;

            for (var i = 0, l = result.depths.list.length; i < l; i++) {
                depth = result.depths.list[i];

                if (depth < 2) {
                    continue;
                } else {
                    this.addDepth(depth - 1);
                }
            }

            return guid;
        },

        block: function(block) {
            var mustache = block.mustache;
            var depth, child, inverse, inverseGuid;

            var params = this.setupStackForMustache(mustache);

            var programGuid = this.compileProgram(block.program);

            if (block.program.inverse) {
                inverseGuid = this.compileProgram(block.program.inverse);
                this.declare('inverse', inverseGuid);
            }

            this.opcode('invokeProgram', programGuid, params.length);
            this.declare('inverse', null);
            this.opcode('append');
        },

        inverse: function(block) {
            this.ID(block.mustache.id);
            var programGuid = this.compileProgram(block.program);

            this.opcode('invokeInverse', programGuid);
            this.opcode('append');
        },

        hash: function(hash) {
            var pairs = hash.pairs, pair, val;

            this.opcode('push', '{}');

            for (var i = 0, l = pairs.length; i < l; i++) {
                pair = pairs[i];
                val = pair[1];

                this.accept(val);
                this.opcode('assignToHash', pair[0]);
            }
        },

        partial: function(partial) {
            var id = partial.id;
            this.usePartial = true;

            if (partial.context) {
                this.ID(partial.context);
            } else {
                this.opcode('push', 'context');
            }

            this.opcode('invokePartial', id.original);
            this.opcode('append');
        },

        content: function(content) {
            this.opcode('appendContent', content.string);
        },

        mustache: function(mustache) {
            var params = this.setupStackForMustache(mustache);

            this.opcode('invokeMustache', params.length, mustache.id.original);

            if (mustache.escaped) {
                this.opcode('appendEscaped');
            } else {
                this.opcode('append');
            }
        },

        ID: function(id) {
            this.addDepth(id.depth);

            this.opcode('getContext', id.depth);

            this.opcode('lookupWithHelpers', id.parts[0] || null);

            for (var i = 1, l = id.parts.length; i < l; i++) {
                this.opcode('lookup', id.parts[i]);
            }
        },

        STRING: function(string) {
            this.opcode('pushString', string.string);
        },

        INTEGER: function(integer) {
            this.opcode('push', integer.integer);
        },

        BOOLEAN: function(boolean) {
            this.opcode('push', boolean.boolean);
        },

        comment: function() {},

        // HELPERS
        pushParams: function(params) {
            var i = params.length, param;

            while (i--) {
                param = params[i];

                if (this.options.stringParams) {
                    if (param.depth) {
                        this.addDepth(param.depth);
                    }

                    this.opcode('getContext', param.depth || 0);
                    this.opcode('pushStringParam', param.string);
                } else {
                    this[param.type](param);
                }
            }
        },

        opcode: function(name, val1, val2) {
            this.opcodes.push(Compiler.OPCODE_MAP[name]);
            if (val1 !== undefined) {
                this.opcodes.push(val1);
            }
            if (val2 !== undefined) {
                this.opcodes.push(val2);
            }
        },

        declare: function(name, value) {
            this.opcodes.push('DECLARE');
            this.opcodes.push(name);
            this.opcodes.push(value);
        },

        addDepth: function(depth) {
            if (depth === 0) {
                return;
            }

            if (!this.depths[depth]) {
                this.depths[depth] = true;
                this.depths.list.push(depth);
            }
        },

        setupStackForMustache: function(mustache) {
            var params = mustache.params;

            this.pushParams(params);

            if (mustache.hash) {
                this.hash(mustache.hash);
            } else {
                this.opcode('push', '{}');
            }

            this.ID(mustache.id);

            return params;
        }
    };

    JavaScriptCompiler.prototype = {
        // PUBLIC API: You can override these methods in a subclass to provide
        // alternative compiled forms for name lookup and buffering semantics
        nameLookup: function(parent, name, type) {
            if (JavaScriptCompiler.RESERVED_WORDS[name] || name.indexOf('-') !== - 1 || !isNaN(name)) {
                return parent + "['" + name + "']";
            } else if (/^[0-9]+$/.test(name)) {
                return parent + "[" + name + "]";
            } else {
                return parent + "." + name;
            }
        },

        appendToBuffer: function(string) {
            return "buffer = buffer + " + string + ";";
        },

        initializeBuffer: function() {
            return this.quotedString("");
        },
        // END PUBLIC API

        compile: function(environment, options) {
            this.environment = environment;
            this.options = options || {};

            this.preamble();

            this.stackSlot = 0;
            this.stackVars = [];
            this.registers = {
                list: []
            };

            this.compileChildren(environment, options);

            Handlebars.log(Handlebars.logger.DEBUG, environment.disassemble() + "\n\n");

            var opcodes = environment.opcodes, opcode, name, declareName, declareVal;

            this.i = 0;

            for (l = opcodes.length; this.i < l; this.i++) {
                opcode = this.nextOpcode(0);

                if (opcode[0] === 'DECLARE') {
                    this.i = this.i + 2;
                    this[opcode[1]] = opcode[2];
                } else {
                    this.i = this.i + opcode[1].length;
                    this[opcode[0]].apply(this, opcode[1]);
                }
            }

            return this.createFunction();
        },

        nextOpcode: function(n) {
            var opcodes = this.environment.opcodes, opcode = opcodes[this.i + n], name, val;
            var extraParams, codes;

            if (opcode === 'DECLARE') {
                name = opcodes[this.i + 1];
                val = opcodes[this.i + 2];
                return ['DECLARE', name, val];
            } else {
                name = Compiler.DISASSEMBLE_MAP[opcode];

                extraParams = Compiler.multiParamSize(opcode);
                codes = [];

                for (var j = 0; j < extraParams; j++) {
                    codes.push(opcodes[this.i + j + 1 + n]);
                }

                return [name, codes];
            }
        },

        eat: function(opcode) {
            this.i = this.i + opcode.length;
        },

        preamble: function() {
            var out = [];
            out.push("var buffer = " + this.initializeBuffer() + ", currentContext = context");

            var copies = "helpers = helpers || Handlebars.helpers;";
            if (this.environment.usePartial) {
                copies = copies + " partials = partials || Handlebars.partials;";
            }
            out.push(copies);

            // track the last context pushed into place to allow skipping the
            // getContext opcode when it would be a noop
            this.lastContext = 0;
            this.source = out;
        },

        createFunction: function() {
            var container = {
                escapeExpression: Handlebars.Utils.escapeExpression,
                invokePartial: Handlebars.VM.invokePartial,
                programs: [],
                program: function(i, helpers, partials, data) {
                    var programWrapper = this.programs[i];
                    if (data) {
                        return Handlebars.VM.program(this.children[i], helpers, partials, data);
                    } else if (programWrapper) {
                        return programWrapper;
                    } else {
                        programWrapper = this.programs[i] = Handlebars.VM.program(this.children[i], helpers, partials);
                        return programWrapper;
                    }
                },
                programWithDepth: Handlebars.VM.programWithDepth,
                noop: Handlebars.VM.noop
            };
            var locals = this.stackVars.concat(this.registers.list);

            if (locals.length > 0) {
                this.source[0] = this.source[0] + ", " + locals.join(", ");
            }

            this.source[0] = this.source[0] + ";";

            this.source.push("return buffer;");

            var params = ["Handlebars", "context", "helpers", "partials"];

            if (this.options.data) {
                params.push("data");
            }

            for (var i = 0, l = this.environment.depths.list.length; i < l; i++) {
                params.push("depth" + this.environment.depths.list[i]);
            }

            if (params.length === 4 && !this.environment.usePartial) {
                params.pop();
            }

            params.push(this.source.join("\n"));

            var fn = Function.apply(this, params);
            fn.displayName = "Handlebars.js";

            Handlebars.log(Handlebars.logger.DEBUG, fn.toString() + "\n\n");

            container.render = fn;

            container.children = this.environment.children;

            return function(context, options, $depth) {
                try {
                    options = options || {};
                    var args = [Handlebars, context, options.helpers, options.partials, options.data];
                    var depth = Array.prototype.slice.call(arguments, 2);
                    args = args.concat(depth);
                    return container.render.apply(container, args);
                } catch (e) {
                    throw e;
                }
            };
        },

        appendContent: function(content) {
            this.source.push(this.appendToBuffer(this.quotedString(content)));
        },

        append: function() {
            var local = this.popStack();
            this.source.push("if(" + local + " || " + local + " === 0) { " + this.appendToBuffer(local) + " }");
        },

        appendEscaped: function() {
            var opcode = this.nextOpcode(1), extra = "";

            if (opcode[0] === 'appendContent') {
                extra = " + " + this.quotedString(opcode[1][0]);
                this.eat(opcode);
            }

            this.source.push(this.appendToBuffer("this.escapeExpression(" + this.popStack() + ")" + extra));
        },

        getContext: function(depth) {
            if (this.lastContext !== depth) {
                this.lastContext = depth;

                if (depth === 0) {
                    this.source.push("currentContext = context;");
                } else {
                    this.source.push("currentContext = depth" + depth + ";");
                }
            }
        },

        lookupWithHelpers: function(name) {
            if (name) {
                var topStack = this.nextStack();

                var toPush = "if('" + name + "' in helpers) { " + topStack +
                " = " + this.nameLookup('helpers', name, 'helper') +
                "; } else { " + topStack + " = " +
                this.nameLookup('currentContext', name, 'context') +
                "; }";

                this.source.push(toPush);
            } else {
                this.pushStack("currentContext");
            }
        },

        lookup: function(name) {
            var topStack = this.topStack();
            this.source.push(topStack + " = " + this.nameLookup(topStack, name, 'context') + ";");
        },

        pushStringParam: function(string) {
            this.pushStack("currentContext");
            this.pushString(string);
        },

        pushString: function(string) {
            this.pushStack(this.quotedString(string));
        },

        push: function(name) {
            this.pushStack(name);
        },

        invokeMustache: function(paramSize, original) {
            this.populateParams(paramSize, this.quotedString(original), "{}", null, function(nextStack, helperMissingString, id) {
                this.source.push("else if(" + id + "=== undefined) { " + nextStack + " = helpers.helperMissing.call(" + helperMissingString + "); }");
                this.source.push("else { " + nextStack + " = " + id + "; }");
            });
        },

        invokeProgram: function(guid, paramSize) {
            var inverse = this.programExpression(this.inverse);
            var mainProgram = this.programExpression(guid);

            this.populateParams(paramSize, null, mainProgram, inverse, function(nextStack, helperMissingString, id) {
                this.source.push("else { " + nextStack + " = helpers.blockHelperMissing.call(" + helperMissingString + "); }");
            });
        },

        populateParams: function(paramSize, helperId, program, inverse, fn) {
            var id = this.popStack(), nextStack;
            var params = [], param, stringParam;

            var hash = this.popStack();

            this.register('tmp1', program);
            this.source.push('tmp1.hash = ' + hash + ';');

            if (this.options.stringParams) {
                this.source.push('tmp1.contexts = [];');
            }

            for (var i = 0; i < paramSize; i++) {
                param = this.popStack();
                params.push(param);

                if (this.options.stringParams) {
                    this.source.push('tmp1.contexts.push(' + this.popStack() + ');');
                }
            }

            if (inverse) {
                this.source.push('tmp1.fn = tmp1;');
                this.source.push('tmp1.inverse = ' + inverse + ';');
            }

            if (this.options.data) {
                this.source.push('tmp1.data = data;');
            }

            params.push('tmp1');

            // TODO: This is legacy behavior. Deprecate and remove.
            if (inverse) {
                params.push(inverse);
            }

            this.populateCall(params, id, helperId || id, fn);
        },

        populateCall: function(params, id, helperId, fn) {
            var paramString = ["context"].concat(params).join(", ");
            var helperMissingString = ["context"].concat(helperId).concat(params).join(", ");

            nextStack = this.nextStack();

            this.source.push("if(typeof " + id + " === 'function') { " + nextStack + " = " + id + ".call(" + paramString + "); }");
            fn.call(this, nextStack, helperMissingString, id);
        },

        invokeInverse: function(guid) {
            var program = this.programExpression(guid);

            var blockMissingParams = ["context", this.topStack(), "this.noop", program];
            this.pushStack("helpers.blockHelperMissing.call(" + blockMissingParams.join(", ") + ")");
        },

        invokePartial: function(context) {
            this.pushStack("this.invokePartial(" + this.nameLookup('partials', context, 'partial') + ", '" + context + "', " + this.popStack() + ", helpers, partials);");
        },

        assignToHash: function(key) {
            var value = this.popStack();
            var hash = this.topStack();

            this.source.push(hash + "['" + key + "'] = " + value + ";");
        },

        // HELPERS

        compiler: JavaScriptCompiler,

        compileChildren: function(environment, options) {
            var children = environment.children, child, compiler;
            var compiled = [];

            for (var i = 0, l = children.length; i < l; i++) {
                child = children[i];
                compiler = new this.compiler();

                compiled[i] = compiler.compile(child, options);
            }

            environment.rawChildren = children;
            environment.children = compiled;
        },

        programExpression: function(guid) {
            if (guid == null) {
                return "this.noop";
            }

            var programParams = [guid, "helpers", "partials"];

            var depths = this.environment.rawChildren[guid].depths.list;

            if (this.options.data) {
                programParams.push("data");
            }

            for (var i = 0, l = depths.length; i < l; i++) {
                depth = depths[i];

                if (depth === 1) {
                    programParams.push("context");
                } else {
                    programParams.push("depth" + (depth - 1));
                }
            }

            if (!this.environment.usePartial) {
                if (programParams[3]) {
                    programParams[2] = "null";
                } else {
                    programParams.pop();
                }
            }

            if (depths.length === 0) {
                return "this.program(" + programParams.join(", ") + ")";
            } else {
                programParams[0] = "this.children[" + guid + "]";
                return "this.programWithDepth(" + programParams.join(", ") + ")";
            }
        },

        register: function(name, val) {
            this.useRegister(name);
            this.source.push(name + " = " + val + ";");
        },

        useRegister: function(name) {
            if (!this.registers[name]) {
                this.registers[name] = true;
                this.registers.list.push(name);
            }
        },

        pushStack: function(item) {
            this.source.push(this.nextStack() + " = " + item + ";");
            return "stack" + this.stackSlot;
        },

        nextStack: function() {
            this.stackSlot++;
            if (this.stackSlot > this.stackVars.length) {
                this.stackVars.push("stack" + this.stackSlot);
            }
            return "stack" + this.stackSlot;
        },

        popStack: function() {
            return "stack" + this.stackSlot--;
        },

        topStack: function() {
            return "stack" + this.stackSlot;
        },

        quotedString: function(str) {
            return '"' + str
            .replace(/\\/g, '\\\\')
            .replace(/"/g, '\\"')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r') + '"';
        }
    };

    var reservedWords = ("break case catch continue default delete do else finally " +
    "for function if in instanceof new return switch this throw " +
    "try typeof var void while with null true false").split(" ");

    compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};

    for (var i = 0, l = reservedWords.length; i < l; i++) {
        compilerWords[reservedWords[i]] = true;
    }

})(Handlebars.Compiler, Handlebars.JavaScriptCompiler);

Handlebars.VM = {
    programWithDepth: function(fn, helpers, partials, data, $depth) {
        var args = Array.prototype.slice.call(arguments, 4);

        return function(context, options) {
            options = options || {};

            options = {
                helpers: options.helpers || helpers,
                partials: options.partials || partials,
                data: options.data || data
            };

            return fn.apply(this, [context, options].concat(args));
        };
    },
    program: function(fn, helpers, partials, data) {
        return function(context, options) {
            options = options || {};

            return fn(context, {
                helpers: options.helpers || helpers,
                partials: options.partials || partials,
                data: options.data || data
            });
        };
    },
    noop: function() {
        return "";
    },
    compile: function(string, options) {
        var ast = Handlebars.parse(string);
        var environment = new Handlebars.Compiler().compile(ast, options);
        return new Handlebars.JavaScriptCompiler().compile(environment, options);
    },
    invokePartial: function(partial, name, context, helpers, partials) {
        if (partial === undefined) {
            throw new Handlebars.Exception("The partial " + name + " could not be found");
        } else if (partial instanceof Function) {
            return partial(context, {
                helpers: helpers,
                partials: partials
            });
        } else {
            partials[name] = Handlebars.VM.compile(partial);
            return partials[name](context, {
                helpers: helpers,
                partials: partials
            });
        }
    }
};

Handlebars.compile = Handlebars.VM.compile;;

define("handlebars", function() {});

define('handlebars.helpers', ['translate', 'moment-loc', 'webs/props', 'handlebars'], function (translate, moment, props) {

    // localize text
    Handlebars.registerHelper('l', function (options) {
        //doesn't escape html entities so Product can put links. use Handlebars.SafeString(translate.translate(options.fn(this))); if you want to.
        return translate.translate(options.fn(this));
    });

    Handlebars.registerHelper('hideHeaderComponent', function (componentName, mobile, options) {
        if (typeof mobile_view === 'string') {
            if (mobile && mobile[componentName]) {
                return "";
            }
        }
        return options.fn(this);
    });

    Handlebars.registerHelper('first', function (list, block, inverse) {
        return list && typeof(list.length) === 'number' && list.length > 0 ? block(list[0]) : inverse();
    });

    Handlebars.registerHelper('greater', function (left, right, block, inverse) {
        if (left > right) {
            return block();
        } else {
            return inverse();
        }
    });

    Handlebars.registerHelper('last', function (list, block, inverse) {
        return list && typeof(list.length) === 'number' && list.length > 0 ? block(list[list.length - 1]) : inverse();
    });

    // Same as built-in helper, but gives content an index and 1+
    Handlebars.registerHelper('each', function (context, block) {
        var ret = "";
        for (var i = 0, j = context.length; i < j; i++) {
            if (typeof(context[i]) === 'object' && context[i] !== null) {
                context[i]._i_ = i;
                context[i]._ip1_ = i + 1;
                // Allows for styling of every nth element in a collection
                context[i]._every_ = function(nth, output) {
                    if ((i + 1) % nth == 0) {
                        return output;
                    }
                };
            }
            ret = ret + block(context[i]);
        }
        return ret;
    });

    Handlebars.registerHelper('seoFooterLinks', function (links, options) {
        var ret = "<ul>",
        i = 0;
        for (; i < links.length; i++) {
            ret += "<li>" + options.fn(links[i]) + "</li>";
            if ((i + 1) % 4 === 0 && links.length > i + 1) {
                ret += "</ul><ul>";
            }
        }
        return ret + "</ul>";
    });

    Handlebars.registerHelper('formatTime', function (hours, minutes, ampm, options) {
        // only used in mobile_hours site
        minutes = minutes < 10 ? "0" + minutes : minutes;
        var timeString = '' + hours + ':' + minutes;
        timeString += ampm ? ' ' + ampm : '';

        return timeString;
    });

    Handlebars.registerHelper('shortenDay', function (day, options) {
        return day.substr(0, 3);
    });

    // The each helper doesn't give you indexes if run on an array of strings,
    // since it tries to put the _i_ and _ip1_ in as properties of the string
    // objects. This helper gives you 'val', '_i_', and '_ip1_' as the new context.
    Handlebars.registerHelper('each_object', function (context, block) {
        var ret = "";
        for (var i = 0, j = context.length; i < j; i++) {
            var data = {
                val: context[i],
                _i_: i,
                _ip1_: i + 1
            };
            ret += block(data);
        }
        return ret;
    });

    Handlebars.registerHelper('text_to_html', function (str, block, inverse) {
        return str.replace(/\n/gi, "<br>");
    });

    Handlebars.registerHelper('case', function (context, condition, block, inverse) {
        if (context == condition) {
            return block(this);
        } else {
            return inverse(this);
        }
    });

    Handlebars.registerHelper('unlessCase', function (context, condition, block, inverse) {
        if (context != condition) {
            return block(this);
        } else {
            return inverse(this);
        }
    });

    Handlebars.registerHelper('odd', function (number, block, inverse) {
        return number % 2 === 1 ? block(this) : inverse(this);
    });

    Handlebars.registerHelper('array_value', function (array, index) {
        return array[index];
    });

    Handlebars.registerHelper('renderIcon', function (context) {
        var html = '<span class="w-icon';
        if (context && typeof context.slug === 'string') 
            html += ' w-icon-' + context.slug;
        if (context && typeof context.set === 'string') 
            html += ' w-iconset-' + context.set;
        html += '"';
        if (!context || !context.enable) 
            html += ' style="display:none"';
        html += '></span>';
        return new Handlebars.SafeString(html);
    });

    Handlebars.registerHelper('ordered_list', function (context, order, block, inverse) {
        var curr,
        ret = '';
        if (order.length === 0) 
            return inverse(context);
        for (var i = 0; i < order.length; i++) {
            curr = {};
            curr[order[i]] = context[order[i]];
            ret += block(curr);
        }
        return ret;
    });

    Handlebars.registerHelper('manipulate_image', function (context, block) {
        var url = 'http://imageprocessor.websimages.com';
        if (props.imageProcessorServer) {
            url = props.imageProcessorServer;
        }

        var baseUrl;

        if (typeof(context) === 'string') {
            baseUrl = context;
            if (block.hash.square) {
                url += '/square/' + block.hash.square;
            }
            if (isFinite(block.hash.width)) {
                url += '/width/' + parseInt(block.hash.width, 10);
            }
            if (isFinite(block.hash.fitWidth)) {
                url += '/fit/' + parseInt(block.hash.fitWidth, 10) + "x" + parseInt(block.hash.fitHeight, 10);
            }

        } else {
            var siteUrl = top.webs && top.webs.site && top.webs.site.url;
            if (context.imageType == 'webs' && context.webs && context.webs.path && context.webs.path[0] != '/' && context.webs.path[context.webs.path.length - 1] != '/' && siteUrl) {
                baseUrl = siteUrl + context.webs.path;
            } else {
                baseUrl = context.url;
            }

            if (block.hash && (block.hash.square || block.hash.width || block.hash.fitWidth)) {
                if (isFinite(block.hash.square)) {
                    url += '/square/' + block.hash.square;
                }
                if (isFinite(block.hash.width)) {
                    url += '/width/' + parseInt(block.hash.width, 10);
                }
                if (isFinite(block.hash.fitWidth)) {
                    url += '/fit/' + parseInt(block.hash.fitWidth, 10) + "x" + parseInt(block.hash.fitHeight, 10);
                }
            } else {
                var resizeFactor = (context.imageWidth / 100);

                var width = Math.round(context.width * resizeFactor);

                // Zoom images 2px more on preview/siteview of photo gallery module resolve 1px differences on edges of images
                if (context.module == 'photo_gallery') {
                    width += 2;
                }

                // scale
                url += '/width/' + width;

                // crop
                var cropTop, cropLeft;
                cropLeft = Math.round( - 1 * (context.left || 0));
                cropTop = Math.round( - 1 * (context.top || 0));
                url += '/crop/' + cropLeft + ',' + cropTop + ',' + context.width + 'x' + context.height;
            }
        }

        url += baseUrl.replace(/https?:\/\//i, '/');
        return url;
    });

    Handlebars.registerHelper('replace', function (str, searchString, replacement) {
        return str.replace(new RegExp(searchString, "g"), replacement);
    });

    Handlebars.registerHelper('submodule', function (slug, data) {
        return new Handlebars.SafeString(
        '<div class="webs-submodule webs-submodule-' + slug + '" webs-submodule-slug="' + slug + '">' +
        webs.modules.ModuleClassLoader.getClass(slug)._compiledTemplate(data) +
        '</div>');
    });

    // Render the href and target attributes inside an already-open a tag.
    Handlebars.registerHelper('renderLinkAttributes', function (linkInfo) {
        var href, classes = [], attributes = '';

        if (linkInfo.lightbox) {
            if (linkInfo.enabled)
                href = "#";
        } else if (linkInfo.url) {
            href = linkInfo.url;
        } else if (linkInfo.email) {
            href = "mailto:" + linkInfo.email;
        }

        if (href) 
            href = Handlebars.Utils.escapeExpression(href);
        if (linkInfo.newWindow) 
            classes.push("w-link-new-window");

        if (href) 
            attributes += ' href="' + href + '"';
        if (classes.length) 
            attributes += ' class="' + classes.join(" ") + '"';

        return new Handlebars.SafeString(attributes);
    });

    // Wrap arguments in an a tag using the provided linkInfo
    Handlebars.registerHelper('wrapInLink', function (linkInfo, block) {
        var out = block(this);

        if (linkInfo) {
            out = '<a ' + Handlebars.helpers.renderLinkAttributes.call(this, linkInfo) + '>' + out;
            out += "</a>";
        }
        return new Handlebars.SafeString(out);
    });

    // Escape special characters for URL encoding
    Handlebars.registerHelper('encodeURIComponent', function (content) {
        return encodeURIComponent(content);
    });

    Handlebars.registerHelper('formatFacebookURL', function(url) {
        /*
        		 * Facebook only allows alphanumeric characters and periods in the page names...  So...
        		 * \w matches A-Z, a-z, and 0-9 \. matches periods
        		 * the + says we need at least one character
        		 * ^ and $ state that we need to check from the beginning to the end of the string
        		 */
        var alphanumericRegex = /^[\w\.]+$/;

        if ( alphanumericRegex.test(url) === true ) {
            url = "http://www.facebook.com/" + url;
        }
        return encodeURIComponent(url);
    });

    // Format a duration (in seconds) in m:ss, or h:mm:ss
    Handlebars.registerHelper('formatDuration', function (context) {
        if (typeof context != "number" || !isFinite(context)) 
            return "0:00";
        var seconds = parseInt(context, 10) % 60;
        var minutes = parseInt(context / 60, 10) % 60;
        var hours = parseInt(context / 60 / 60, 10);
        var formatted = "";
        if (hours !== 0)
            formatted += "" + hours + ":";
        if (hours !== 0 && minutes < 10)
            formatted += "0";
        formatted += minutes + ":";
        if (seconds < 10)
            formatted += "0";
        return formatted + seconds;
    });

    Handlebars.registerHelper('buildTitleCaption', function(context, image, block) {
        var ret = ""
        var data = {
            'showTitle' : (context.showTitle == 'grid' || context.showTitle == 'both'),
            'showCaption' : (context.showCaption == 'grid' || context.showCaption == 'both'),
            'showSocial' : false
        };

        if (data.showTitle || data.showCaption || data.showSocial) {
            // extend image to data
            for (var prop in image) {
                data[prop] = image[prop];
            }

            ret = block(data);
        }
        return new Handlebars.SafeString(ret);
    });

});

/*
 * jQuery utility functions. Ported into jQuery from underscore.js
 * Originally by Jeremy Ashkenas
 * Port: http://blog.greyboxware.com/2010/10/22/jquery-deep-comparison-checking-to-test-object-equality-underscore-js/
*/
(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define('internal/sitebuilder/builderChrome/utilities', ['jquery'], factory);
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {
    $.isDate = function(obj) {
        return !!(obj && obj.getTimezoneOffset && obj.setUTCFullYear);
    };

    $.isNumber = function(obj) {
        return (obj === + obj) || (Object.prototype.toString.call(obj) === '[object Number]');
    };

    $.isRegExp = function(obj) {
        return !!(obj && obj.test && obj.exec && (obj.ignoreCase || obj.ignoreCase === false));
    };

    /* jshint ignore:start */
    $.range = function(start, stop, step) {
        var args = Array.prototype.slice.call(arguments),
        solo = args.length <= 1,
        start = solo ? 0 : args[0],
        stop = solo ? args[0] : args[1],
        step = args[2] || 1,
        len = Math.max(Math.ceil((stop - start) / step), 0),
        idx = 0,
        range = new Array(len);

        while (idx < len) {
            range[idx++] = start;
            start += step;
        }

        return range;
    };
    /* jshint ignore:end */

    $.keys = Object.keys || function(obj) {
        if ($.isArray(obj)) 
            return $.range(0, obj.length);

        var keys = [];

        for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                keys[keys.length] = key;
            }
        }
        return keys;
    };

    $.isEqual = function(a, b) {
        if (a === b) 
            return true; //object identity
        var atype = typeof a;
        var btype = typeof b;
        if (atype != btype) 
            return false; //check types
        if (a == b) 
            return true; //basic equality
        if ((!a && b) || (a && !b)) 
            return false; //one falsy and other truthy
        if (a.isEqual) 
            return a.isEqual(b); //one implement isEqual?
        if ($.isDate(a) && $.isDate(b)) 
            return a.getTime() === b.getTime(); //dates
        if ($.isNumber(a) && isNaN(a) && $.isNumber(b) && isNaN(b)) 
            return false; //NaNs?
        if ($.isRegExp(a) && $.isRegExp(b)) {
            //regexps?
            return a.source === b.source &&
            a.global === b.global &&
            a.ignoreCase === b.ignoreCase &&
            a.multiline === b.multiline;
        }
        if (atype !== 'object') 
            return false; //not an object, can't handle it
        if (a.length && (a.length !== b.length)) 
            return false; //diff array length?

        var aKeys = $.keys(a);
        var bKeys = $.keys(b);
        if (aKeys.length != bKeys.length) 
            return false; //different object sizes?

        //recursive comparison of contents
        for (var key in a) {
            if (!(key in b) || !$.isEqual(a[key], b[key])) 
                return false;
        }

        return true;
    };
}));
(function () {
    if (typeof define === "function" && define.amd) {
        define('internal/common/websover', ['jquery', 'translate!webs.util'], defineWebsover);
    } else {
        defineWebsover(window.jQuery, function() {
            return 'Close';
        });
    }
    function defineWebsover ($, translate) {
        window.Popover = function(url, options) {
            this.url = url;
            this.options = options;
            this.viewportwidth = "";
            this.viewportheight = "";

            return this;
        };

        window.Popover.prototype = {
            reposition: function() {
                websover.reposition();
            },
            resize: function(resizeObj) {
                websover.resize(resizeObj);
            },
            show: function() {
                var self = this;
                websover.removeBadElements();

                /*---------------------------------------| Setting up options and parameters |---------------------------------------*/
                var options = this.options, scrollOption = (typeof options.scrolling !== "undefined" && options.scrolling ? "auto" : "no");
                websover.options = options;
                websover.width = (options.width ? options.width : 100);
                websover.height = (options.height ? options.height : 100);
                if (websover.height === 'auto') {
                    websover.top = 0;
                } else {
                    websover.top = - (parseInt(websover.extraHeight, 10) + parseInt(websover.height, 10)) / 2;
                }
                if (typeof options.closeButton == 'undefined') 
                    options.closeButton = true;
                if (typeof options.closeOnEsc == 'undefined') 
                    options.closeOnEsc = true;


                /*---------------------------------------| Creating websover DOM nodes |---------------------------------------*/
                websover.feedback = websover.feedback ? websover.feedback : $('<div/>').attr('id', 'websover_feedback').appendTo(document.body);
                websover.feedback.hide();

                if (!options.hasOwnProperty('showCover') || options.showCover) {
                    if (!websover.currentShadow) {
                        websover.currentShadow = document.createElement('div');
                        websover.currentShadow.setAttribute("id", "websover_shadow");
                        document.body.appendChild(websover.currentShadow);
                        $(websover.currentShadow).bind('drop dragover', function (e) {
                            e.preventDefault();
                        });
                    }

                    // in certain spots, various CSS rules !important this to 2000px. Consider doing that here instead.
                    //websover.currentShadow.style.height = websover.getTotalDocSize() + "px";
                    websover.currentShadow.style.display = "block";
                }

                if (!websover.garbageBin) {
                    websover.garbageBin = document.createElement('div');
                    websover.garbageBin.cssText = "display: none;";
                    document.body.appendChild(websover.garbageBin);
                }

                if (!websover.currentWrap) {
                    websover.currentWrap = document.createElement('div');
                    websover.currentWrap.setAttribute("id", "websover_wrap");
                    document.body.appendChild(websover.currentWrap);
                }
                if (options.className) {
                    websover.currentWrap.setAttribute("class", options.className);
                } else {
                    websover.currentWrap.removeAttribute("class");
                }


                if (!websover.currentBorder) {
                    websover.currentBorder = document.createElement('div');
                    websover.currentBorder.setAttribute("id", "websover_border");
                    websover.currentWrap.appendChild(websover.currentBorder);
                }

                if (!websover.currentPopover) {
                    websover.currentPopover = document.createElement('div');
                    websover.currentPopover.setAttribute("id", "inner_websover");
                    websover.currentBorder.appendChild(websover.currentPopover);
                }


                var feedbackAnim = typeof jQuery !== 'undefined' && this.options.feedback;
                websover.$fb = null;
                if (feedbackAnim) {
                    var
                    feedback = this.options.feedback,
                    el = jQuery(feedback.ref);
                    if (el.length > 0) {
                        var
                        elWidth = el.width(),
                        elHeight = el.height(),
                        elOffset = el.offset(),
                        scrollTop = jQuery(el[0].ownerDocument).scrollTop(),
                        extraOffsetLeft = feedback.offset ? feedback.offset.left : 0,
                        extraOffsetTop = feedback.offset ? feedback.offset.top : 0;

                        websover.$fb = jQuery(websover.feedback).css({
                            left: elOffset.left + extraOffsetLeft,
                            top: elOffset.top + extraOffsetTop - scrollTop,
                            width: elWidth,
                            height: elHeight
                        });
                    }
                }


                if (typeof this.url === "string") {
                    /*---------------------------------------| Iframe |---------------------------------------*/
                    websover.currentContent = document.createElement("iframe");
                    websover.currentContent.setAttribute("id", "websover_iframe");
                    websover.currentContent.setAttribute("rel", this.url);
                    websover.currentContent.setAttribute("name", "popoverIframe");
                    websover.currentContent.setAttribute("frameborder", "0");

                    // IE won't allow frameborder to be set with setAttribute
                    try {
                        websover.currentContent.frameBorder = 0;
                    } catch (e) {}

                    websover.currentContent.setAttribute("scrolling", scrollOption);
                    websover.currentContent.src = this.url;

                    $(websover.currentContent).load(function() {
                        websover.currentContent.style.visibility = "visible";
                        $(iframeContainer).removeClass("loading");
                    });

                    websover.currentContent.style.cssText = 'visibility: hidden; ' + (scrollOption === "no" ? 'overflow: hidden;' : 'overflow: auto;');
                } else {
                    /*---------------------------------------| DOM Object |---------------------------------------*/
                    this.url.style.display = "block";
                    websover.currentContent = this.url;
                    websover.currentContent.className = 'websover_content';
                }

                /*---------------------------------------| create and place popover elements onto the page |---------------------------------------*/
                websover.currentPopover.innerHTML = '<div id="websover_header">' +
                '<span id="websover_title">' + options.heading + '</span>' +
                (options.closeButton ? '<a href="#" title="' + translate('webs.util.close') + '" id="websover_close">' + translate('webs.util.close') + '</a>' : '') + '</div>' +
                '<div id="websover_iframe_container" class="loading"></div>';
                websover.currentWrap.style.display = "block";
                websover.currentPopover.style.width = websover.width + "px";

                websover.currentBorder.style.visibility = 'hidden';
                websover.currentBorder.style.width = websover.width + "px";
                websover.currentBorder.style.left = - (parseInt(websover.extraWidth, 10) + parseInt(websover.width, 10)) / 2 + "px";
                websover.currentBorder.style.top = websover.top + "px";

                var iframeContainer = document.getElementById("websover_iframe_container");
                if (typeof this.url == "string") 
                    iframeContainer.style.cssText = 'height: ' + (websover.height - 26) + 'px';
                else 
                    $(iframeContainer).removeClass('loading');

                /*---------------------------------------| Show the popover accordingly |---------------------------------------*/
                if (websover.currentContent.tagName === "IFRAME") {
                    self.afterShow();
                } else {
                    websover.resize({
                        height: websover.currentContent.offsetHeight,
                        width: websover.width
                    });
                    websover.currentBorder.style.height = "auto";
                    self.afterShow();
                }

                if (document.getElementById("websover_close")) 
                    document.getElementById("websover_close").onclick = function() {
                        websover.hide();
                        return false;
                    };

                websover.reposition();

                window.currentPopover = this;

                websover.active = true;
                return this;
            },

            complete: function(triggerName, triggerData) {
                var self = this;
                var triggerDataJSON = JSON.stringify(triggerData);
                window.setTimeout(function() {
                    self.hide(function() {
                        self.trigger(triggerName, window.JSON.parse(triggerDataJSON));
                    });
                }, 1);
            },

            hide: function(callback, param) {
                if (typeof this.options != "undefined" && this.options.onClose) 
                    this.options.onClose();
                if (websover.$fb) {
                    var growTo = $(this.options.feedback.ref),
                    finalWidth = growTo.width(),
                    finalHeight = growTo.height(),
                    offset = growTo.offset(),
                    scrollTop = $(growTo[0].ownerDocument).scrollTop(),
                    feedback = this.options.feedback,
                    extraOffsetLeft = feedback.offset ? feedback.offset.left : 0,
                    extraOffsetTop = feedback.offset ? feedback.offset.top : 0,
                    animTime = websover.animate ? 500 : 1,
                    animObj = {
                        width : finalWidth,
                        height : finalHeight,
                        left : offset.left + extraOffsetLeft,
                        top : offset.top + extraOffsetTop - scrollTop
                    };

                    websover.displayHide();
                    websover.$fb.show().animate(animObj, animTime, function() {
                        websover.$fb.hide();
                        websover.hide({
                            fromInst: true 
                        });
                    });
                } else {
                    websover.hide({
                        fromInst: true
                    });
                }
                if (typeof callback === 'function') 
                    callback.call(this, param);

                return this;
            },

            afterShow: function() {
                var iframeContainer = document.getElementById("websover_iframe_container");

                if (websover.$fb) {
                    var growTo = $(websover.currentBorder),
                    offset = growTo.offset(),
                    animTime = websover.animate ? 300 : 1,
                    animObj = {
                        width : growTo.width(),
                        height : growTo.height(),
                        left : offset.left,
                        top : offset.top
                    };

                    websover.$fb.show().animate(animObj, animTime, function() {
                        websover.currentContent.style.visibility = "visible";
                        websover.currentBorder.style.visibility = "visible";
                        websover.$fb.hide();

                        iframeContainer.appendChild(websover.currentContent);
                    });
                } else {
                    websover.currentBorder.style.visibility = "visible";
                    websover.currentContent.style.visibility = "visible";

                    iframeContainer.appendChild(websover.currentContent);
                }

                $(iframeContainer).find('#websover_iframe').load(function() {
                    $(this).contents().find('body').on('click', '.w-submit:not(.invalid)', function() {
                        $(this).removeClass('green w-btn1-green').addClass('disabled');

                        $(this).click(function(event) {
                            event.stopPropagation();
                        });
                    });
                });
            },

            trigger: function(name, val) {
                if (this.suspendListeners) 
                    return this;

                if (!this.eventListeners) 
                    this.eventListeners = {
                        defaultListener: function() {}
                    };

                if (typeof this.eventListeners[name] === 'function') {
                    this.eventListeners[name](val, name);
                } else {
                    this.eventListeners['defaultListener'](val, name);
                }


                return this;
            },

            bind: function(listener, fn) {
                var self = this;
                if (!this.eventListeners) 
                    this.eventListeners = {
                        defaultListener: function() {}
                    };

                if (typeof listener === 'object') {
                    $.each(listener, function(key, val) {
                        self.eventListeners[key] = val;
                    });
                } else if (typeof listener === 'string') {
                    this.eventListeners[listener] = fn;
                } else if (typeof listener === 'function') {
                    this.eventListeners['defaultListener'] = listener;
                }

                return this;
            },

            unbind: function() {
                this.eventListeners = null;
                return this;
            }
        };


        window.websover = {

            animate: true,

            extraWidth: 22,
            // accounts for paddings and borders
            extraHeight: 68,
            // and the titlebar height as well (22 + 46)

            /* Slots to store active context */
            currentShadow: null,
            currentWrap: null,
            currentBorder: null,
            currentPopover: null,
            currentContent: null,
            garbageBin: null,

            imageToLoad: null,
            //holds URL of image to load, set here for the sake of having reference during setTimeout
            loadSrcTo: null,
            //for use with multiple images lightbox, swaps src when image w corresponding src is loaded

            removeBadElements: function() {
                return;
                /*
                				var i;
                				if(/msie|MSIE 6/.test(navigator.userAgent)) {
                					var selects = document.getElementsByTagName("SELECT");
                					for(i = 0; i < selects.length; i++) {
                						if(selects[i].style.visibility == "hidden") selects[i].style.visibility = "visible";
                						else selects[i].style.visibility = "hidden";
                					}
                				}

                				var iframes = document.getElementsByTagName("IFRAME");
                				for(i = 0; i < iframes.length; i++) {
                					if(iframes[i].style.visibility == "hidden") {
                						iframes[i].style.visibility = "visible";
                					} else { if(iframes[i].id != "websover_iframe" && iframes[i].id != "documentarea") iframes[i].style.visibility = "hidden"; }
                				}
                				*/
            },

            getTotalDocSize: function() {
                return Math.max((document.documentElement.scrollHeight || document.body.scrollHeight), (document.documentElement.offsetHeight || document.body.offsetHeight));
            },

            displayHide: function() {
                websover.currentWrap.style.display = "none";
                websover.currentShadow.style.display = "none";
            },

            // more like "close" because we kill off the frame
            hide: function(opts) {
                // websover.hide() is called from popover.hide(), avoid multiple onClose calls
                var fromInst = opts && opts.fromInst;
                if (!fromInst && currentPopover && currentPopover.options && currentPopover.options.onClose) {
                    if (currentPopover.options.onClose(true) === false) 
                        return false;
                }

                if (!fromInst && currentPopover && currentPopover.options && currentPopover.options.reloadOnClose) {
                    return window.location.reload();
                }

                websover.active = false;
                websover.removeBadElements();

                /* Temporarily uncommenting for odd Chrome bug -- Ryan :: if(websover.currentContent.id === "websover_iframe") websover.currentContent.src = "javascript:false;"; */
                websover.currentWrap.style.display = "none";
                if (websover.currentShadow) {
                    websover.currentShadow.style.display = "none";
                }
                websover.currentWrap.removeAttribute("class");

                // If it's an iframe, we're safe to fully obliterate the reference, but if it's an object we need to keep the reference around.
                if (websover.currentContent.tagName === "IFRAME") {
                    /* jshint ignore:start */
                    websover.currentContent.src = "javascript:false;"; // Shhhh, fixes a very ninja-esque bug that Idris found.
                    /* jshint ignore:end */
                    websover.garbageBin.appendChild(websover.currentContent);
                    websover.garbageBin.innerHTML = "";
                } else {
                    if (websover.currentContent.parentNode) 
                        websover.currentContent.parentNode.removeChild(websover.currentContent);
                }

                // dereference width/height/etc when closing popover
                websover.top = null;
                websover.width = null;
                websover.height = null;
            },

            /* This is used in maybe one place. Consider killing it. */
            changeIframeDest: function(paramObj) {
                var iframe;
                if (websover.currentContent.tagName === "IFRAME") {
                    iframe = websover.currentContent;
                } else {
                    iframe = document.createElement("iframe");
                    iframe.setAttribute("id", "websover_iframe");
                    iframe.setAttribute("rel", this.url);
                    iframe.setAttribute("name", "popoverIframe");
                    iframe.setAttribute("frameborder", "0");

                    var parent = websover.currentContent.parentNode;
                    parent.removeChild(websover.currentContent);
                    parent.appendChild(iframe);
                    websover.currentContent = iframe;
                }
                websover.changeHeading(paramObj.title);
                iframe.src = paramObj.url;
            },

            checkScrolling: function(resizeObj, websoverIframe) {
                if (typeof resizeObj.scrolling !== "undefined") {
                    if (resizeObj.scrolling === true) {
                        websoverIframe.setAttribute("scrolling", "auto");
                        websoverIframe.style.overflow = "auto";
                    } else if (resizeObj.scrolling === false) {
                        websoverIframe.setAttribute("scrolling", "no");
                        websoverIframe.style.overflow = "hidden";
                    }
                }
            },

            changeHeading: function(str) {
                var titleSpan = document.getElementById("websover_title");
                if (titleSpan) 
                    titleSpan.innerHTML = str;
            },

            resize: function(resizeObj) {

                // Note: Resize !== the same as reposition. Resize uses different math based on passed in obj params.
                var
                websoverIframe = document.getElementById("websover_iframe_container") || websover.currentContent,
                toWidth = resizeObj.width ? resizeObj.width : websover.width,
                toHeight = resizeObj.height ? resizeObj.height : websover.height,
                newLeft = - parseInt((toWidth + websover.extraWidth) / 2, 10),
                newTop = - parseInt((toHeight + websover.extraHeight) / 2, 10),
                animTime = websover.animate ? 500 : 1;

                if (typeof resizeObj.heading === "string") 
                    websover.changeHeading(resizeObj.heading);

                if (typeof resizeObj.before !== "undefined" && typeof resizeObj.before === "function") 
                    resizeObj.before();

                // SITEBUILDER-749 - websover should change top position when resizing taller but not shorter
                var borderCss = {
                    left: newLeft,
                    width: toWidth 
                };
                if (websover.height < toHeight && websover.top > newTop) {
                    borderCss.top = newTop;
                    websover.top = borderCss.top;
                }
                jQuery(websover.currentBorder).animate(borderCss, animTime);

                jQuery(websover.currentPopover).animate({
                    width: toWidth
                }, animTime, function() {
                    if (typeof resizeObj.after !== "undefined" && typeof resizeObj.after === "function") 
                        resizeObj.after();
                    websover.checkScrolling(resizeObj, websoverIframe);
                    jQuery(websoverIframe).fadeIn("fast");

                    if (websover.height !== 'auto') {
                        websover.reposition();
                    }
                });

                if (websoverIframe.tagName !== "IMG") 
                    jQuery(websoverIframe).animate({
                        height: toHeight
                    }, animTime);

                websover.width = toWidth;
                websover.height = toHeight;

            },


            reposition: function() {
                var windowHeight = (typeof window.innerHeight != 'undefined' ? window.innerHeight : document.documentElement.clientHeight);
                var verticalScroll = (typeof window.pageYOffset != 'undefined' ? window.pageYOffset : document.documentElement.scrollTop);

                if (windowHeight < websover.height + websover.extraHeight) {
                    websover.currentWrap.style.position = "absolute";
                    websover.currentWrap.style.top = "0";
                    websover.currentBorder.style.top = verticalScroll + 20 + "px";
                    //websover.currentBorder.style.top = parseInt(websover.currentBorder.style.top) + (websover.height - document.height)/2 + websover.extraHeight + "px";
                } else {
                    websover.currentWrap.style.position = "fixed";
                    if (websover.options.height == "auto") {
                        websover.currentBorder.style.top = - (websover.currentBorder.offsetHeight / 2) + 'px';
                    }
                    websover.currentWrap.style.top = (this.options.position && this.options.position.top) || "50%";
                }
            }
        };

        if (typeof $ !== 'undefined') {
            $(document.body).keydown(function(e) {
                if (websover && websover.options && websover.options.closeOnEsc && e.keyCode === 27) 
                    websover.hide();
            });
        }

    }
})();

define('internal/sitebuilder/builderChrome/controls', [
'jquery'
], function($) {
    var controls = {};
    var shared = {
        bind: function(event, fn) {
            var events = (this.events || (this.events = {}));

            if (typeof event === 'object') {
                for (var key in event) {
                    if (event.hasOwnProperty(key))
                        this.bind(key, event[key]);
                }
            } else if (typeof event === 'string') {
                if (typeof fn !== 'function') 
                    return false;
                if (typeof events[event] !== 'object' || !(events[event] instanceof Array)) 
                    events[event] = [];
                events[event].push(fn);
            } else if (typeof events === 'function') {
                events['default'].push(fn);
            }
            return this;
        },
        trigger: function(event, param) {
            var events = (this.events || (this.events = {}));
            if (typeof events[event] !== 'object' || !(events[event] instanceof Array)) 
                return false;
            for (var i = 0; i < events[event].length; i++) {
                if (typeof events[event][i] === 'function') 
                    events[event][i](param, event);
            }
            return this;
        },
        /**
        		 * TODO: unbind a specific callback in event stack
        		 */
        unbind: function(event) {
            var events = (this.events || (this.events = {}));
            delete this.events[event];
            return this;
        }
    };

    return {
        create: function(type, options) {
            var obj = Object.create($.extend(controls[type], shared));
            obj.init(options);
            return obj;
        },

        register: function(type, klass) {
            controls[type] = klass;
        }
    };
});

define('internal/sitebuilder/builderChrome/frames', [
'handlebars'
], function() {
    // source is used to determine if we should look at a template-defined frame or webs-defined frame
    // slug is the same hash of the frame object
    var _framesPath = webs.props.staticServer + "/static/projects/finch/images/frames/thumbs/";
    if (typeof webs === 'undefined') 
        webs = {};
    webs.frameData = {
        "default": {
            "label": "Default",
            "slug": "default",
            "preview": _framesPath + 'default.png',
            "template": '<div class="webs-frame-container"> {{{html}}} </div>'
        },

        "tape": {
            "label": "Tape",
            "slug": "tape",
            "preview": _framesPath + 'tape.png',
            "template":
            '<div class="webs-frame-tape-left-container"><div class="webs-frame-tape-left covering"></div></div>' +
            '<div class="webs-frame-tape-right-container"><div class="webs-frame-tape-right covering"></div></div>' +
            '<div class="webs-frame-tape-container"> {{{html}}} </div>'
        },

        "u_shadow": {
            "label": "U Shadow",
            "slug": "u_shadow",
            "preview": _framesPath + 'u_shadow.png',
            "template": '<div class="webs-frame-container"> {{{html}}}' +
            '<div class="webs-frame-shadow"><span class="webs-frame-shadow-tile"></span></div></div>'
        },
        "inner_opacity-light": {
            "label": "Inner Opacity Light",
            "slug": "inner_opacity-light",
            "preview": _framesPath + 'inner_opacity-light.png',
            "template": '<div class="webs-frame-inner_opacity"> {{{html}}}' +
            '<div class="webs-frame-top"></div><div class="webs-frame-bottom"></div>' +
            '<div class="webs-frame-left"></div><div class="webs-frame-right"></div></div>'
        },
        "inner_opacity-dark": {
            "label": "Inner Opacity Dark",
            "slug": "inner_opacity-dark",
            "preview": _framesPath + 'inner_opacity-dark.png',
            "template": '<div class="webs-frame-inner_opacity"> {{{html}}}' +
            '<div class="webs-frame-top"></div><div class="webs-frame-bottom"></div>' +
            '<div class="webs-frame-left"></div><div class="webs-frame-right"></div></div>'
        },
        "double_contrast": {
            "label": "Double Contrast",
            "slug": "double_contrast",
            "preview": _framesPath + 'double_contrast.png',
            "template": '<div class="webs-frame-container1">' +
            '<div class="webs-frame-container2">{{{html}}}</div></div>'
        },

        "paper": {
            "label": "Paper",
            "slug": "paper",
            "preview": _framesPath + 'paper.png',
            "template": '<div class="webs-frame-container">{{{html}}}' +
            '<div class="webs-frame-paper-shade"><span class="webs-frame-paper-tile"></span></div></div>'
        }
        /*
        			"thickborder": {
        				"label": "Thick Border",
        				"slug": "thickborder",
        				"preview": _framesPath + 'thickborder.png',
        				"template": '<div class="webs-frame-container"> {{{html}}} </div>'
        			},
        		"album": {
        			"label": "Album",
        			"slug": "album",
        			"template":
        				'<div class="webs-frame-album-bind"></div>'+
        				'<div class="webs-frame-album-container"> {{{html}}} </div>'
        			},

        		"thumbtack": {
        			"label": "Thumbtack",
        			"slug": "thumbtack",
        			"template":
        				'<div class="webs-frame-thumbtack-pin"></div>'+
        				'<div class="webs-frame-thumbtack-container"> {{{html}}} </div>'
        			},
        		"photocorners": {
        			"label": "Photo Corners",
        			"slug": "photocorners",
        			"template":
        				'<div class="webs-frame-pc-all webs-frame-pc-tl covering"></div>'+
        				'<div class="webs-frame-pc-all webs-frame-pc-tr covering"></div>'+
        				'<div class="webs-frame-pc-all webs-frame-pc-bl covering"></div>'+
        				'<div class="webs-frame-pc-all webs-frame-pc-br covering"></div>'+
        				'<div class="webs-frame-pc-container"> {{{html}}} </div>'
        			}
        				*/

    };

    var _frames = webs.frameData;
    var _compiledFrames = {};
    Handlebars.registerHelper('wrapInFrame', function(block) {
        var frameSlug = this.frame;
        var align = " webs-align-" + this.align;
        var position = this.position ? " position: " + this.position + "; left: " + this.left + "px; top: " + this.top + "px; z-index: " + this['z-index'] + ";" : "";

        if (frameSlug) {
            if (typeof _compiledFrames[frameSlug] === 'undefined') {
                _compiledFrames[frameSlug] = Handlebars.compile(_frames[frameSlug].template);
            }
            var slug = " webs-frame-" + frameSlug;
            var compiled = _compiledFrames[frameSlug]({
                html: block(this),
                width: this.width,
                height: this.height,
                top: this.top,
                left: this.left,
                position: this.position,
                align: this.align,
                frameColor: this.frameColor
            });
            var html = '<div class="webs-frame' + align + slug + '" style="' + position + '">' + compiled + '</div>';

            return html;
        } else {
            return block(this);
        }
    });

    return webs.frameData;
});

/* global define:false */
define('internal/sitebuilder/builderChrome/iconsets', [], function() {
    "use strict";

    /**
    	 * Defining icon sets. If path is set, icon URL will be  path/slug.png
    	 * Otherwise,   /static/projects/finch/images/icon_sets/iconset_slug/icon_slug.png  will be used
    	 */
    return [
    {
        label: "Boolean",
        slug: "boolean",
        path: null,
        items: [
        {
            label: "0",
            slug: "0" 
        },
        {
            label: "Airmail",
            slug: "Airmail" 
        },
        {
            label: "Binocular",
            slug: "Binocular" 
        },
        {
            label: "Bookmark",
            slug: "Bookmark" 
        },
        {
            label: "Calculator",
            slug: "Calculator" 
        },
        {
            label: "Calendar",
            slug: "Calendar" 
        },
        {
            label: "Clapperboard_Open",
            slug: "Clapperboard_Open" 
        },
        {
            label: "Compact_Disc",
            slug: "Compact_Disc" 
        },
        {
            label: "Computer_Keyboard",
            slug: "Computer_Keyboard" 
        },
        {
            label: "Contacts_Alt",
            slug: "Contacts_Alt" 
        },
        {
            label: "Direction_Board",
            slug: "Direction_Board" 
        },
        {
            label: "Document",
            slug: "Document" 
        },
        {
            label: "Done_Square",
            slug: "Done_Square" 
        },
        {
            label: "Door",
            slug: "Door" 
        },
        {
            label: "Envelope",
            slug: "Envelope" 
        },
        {
            label: "Folder",
            slug: "Folder" 
        },
        {
            label: "Help_Circle",
            slug: "Help_Circle" 
        },
        {
            label: "Home",
            slug: "Home" 
        },
        {
            label: "Images_Night_Scene",
            slug: "Images_Night_Scene" 
        },
        {
            label: "Images",
            slug: "Images" 
        },
        {
            label: "Mail",
            slug: "Mail" 
        },
        {
            label: "Manual",
            slug: "Manual" 
        },
        {
            label: "Monitor_Off",
            slug: "Monitor_Off" 
        },
        {
            label: "Monitor",
            slug: "Monitor" 
        },
        {
            label: "Music",
            slug: "Music" 
        },
        {
            label: "Newspaper",
            slug: "Newspaper" 
        },
        {
            label: "Note",
            slug: "Note" 
        },
        {
            label: "Notepad",
            slug: "Notepad" 
        },
        {
            label: "OK",
            slug: "OK" 
        },
        {
            label: "Soccer_Ball",
            slug: "Soccer_Ball" 
        },
        {
            label: "Speaker",
            slug: "Speaker" 
        },
        {
            label: "Tag",
            slug: "Tag" 
        },
        {
            label: "Ticket_Golden",
            slug: "Ticket_Golden" 
        },
        {
            label: "Ticket_Red",
            slug: "Ticket_Red" 
        },
        {
            label: "Tree",
            slug: "Tree" 
        },
        {
            label: "Videos",
            slug: "Videos" 
        },
        {
            label: "White_Lego",
            slug: "White_Lego" 
        }
        ]
    },
    {
        label: "Classy",
        slug: "classy",
        path: null,
        items: [
        {
            label: "Accept",
            slug: "accept" 
        },
        {
            label: "Business User",
            slug: "business_user" 
        },
        {
            label: "Calendar",
            slug: "calendar" 
        },
        {
            label: "CD",
            slug: "cd" 
        },
        {
            label: "Chart",
            slug: "chart" 
        },
        {
            label: "Comment",
            slug: "comment" 
        },
        {
            label: "Comments",
            slug: "comments" 
        },
        {
            label: "Computer",
            slug: "computer" 
        },
        {
            label: "Digital Camcorder",
            slug: "digital_camcorder" 
        },
        {
            label: "Down",
            slug: "down" 
        },
        {
            label: "Favorite",
            slug: "favorite" 
        },
        {
            label: "Folder",
            slug: "folder" 
        },
        {
            label: "Folder Empty",
            slug: "folder_empty" 
        },
        {
            label: "Globe",
            slug: "globe" 
        },
        {
            label: "Headphones",
            slug: "headphones" 
        },
        {
            label: "Help",
            slug: "help" 
        },
        {
            label: "Home",
            slug: "home" 
        },
        {
            label: "Image",
            slug: "image" 
        },
        {
            label: "Image BMP",
            slug: "image_bmp" 
        },
        {
            label: "Image JPG",
            slug: "image_jpg" 
        },
        {
            label: "Info",
            slug: "info" 
        },
        {
            label: "Lock",
            slug: "lock" 
        },
        {
            label: "Mail",
            slug: "mail" 
        },
        {
            label: "Mobile Phone",
            slug: "mobile_phone" 
        },
        {
            label: "New Mail",
            slug: "new_mail" 
        },
        {
            label: "Next",
            slug: "next" 
        },
        {
            label: "Notebook",
            slug: "notebook" 
        },
        {
            label: "Page",
            slug: "page" 
        },
        {
            label: "Page Blank",
            slug: "page_blank" 
        },
        {
            label: "Previous",
            slug: "previous" 
        },
        {
            label: "Process",
            slug: "process" 
        },
        {
            label: "RSS",
            slug: "rss" 
        },
        {
            label: "Search",
            slug: "search" 
        },
        {
            label: "Shopping Cart",
            slug: "shopping_cart" 
        },
        {
            label: "Speaker",
            slug: "speaker" 
        },
        {
            label: "Up",
            slug: "up" 
        },
        {
            label: "User",
            slug: "user" 
        },
        {
            label: "Users",
            slug: "users" 
        }
        ]
    },
    {
        label: "Fatcow",
        slug: "fatcow",
        path: null,
        items: [
        {
            label: "Accept",
            slug: "accept" 
        },
        {
            label: "Apple",
            slug: "apple" 
        },
        {
            label: "Arrow Down",
            slug: "arrow_down" 
        },
        {
            label: "Arrow Left",
            slug: "arrow_left" 
        },
        {
            label: "Arrow Right",
            slug: "arrow_right" 
        },
        {
            label: "Arrow Up",
            slug: "arrow_up" 
        },
        {
            label: "Asterisk Yellow",
            slug: "asterisk_yellow" 
        },
        {
            label: "Attach",
            slug: "attach" 
        },
        {
            label: "Attribution",
            slug: "attribution" 
        },
        {
            label: "Award Star Bronze",
            slug: "award_star_bronze_3" 
        },
        {
            label: "Baloon",
            slug: "baloon" 
        },
        {
            label: "Barchart",
            slug: "barchart" 
        },
        {
            label: "Basket",
            slug: "basket" 
        },
        {
            label: "Beer",
            slug: "beer" 
        },
        {
            label: "Book Addresses",
            slug: "book_addresses" 
        },
        {
            label: "Bookmark",
            slug: "bookmark" 
        },
        {
            label: "Bullet Star",
            slug: "bullet_star" 
        },
        {
            label: "Butterfly",
            slug: "butterfly" 
        },
        {
            label: "Cake",
            slug: "cake" 
        },
        {
            label: "Calendar",
            slug: "calendar" 
        },
        {
            label: "Camera",
            slug: "camera" 
        },
        {
            label: "Card Credit",
            slug: "card_credit" 
        },
        {
            label: "Card Debit",
            slug: "card_debit" 
        },
        {
            label: "Cart",
            slug: "cart" 
        },
        {
            label: "CD",
            slug: "cd" 
        },
        {
            label: "Chart Bar",
            slug: "chart_bar" 
        },
        {
            label: "Chart Curve",
            slug: "chart_curve" 
        },
        {
            label: "Chart Pie",
            slug: "chart_pie" 
        },
        {
            label: "Chart Up",
            slug: "chart_up_color" 
        },
        {
            label: "Coins",
            slug: "coins" 
        },
        {
            label: "Comment",
            slug: "comment" 
        },
        {
            label: "Cup",
            slug: "cup" 
        },
        {
            label: "Date",
            slug: "date" 
        },
        {
            label: "Document Empty",
            slug: "document_empty" 
        },
        {
            label: "Drink",
            slug: "drink" 
        },
        {
            label: "Email",
            slug: "email" 
        },
        {
            label: "Emotion Smile",
            slug: "emotion_smile" 
        },
        {
            label: "Cow",
            slug: "fatcow" 
        },
        {
            label: "Feed",
            slug: "feed" 
        },
        {
            label: "Film",
            slug: "film" 
        },
        {
            label: "Fire",
            slug: "fire" 
        },
        {
            label: "Blue Flag",
            slug: "flag_2" 
        },
        {
            label: "Folder",
            slug: "folder" 
        },
        {
            label: "Leaf",
            slug: "green" 
        },
        {
            label: "Heart",
            slug: "heart" 
        },
        {
            label: "Information",
            slug: "information" 
        },
        {
            label: "Lightning",
            slug: "lightning" 
        },
        {
            label: "Gold Medal",
            slug: "medal_gold_3" 
        },
        {
            label: "Microphone",
            slug: "microphone" 
        },
        {
            label: "Money",
            slug: "money" 
        },
        {
            label: "Money Dollar",
            slug: "money_dollar" 
        },
        {
            label: "White Page",
            slug: "page_white" 
        },
        {
            label: "Paypal",
            slug: "paypal-2" 
        },
        {
            label: "Picture",
            slug: "picture" 
        },
        {
            label: "Popcorn",
            slug: "popcorn" 
        },
        {
            label: "Rainbow",
            slug: "rainbow" 
        },
        {
            label: "Recycle",
            slug: "recycle" 
        },
        {
            label: "Report",
            slug: "report" 
        },
        {
            label: "Ribbon",
            slug: "ribbon" 
        },
        {
            label: "Ruby",
            slug: "ruby" 
        },
        {
            label: "Scull",
            slug: "scull" 
        },
        {
            label: "Shield",
            slug: "shield" 
        },
        {
            label: "Handshake",
            slug: "small_business" 
        },
        {
            label: "Eight-ball",
            slug: "sport_8ball" 
        },
        {
            label: "Basketball",
            slug: "sport_basketball" 
        },
        {
            label: "Football",
            slug: "sport_football" 
        },
        {
            label: "Golf",
            slug: "sport_golf" 
        },
        {
            label: "Raquet",
            slug: "sport_raquet" 
        },
        {
            label: "Soccer",
            slug: "sport_soccer" 
        },
        {
            label: "Tennis",
            slug: "sport_tennis" 
        },
        {
            label: "Star",
            slug: "star" 
        },
        {
            label: "Computer",
            slug: "terminal" 
        },
        {
            label: "Check",
            slug: "tick" 
        },
        {
            label: "User",
            slug: "user" 
        },
        {
            label: "User Female",
            slug: "user_female" 
        },
        {
            label: "User Gray",
            slug: "user_gray" 
        },
        {
            label: "User Green",
            slug: "user_green" 
        },
        {
            label: "User Red",
            slug: "user_red" 
        },
        {
            label: "User Silhouette",
            slug: "user_silhouette" 
        },
        {
            label: "User Suit",
            slug: "user_suit" 
        }
        ]
    },
    {
        label: "Fugue",
        slug: "fugue",
        path: null,
        items: [
        {
            label: "Address Book Open",
            slug: "address-book-open" 
        },
        {
            label: "Address Book",
            slug: "address-book" 
        },
        {
            label: "Alarm Clock",
            slug: "alarm-clock-blue" 
        },
        {
            label: "Arrow Right",
            slug: "arrow-000-medium" 
        },
        {
            label: "Arrow Up",
            slug: "arrow-090-medium" 
        },
        {
            label: "Arrow Left",
            slug: "arrow-180-medium" 
        },
        {
            label: "Arrow Down",
            slug: "arrow-270-medium" 
        },
        {
            label: "Asterisk",
            slug: "asterisk" 
        },
        {
            label: "Auction Hammer",
            slug: "auction-hammer" 
        },
        {
            label: "Balloon",
            slug: "balloon" 
        },
        {
            label: "Bandaid",
            slug: "bandaid" 
        },
        {
            label: "Bell",
            slug: "bell" 
        },
        {
            label: "Book with Bookmark",
            slug: "book-bookmark" 
        },
        {
            label: "Book",
            slug: "book-brown" 
        },
        {
            label: "Briefcase",
            slug: "briefcase" 
        },
        {
            label: "Brightness",
            slug: "brightness" 
        },
        {
            label: "Broom",
            slug: "broom" 
        },
        {
            label: "Building",
            slug: "building" 
        },
        {
            label: "Burn",
            slug: "burn" 
        },
        {
            label: "Cake",
            slug: "cake-plain" 
        },
        {
            label: "Calendar",
            slug: "calendar" 
        },
        {
            label: "Camera",
            slug: "camera" 
        },
        {
            label: "Car",
            slug: "car" 
        },
        {
            label: "Card",
            slug: "card" 
        },
        {
            label: "Chart Up",
            slug: "chart-up" 
        },
        {
            label: "Chart",
            slug: "chart" 
        },
        {
            label: "Chevron Expand",
            slug: "chevron-expand" 
        },
        {
            label: "Clipboard Text",
            slug: "clipboard-text" 
        },
        {
            label: "Clock",
            slug: "clock" 
        },
        {
            label: "Cookie",
            slug: "cookie" 
        },
        {
            label: "Cutlery",
            slug: "cutlery" 
        },
        {
            label: "Disc",
            slug: "disc" 
        },
        {
            label: "Document Arrow",
            slug: "document--arrow" 
        },
        {
            label: "Document Music",
            slug: "document-music" 
        },
        {
            label: "Document Text",
            slug: "document-text" 
        },
        {
            label: "Film",
            slug: "film" 
        },
        {
            label: "Fire",
            slug: "fire" 
        },
        {
            label: "Folder Horizontal",
            slug: "folder-horizontal" 
        },
        {
            label: "Fruit",
            slug: "fruit" 
        },
        {
            label: "Globe",
            slug: "globe-green" 
        },
        {
            label: "Guitar",
            slug: "guitar" 
        },
        {
            label: "Hammer",
            slug: "hammer" 
        },
        {
            label: "Heart",
            slug: "heart" 
        },
        {
            label: "Home",
            slug: "home" 
        },
        {
            label: "Image",
            slug: "image" 
        },
        {
            label: "Information",
            slug: "information" 
        },
        {
            label: "Key",
            slug: "key" 
        },
        {
            label: "Leaf",
            slug: "leaf" 
        },
        {
            label: "Lifebuoy",
            slug: "lifebuoy" 
        },
        {
            label: "Lightning",
            slug: "lightning" 
        },
        {
            label: "Luggage",
            slug: "luggage" 
        },
        {
            label: "Magnifier",
            slug: "magnifier" 
        },
        {
            label: "Mail",
            slug: "mail" 
        },
        {
            label: "Marker",
            slug: "marker" 
        },
        {
            label: "Medal",
            slug: "medal" 
        },
        {
            label: "Money Coin",
            slug: "money-coin" 
        },
        {
            label: "Paper Clip",
            slug: "paper-clip" 
        },
        {
            label: "Plus",
            slug: "plus-white" 
        },
        {
            label: "Price Tag",
            slug: "price-tag" 
        },
        {
            label: "Question",
            slug: "question-white" 
        },
        {
            label: "Report Paper",
            slug: "report-paper" 
        },
        {
            label: "Smiley",
            slug: "smiley" 
        },
        {
            label: "Star",
            slug: "star" 
        },
        {
            label: "Sticky Note",
            slug: "sticky-note" 
        },
        {
            label: "T-shirt",
            slug: "t-shirt" 
        },
        {
            label: "Tag",
            slug: "tag" 
        },
        {
            label: "Tick",
            slug: "tick-white" 
        },
        {
            label: "User Black",
            slug: "user-black" 
        },
        {
            label: "User Silhouette",
            slug: "user-silhouette" 
        },
        {
            label: "Wrench",
            slug: "wrench" 
        }
        ]
    },
    {
        label: "Rocky",
        slug: "rocky",
        path: null,
        items: [
        {
            label: "Accessibility",
            slug: "accessibility" 
        },
        {
            label: "Add",
            slug: "add" 
        },
        {
            label: "Agenda",
            slug: "agenda" 
        },
        {
            label: "Airplane",
            slug: "airplane" 
        },
        {
            label: "Alarm",
            slug: "alarm" 
        },
        {
            label: "Album",
            slug: "album" 
        },
        {
            label: "Alert",
            slug: "alert" 
        },
        {
            label: "Annoucement",
            slug: "annoucement" 
        },
        {
            label: "Arrow Down",
            slug: "arrow-down" 
        },
        {
            label: "Arrow Left",
            slug: "arrow-left" 
        },
        {
            label: "Arrow Right",
            slug: "arrow-right" 
        },
        {
            label: "Arrow Up",
            slug: "arrow-up" 
        },
        {
            label: "Art Brush",
            slug: "art-brush" 
        },
        {
            label: "Auction",
            slug: "auction" 
        },
        {
            label: "Award",
            slug: "award" 
        },
        {
            label: "Bell",
            slug: "bell" 
        },
        {
            label: "Bicycle",
            slug: "bicycle" 
        },
        {
            label: "Bluetooth",
            slug: "bluetooth" 
        },
        {
            label: "Boat",
            slug: "boat" 
        },
        {
            label: "Bookmark",
            slug: "bookmark" 
        },
        {
            label: "Briefcase",
            slug: "briefcase" 
        },
        {
            label: "Brightness",
            slug: "brightness" 
        },
        {
            label: "Bug",
            slug: "bug" 
        },
        {
            label: "Bus",
            slug: "bus" 
        },
        {
            label: "Calculator",
            slug: "calculator" 
        },
        {
            label: "Calendar",
            slug: "calendar" 
        },
        {
            label: "Camera",
            slug: "camera" 
        },
        {
            label: "Car",
            slug: "car" 
        },
        {
            label: "CD",
            slug: "cd" 
        },
        {
            label: "Chart",
            slug: "chart" 
        },
        {
            label: "Check Box",
            slug: "check-box" 
        },
        {
            label: "Check",
            slug: "check" 
        },
        {
            label: "Clipboard",
            slug: "clipboard" 
        },
        {
            label: "Clock",
            slug: "clock" 
        },
        {
            label: "Coffee Mug",
            slug: "coffee-mug" 
        },
        {
            label: "Comment",
            slug: "comment" 
        },
        {
            label: "Compass",
            slug: "compass" 
        },
        {
            label: "Connection Signal",
            slug: "connection-signal" 
        },
        {
            label: "Construction Hat",
            slug: "construction-hat" 
        },
        {
            label: "Construction",
            slug: "construction" 
        },
        {
            label: "Contact Book",
            slug: "contact-book" 
        },
        {
            label: "Controller Play",
            slug: "controller-play" 
        },
        {
            label: "Cool",
            slug: "cool" 
        },
        {
            label: "Cursor",
            slug: "cursor" 
        },
        {
            label: "Cut",
            slug: "cut" 
        },
        {
            label: "Dashboard",
            slug: "dashboard" 
        },
        {
            label: "Delete",
            slug: "delete" 
        },
        {
            label: "Delivery Truck",
            slug: "delivery-truck" 
        },
        {
            label: "Discussion",
            slug: "discussion" 
        },
        {
            label: "Download",
            slug: "download" 
        },
        {
            label: "Earth",
            slug: "earth" 
        },
        {
            label: "Email",
            slug: "email" 
        },
        {
            label: "Eye",
            slug: "eye" 
        },
        {
            label: "Fan",
            slug: "fan" 
        },
        {
            label: "Favorite",
            slug: "favorite" 
        },
        {
            label: "Fever Chart",
            slug: "fever-chart" 
        },
        {
            label: "Financial",
            slug: "financial" 
        },
        {
            label: "First Aid Box",
            slug: "first-aid-box" 
        },
        {
            label: "Flag",
            slug: "flag" 
        },
        {
            label: "Flash",
            slug: "flash" 
        },
        {
            label: "Folder",
            slug: "folder" 
        },
        {
            label: "Game Controller",
            slug: "game-controller" 
        },
        {
            label: "Gift",
            slug: "gift" 
        },
        {
            label: "Go-to Bottom",
            slug: "go-to-bottom" 
        },
        {
            label: "Go-to Top",
            slug: "go-to-top" 
        },
        {
            label: "Gym",
            slug: "gym" 
        },
        {
            label: "Hammer",
            slug: "hammer" 
        },
        {
            label: "Hand-pointer",
            slug: "hand-pointer" 
        },
        {
            label: "Hand",
            slug: "hand" 
        },
        {
            label: "Headphone",
            slug: "headphone" 
        },
        {
            label: "Help",
            slug: "help" 
        },
        {
            label: "Highlighter",
            slug: "highlighter" 
        },
        {
            label: "Home",
            slug: "home" 
        },
        {
            label: "Hot",
            slug: "hot" 
        },
        {
            label: "Hourglass",
            slug: "hourglass" 
        },
        {
            label: "Infinite",
            slug: "infinite" 
        },
        {
            label: "Info",
            slug: "info" 
        },
        {
            label: "Iphone",
            slug: "iphone" 
        },
        {
            label: "Ipod",
            slug: "ipod" 
        },
        {
            label: "Key",
            slug: "key" 
        },
        {
            label: "Lab",
            slug: "lab" 
        },
        {
            label: "Laptop",
            slug: "laptop" 
        },
        {
            label: "Light-bulb",
            slug: "light-bulb" 
        },
        {
            label: "Link",
            slug: "link" 
        },
        {
            label: "Location",
            slug: "location" 
        },
        {
            label: "Lock",
            slug: "lock" 
        },
        {
            label: "Login",
            slug: "login" 
        },
        {
            label: "Logout",
            slug: "logout" 
        },
        {
            label: "Magic Wand",
            slug: "magic-wand" 
        },
        {
            label: "Martini Glass",
            slug: "martini-glass" 
        },
        {
            label: "Microphone",
            slug: "microphone" 
        },
        {
            label: "Museum",
            slug: "museum" 
        },
        {
            label: "Music",
            slug: "music" 
        },
        {
            label: "Orbit",
            slug: "orbit" 
        },
        {
            label: "Paint Brush",
            slug: "paint-brush" 
        },
        {
            label: "Paperclip",
            slug: "paper-clip" 
        },
        {
            label: "Pencil",
            slug: "pencil" 
        },
        {
            label: "Phone Classic",
            slug: "phone-classic" 
        },
        {
            label: "Phone",
            slug: "phone" 
        },
        {
            label: "Picture",
            slug: "picture" 
        },
        {
            label: "Pin",
            slug: "pin" 
        },
        {
            label: "Power",
            slug: "power" 
        },
        {
            label: "Print",
            slug: "print" 
        },
        {
            label: "Recycle",
            slug: "recycle" 
        },
        {
            label: "Restrict",
            slug: "restrict" 
        },
        {
            label: "Rocket",
            slug: "rocket" 
        },
        {
            label: "Rss",
            slug: "rss" 
        },
        {
            label: "Satellite",
            slug: "satellite" 
        },
        {
            label: "Save",
            slug: "save" 
        },
        {
            label: "Setting",
            slug: "setting" 
        },
        {
            label: "Share",
            slug: "share" 
        },
        {
            label: "Shopping Bag",
            slug: "shopping-bag" 
        },
        {
            label: "Shopping Basket",
            slug: "shopping-basket" 
        },
        {
            label: "Shopping Cart",
            slug: "shopping-cart" 
        },
        {
            label: "Shovel",
            slug: "shovel" 
        },
        {
            label: "Star",
            slug: "star" 
        },
        {
            label: "Stock Chart",
            slug: "stock-chart" 
        },
        {
            label: "Stop",
            slug: "stop" 
        },
        {
            label: "Tag Cloud",
            slug: "tag-cloud" 
        },
        {
            label: "Tag",
            slug: "tag" 
        },
        {
            label: "Thumb Down",
            slug: "thumb-down" 
        },
        {
            label: "Thumb Up",
            slug: "thumb-up" 
        },
        {
            label: "Tool",
            slug: "tool" 
        },
        {
            label: "Trophy",
            slug: "trophy" 
        },
        {
            label: "Tv",
            slug: "tv" 
        },
        {
            label: "Umbella",
            slug: "umbella" 
        },
        {
            label: "Undo",
            slug: "undo" 
        },
        {
            label: "Unlock",
            slug: "unlock" 
        },
        {
            label: "Upload",
            slug: "upload" 
        },
        {
            label: "Usb",
            slug: "usb" 
        },
        {
            label: "User Group",
            slug: "user-group" 
        },
        {
            label: "User",
            slug: "user" 
        },
        {
            label: "Video Camera",
            slug: "video-camera" 
        },
        {
            label: "Video Clapper",
            slug: "video-clapper" 
        },
        {
            label: "Video Reel",
            slug: "video-reel" 
        },
        {
            label: "Walk",
            slug: "walk" 
        },
        {
            label: "Weather",
            slug: "weather" 
        },
        {
            label: "Web",
            slug: "web" 
        },
        {
            label: "Webcam",
            slug: "webcam" 
        },
        {
            label: "Wine Glass",
            slug: "wine-glass" 
        },
        {
            label: "Wireless",
            slug: "wireless" 
        },
        {
            label: "Zoom In",
            slug: "zoom-in" 
        }
        ]
    }
    ];
});
/* Custom radio UI controls. Sample selector $('input[type|="radio"][name|="name"]') */
(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define('internal/sitebuilder/common/jquery.customSelect', ['jquery'], factory);
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {
    $.fn.cuiRadio = function(parent, options) {
        if (this.length === 0) 
            return;

        var $current = $(),
        $radioArray = this,
        opts = $.extend({
            classContainer: 'cui_radio_container',
            classItem: 'cui_radio_item',
            classGraphics: 'cui_radio_icon',
            classSelected: 'cui_radio_selected',
            classText: 'cui_radio_text',
            label: []
        }, options),
        $container = $(document.createElement('ul')).addClass(opts.classContainer),
        $parent = $(parent);

        this.each(function(i) {
            var $this = $(this);
            var $radioItem = $(document.createElement('li'))
            .attr('rel', i)
            .addClass(opts.classItem)
            .click(function(e) {
                $current.removeClass(opts.classSelected);
                $current = $(this).addClass(opts.classSelected);

                // Sets the selected radio option
                $radioArray[$current.attr("rel")].checked = true;
                return false;
            })
            .html('<span class="' + opts.classGraphics + '"> </span><span class="' + opts.classText + '">' +
            (typeof opts.label[i] !== "undefined" ? opts.label[i] : $this.val()) + '</span>')
            .appendTo($container);
            if ($radioArray[i].checked) {
                $current = $radioItem.addClass(opts.classSelected);
            }
        });

        //hide the original asset and put ours in
        $parent.hide();
        $container.insertBefore($parent);
    };

    $.fn.customSelect = function(options) {


        /**
        		 * Makes dropdown collapse when clicking non-target
        		 * An event is attached to the body element to determine non-target.
        		 * This function makes sure the event is attached on the same body element which contains the dropdown
        		 * since we sometimes create the dropdown in one frame and append it to another
        		 */
        var attachHideEvent = function($el) {
            var $body = $el.parents('body'),
            events = $body.data('events');

            // check to see if body click event is already bound on target's body
            if (events && events.click) {
                for (var i = 0; i < events.click.length; i++) {
                    if (events.click[i].namespace === 'custom_dropdown') {
                        return false;
                    }
                }
            }

            // custom_dropdown event is not bound on the body yet
            $body.bind('click.custom_dropdown', function(e) {
                var $t = $(e.target),
                $c = $t.parents('.select_container');

                $body.find('.select_container.active').removeClass('active');

                // clicked inside a select container
                if ($c.length) 
                    $c.addClass('active');
            });
        };

        return this.each(function() {
            var $this = $(this),
            opts = $.extend({
                classHandle: 'select_handle',
                classContainer: 'select_container',
                classElements: 'select_elements',
                classVisible: 'select_visible',
                classSelected: 'select_selected',
                classHover: 'select_li_hover',
                classUl: 'select_ul',
                classLi: 'select_li',
                width: "150px",
                maxHeight: "auto",
                getOption: function(value, text) {
                    return text;
                }
            }, options),
            //keep a reference back to the select which is being replaced
            $originalSelect = $this,
            //create a div to contain everything
            $container = $('<div/>')
            .width(opts.width)
            .addClass(opts.classContainer),
            // Create a placeholder & container for the selected item.
            // When the user selects an item, the html will be copied from the menu item
            $selectBox = $('<div/>').addClass(opts.classVisible).click(function(e) {
                toggleMenuItems();
            }),
            $selectedItem = $('<div/>').addClass(opts.classSelected),
            $selectHandle = $('<a/>').addClass(opts.classHandle).append($('<span/>').html("Handle")),
            $menuItems = $('<ul/>').addClass(opts.classUl).css({
                maxHeight: opts.maxHeight
            }),
            $clear = $('<div/>').addClass('clears').html('&nbsp;'),
            toggleMenuItems = function() {
                $container.toggleClass('active');
            };

            setTimeout(function() {
                attachHideEvent($this);
            }, 2000);

            $originalSelect.change(function(e) {
                var selectedIndex = this.selectedIndex;
                $selectedItem.html($('.select_li[rel="' + selectedIndex + '"]', $menuItems).html());
            }).children("option").each(function(i, selected) {
                $('<li/>')
                .addClass(opts.classLi)
                .attr('rel', i)
                .html(opts.getOption($(this).val(), $(this).text()))
                .click(function(e) {
                    toggleMenuItems();

                    $originalSelect[0].selectedIndex = $(this).attr('rel');
                    $originalSelect.change(); // fire the change event which will properly update the UI as well

                    return false;
                })
                .appendTo($menuItems);
            });

            //preset the selectedItem
            $selectedItem.html($menuItems.children("li:eq(" + $originalSelect[0].selectedIndex + ")").html());

            //put everything together
            $selectBox.appendTo($container);
            $selectHandle.appendTo($selectBox);
            $selectedItem.appendTo($selectBox);
            $menuItems.appendTo($container);

            //hide the original select and put ours in
            $originalSelect.hide();
            $container.insertBefore($originalSelect);

            //set the width and height of the UI components so everything lines up nicely
            if ($menuItems.height() > parseInt($menuItems.css("maxHeight"), 10)) {
                $menuItems.height($menuItems.css("maxHeight"));
            }
            $selectHandle.height($selectBox.height() - 2);

        });
    };
}));
// Input placeholder polyfill
//
//	<input placeholder="Hello world!">
//  $("input").placeholder();
//
//  Works just like html5 placeholder, but also adds a 'placeholder'
//  class on the input when the placeholder text is shown, so you can style it.

(function(factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module:
        define('jquery.placeholder', ['jquery'], factory);
    } else {
        // Browser globals:
        factory(jQuery);
    }
})(function($) {
    $.fn.placeholder = function() {
        this.each(function(i, input) {
            makePlaceholder($(input));
        });
    };

    function makePlaceholder(input) {
        var placeholderText = input.attr('placeholder');

        // if password inputs have a value as their default text,
        // a user will just see a bunch of obfuscated foreign input,
        // so change the input type to text:
        if (input.attr('type') === "password") {
            // IE8 and below don't allow changing input types,
            // so try/catch the following:
            try {
                input.attr('type', 'text');
                input.on('focus', function(event) {
                    input.attr('type', 'password');
                });
                input.on('blur', function(event) {
                    if (input.val() === placeholderText || $.trim(input.val()).length < 1) {
                        input.attr('type', 'text');
                    }
                });
            } catch (err) {
                // follow through if the input type isn't supported.
                // WARNING: this path produces a mediocre-looking "obfuscated text"
                // placeholder.
            }
        }

        if (input.val() === "") {
            input.val(placeholderText);
            input.addClass("placeholder");
        } else {
            input.data('changed', true);
        }

        input.focus(function(e) {
            if (input.data('changed') === true) 
                return;
            if (input.val() === placeholderText) {
                input.val('');
                input.removeClass("placeholder");
            }
        }).blur(function(e) {
            if (input.val() === '') {
                input.val(placeholderText);
                input.addClass("placeholder");
            }
        }).change(function(e) {
            input.data('changed', input.val() !== '');
            if (input.val() !== placeholderText) {
                input.removeClass("placeholder");
            }
        });

    }
});

/**
 * jQuery plugin that wraps a list with a UI layer.
 * @author 		Dominick Pham
 * @requires 	/static/global/2010/internal/css/base.css
 *
 * Accepts an object with callback [fn] that gets fired with the value [title] of the selected list item
 * If a list-item has the "selected" class, that item will be chosen first and the callback will fire.
 * All classes on the list items will get appended to the selected element, so it's safe to style the list item's class selector
 *
 * Example Usage:
 * The example below turn the unordered list into a dropdown.
 * When an 'li' gets clicked, 'fn' will fire with the value specified by the title attribute on the list item.
 * The list item with .webs-currency-gbp will be shown as selected after init because it has the 'selected' class.
 *
 * HTML
 * <ul class="webs-ui-dropdown webs-currency-selector">
 *	<li class="webs-currency-item webs-currency-eur" title="EUR"><span>EUR &#8364;</span></li>
 *	<li class="webs-currency-item webs-currency-aud" title="AUD"><span>AUD &#36;</span></li>
 *	<li class="webs-currency-item webs-currency-cad" title="CAD"><span>CAD &#36;</span></li>
 *	<li class="webs-currency-item webs-currency-gbp selected" title="GBP"><span>GBP &#163;</span></li>
 *	<li class="webs-currency-item webs-currency-usd" title="USD"><span>USD &#36;</span></li>
 * </ul>
 *
 * JAVASCRIPT CALL
 *	$('ul.webs-currency-selector')
 *		.customDropdown({
 *			fn: function(val){
 *				if(webs && webs.currency) {
 *					webs.currency.set(val);
 *					webs.currency.apply('.webs-currency');
 *				}
 *			}
 *		});
 *
 */
(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define('jquery.customDropdown', ['jquery'], factory);
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {
    /**
    	 * Makes dropdown collapse when clicking non-target
    	 * An event is attached to the body element to determine non-target.
    	 * This function makes sure the event is attached on the same body element which contains the dropdown
    	 * since we sometimes create the dropdown in one frame and append it to another
    	 */
    var instances = [];

    var attachHideEvent = function(instance, $el) {
        var $body = $el.parents('body'),
        events = $body.data('events');

        instances.push(instance);

        // check to see if body click event is already bound on target's body
        if (events && events.click) {
            for (var i = 0; i < events.click.length; i++) {
                if (events.click[i].namespace === 'w-dropdown') {
                    return;
                }
            }
        }

        // custom_dropdown event is not bound on the body yet
        $body.bind('click.w-dropdown', function(e) {
            var $t = $(e.target),
            $c = $t.parents('.w-dropdown-container');

            $.each(instances, function(i, instance) {
                instance.toggle(false);
            });

            // clicked inside a select container
            if ($c.length) 
                $c.addClass('active');
        });
    };


    /**
    	 * Class Constants
    	 */
    var CLASSES = {
        HANDLE: 'w-dropdown-handle',
        CONTAINER: 'w-dropdown-container',
        VISIBLE: 'w-dropdown-visible',
        SELECTED: 'w-dropdown-selected',
        UL: 'w-dropdown-ul',
        LI: 'w-dropdown-li'
    };


    var methods = {
        init: function(element, opts) {
            if (!opts) 
                opts = {};
            if (typeof opts.valueMapping != "function") 
                opts.valueMapping = function(val) {
                    return val;
                };
            if (typeof opts.reverseValueMapping != "function") 
                opts.reverseValueMapping = function(val) {
                    return val;
                };
            var
            self = this,



            /**
            			 * Container to wrap the current list and selected item which will be created later
            			 */
            $container = $('<div/>').width(typeof opts.width === 'number' ? opts.width : 150).addClass(CLASSES.CONTAINER),

            /**
            			 * Setting classes and dom tree insertion for original list
            			 */
            $ul = element.addClass(CLASSES.UL).before($container).appendTo($container),
            $li = $ul.find("li").addClass(CLASSES.LI),

            /**
            			 * Array of list item value key to their html and index for callbacks
            			 */
            listItem,
            setListItem = function() {
                var obj = {},
                children = $li,
                child, value, title;

                $li.each(function(i) {
                    child = $li.eq(i);
                    title = child.attr("title");
                    if (title && typeof child.data("value") !== "string") 
                        child.data("value", title);
                    value = child.data('value');
                    obj[value] = {
                        el: child,
                        html: child.html(),
                        index: i,
                        classNames: child.attr('class') || ''
                    };
                });
                listItem = obj;
            },

            /**
            			 * The visible [selected] box
            			 */
            $selectedItem = $('<div/>').addClass(CLASSES.SELECTED),
            $selectHandle = $('<a/>').addClass(CLASSES.HANDLE).append($('<span/>').html("Handle")),
            $selectBox = $('<div/>').addClass(CLASSES.VISIBLE).append($selectHandle, $selectedItem).insertBefore($ul),

            /**
            			 * Toggles the list
            			 */
            toggle = function(on) {
                if (typeof on !== 'undefined') {
                    if (on) 
                        $container.addClass('active');
                    else 
                        $container.removeClass('active');
                } else {
                    $container.toggleClass('active');
                }

                if ($container.hasClass('active')) {
                    if (typeof opts.afterOpen == "function") 
                        opts.afterOpen($container);
                    scrollToSelected();
                } else {
                    if (typeof opts.afterClose == "function") 
                        opts.afterClose($container);
                }
            },
            scrollToSelected = function() {
                var item = $container.find(".selected");
                if (item.length) {
                    var top = item.position().top - 48;
                    $ul.scrollTop(top);
                }
            },

            /**
            			 * gets list item reference. Refer to listItem
            			 */
            getItem = function(val) {
                if (!val) 
                    return null;
                if (val === "__default__") {
                    if (!listItem[val]) 
                        return null;
                }

                // if list-item is passed in, get it's value
                if (val.jquery) 
                    val = val.data('value');
                return listItem[val];
            },
            getItems = function(val) {
                if (!val) 
                    return null;
                if (val === "__default__") {
                    if (!listItem[val]) 
                        return null;
                }
                if (val.jquery) 
                    val = val.data('value');
                val = opts.valueMapping(val);
                var items = [listItem[val]];
                if (listItem[opts.reverseValueMapping(val)])
                    items.push(listItem[opts.reverseValueMapping(val)]);
                return items;
            },
            /**
            			 * sets the specified option as active
            			 * @param   val         option item to set
            			 * @param   fallback    fallback option
            			 */
            setOption = function(val) {
                var items = getItems(val);
                if (!items) 
                    return null;
                if (items[0]) {
                    items[0].el.parents(".w-dropdown-ul").find(".w-dropdown-li.selected").removeClass("selected");
                }
                for (var i = 0; i < items.length; ++i) {
                    var item = items[i];
                    if (item) {
                        item.el.addClass('selected');
                        $selectedItem.html(item.html).attr('class', '').addClass(CLASSES.SELECTED + ' ' + item.classNames);
                    }
                }
            },
            /**
            			 * clears out all list options and pushes a new set in
            			 * format is [{label: "string", slug: "string"}]
            			 */
            replaceOptions = function(opts) {
                clearOptions();
                addOptions(opts);
            },

            /**
            			 * Removes all options in dropdown
            			 */
            clearOptions = function() {
                $li.remove();
            },
            /**
            			 * appends more list items into the dropdown
            			 * format is [{label: "string", slug: "string"}]
            			 */
            addOptions = function(opts) {
                var slug, label, _item;
                for (var i = 0, len = opts.length; i < len; i++) {
                    slug = opts[i].slug;
                    label = opts[i].label;
                    _item = $("<li/>")
                    .appendTo($ul)
                    .addClass(CLASSES.LI)
                    .html(label)
                    .data("value", slug)
                    .attr("title", slug);
                }
                $li = $ul.children();
                setListItem();
                setOption("__default__");
            },
            /**
            	         * appends one list items into the dropdown
            	         * format is {label: "string", slug: "string"}
            	         * addOptions breaks if you have categories in your dropdown (as in the fonts dropdown)
            	         * this is a workaround for now.
            	         */

            addOption = function(opt) {
                var slug, label, _item, val;
                slug = opt.slug;
                label = opt.label;
                _item = $("<li/>")
                .appendTo($ul)
                .addClass(CLASSES.LI)
                .html(label)
                .data("value", slug)
                .attr("title", slug);
                if (opt.clazz) 
                    _item.addClass(opt.clazz);
                $li = $ul.children();

                val = {
                    el: _item,
                    html: _item.html(),
                    classNames: _item.attr('class') || ''
                }; //dropped the index property... ramifications?!?
                listItem[slug] = val;
                setOption(val);
            },
            /**
            			 * Fires a callback (if one exists), happens after an option item is clicked
            			 * @param 	li 	reference to the list item whose value will be fired with
            			 */
            fireCallback = function(val) {
                var item = getItem(val);
                if (item && opts && typeof opts.fn === 'function') 
                    opts.fn(val);
            },

            /**
            			 * Sets option and fires callback
            			 */
            callOption = function(val) {
                var item = getItem(val);
                if (item) {
                    setOption(val);
                    fireCallback(val);
                }
            };


            /**
            			 * setting events on list and list items
            			 */
            $selectBox.click(function(e) {
                $("body").trigger("click");
                toggle();
                return false;
            });
            $ul.delegate("li." + CLASSES.LI, "click", function() {
                toggle();
                callOption($(this).data("value"));
                return false;
            });


            /**
            			 * Sets the selected item (or first item if selected doesn't exist)
            			 */
            + function() {
                var $els = $ul.find('li.selected'),
                $sel = $els.length ? $els.removeClass('selected').eq(0) : $li.eq(0);

                setListItem();
                setOption($sel);
                if ($els.length) {
                    if (!opts.preventInitCall) 
                        fireCallback($sel);
                } else {
                    if (opts && typeof opts.initFn === 'function') 
                        opts.initFn();
                }
            }();

            setTimeout(function() {
                attachHideEvent(self, element);
            }, 2000);

            this.setOption = setOption;
            this.fireCallback = fireCallback;
            this.callOption = callOption;
            this.toggle = toggle;


            this.replaceOptions = replaceOptions;
            this.clearOptions = clearOptions;
            this.addOptions = addOptions;
            this.addOption = addOption;
        },

        destroy: function() {
}
    };

    $.fn.customDropdown = function(method) {
        if (typeof method === 'object' || !method) {
            var dropdown = Object.create(methods);
            dropdown.init(this, method);
            this.data('dropdown', dropdown);
        }
        return this;
    };
}));

define('internal/sitebuilder/common/fontsDropdownController', [
'internal/sitebuilder/common/fontsController',
'translate!webs.bldr.toolbar.fonts',
'jquery',
'spine',
'jquery.customDropdown'
], function(fontsController, translate, $, Spine) {
    var FontsDropdownController = Spine.Controller.create({
        init: function(opts) {
            this.fonts = fontsController.fonts;
            this.recentFonts = []; //We want to display the 5 most recent fonts, one of which will always be the theme's default font.
            /* jshint ignore:start */
            this.$list;
            /* jshint ignore:end */
            this.categories = {
                recent: translate("webs.bldr.toolbar.fonts.recent"),
                all: translate("webs.bldr.toolbar.fonts.all")
            };
            this.customDropdownOpts = {};
            fontsController.bind("fontLoaded", this.proxy(this.loadFont));
        },

        loadFont: function(font) {
            //Font doesn't exist
            if (!font) {
                return false;
            }
            var fontSlug = font.slug,
            removedFontSlug = this.addRecentFont(fontSlug);

            this.replaceRecentFonts(fontSlug);
            return true;
        },

        addRecentFont: function(fontSlug) {
            var recentFonts = this.recentFonts,
            recentLen = recentFonts.length,
            indexOfRecentFont = this.isRecentFont(fontSlug),
            removedFontSlug;

            // Check if font is already in list.
            if (indexOfRecentFont >= 0) {
                recentFonts.splice(indexOfRecentFont, 1);
            }
            // If we've already got 4 fonts, take the oldest one out.
            else if (recentLen >= 4) {
                removedFontSlug = recentFonts.shift(); // I realize shift is a slow operation, but for 4 elements I think we'll be ok
            }
            recentFonts.push(fontSlug);
            return removedFontSlug;
        },

        isRecentFont: function(fontSlug) {
            var recentFonts = this.recentFonts,
            recentLen = recentFonts.length;

            for (var i = 0; i < recentLen; i++) {
                if (recentFonts[i] === fontSlug) {
                    return i;
                }
            }
            return - 1;
        },

        replaceRecentFonts: function(fontSlug) {

            var container = this.$list,
            customDropdown = container.data("dropdown"),
            recentContainer = container.find("ul.w-font-category-recent"),
            defaultFont = recentContainer.find("li:first"),
            recentList = recentContainer.find("li:gt(0)"),
            recentFonts = this.recentFonts,
            recentLen = recentFonts.length;

            recentList.remove();

            for (var i = 0; i < recentLen; i++) {
                var font = fontsController.getFont(recentFonts[i]);

                if (typeof(font.label) === 'undefined') {
                    font.label = (font.source === 'google') ? this.getGoogleLabel(font.slug) : this.getWebsafeLabel(font);
                }
                var clazz = "w-font-item";
                if (fontSlug && font.slug == fontSlug) {
                    clazz += " selected";
                }

                customDropdown.addOption({
                    label: font.label,
                    slug: font.slug + "-recent",
                    clazz: clazz
                });

                recentContainer.append(container.children().last());
            }

        },

        renderRecentFonts: function(container) {
            if (typeof(container) === "undefined") {
                this.replaceRecentFonts();
            }
            var self = this,
            categoryContainer = container;

            categoryContainer.empty();

            //Add Default Font to top of the list
            this.appendDefaultFont(categoryContainer);

            $.each(this.recentFonts, function(i, fontSlug) {
                self.appendFont({
                    container: categoryContainer,
                    font: fontsController.getFont(fontSlug)
                });
            });
        },

        renderList: function(customDropdownOpts) {
            if (typeof(this.$list) === 'undefined') {
                this.$list = this.createList();
            }
            this.el.append(this.$list);
            var self = this;
            if (this.$list.customDropdown) {
                customDropdownOpts.valueMapping = function(val) {
                    if (typeof val == "string")
                        return val.replace(/-recent$/, "");
                    else
                        return val;
                };
                customDropdownOpts.reverseValueMapping = function(val) {
                    if (typeof val == "string")
                        return val + "-recent";
                    else
                        return val;
                };
                customDropdownOpts.fn = function(val) {
                    self.trigger("change", val);
                };
                this.$list.customDropdown(customDropdownOpts);
                this.customDropdownOpts = customDropdownOpts; //Hacky.
            }

            return this.$list;
        },

        createList: function() {
            var cat = {},
            $list = $('<ul/>').addClass("w-font-listing"),
            categories = this.categories,
            self = this;

            //Setup category headings
            $.each(categories, function(i, o) {
                cat[o] = $('<ul class="w-font-category w-font-category-' + i + '"/>');
            });
            // Drop fonts in respective buckets
            this.renderRecentFonts(cat[categories.recent]);

            // Render all public fonts
            $.each(this.fonts, function(i, f) {
                if (f["public"]) {
                    self.appendFont({
                        container: cat[categories.all],
                        font: f
                    });
                }
            });

            $.each(cat, function(key, $cat) {
                $list.append(
                $('<li/>').addClass("w-font-category_label w-dropdown-null").html(key),
                $('<li/>').addClass("w-dropdown-null").append($cat)
                );
            });
            return $list;
        },

        appendFont: function(opts) {
            if (typeof(opts.label) === 'undefined') {
                opts.label = (opts.font.source === 'google') ? this.getGoogleLabel(opts.font.slug) : this.getWebsafeLabel(opts.font);
            }

            var listItem = $('<li/>').addClass("w-font-item").data('value', opts.font.slug).html(opts.label);
            opts.container.append(listItem);
        },

        appendDefaultFont: function(container) {
            this.appendFont({
                container: container,
                font: {
                    slug: '__default__'
                },
                label: translate('webs.bldr.toolbar.fonts.default')
            });
        },

        getGoogleLabel: function(slug) {
            return '<span class="w-font-preview" style="background-image: url(' +
            webs.props.staticServer +
            '/static/global/fonts/images/' +
            slug +
            '.png)"></span>';
        },

        getWebsafeLabel: function(font) {
            return '<span style="font-family: \'' + font.name + '\' ' + font.fallback + '">' + font.name + '</span>';
        },

        setOption: function(slug) {
            var val = (fontsController.isFontPublic(slug)) ? slug : "__default__";
            this.$list.data("dropdown").setOption(val);
        }
    });

    return FontsDropdownController;

});
require([
'jquery'
], function jquery_numberInput($) {

    var polyfillTemplate = '<div class="numberInput"><input type="text"><a class="increment"></a><a class="decrement"></a></div>';

    $.fn.numberInput = function numberInput(opts) {
        var instance = {
            $el: this,
            value: parseFloat(opts && opts.value || this.attr('value') || 0),
            min: parseFloat(opts && opts.min || this.attr('min') || - Infinity),
            max: parseFloat(opts && opts.max || this.attr('max') || Infinity),
            step: parseFloat(opts && opts.step || this.attr('step') || 1)
        },
        $numberInput = $(polyfillTemplate).
        width (this.outerWidth()).
        data ('numberInput', instance);
        instance.set = $.proxy(set, $numberInput);
        this.data("numberInput", $numberInput);

        this.before($numberInput).hide();
        update($numberInput, instance, true);

        $numberInput.
        on('click', '.numberInput>.increment', increment).
        on('click', '.numberInput>.decrement', decrement).
        on('keypress', '.numberInput>input', keypress).
        on('keydown', '.numberInput>input', keydown).
        on('change', '.numberInput>input', change).
        on('paste', '.numberInput>input', change).
        on('cut', '.numberInput>input', change);

        return $numberInput;
    };

    function set(value) {
        var instance = this.data('numberInput');
        instance.value = value;
        update(this, instance, true);
    }

    function increment(e) {
        var $numberInput = $(e.currentTarget).closest('.numberInput'),
        instance = $numberInput.data('numberInput');
        instance.value += instance.step;
        update($numberInput, instance);
    }

    function decrement(e) {
        var $numberInput = $(e.currentTarget).closest('.numberInput'),
        instance = $numberInput.data('numberInput');
        instance.value -= instance.step;
        update($numberInput, instance);
    }

    function keypress(e) {
        // Only allow certain characters to be inserted
        if ((e.charCode < 48 || 58 <= e.charCode) /* Digits */
        && e.charCode != 13 /* Enter (e.g. to submit) */
        && e.charCode != 45 /* - (negative) */
        && e.charCode != 46 /* . (floats) */
        ) {
            e.preventDefault();
            return false;
        }
        // Ok, let it be inserted, but validate immediately afterward.
        var $numberInput = $(e.currentTarget).closest('.numberInput'),
        instance = $numberInput.data('numberInput');
        instance.updateTimeout && clearTimeout(instance.updateTimeout)
        instance.updateTimeout = setTimeout(function() {
            delete instance.updateTimeout;
            instance.value = parseFloat($numberInput.find('input').val());
            update($numberInput, instance);
        }, 1);
    }

    function keydown(e) {
        // On delete or backspace, revalidate
        if (e.keyCode == 8 /*delete*/
        || e.keyCode == 46 /*backspace*/
        ) {
            var $numberInput = $(e.currentTarget).closest('.numberInput'),
            instance = $numberInput.data('numberInput');
            instance.updateTimeout && clearTimeout(instance.updateTimeout);
            instance.updateTimeout = setTimeout(function() {
                delete instance.updateTimeout;
                instance.value = parseFloat($numberInput.find('input').val());
                update($numberInput, instance);
            }, 1);
        } else if (e.keyCode == 38) {
            increment(e);
        } else if (e.keyCode == 40) {
            decrement(e);
        }
    }

    function change(e) {
        // Something changed, revalidate
        var $numberInput = $(e.currentTarget).closest('.numberInput'),
        instance = $numberInput.data('numberInput');
        instance.updateTimeout && clearTimeout(instance.updateTimeout);
        instance.updateTimeout = setTimeout(function() {
            delete instance.updateTimeout;
            instance.value = parseFloat($numberInput.find('input').val());
            update($numberInput, instance);
        }, 1);
    }

    function update($numberInput, instance, preventTrigger) {
        ensureBounds($numberInput, instance);
        $numberInput.find('input').val(String(instance.value));
        instance.$el.val(instance.value);
        if (!preventTrigger) {
            // trigger changes on the original element and the polyfill
            $numberInput.trigger("change");
            instance.$el.trigger("change");
        }
    }

    function ensureBounds($numberInput, instance) {
        updateBounds($numberInput);
        if (!isFinite(instance.value)) 
            instance.value = 0;
        instance.value = Math.max(Math.min(instance.value, instance.max), instance.min);
    }

    function updateBounds($numberInput) {
        var instance = $numberInput.data('numberInput'),
        $el = instance.$el;
        if (isFinite($el.attr("min"))) 
            instance.min = parseFloat($el.attr("min"));
        if (isFinite($el.attr("max"))) 
            instance.max = parseFloat($el.attr("max"));
    }


});

define("jquery.numberInput", function() {});

define('internal/sitebuilder/builderChrome/ColumnResizeController', [
'jquery',
'spine',
'internal/sitebuilder/common/base'
], function($, Spine) {
    var MIN_SNAP_WIDTH = 100,
    CLASSES = {
        EDGE: 'bldr-edge'
    };

    /* Resizing columns within rows */
    var ColumnResizeController = Spine.Controller.create({

        init: function(options) {
            var self = this;
            this.pageController.dom.$body
            .bind('mouseup', function(e) {
                self.mouseup(e);
            })
            .bind('mousemove', function(e) {
                self.mousemove(e);
            });

            // FIXME: Sloppy!! Should be using bldr.pageController
            this.pageController = options.pageController;

            this.activeResizeDragger = null;

            this.pageController.dom.$body.delegate('.' + CLASSES.EDGE, 'mousedown', this.proxy(this.mousedown));

            this.guideline = $('<div/>').attr('id', 'guideline').appendTo(this.pageController.dom.$body);

            this.snap = {
                delta: 8,
                // How close you have to get (in px) before it snaps
                enable: true
            };

            this.pageController.dom.$body.keydown(this.proxy(function(e) {
                if (e.keyCode == 17) {
                    this.snap.enable = false;
                    this.guideline.css('left', - 9999);
                }
            })).keyup(this.proxy(function(e) {
                if (e.keyCode == 17) 
                    this.snap.enable = true;
            }));

            //			delete this.pageController; // FIXME: Because we shouldn't be using it like this anyway!
        },

        addSnapPoint: function(x, type) {
            this.snap.points.push({
                x: (this.xOffset + Math.floor(x)),
                type: (type || 'global') 
            });
        },

        addSnapPoints: function(numPoints, type) {
            var snapWidth = this.treeWidth / numPoints;
            for (var i = 1; i < numPoints; i++) {
                this.addSnapPoint(i * snapWidth, type || 'global');
            }
        },

        mousedown: function(e) {
            var edge = this.pageController.$(e.currentTarget),
            dragger = edge.find('div');

            if (this.activeResizeDragger && this.activeResizeDragger[0] != dragger[0]) {
                this.activeResizeDragger.attr('style', '');
            }
            this.activeResizeDragger = dragger;
            this.activeResizeDragger.css('top', this.activeResizeDragger.position().top);

            if (this.pageController.isActive()) {
                // save and de-activate the current bin.
                this.pageController.clearCurrentController();
            }

            // cache dom data we will use on every mouse move
            this.rightCol = edge.data('el');
            this.rightController = this.rightCol.data('controller');
            this.leftCol = this.rightCol.prev();
            this.leftController = this.leftCol.data('controller');

            this.minLeftWidth = this.leftController.getMinWidth();
            this.minRightWidth = this.rightController.getMinWidth();

            this.row = this.leftController.model.parentNode;
            this.rowController = this.row.controller;
            this.tree = this.row.tree();

            this.leftOffset = this.leftCol.offset().left;
            this.leftWidth = this.leftCol.width();
            this.rightWidth = this.rightCol.width();
            this.rowWidth = this.rowController.el.width();
            this.totalWidth = this.leftWidth + this.rightWidth;
            this.xOffset = this.rowController.el.offset().left;

            this.treeWidth = this.tree.controller.el.width();

            this.snap.points = [];

            // Break the tree into 6ths, 3rds, and halves, if there's enough space
            if (MIN_SNAP_WIDTH * 6 < this.treeWidth) {
                this.addSnapPoints(6, 'global');
            } else {
                if (MIN_SNAP_WIDTH * 3 < this.treeWidth) {
                    this.addSnapPoints(3, 'global');
                }
                if (MIN_SNAP_WIDTH * 2 < this.treeWidth) {
                    this.addSnapPoints(2, 'global');
                }
            }

            // Break the current row into even parts
            if (this.row.children.length != 6 && this.row.children.length > 3) {
                this.addSnapPoint(this.rightCol.index() * (this.treeWidth / this.row.children.length), 'local');
            }

            // Setup global drag/drop UI.
            this.resizing = true;
            this.pageController.dom.$body.addClass('resizing');
            this.rowController.widthToPercent();

            return true;
        },

        mouseup: function(e) {
            if (!this.resizing) 
                return true;

            // clear up global drag and drop UI
            $('.' + CLASSES.EDGE).removeClass('active');
            this.resizing = false;
            this.pageController.dom.$body.removeClass('resizing');
            this.guideline.css('left', - 9999);

            // commit change to column widths
            var leftModel = this.leftController.model,
            rightModel = this.rightController.model,
            total = leftModel.width + rightModel.width,
            leftWidth = parseInt(this.leftWidth / this.rowWidth * 100, 10);
            leftModel.width = leftWidth;
            rightModel.width = total - leftWidth;

            // resize the nodes
            this.leftController.resized(true);
            this.rightController.resized(true);
            leftModel.tree().dirty(true);

            this.rowController.widthToPixel();
        },

        mousemove: function(e) {
            if (!this.resizing) 
                return true;

            var i,
            point,
            clientX = e.clientX,
            leftEl = this.leftCol,
            rightEl = this.rightCol,
            newLeftWidth = clientX - this.leftOffset,
            newRightWidth = this.totalWidth - newLeftWidth,
            leftNode = this.leftController.model,
            rightNode = this.rightController.model,
            minLeftWidth = this.minLeftWidth,
            minRightWidth = this.minRightWidth,
            snapped = false;

            if (newLeftWidth < minLeftWidth || newRightWidth < minRightWidth) {
                // Can't resize any more because one side has reached the minimum width

                if (newLeftWidth < minLeftWidth) {
                    // Left is too small
                    newRightWidth = newRightWidth + newLeftWidth - minLeftWidth;
                    newLeftWidth = minLeftWidth;
                } else {
                    // Right is too small
                    newLeftWidth = newRightWidth + newLeftWidth - minRightWidth;
                    newRightWidth = minRightWidth;
                }
            } else {
                // No size restrictions hit

                if (this.snap.enable) {
                    /* snap to global (tree-based) fractions */
                    for (i = 0; i < this.snap.points.length; i++) {
                        point = this.snap.points[i].x;
                        if (point - this.snap.delta < clientX && clientX <= point + this.snap.delta) {
                            newLeftWidth = parseInt(point - this.leftOffset, 10);
                            newRightWidth = parseInt(this.totalWidth - newLeftWidth, 10);

                            this.guideline.attr('class', 'guideline-' + this.snap.points[i].type).css('left', point);
                            snapped = true;
                            break;
                        }
                    }
                }
            }


            // If there was no snap, hide the guideline
            if (!snapped) 
                this.guideline.css('left', - 9999);

            var changed = false;
            if (leftEl.width() != newLeftWidth) 
                changed = true;

            if (changed) {
                leftEl.width(newLeftWidth);
                rightEl.width(newRightWidth);
                this.leftWidth = newLeftWidth;
                this.rightWidth = newRightWidth;

                // show resize edge in new position
                var parent = this.rowController.el,
                parentWidth = parent.width(),
                relativeLeft = Math.round(100000 * (rightEl.offset().left - parent.offset().left - 1) / parent.width()) / 1000,
                rightEdge = rightEl.data('edge');

                rightEdge.css('left', relativeLeft + "%");

                // resize the nodes
                leftNode.controller.resized(false);
                rightNode.controller.resized(false);
            }

            return true;
        }
    });

    return ColumnResizeController;
});
define('internal/sitebuilder/builderChrome/binaryPlane', [], function() {

    function BinaryPlane(opts) {
        if (!opts) 
            opts = {};

        this.padding = opts.padding || 0;
        this.paddingTop = opts.paddingTop || this.padding;
        this.paddingBottom = opts.paddingBottom || this.padding;
        this.paddingRight = opts.paddingRight || this.padding;
        this.paddingLeft = opts.paddingLeft || this.padding;

        if (opts.position && typeof opts.offset == "function") {
            var pos = opts.offset();
            this.left = pos.left;
            this.top = pos.top;
        } else {
            this.left = opts.left || 0;
            this.top = opts.top || 0;
        }
        if (opts.outerWidth && typeof opts.outerWidth == "function") {
            this.width = opts.outerWidth();
        } else if (opts.width && typeof opts.width == "function") {
            this.width = opts.width();
        } else {
            this.width = opts.width || 100;
        }
        if (opts.outerHeight && typeof opts.outerHeight == "function") {
            this.height = opts.outerHeight();
        } else if (opts.height && typeof opts.height == "function") {
            this.height = opts.height();
        } else {
            this.height = opts.height || 100;
        }
        this.present = true;
    }

    BinaryPlane.prototype.getLeft = function getLeft() {
        return this.left;
    };
    BinaryPlane.prototype.getRight = function getRight() {
        return this.left + this.width;
    };
    BinaryPlane.prototype.getTop = function getTop() {
        return this.top;
    };
    BinaryPlane.prototype.getBottom = function getBottom() {
        return this.top + this.height;
    };
    BinaryPlane.prototype.getWidth = function getWidth() {
        return this.width;
    };
    BinaryPlane.prototype.getHeight = function getHeight() {
        return this.height;
    };

    BinaryPlane.prototype.intersects = function intersects(box) {
        return !(box.getRight() <= this.getLeft() ||
        this.getRight() <= box.getLeft() ||
        box.getBottom() <= this.getTop() ||
        this.getBottom() <= box.getTop());
    };

    BinaryPlane.prototype.contains = function contains(box) {
        return (this.containsPoint(box.getLeft(), box.getTop()) &&
        this.containsPoint(box.getRight(), box.getBottom()));
    };

    BinaryPlane.prototype.containsPoint = function containsPoint(x, y) {
        return (this.getLeft() <= x &&
        x <= this.getRight() &&
        this.getTop() <= y &&
        y <= this.getBottom());
    };

    BinaryPlane.prototype.eachBox = function eachBox(fn) {
        if (this.children) {
            for (var i = 0; i < this.children.length; ++i) {
                this.children[i].eachBox(fn);
            }
        } else if (this.present) {
            fn(this);
        }
        return this;
    };

    BinaryPlane.prototype.remove = function remove(box) {
        box = new BinaryPlane(box);
        box.left -= this.paddingLeft;
        box.top -= this.paddingTop;
        box.width += this.paddingLeft + this.paddingRight;
        box.height += this.paddingTop + this.paddingBottom;
        if (!this.present || !this.intersects(box)) {
            return this;
        } else if (this.children) {
            for (var i = 0; i < this.children.length; ++i) {
                this.children[i].remove(box);
                if (!this.children[i].present) {
                    this.children.splice(i--, 1);
                }
            }
        } else {
            if (box.contains(this)) {
                this.present = false;
                delete this.children;
            } else if (this.intersects(box)) {
                this.children = [];

                var target = this;

                if (target.getTop() < box.getTop()) {
                    var top = new BinaryPlane({
                        left: target.getLeft(),
                        top: target.getTop(),
                        width: target.getWidth(),
                        height: box.getTop() - target.getTop()
                    });
                    this.children.push(top);
                    target = new BinaryPlane({
                        left: this.getLeft(),
                        top: box.getTop(),
                        width: this.getWidth(),
                        height: this.getHeight() - top.getHeight()
                    });
                }
                if (box.getBottom() < target.getBottom()) {
                    var bottom = new BinaryPlane({
                        left: target.getLeft(),
                        top: box.getBottom(),
                        width: target.getWidth(),
                        height: target.getBottom() - box.getBottom()
                    });
                    this.children.push(bottom);
                    target = new BinaryPlane({
                        left: target.getLeft(),
                        top: target.getTop(),
                        width: target.getWidth(),
                        height: box.getBottom() - target.getTop()
                    });
                }
                if (target.getLeft() < box.getLeft()) {
                    var left = new BinaryPlane({
                        left: target.getLeft(),
                        top: target.getTop(),
                        width: box.getLeft() - target.getLeft(),
                        height: target.getHeight()
                    });
                    this.children.push(left);
                    target = new BinaryPlane({
                        left: box.getLeft(),
                        top: target.getTop(),
                        width: target.getRight() - box.getLeft(),
                        height: target.getHeight()
                    });
                }
                if (box.getRight() < target.getRight()) {
                    var right = new BinaryPlane({
                        left: box.getRight(),
                        top: target.getTop(),
                        width: target.getRight() - box.getRight(),
                        height: target.getHeight()
                    });
                    this.children.push(right);
                    target = new BinaryPlane({
                        left: target.getLeft(),
                        top: target.getTop(),
                        width: box.getRight() - target.getLeft(),
                        height: target.getHeight()
                    });
                }
                target.present = false;
            }
        }
        return this;
    };

    return BinaryPlane;

});
var mpq = window.mpq;
/* jshint ignore:start */
if (typeof(mpq) == 'undefined') {
    mpq = [];
    mpq.push(["init", "58fa82747b4c3f4992b74583e70b8940"]);
    (function() {
        var b, a, e, d, c;
        b = document.createElement("script");
        b.type = "text/javascript";
        b.async = true;
        b.src = (document.location.protocol === "https:" ? "https:" : "http:") +
        "//api.mixpanel.com/site_media/js/api/mixpanel.js";
        a = document.getElementsByTagName("script")[0];
        a.parentNode.insertBefore(b, a);
        e = function(f) {
            return function() {
                mpq.push(
                [f].concat(Array.prototype.slice.call(arguments, 0)))
            }
        };
        d = ["init", "track", "track_links",
        "track_forms", "register", "register_once", "identify", "name_tag", "set_config"];
        for (c = 0; c <
        d.length; c++) {
            mpq[d[c]] = e(d[c])
        }
    })();
}
/* jshint ignore:end */

define('internal/sitebuilder/common/mixpanel', [], function() {

    // mixpanelNotifier is a higher level helper consuming mpq
    return mpq;
});

define('internal/sitebuilder/common/trackEvents', [
'internal/sitebuilder/common/mixpanel',
'internal/sitebuilder/common/eventBuffer',
'internal/sitebuilder/common/log',
'jquery'
], function(mixpanel, eventBuffer, log, $) {

    // Track events in SiteBuilder/SiteDesigner.
    //
    // Watches a configurable set of global events and sends the data points to
    // MixPanel. Also registers global properties identifying the user by site id,
    // and telling us if they already have premium.

    var everyTimeEventNames = [
    "module:drop",
    "dialog:publish:success",
    "dialog:image:upload",
    "image:search",
    "theme:change"
    ],
    firstTimeEventNames = [
    "loaded:sitebuilder",
    "loaded:sitedesigner",
    "loaded:sandbox",
    "loaded:sandboxSignup",
    "module:drop:failed",
    "module:edit",
    "dialog:addPage:viewedApps",
    "dialog:changeLayout",
    "dialog:addPage",
    "dialog:published", // when the "publish" page is viewed (loader is displayed)
    "dialog:publish:error",
    "dialog:premium",
    "theme:saveChanges",
    "theme:discardChanges",
    "theme:customizeVariable",
    "save:failure",
    "save:failure:strangeItem",
    "unsavedChanges"
    ];

    init();

    function init() {
        if (!window.webs || !webs.site) 
            return;

        function listenToEvents(eventNames) {
            var eventName;
            for (var i = 0, l = eventNames.length; i < l; i++) {
                eventName = eventNames[i];
                eventBuffer.bind(eventName, handleEvent(eventName));
            }
        }
        if (webs.site.firstSession)
            listenToEvents(firstTimeEventNames);
        listenToEvents(everyTimeEventNames);


        // Track document mode and user agent
        var documentMode, ua;
        try {
            if ($.browser.msie) {
                documentMode = "IE < 8";
                // documentMode is available IE 8+, returns compat version being used
                if (document.documentMode) {
                    documentMode = "IE >= 8, acting as " + document.documentMode;
                }
            }
            ua = window.navigator && navigator.userAgent;
        } catch (e) {
            ua = "detection error";
        }

        if (window.top.webs && top.webs.site) {
            mixpanel.push(['register', {
                'siteId': webs.site.id,
                'premium': webs.site.premium,
                'documentMode': documentMode,
                "ua": ua
            }
            ]);
            mixpanel.push(['name_tag', "Webs Site #" + webs.site.id]);
            log.trigger("tracking", "info", "first time: registering user identity", webs.site.id);
        }
    }

    function handleEvent(eventName) {
        return function(data) {
            log.trigger("tracking", "info", "first time: tracking event", eventName);
            mixpanel.push(['track', "sb3:" + eventName, data]);
        };
    }


});

/*
CSS Browser Selector v0.4.0 (Nov 02, 2010)
Rafael Lima (http://rafael.adm.br)
http://rafael.adm.br/css_browser_selector
License: http://creativecommons.org/licenses/by/2.5/
Contributors: http://rafael.adm.br/css_browser_selector#contributors
*/
/* jshint ignore:start */
function css_browser_selector(u) {
    var ua = u.toLowerCase(), is = function(t) {
        return ua.indexOf(t)>-1
    }, g = 'gecko', w = 'webkit', s = 'safari', o = 'opera', m = 'mobile', h = document.documentElement, b = [(!(/opera|webtv/i.test(ua)) && /msie\s(\d)/.test(ua)) ? ('ie ie' + RegExp.$1): is('firefox/2') ? g + ' ff2': is('firefox/3.5') ? g + ' ff3 ff3_5': is('firefox/3.6') ? g + ' ff3 ff3_6': is('firefox/3') ? g + ' ff3': is('gecko/') ? g: is('opera') ? o + (/version\/(\d+)/.test(ua) ? ' ' + o + RegExp.$1 : (/opera(\s|\/)(\d+)/.test(ua) ? ' ' + o + RegExp.$2 : '')): is('konqueror') ? 'konqueror': is('blackberry') ? m + ' blackberry': is('android') ? m + ' android': is('chrome') ? w + ' chrome': is('iron') ? w + ' iron': is('applewebkit/') ? w + ' ' + s + (/version\/(\d+)/.test(ua) ? ' ' + s + RegExp.$1 : ''): is('mozilla/') ? g: '', is('j2me') ? m + ' j2me': is('iphone') ? m + ' iphone': is('ipod') ? m + ' ipod': is('ipad') ? m + ' ipad': is('mac') ? 'mac': is('darwin') ? 'mac': is('webtv') ? 'webtv': is('win') ? 'win' + (is('windows nt 6.0') ? ' vista' : ''): is('freebsd') ? 'freebsd': (is('x11') || is('linux')) ? 'linux': '', 'js'];
    c = b.join(' ');
    h.className += ' ' + c;
    return c;
};
css_browser_selector(navigator.userAgent);
/* jshint ignore:end */
;
define("internal/sitebuilder/common/css_browser_selector", function() {});

/* global jQuery:false, Modernizr:false */
(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define('internal/sitebuilder/common/jquery.loadingSpinner', ['jquery'], factory);
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {
    "use strict";
    /* jshint ignore:start */
    function loading() {
        var $this = $(this),
        instance = $this.data('loadingSpinner');
        if (instance.$spinner) {
            return;
        }
        instance.$spinner = $('<div/>').addClass('loadingSpinner').appendTo($this);
        instance.angle = 0;
        if ((typeof(Modernizr) !== 'undefined' && !Modernizr.cssanimations) || (typeof(Modernizr) == 'undefined' && $.browser.msie)) {
            instance.updateInterval = setInterval($.proxy(rotate_msie, $this), 81);
        }
    }

    function rotate_msie() {
        var instance = this.data('loadingSpinner');
        instance.angle = (instance.angle - 45) % 360;
        instance.$spinner.css({
            'msTransform': 'rotate(' + instance.angle + 'deg)'
        });
    }

    function loaded() {
        var $this = $(this),
        instance = $this.data('loadingSpinner');
        if (instance.updateInterval) {
            clearInterval(instance.updateInterval);
            delete instance.updateInterval;
        }
        if (instance.$spinner) {
            instance.$spinner.remove();
            delete instance.$spinner;
        }
    }

    function destroy() {
        var $this = $(this),
        instance = $this.data('loadingSpinner');
        $this.
        trigger('spinner.loaded').
        unbind('spinner.loading').
        unbind('spinner.loaded').
        unbind('spinner.destroy').
        data('loadingSpinner', null);
    }
    /* jshint ignore:end */

    $.fn.loadingSpinner = function loadingSpinner(opts) {
        var $this = $(this).eq(0),
        method;
        if (typeof opts == 'string') {
            method = opts;
            opts = arguments[1];
        }
        opts = $.extend({}, opts);
        $this.
        data('loadingSpinner', opts).
        bind('spinner.loading', loading).
        bind('spinner.loaded', loaded).
        bind('spinner.destroy', destroy);
        if (method === undefined || method === 'start') {
            $this.trigger('spinner.loading');
        }
        return this;
    };
}));
define('internal/sitebuilder/builderChrome/moduleBar', [
'jquery',
'require',
'spine',
'internal/sitebuilder/builderChrome/toolbar',
'translate!webs.bldr.toolbar'
], function($, require, Spine, toolbar, translate) {

    /**
    	 * CLASS CONSTANT
    	 */
    var MODULEBAR = 'bldr-modulebar',

    /**
    	 * Simple controller for handling elements indexing and scrolling during hovers
    	 */
    ElementScroller = Spine.Controller.create({

        scrollInfo: null,
        // Flag indicating scrolling and direction
        scrollTimer: 0,
        // Timer
        scrollable: false,
        // Should we scroll-check?
        scrollWidth: 30,

        init: function(opts) {
            var self = this;

            self.elLeft = self.el.offset().left;

            // Slide container, width, and width of individual slide item
            self.ul = $("<ul/>").addClass("clearfix").appendTo(self.el);
            self.ulWidth = self.ul.width();

            // Event binding to begin/stop scrolling
            self.el.addClass("bldr-scrolLIze")
            .mousemove(function(e) {
                return self.elMove(e);
            })
            .mouseleave(function(e) {
                return self.elLeave(e);
            });

            return self;
        },

        elLeave: function(e) {
            var self = this;
            if (!self.scrollable) 
                return false;
            self.scrollInfo = null;
            clearInterval(self.scrollTimer);
        },

        elMove: function(e) {
            var self = this;
            if (!self.scrollable) 
                return false;

            var left = self.ul.position().left;
            var pos = (e.clientX - self.elLeft);

            if (pos < self.scrollWidth && left < 0) {
                if (self.scrollInfo !== "left") {
                    self.scrollInfo = "left";
                    self.scrollTimer = setInterval(function() {
                        self.scrollSlides();
                    }, 18);
                }
            } else if (pos > self.maxWidth - self.scrollWidth && left > self.maxWidth - self.ulWidth) {
                if (self.scrollInfo !== "right") {
                    self.scrollInfo = "right";
                    self.scrollTimer = setInterval(function() {
                        self.scrollSlides();
                    }, 18);
                }
            } else {
                self.scrollInfo = null;
                clearInterval(self.scrollTimer);
            }
        },

        scrollSlides: function() {
            var
            self = this,
            left = self.ul.position().left,
            slideContainerWidth = self.ulWidth;

            if (self.scrollInfo) {
                if (self.scrollInfo === "right") {
                    if (left < self.maxWidth - self.ulWidth) {
                        left = self.maxWidth - self.ulWidth + 2;
                        clearInterval(self.scrollTimer);
                    }
                    self.ul.css("left", left - 2);

                } else if (self.scrollInfo === "left") {
                    if (left > 0) {
                        left = - 2;
                        clearInterval(self.scrollTimer);
                    }
                    self.ul.css("left", left + 2);
                }
            }
        },

        select: function(i) {
            var self = this;
            if (!self.scrollable) 
                return false;

            var
            li = self.ul.children().eq(i),
            left = li.position().left,
            right = left + li.width(),
            containerLeft = - self.ul.position().left,
            containerRight = containerLeft + self.maxWidth;

            if (containerRight < right) {
                //too far to the right
                self.ul.animate({
                    "left": self.maxWidth - right
                }, 400);
            } else if (containerLeft > left) {
                //too far to the left
                self.ul.animate({
                    "left": - left
                }, 400);
            } else {
                // possibly in view but needs to shift anyway (empty space after delete)
                if (i === self.ul.children().length - 1 && right < containerRight) {
                    self.ul.animate({
                        "left": self.maxWidth - right
                    }, 400);
                }

            }

        },

        // Appends a list item to list and perform scrollable check
        append: function(el) {
            var self = this;

            if (el && el.jquery && el[0].nodeName === "LI") {
                self.ul.append(el);
                self.check();
            }
        },

        // Checks whether container is scrollable or not
        check: function(fn) {
            var self = this;
            var parent = self.el.parent();

            parent.css({
                "height": 0,
                "width": parent.width(),
                "overflow": "hidden"
            });

            // Grab the ul's width
            self.el.width(9999);
            self.ul.width('');

            setTimeout(function() {
                self.ulWidth = self.ul.width();
                self.ul.width(self.ulWidth);

                parent.css({
                    "height": "",
                    "width": "",
                    "overflow": ""
                });

                if (self.ulWidth > self.maxWidth) {
                    self.scrollable = true;
                    self.el.addClass("bldr-scrolLIze-able");
                    self.el.width(self.maxWidth);
                } else {
                    self.scrollable = false;
                    self.el.removeClass("bldr-scrolLIze-able");
                    self.el.width(self.ulWidth);
                    self.ul.animate({
                        "left": 0
                    });
                }
                if (typeof fn === "function") 
                    fn();
            }, 0);
        }
    }),

    // get it? scrol-LI-ze?
    scrolLIze = function(opts) {
        return ElementScroller.init(opts);
    },

    /**
    	 * ModuleBar Class
    	 */
    ModuleBar = {
        /**
        		 * Sets popover feedback
        		 */
        setFeedback: function($el) {
            if (!$el.jquery) 
                return false;
            this.feedback = {
                ref : $el 
            };
            return true;
        },

        /**
        		 * TODO: better way of doing this.
        		 * scrolLIze is its own controller but needs modulebar inst for accessor is ugly
        		 */
        scrolLIze: scrolLIze,

        init: function() {
            toolbar = require('internal/sitebuilder/builderChrome/toolbar');
            var self = this,
            container = $('<div/>').addClass(MODULEBAR + " bldr-prevent-clear"), // Container wrapping the whole bar
            buttonContainer = $('<ul/>').addClass(MODULEBAR + '-buttons'),
            buttonContainerRight = $('<ul/>').addClass(MODULEBAR + '-buttons ' + MODULEBAR + '-buttons-right'),
            buttonDoneContainer = $('<li/>').addClass('bldr-modulebar-done-container').appendTo(buttonContainerRight),
            buttonDone = toolbar
            .createUI({
                type: 'button',
                btnPrefix: 'w-btn1',
                label: 'Done',
                icon: 'check',
                style: 'green',
                name: 'done',
                click: function() {
                    bldr.pageController.clearCurrentController();
                }
            }, buttonDoneContainer, self).addClass(MODULEBAR + '-done');


            container.append(buttonContainer, buttonContainerRight);

            this.container = container;
            this.buttonContainer = buttonContainer;
            this.buttonContainerRight = buttonContainerRight;
            this.eventListeners = {};
        },

        /* opts = object with options: [] which includes UI elements */
        build: function(opts) {
            var self = this,
            optionsContainer = $('<li/>').addClass(MODULEBAR + '-options w-more').appendTo(this.buttonContainerRight),
            optionsButton = toolbar.createUI({
                type: 'button',
                btnPrefix: 'w-btn1',
                icon: 'settings',
                name: 'settings',
                label: 'Options',
                more: true,
                width: 120
            }, optionsContainer, self).removeClass('w-btn-icon').addClass('w-btnstates'),
            optionsWrap = $('<div/>').addClass('w-more_container'),
            optionsMenu = $('<ul/>').addClass('w-more_list');

            if (opts.title) {
                var translatedTitle = translate('webs.bldr.toolbar.text.' + opts.title.replace(/\s/g, ''));
                optionsMenu.append(
                $('<li/>').addClass('w-more-title').html(translatedTitle),
                $('<li/>').addClass('w-more-divider')
                );
            }

            if (opts.width) 
                optionsWrap.width(opts.width);

            $.each(opts.menu, function(index, menuItem) {
                var newli = $('<li/>').appendTo(optionsMenu).addClass('clearfix'),
                layoutClass = $;

                if (menuItem instanceof Array) {
                    $.each(menuItem, function(index, menuItem) {
                        if (menuItem.type === 'more-divider') {
                            toolbar.createUI(menuItem, newli, self);
                        } else {
                            var newContainer = $('<div/>').appendTo(newli).addClass('more_item_container ');
                            toolbar.createUI(menuItem, newContainer, self);
                        }
                    });
                } else {
                    if (typeof menuItem.type !== 'string') 
                        menuItem.type = 'link';
                    toolbar.createUI(menuItem, newli, self);
                }

            });

            optionsContainer.append(optionsWrap.append(optionsMenu));
            this.optionsMenu = optionsMenu;
        },

        addGroup: function(opts) {
            var container = $('<li/>').appendTo(this.buttonContainer);
            opts = opts || {
                type: 'button-group',
                items: []
            };

            return toolbar.createUI(opts, container, this);
        },

        /*
        		Adds button to the module button bar on the left
        		TODO: accept param type Array and multiple arguments
        		*/
        addButton: function(button, ref) {
            button.btnPrefix = button.btnPrefix || 'w-btn1';

            var container = button.container || $('<li/>');
            button = toolbar.createUI(button, container, this);

            if (typeof ref !== 'undefined') {
                ref.before(container);
            } else {
                this.buttonContainer.append(container);
            }

            return container;
        },

        removeButton: function(button) {
            button = $(button);
            var buttons = $('a.webs_btn', this.buttonContainer);
            $.each(buttons, function(i, btn) {
                if (btn[0] == button[0]) 
                    btn.parent().remove();
            });
        },

        remove: function() {
            this.container.remove();
        },

        // remove existing controls, resetting to a blank modulebar
        empty: function() {
            this.container.empty();
        },

        destroy: function() {
            this.remove();
            if (this.glueTimer) 
                window.clearInterval(this.glueTimer);
        },

        // appends container to document body, keeps modulebar glued to a certain position
        glueTo: function(element) {
            this.gluedEl = $(element);
            this.$html = this.gluedEl.parents("html");
            this.container.appendTo(this.gluedEl.parents("body"));
            this.container.width(this.gluedEl.width());
            this.glueTimer = window.setInterval($.proxy(this, "fixGluedPosition"), 100);
        },

        fixGluedPosition: function() {
            var css = this.gluedEl.offset();
            css.top += this.gluedEl.height() - parseInt(this.$html.css("padding-top"), 10);
            css.width = this.gluedEl.width();
            this.container.css(css);
        },

        addListener: function(event, fn) {
            var self = this,
            events = this.eventListeners;

            if (typeof event === 'object') {
                for (var key in event) 
                    if (event.hasOwnProperty(key)) 
                        this.addListener(key, event[key]);
            } else if (typeof event === 'string') {
                if (typeof events[event] !== 'object' || !(events[event] instanceof Array)) 
                    events[event] = [];
                events[event].push(fn);
            } else if (typeof events === 'function') {
                events['default'].push(fn);
            }

            return this;
        },

        change: function(event, param) {
            var events = this.eventListeners;

            if (typeof events[event] !== 'object' || !(events[event] instanceof Array)) 
                return false;
            for (var i = 0; i < events[event].length; i++) {
                if (typeof events[event][i] === 'function') 
                    events[event][i](param, event);
            }
        },

        /**
        		 * Adding bind and trigger since that's what we call it everywhere else
        		 */
        bind: function(event, fn) {
            return this.addListener(event, fn);
        },
        trigger: function(event, param) {
            return this.change(event, param);
        },
        unbind: function() {
            this.eventListeners = {};
        }
    };




    return {
        create: function() {
            var mb = Object.create(ModuleBar);
            mb.init();
            return mb;
        }

    };

});
/* 	Node Controllers

	Control display, styling, and events for nodes in the page tree.

    Last edited: 7/30/11
	Authors: Idris, Adam
*/

define('internal/sitebuilder/builderChrome/nodeControllers', [
'jquery',
'require',
'spine',
'internal/sitebuilder/common/eventBuffer',
'internal/sitebuilder/common/log',
'internal/sitebuilder/builderChrome/undoer',
'internal/sitebuilder/builderChrome/moduleBar',
'internal/sitebuilder/builderChrome/toolbar',
'internal/sitebuilder/common/ModuleClassLoader',
'internal/sitebuilder/builderChrome/nodes',
'sb3Branding',
'translate!webs.bldr',
'instance/site/entitlements',
'internal/sitebuilder/builderChrome/chromeController',
'persist'
], function define_nodeControllers($, require, Spine, eventBuffer, log, undoer, moduleBar, toolbar, ModuleClassLoader, nodes, sb3Branding, translate, entitlements) {
    // class hierarchy
    var NodeController = Spine.Controller.create(),
    PlaceholderNodeController = NodeController.create(),
    ModuleNodeController = NodeController.create(),
    SplitNodeController = NodeController.create(),
    ColumnController = SplitNodeController.create(),
    RowController = SplitNodeController.create(),
    TreeController = ColumnController.create(),
    FreebarController = PlaceholderNodeController.create();

    // NodeRenderer: FIXME move somewhere else

    var nodeRenderer = Spine.Controller.create({
        toRender: [],
        renderTimeout: false,

        renderLater: function nodeRenderer_renderLater(controller) {
            this.toRender.push(controller);
            if (!this.renderTimeout) 
                this.setRenderTimeout();
        },

        render: function nodeRenderer_render() {
            var toRender = this.toRender,
            orderToRender = [],
            i, j, l, l2,
            controller, depth, placeInOrder, controllers;

            // First sort the controllers by depth so we render parents before children
            for (i = 0, l = toRender.length; i < l; i++) {
                controller = toRender[i];
                depth = controller.model.depth();
                placeInOrder = orderToRender[depth];

                if (placeInOrder)
                    placeInOrder.push(controller);
                else
                    orderToRender[depth] = [controller];
            }

            // Now render each controller in each depth if it hasn't already been rendered by its parent
            for (i = 0, l = orderToRender.length; i < l; i++) {
                controllers = orderToRender[i];
                if (!controllers) 
                    continue;

                for (j = 0, l2 = controllers.length; j < l2; j++) {
                    controller = controllers[j];
                    if (controller.needsRender) 
                        controller.render();
                }
            }
        },

        setRenderTimeout: function nodeRenderer_setRenderTimeout() {
            var self = this;
            this.renderTimeout = setTimeout(
            function nodeRenderer_setRenderTimeout_timeoutFn() {
                self.render();
                self.renderTimeout = false;
            }, 1);
        }

    }).init();

    // constants

    var CLASSES = {
        TREE: 'webs-content',
        ROW: 'webs-row',
        COLUMN: 'webs-col',
        TOPLEVEL: 'webs-parent-0',
        BINPARENT: 'webs-parent',
        BINPARENT_N: function(n) {
            return CLASSES.BINPARENT + "-" + n;
        },

        SPLIT: {
            "row": "webs-row",
            "column": "webs-col",
            "tree": 'webs-parent'
        },

        BIN: 'webs-bin',
        BINWRAP: 'webs-bin-wrap',
        BINACTIVE: 'webs-bin-active',
        CONTAINER: 'webs-container',
        EDGE: 'bldr-edge',

        PLACEHOLDER: 'bldr-placeholder',

        BINOVERLAY: 'bldr-bin-overlay',
        COVER: 'bldr-canvas-cover'
    };

    var nodeTypeToControllerClass = {
        "placeholder": PlaceholderNodeController,
        "module": ModuleNodeController,
        "column": ColumnController,
        "row": RowController,
        "tree": TreeController,
        "freebar": FreebarController
    };

    var factory = function(modelClass) {
        var controller = nodeTypeToControllerClass[modelClass.type];
        if (modelClass.freebar) 
            controller = nodeTypeToControllerClass['freebar'];
        if (controller)
            return controller.init({
                model: modelClass 
            });
        else
            return log.error("Could not initialize controller for model type:" + modelClass.type);
    };

    NodeController.prototype.init = function NodeController_init(options) {
        this.model = options.model;
        this.jQuery = bldr.pageController.$;
        this.$ = function(sel) {
            this.jQuery(sel, this.el);
        };
        this._ensureEl();
        this._decorateEl();
        this._attachEvents();
        return this;
    };

    SplitNodeController.fn.init = function SplitNodeController_init(options) {
        NodeController.fn.init.call(this, options);
    };

    //Function to finish setting up the tree after it's been loaded.
    TreeController.prototype.treeLoaded = function(data) {
        this.model = require('internal/sitebuilder/builderChrome/nodes').Tree.load(data.id, data);
        if (this.model.children && this.model.children[0] && this.model.children[0].freebarRemoved) {
            this.model.dirty();
        }
        this.model.controller = this;
        this.model._isLocked = this.el.data('websLocked');
        this._attachEvents();
        this.renderLater();
        this.el.addClass('role-' + this.role);
        this.treeLoadedDeferred.resolve();
    };

    TreeController.prototype.init = function TreeController_init(options) {
        this.el = options.el;
        var id = this.el.attr('id');
        this.role = this.el.data("role");
        var treeData = options.treeData;

        /*
        		 * this.treeLoadedPromise is resolved when a tree is loaded, and rejected if that load fails.
        		 * this.treeLoadedIgnoringErrorsPromise is always resolved regardless of errors
        		 * This is to get around the fact that $.when (used to create composite promises) will short-circuit
        		 * if any of the provided promises are rejected.
        		 *
        		 * See: PageController.display()
        		 */
        this.treeLoadedDeferred = new $.Deferred();
        this.treeLoadedPromise = this.treeLoadedDeferred.promise();
        var treeLoadedIgnoringErrorsDeferred = new $.Deferred();
        this.treeLoadedIgnoringErrorsPromise = treeLoadedIgnoringErrorsDeferred.promise();
        this.treeLoadedPromise.always(treeLoadedIgnoringErrorsDeferred.resolve);

        if (id.indexOf('faketree') >= 0) {
            // BackEnd generates this when it doesn't have a tree for the section.
            log.error("No tree for section " + this.role);
            // TODO: This should be translated.
            alert("We were unable to load one of the sections of your page. Please contact support.");
            this.treeLoadedDeferred.reject();
            return false;
        }

        //If the tree data is already available, skip the Ajax call to load it.
        if (treeData) {
            this.treeLoaded(treeData);
        } else {
            //The tree data was not available, load it via Ajax.
            require('persist').load(id, $.proxy(function TreeController_init_loadSuccess(treeData) {
                this.treeLoaded(treeData);
            }, this), function TreeController_init_loadError(jqXHR, textStatus, errorThrown) {
                log.error("Unable to load tree: " + id);

                // If it was aborted (user left the page or hit escape), don't alert.
                var aborted = jqXHR && typeof(jqXHR.status) == 'number' && jqXHR.status === 0;
                if (!aborted) {
                    // TODO: This should be translated.
                    alert("We were unable to load one of the sections of your page. Please refresh the page.");
                }
                this.treeLoadedDeferred.reject();
            });
        }

        if (this.role === 'webs-footer') {
            var self = this;
            this.treeLoadedDeferred.done(function () {
                if (!webs.site.editableFooter && !webs.site.isCobrand && !self.model.hasSinglePlaceholder() &&
                !self.model.hasSingleFreebar()) {
                    var hasSEOEntitlement = entitlements.hasEntitlement("SEO");
                    var showPopover = function (e) {
                        var target = $(e.target);
                        if (!target.closest('.bldr-freebar').length && (!target.closest('.webs-module-seo_footer').length || !hasSEOEntitlement)) {
                            e.preventDefault();
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                            require(['translate!webs.internal.footer'], function (translate) {
                                var popover = new Popover('/s/sitebuilder/dialogs/clearFooter', {
                                    heading: translate('webs.internal.footer.expiredFooterTitle'),
                                    width: 400,
                                    height: 200
                                });
                                popover.show();
                            });
                        }
                    };

                    var stopHover = function (e) {
                        var target = $(e.target);
                        if (target.closest('.webs-module-seo_footer').length && !hasSEOEntitlement) {
                            e.preventDefault();
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                        }
                    };

                    /* If we're not in IE8, use addEventListener( ev, func, true) to capture click event instead of bubble
                    					 * so that we get the click event at outermost element first, rather than bubbling up from inside
                    					 */
                    var footerEl = self.el.get(0);
                    if (footerEl.addEventListener) {
                        footerEl.addEventListener('click', showPopover, true);
                        footerEl.addEventListener('mousemove', stopHover, true);
                    } else {
                        // If IE8, just use mousedown to do the best we can not to conflict with module behavior
                        self.el.bind('mousedown', showPopover);
                        self.el.bind('mousemove', stopHover);
                    }
                }
            });
        }
    };

    /*

    	Wrapping Element
    	*/
    NodeController.prototype._ensureEl = function NodeController__ensureEl() {
        this.el = (this.el && this.jQuery(this.el) || this.jQuery("<div/>")).addClass(CLASSES.BIN);
        return this.el;
    };

    SplitNodeController.prototype._ensureEl = function SplitNodeController__ensureEl() {
        var self = this;
        this.el = (this.el && this.jQuery(this.el) || this.jQuery("<div/>"));

        // need to stall a fraction of the time before model.depth() returns something meaningful
        setTimeout(function SplitNodeController__ensureEl_timeout() {
            self.el
            .addClass(CLASSES.BINPARENT)
            .addClass(CLASSES.BINPARENT_N(self.model.depth()))
            .addClass(CLASSES.SPLIT[self.model.type]);
        }, 0);

        return this.el;
    };

    TreeController.prototype._ensureEl = function TreeController__ensureEl() {
        this.el = this.jQuery("#" + this.model.id);
        SplitNodeController.prototype._ensureEl.call(this);
    };

    NodeController.prototype._decorateEl = function NodeController__decorateEl() {
        this.el.data("controller", this);
    };


    /*

    	Rendering
    	*/
    // Render this node after the current stack winds down.
    NodeController.fn.renderLater = function NodeController_renderLater(callback) {
        this.needsRender = true;
        // TODO: Fixme
        // This is like using $el[0].onClick=function(){...} instead of $el.on('click',function(){...}) in that it
        // only allows one callback to be bound at a time. I think if we call renderLater twice in the same call
        // stack, the expectation would be that both callbacks are called after rendering.
        this._renderCallback = callback;
        nodeRenderer.renderLater(this);
    };

    NodeController.prototype.render = function NodeController_render() {
        // has this element been rendered a first time?
        this.rendered = true;

        // does this element need to be rendered or have its children reflowed?
        this.needsRender = false;

        if (typeof(this._renderCallback) == "function") {
            this._renderCallback();
            delete this._renderCallback;
        }

        return this.el;
    };

    PlaceholderNodeController.prototype.render = function PlaceholderNodeController_render() {
        NodeController.prototype.render.call(this);

        var placeholderText;

        if (this.model.isOnlyNode()) {
            switch (this.model.tree().controller.role) {
            case "webs-body":
                placeholderText = translate('webs.bldr.placeholder.body');
                break;
            case "webs-sidebar":
                placeholderText = translate('webs.bldr.placeholder.sidebar');
                break;
            case "webs-footer":
                placeholderText = translate('webs.bldr.placeholder.footer');
                break;
            case "webs-subfooter":
                placeholderText = translate('webs.bldr.placeholder.subfooter');
                break;
            default:
                placeholderText = translate('webs.bldr.placeholder.default');
            }
        } else {
            placeholderText = translate('webs.bldr.placeholder.default');
        }

        this.el = this.el.addClass(CLASSES.PLACEHOLDER).html(
        '<div class="' + CLASSES.BINWRAP + '">' +
        '<div class="' + CLASSES.CONTAINER + '">' +
        '<span>' + placeholderText + '</span>' +
        '</div></div>');
        return this.el;
    };

    FreebarController.prototype.render = function FreebarController_render() {
        NodeController.prototype.render.call(this);
        this.el.html(
        '<div class="' + CLASSES.BIN + ' bldr-freebar">' +
        '<div class="' + CLASSES.BINWRAP + '">' +
        '<div class="' + CLASSES.CONTAINER + '">' +
        sb3Branding.getFreebarHTML() +
        '</div>' +
        '</div>' +
        '</div>');

        var self = this;
        this.el.click(function FreebarController_render_click() {
            self.remove();
        });
        return this.el;
    };

    ModuleNodeController.prototype.render = function ModuleNodeController_render() {
        NodeController.prototype.render.call(this);

        if (this.model.module) {
            this.model.module.render();
            this.model.module.container = this.el.find("." + CLASSES.CONTAINER);
            this.fit(true);
        } else {
            // Sometimes we call render before it's been initted (like when we're building out the tree)
            //				log.debug('rendering a ModuleNodeController, but this.model.module is undefined');
        }

        return this.el;
    };

    ModuleNodeController.prototype.renderSpinner = function ModuleNodeController_renderSpinner() {};

    SplitNodeController.prototype.render = function SplitNodeController_render() {
        var el = this.el,
        kids = this.model.children;
        NodeController.prototype.render.call(this);

        // first display them all in order, then render them all in order
        $.each(kids, function SplitNodeController_render_append(i, node) {
            var c = node.controller;
            c.el.appendTo(el);
        });

        $.each(kids, function SplitNodeController_render_render(i, node) {
            var c = node.controller;
            c.render();
        });
        return el;
    };

    RowController.fn.render = function RowController_render() {
        var el = this.el,
        totalWidth = el.width(),
        kids = this.model.children;

        NodeController.fn.render.call(this);

        // first display them all in order, then render them all in order
        $.each(kids, function RowController_render_append(i, node) {
            var controller = node.controller,
            width = parseInt(node.width * totalWidth / 100, 10);

            controller.el.width(width);
            controller.el.appendTo(el);
        });

        $.each(kids, function RowController_render_render(i, node) {
            node.controller.render();
        });
    };

    ColumnController.prototype.render = function ColumnController_render() {
        SplitNodeController.fn.render.call(this);

        this.ensureEdge();
        return this.el;
    };

    ColumnController.fn.setWidth = function ColumnController_setWidth() {
        var model = this.model,
        parent = model.parentNode,
        parentC = parent && parent.controller,
        total = parentC && parentC.el.width(),
        width = parseInt(total * model.width / 100, 10);
        if (!total) 
            return;

        this.el.width(width);
        this.fit(true);
        this.ensureEdge();
    };

    // Initialize module
    ModuleNodeController.fn.initModule = function ModuleNodeController_initModule() {
        var model = this.model,
        self = this;

        // Sorry. This used to be in render, but I needed it to happen before we init the module
        this.el.html('<div class="' + CLASSES.BINWRAP + '"><div class="' + CLASSES.CONTAINER + '"/></div>');

        ModuleClassLoader.create(model.moduleType, {
            data: model.data,
            container: this.el.find('.' + CLASSES.CONTAINER) 
        }).done(function ModuleNodeController_initModule_createSuccess(m) {
            model.module = m;
            m.el.addClass('webs-module-' + m.parent.slug);
            if (model.parentNode.controller) 
                model.parentNode.controller.renderLater();
            self.renderLater();
            model.controller.fit();

            // Provide hook for modules to trigger a save
            m.bind("dirty", function ModuleNodeController_initModule_createSuccess_dirty() {
                model.save();
            });

            if (!model.id) {
                // mark as dirty, so that we can get an id
                m.dirty();
            }

            // Highlight for two seconds after loaded
            setTimeout(function() {
                self.el.removeClass('loading');
            }, 10);
            setTimeout(function() {
                self.el.removeClass('blink');
            }, 2000);
        }).fail(function ModuleNodeController_initModule_createError(jqXHR, textStatus, errorThrown) {
            // NB: do not remove nodes that have an id (e.g. are saved).
            // Imagine the user loads their beautiful page and the static server can't send the module files.
            // We don't want to remove those modules and lose all their data.
            if (!model.id) 
                self.model.remove();
            log.trigger("Load Fail", "error", "Unable to load module type: " + model.moduleType + ".");

            // If it was aborted (user left the page or hit escape), don't alert.
            var aborted = jqXHR && typeof(jqXHR.status) == 'number' && jqXHR.status === 0;
            if (!aborted) {
                alert("There was an error loading the " + model.moduleType + " module.\n" +
                "Please refresh the page and if the problem persists contact support.");
            }
        });

        this.renderSpinner();
    };


    /**
    		Tree operations
    	*/
    // Watch for model changes
    NodeController.fn._attachEvents = function NodeController__attachEvents() {
        this.model.bind("inserted", $.proxy(this, "inserted"));
        this.model.bind("removed", $.proxy(this, "removed"));
    };
    SplitNodeController.fn._attachEvents = function SplitNodeController__attachEvents() {
        NodeController.fn._attachEvents.call(this);
        this.model.bind("childRemoved", $.proxy(this, "childRemoved"));
        this.model.bind("childAdded", $.proxy(this, "childAdded"));
    };
    ColumnController.fn._attachEvents = function ColumnController__attachEvents() {
        SplitNodeController.fn._attachEvents.call(this);
        this.model.bind("widthChanged", $.proxy(this, "setWidth"));
    };

    ModuleNodeController.fn.inserted = function ModuleNodeController_inserted() {
        this.initModule();
    };

    ModuleNodeController.fn.removed = function ModuleNodeController_removed() {
        if (this.module) 
            this.module.deactivate();
        delete this.module;
        NodeController.fn.removed.call(this);
    };

    NodeController.fn.inserted = function NodeController_inserted() {
        this.renderLater();
    };

    NodeController.fn.removed = function NodeController_removed() {
        this.el.detach();
        if (this.edgeEl) 
            this.edgeEl.detach();

        require('internal/sitebuilder/builderChrome/nodes').Tree.each(function NodeController_removed_eachTree(tree) {
            if (tree.hasSinglePlaceholder()) {
                tree.controller.autoHeight();
                tree.controller.fixHeight();
            }
        });
    };

    PlaceholderNodeController.fn.inserted = function PlaceholderNodeController_inserted() {
        NodeController.fn.inserted.call(this);
        var self = this;

        setTimeout(function PlaceholderNodeController_inserted_timeout() {
            var tree = self.model.tree();

            if (typeof tree === "undefined") 
                return;

            if (tree.hasSinglePlaceholder()) {
                tree.controller.fixHeight();
            }
        }, 1);
    };

    PlaceholderNodeController.fn.removed = function PlaceholderNodeController_removed() {
        var tree = this.model.tree();
        NodeController.fn.removed.call(this);
        if (tree) {
            tree.controller.autoHeight();
        }
    };

    SplitNodeController.fn.childRemoved = function SplitNodeController_childRemoved() {};

    SplitNodeController.fn.childAdded = function SplitNodeController_childAdded(node, index) {
        var c = node.controller;
        this.renderLater();
    };


    NodeController.fn.fit = RowController.fn.fit = function NodeOrRowController_fit() {
        return false;
    };
    ColumnController.fn.fit = function ColumnController_fit(persist) {
        $.each(this.model.children, function ColumnController_fit_eachChild(i, node) {
            node.controller.fit(persist);
        });
    };
    ModuleNodeController.fn.fit = function ModuleNodeController_fit(persist) {
        if (this.model.module) {
            var width = this.el.find("." + CLASSES.CONTAINER).width();
            if (width > 0) 
                this.model.module.fit(width, persist);
        }
    };

    NodeController.prototype.pushUndoRemove = function NodeController_pushUndoRemove() {
        var model = this.model,
        insertMethod = model.insertMethod();
        if (!insertMethod) 
            return;
        var refNode = insertMethod[0],
        refC = refNode.controller,
        direction = insertMethod[1];
        undoer.pushAction(refC.insert, [model, direction, true], refC);
    };

    NodeController.prototype.remove = function NodeController_remove(scrollback, undoing) {
        if (!this.model) 
            return false;
        var model = this.model,
        parent = model.parentNode,
        parentC = parent.controller;

        if (undoing) {
            if (parent.type == "column" && parent.children.length == 1) {
                return parentC.remove(scrollback);
            }
        }
        this.model.backendDelete();
        this.pushUndoRemove();

        var removed = this.model.remove(true);
        this.renderLater();

        // FIXME: how do we ever reclaim this memory?
        // What if they undo to reinsert a node?
        // delete model.controller;
        // delete this.model;

        if (scrollback) {
            bldr.pageController.dom.$htmlbody.animate({
                scrollTop: scrollback
            }, 250);
        }

        return removed;
    };

    FreebarController.prototype.remove = function FreebarController_remove(scrollback, undoing) {
        if (webs.site.editableFooter) {
            return PlaceholderNodeController.prototype.remove.call(this, scrollback, undoing);
        } else {
            if (sb3Branding.onClickFreebar) {
                sb3Branding.onClickFreebar();
            }
            return false;
        }
    };

    NodeController.prototype.insert = function NodeController_insert(newNode, side, forceSave) {
        var newC = newNode.controller;
        undoer.pushAction(newC.remove, [bldr.pageController.dom.$htmlbody.scrollTop(), true], newC);

        var model = this.model,
        tree = model.tree();
        model.insert(newNode, side);

        newC.renderLater(function NodeController_insert_renderLater() {
            if (forceSave) {
                newC.model.forceSave();
            }
            bldr.pageController.dom.$htmlbody.animate({
                scrollTop: newC.el.offset().top - 100
            }, 250);
        });
    };


    /**
    		* Move a subtree or node from one part of the tree to another (or to another tree altogether).
    		* @param {obj} requires at least
    		*    referenceNode & side:  The side of reference node to move the node to
    		*
    		* If moving last node of one tree to another tree, node will be replaced with placeholder
    		*/
    NodeController.prototype.moveTo = function NodeController_moveTo(referenceNode, side) {
        var model = this.model,
        tree = model.tree();

        undoer.pushAction(this.moveTo, this.model.insertMethod(), this);
        model.moveTo(referenceNode, side);
    };


    /**
    		 * Covert all columns to percentage width equalling 100% with 3 decimal rounding
    		 */
    NodeController.fn.widthToPercent = function NodeController_widthToPercent() {
        // Only applicable for Split nodes.
    };

    SplitNodeController.fn.widthToPercent = function SplitNodeController_widthToPercent() {
        $.each(this.model.children, function(i, child) {
            child.controller.widthToPercent();
        });
    };

    RowController.fn.widthToPercent = function RowController_widthToPercent() {
        var fullWidth = this.el.width(),
        widthPercentageSum = 0,
        children = $.map(this.model.children, function(c, i) {
            return c.controller;
        });

        var widthArray = $.map(children, function(child, i) {
            return child.el.width();
        }),
        length = widthArray.length;

        $.each(children, function RowController_widthToPercent_eachChild(i, child) {
            if (i != length - 1) {
                widthArray[i] = Math.round(100000 * widthArray[i] / fullWidth) / 1000; // now holds width percentage
                widthPercentageSum += widthArray[i];
            } else {
                widthArray[i] = 100 - widthPercentageSum;
            }
            child.el.width(widthArray[i] + '%');
            if (i !== 0) 
                child.ensureEdge();

            child.widthToPercent();
        });
    };


    /**
    		 * Covert all columns to percentage pixel width
    		 */
    NodeController.fn.widthToPixel = function NodeController_widthToPixel() {
        // Do nothing.
    };

    ColumnController.fn.widthToPixel = function ColumnController_widthToPixel() {
        $.each(this.model.children, function ColumnController_widthToPixel_eachChild(i, child) {
            child.controller.widthToPixel();
        });
    };

    RowController.fn.widthToPixel = function RowController_widthToPixel() {
        var fullWidth = this.el.width(),
        widthArray,
        length,
        widthSum = 0,
        children = $.map(this.model.children, function RowController_widthToPixel_mapToController(c, i) {
            return c.controller;
        });

        length = children.length;
        widthArray = $.map(children, function RowController_widthToPixel_mapToWidth(child, i) {
            return child.el.width();
        });

        $.each(children, function RowController_widthToPixel_eachChild(i, child) {
            if (this.model.type === 'row') {
                if (i != length - 1) {
                    widthSum += widthArray[i];
                } else {
                    widthArray[i] = fullWidth - widthSum;
                }
                child.el.width(widthArray[i]);

                // saves the percentage width
                child.width = parseInt(widthArray[i] / fullWidth, 100);
                child.model.tree().dirty(true);

            }
            if (child.children) 
                child.widthToPixel();
        });
    };


    NodeController.fn.getMinWidth = function NodeController_getMinWidth() {
        return 50;
    };

    ModuleNodeController.fn.getMinWidth = function ModuleNodeController_getMinWidth() {
        if (this.model.module) 
            return this.model.module.getMinWidth() + 20; // For now, all modules are padded with 10px on each side.
        else 
            return NodeController.fn.getMinWidth.call(this);
    };

    RowController.fn.getMinWidth = function RowController_getMinWidth() {
        var sum = 0;
        for (var i = 0, len = this.model.children.length; i < len; i++) {
            sum += this.model.children[i].controller.getMinWidth();
        }
        return sum;
    };

    ColumnController.fn.getMinWidth = function ColumnController_getMinWidth() {
        var max = 1;
        for (var i = 0, len = this.model.children.length; i < len; i++) {
            max = Math.max(max, this.model.children[i].controller.getMinWidth());
        }
        return max;
    };


    // Save the module and re-insert it.
    // This is an easy way to clear all added controls and events.
    ModuleNodeController.fn.reload = function ModuleNodeController_reload(save) {
        var data = save ? this.saveModule() : this.model.save();

        this.init({
            model: this.model 
        });
    };


    /*
    	* Resizing
    	*/

    /**
    	* Ensure that this column has a resize edge
    	*/
    ColumnController.fn.ensureEdge = function ColumnController_ensureEdge() {
        if (!this.model || !this.model.parentNode || this.model.parentNode.type != "row") 
            return;

        var model = this.model,
        parent = model.parentNode,
        index = parent.indexOfChild(model);

        // Edge always goes to the right, so the first column in a row doesn't have an edge
        if (index === 0) 
            return this.edgeEl && this.edgeEl.detach();

        var $ = bldr.pageController.$,
        parentEl = parent.controller.el,
        left = this.el.position().left;

        if (!this.edgeEl) {
            this.edgeEl = $('<div/>').data('el', this.el).addClass(CLASSES.EDGE).append($('<div/>'));
            this.el.data('edge', this.edgeEl);
        }


        this.edgeEl.appendTo(parentEl).css({
            'left': left - 2
        });
    };

    NodeController.fn.ensureEdge = TreeController.fn.ensureEdge = function NodeOrTreeController_ensureEdge() {
        // Just here so we don't fall back to ColumnController.ensureEdge
    };

    /**
    	* Called after the width of this node's container has changed.
    	*
    	* @param {Boolean} persist Whether or not to persist (usually only happens on mouseup after resize)
    	*/
    NodeController.fn.resized = function NodeController_resized(persist) {
        // Do nothing.
    };
    ModuleNodeController.fn.resized = function ModuleNodeController_resized(persist) {
        if (this.model && this.model.module) 
            this.fit(persist);
    };
    SplitNodeController.fn.resized = function SplitNodeController_resized(persist) {
        var kids = this.model.children;
        for (var i = 0, len = kids.length; i < len; i++) {
            kids[i].controller.resized(persist);
        }
    };

    ColumnController.fn.resized = function ColumnController_resized(persist) {
        SplitNodeController.fn.resized.call(this, persist);
        if (this.model.type == 'column') 
            this.ensureEdge();
    };

    ColumnController.fn.setModelWidth = function ColumnController_setModelWidth(width) {
        this.model.width = width;
        if (this.model && this.model.module) 
            this.fit(true);
    };


    /*

    	Activating edit mode
    	*/
    ModuleNodeController.prototype.activate = function ModuleNodeController_activate(opts) {
        var node = this.model,
        transition = opts && opts.transition || false;

        if (!node.module) 
            return;

        eventBuffer.trigger("module:edit", {
            moduleType: node.module.moduleType 
        });

        this.el.addClass(CLASSES.BINACTIVE);

        if (!this.model.tree().isLocked()) 
            bldr.pageController.activeTitlebar.show(this);

        if (node.module.parent.shouldShowCover()) {
            bldr.pageController.moduleBar = moduleBar.create();
            bldr.pageController.moduleBar.glueTo(this.el);

            require('internal/sitebuilder/builderChrome/chromeController').toggleControls(false);
            bldr.pageController.showCover(this);
        }

        node.module.activate(opts.event);
        this.fit();
    };

    ModuleNodeController.prototype.deactivate = function ModuleNodeController_deactivate(opts) {
        opts = $.extend({
            save: true,
            transition: false
        }, opts || {});

        var node = this.model,
        transition = opts.transition;

        this.reload(opts.save);
        this.el.removeClass(CLASSES.BINACTIVE);

        // hide titlebar
        bldr.pageController.activeTitlebar.hide();

        node.module.deactivate(opts.event);

        // kills off (and dereference) modulebar
        if (bldr.pageController.moduleBar) {
            bldr.pageController.moduleBar.destroy();
            bldr.pageController.moduleBar = null;
        }

        this.saveModule();

        bldr.pageController.hideCover();

        if (!transition) {
            require('internal/sitebuilder/builderChrome/chromeController').toggleControls(true);
            require('internal/sitebuilder/builderChrome/toolbar').switchToolbar();
        }


        this.fit();
    };

    NodeController.prototype.rightClick = function NodeController_rightClick(e) {};

    ModuleNodeController.prototype.rightClick = function NodeController_rightClick(e) {
        var self = this;
        // Timeout so that this runs after all other mousedown handlers, so module activation can happen first.
        setTimeout(function() {
            self.model.module.rightClick(e);
        }, 1);
    };

    NodeController.prototype.mouseEnter = function NodeController_mouseEnter(e) {
        if (!bldr.pageController.isMoving()) {
            // cascade up the tree (TODO: we could use event bubbling instead..)
            if (this.model.parentNode) 
                this.model.parentNode.controller.mouseEnter(e);
        }
    };

    PlaceholderNodeController.fn.mouseEnter = function PlaceholderNodeController_mouseEnter(e) {
        // Placeholders which are the last child don't have titlebars
        if (!bldr.pageController.isMoving()) {
            if (!this.model.isOnlyNode()) {
                if (!this.model.tree().isLocked()) 
                    bldr.pageController.hoverTitlebar.show(this);
                NodeController.fn.mouseEnter.call(this, e);
            } else {
                // Only placeholder node left in this tree, isManatory signifies if a tree is required
                // to be on the page (body, footer, header)
                if (this.model.tree().isRemovable()) {
                    bldr.pageController.hoverTitlebar.bindPageLayout(this);
                }
            }
        }
    };
    FreebarController.fn.mouseEnter = function FreebarController_mouseEnter(e) {
        // Placeholders don't have move/delete, but freebar does, so act like a module
        ModuleNodeController.fn.mouseEnter.call(this, e);
    };
    ModuleNodeController.fn.mouseEnter = function ModuleNodeController_mouseEnter(e) {
        if (!bldr.pageController.isMoving()) {
            if (!this.model.tree().isLocked()) {
                bldr.pageController.hoverTitlebar.show(this);
            } else {
                // locked module
                if (this.model && this.model.moduleType === "carousel") {
                    bldr.pageController.hoverTitlebar.bindPageLayout(this);
                    return;
                }
            }
            NodeController.fn.mouseEnter.call(this, e);
        }
    };

    RowController.fn.mouseEnter = function RowController_mouseEnter(e) {
        // Show all edges in this row
        var kids = this.model.children;
        for (var i = 0, len = kids.length; i < len; i++) {
            var col = kids[i];

            // FIXME: this is kinda bs, but it works
            // Ensure edges exist and in right place
            col.controller.ensureEdge();

            var edge = col.controller.el.data('edge');
            if (edge) 
                edge.addClass('active');
        }

        NodeController.fn.mouseEnter.call(this, e);
    };

    TreeController.prototype.mouseEnter = function TreeController_mouseEnter(e) {
        // Do nothing.
    };


    NodeController.prototype.mouseLeave = function NodeController_mouseLeave(e) {
        if (!bldr.pageController.isMoving()) {
            // cascade up the tree (TODO: we could use event bubbling instead..)
            bldr.pageController.hoverTitlebar.hide();
            if (this.model.parentNode) 
                this.model.parentNode.controller.mouseLeave(e);
        }
    };

    RowController.fn.mouseLeave = function RowController_mouseLeave(e) {
        if (this.el[0] != e.toElement && this.el.find(e.toElement).length === 0) {
            bldr.pageController.$('.' + CLASSES.EDGE).removeClass('active');
        }

        NodeController.fn.mouseLeave.call(this, e);
    };

    TreeController.prototype.mouseLeave = function TreeController_mouseLeave(e) {
        // Do nothing.
    };

    TreeController.prototype.fixHeight = function TreeController_fixHeight() {
        var margins;

        if (!this.model.isLocked() && !this.el.data('websConstrain')) {
            margins = this.el.outerHeight(true) - this.el.height();
            this.el.height(this.el.parent().height() - margins);
        }
    };

    TreeController.prototype.autoHeight = function TreeController_autoHeight() {
        if (!this.model.isLocked() && !this.el.data('websConstrain')) {
            this.el.height('auto');
        }
    };


    NodeController.prototype.saveModule = function NodeController_saveModule() {
        var model = this.model;
        if (!model || model.isPlaceholder() || !model.module) 
            return false;

        model.save();
    };
    /*

    	Exports
    	*/
    return {
        factory: factory,
        PlaceholderNodeController: PlaceholderNodeController,
        ModuleNodeController: ModuleNodeController,
        TreeController: TreeController
    };
});

/*

  SiteBuilder Nodes

  Nodes are the building blocks of pages. They represent the hierarchy of modules, containers, and
  groups of elements that should get rendered on the page.

  Node follows the aggregate pattern. Each node has a parentNode (unless it is detached from the page),
  and either its own contents or an array of children.

  There are four kinds of nodes:
    - plain nodes, which contain a module or some other simple content.
    - columns, which arrange their children nodes stacked on top of each other vertically
    - rows, which arrange their children nodes stacked next to each other horizontally
    - trees, which behave like columns, have rows for children, have no parentNode, and can be found by id.

  Each kind of node knows how to:
    - insert other nodes relative to itself
    - promote itself to another kind of node
    - save itself
	- handle and trigger events itself and delegate them up the tree

*/

define('internal/sitebuilder/builderChrome/nodes', [
'jquery',
'require',
'spine',
'internal/sitebuilder/common/log',
'persist',
'internal/sitebuilder/builderChrome/nodeControllers'
], function define_nodes($, require, Spine, log, persist) {
    // Constants
    var nodeControllerFactory = require('internal/sitebuilder/builderChrome/nodeControllers').factory;

    // Instantiate class hierarchy
    var Node = Spine.Class.create(),
    PlaceholderNode = Node.create({
        type: "placeholder"
    }),
    ModuleNode = Node.create({
        type: "module"
    }),
    SplitNode = Node.create(),
    RowNode = SplitNode.create({
        type: "row"
    }),
    ColumnNode = SplitNode.create({
        type: "column"
    }),
    Tree = ColumnNode.create({
        type: "tree"
    }),
    FreebarNode = PlaceholderNode.create({
        freebar: true
    });

    Node.extend(Spine.Events);
    Node.include(Spine.Events);

    /*

    	Initializing nodes
    	*/
    Node.include({
        init: function Node_init(data) {
            this.trigger("initializing");

            if (!this.controller && this.type != "tree")
                this.controller = nodeControllerFactory(this);
        },

        isPlaceholder: function Node_isPlaceholder() {
            return false;
        },

        isRemovable: function Node_isRemovable() {
            if (!this.module || !this.module.parent || !this.module.parent.isRemovable) {
                return true;
            }
            return this.module.parent.isRemovable();
        },

        isMovable: function Node_isMovable() {
            if (!this.module || !this.module.parent || !this.module.parent.isMovable) {
                return true;
            }
            return this.module.parent.isMovable();
        },

        toString: function Node_toString() {
            return this.type + " node" +
            ("id" in this ? (" (" + this.id + ")") : "") +
            ("moduleType" in this ? (" [" + this.moduleType + "]") : "");
        }
    });

    ModuleNode.fn.init = function ModuleNode_init(data) {
        if (typeof(data) == 'undefined' || typeof(data.moduleType) != 'string') 
            throw new Error("Cannot init ModuleNode without a moduleType");
        this.data = $.extend({}, data.data || data.content || {});
        this.id = data.moduleId || data.id;
        this.moduleType = data.moduleType;

        Node.prototype.init.call(this, data);
    };

    PlaceholderNode.include({
        init: function PlaceholderNode_init(data) {
            Node.prototype.init.call(this, data);
        },

        isPlaceholder: function PlaceholderNode_isPlaceholder() {
            return true;
        },

        isMovable: function PlaceholderNode_isMovable() {
            return false;
        }
    });

    SplitNode.include({
        init: function SplitNode_init(data) {
            Node.prototype.init.call(this, data);

            this.bind("childAdded", $.proxy(this, "childAdded"));
            this.bind("childRemoved", $.proxy(this, "childRemoved"));

            this.children = [];
            this.initing = true;
            this.addChildren(data.children, 0);
            this.initing = false;
        }
    });

    ColumnNode.fn.init = function ColumnNode_init(data) {
        this.width = data.width || 50;
        SplitNode.fn.init.call(this, data);
    };

    Tree.include({
        init: function Tree_init(data) {
            SplitNode.prototype.init.call(this, data);
        }
    });


    /*

    	Loading and saving nodes
    	*/
    Node.extend({
        load: function Node_load(data) {
            if (data.moduleType == "freebar") 
                return FreebarNode.load(data);
            if (data.moduleType) 
                return ModuleNode.load(data);
            if (data.type == "column") 
                return ColumnNode.load(data);
            if (data.type == "row") 
                return RowNode.load(data);
            if (data.type == "placeholder") 
                return PlaceholderNode.load(data);
            throw new Error("trying to load an unknown type of node");
        }
    });

    Node.include({
        backendDelete: function Node_backendDelete() {
            //log.error("UNSUPPORTED backendDelete on ", this);
        },
        forceSave: function Node_forceSave() {
            //log.error("UNSUPPORTED forceSave on ", this);
        }
    });

    SplitNode.include({
        backendDelete: function SplitNode_backendDelete() {
            $.each(this.children, function SplitNode_backendDelete_eachChild(i, child) {
                child.backendDelete();
            });
        },
        forceSave: function SplitNode_forceSave() {
            $.each(this.children, function SplitNode_forceSave_eachChild(i, child) {
                child.forceSave();
            });
        }
    });

    ModuleNode.include({
        backendDelete: function ModuleNode_backendDelete() {
            this.deleteFromTreeId = this.tree().id;
            this.module.dirty();
        },
        forceSave: function ModuleNode_forceSave() {
            delete this.deleteFromTreeId;
            this.module.dirty();
        }
    });

    PlaceholderNode.extend({
        load: function PlaceholderNode_load(data) {
            return this.init(data);
        }
    });

    ModuleNode.extend({
        load: function ModuleNode_load(data) {
            if (data.moduleType == 'freebar') 
                return FreebarNode.load(data);
            if (data.moduleType == 'placeholder') 
                return PlaceholderNode.load(data);
            var node = this.init({
                data: data.content || data.data,
                moduleId: data.moduleId,
                moduleType: data.moduleType 
            });

            return node;
        }
    });

    ColumnNode.extend({
        load: function ColumnNode_load(data) {
            data.children = data.children ? $.map(data.children, Node.load) : [];
            return this.init(data);
        }
    });

    RowNode.extend({
        load: function RowNode_load(data) {
            data.children = data.children ? $.map(data.children, Node.load) : [];
            return this.init(data);
        }
    });

    RowNode.loadWithColumns = function RowNode_loadWithColumns(n) {
        // handle all-integer percentage widths.
        var children = [],
        width = parseInt(100 / n, 10);
        for (var i = 0; i < n; i++)
            children.push(ColumnNode.init({
                width: width,
                children: []
            }));
        return this.init({
            children: children
        });
    };

    Tree.extend({
        load: function Tree_load(id, data) {
            var tree = ColumnNode.load.call(this, data);
            tree.id = id;
            Tree.instances[id] = tree;

            // We just loaded it! I assure you it's not dirty
            tree.dirty(false);

            if (tree.children[0].type != 'column') {
                // Trees may only contain columns!
                tree.children[0].wrapInColumn();
            }

            return tree;
        }
    });

    /*

    	Node hierarchy manipulation
    	*/

    SplitNode.include({
        addChild: function SplitNode_addChild(newNode, index, refNode) {
            if (refNode) 
                index += this.indexOfChild(refNode);
            if (index > this.children.length )
                throw new Error("trying to add child beyond length of children");

            newNode.remove();
            newNode.parentNode = this;
            this.children.splice(index, 0, newNode);
            this.childrenChanged();
            this.trigger("childAdded", newNode, index);
            newNode.trigger("inserted");
            return this.children;
        },
        // helper method, only triggers child changed once
        addChildren: function SplitNode_addChildren(newNodes, index, refNode) {
            if (index < 0 || index > this.children.length)
                throw new Error("trying to add child outside array bounds");

            /*
            				* Sometimes this method is called with newNodes being something.children
            				* Since we're going to modify something.children later on, we need to copy the array
            				*/
            newNodes = $.merge([], newNodes);

            if (refNode) 
                index += this.indexOfChild(refNode);
            var self = this;
            $.each(newNodes, function SplitNode_addChildren_removeNewNodes(i, node) {
                node.remove();
                node.parentNode = self;
            });

            this.children.splice.apply(this.children, [index, 0].concat(newNodes));
            this.childrenChanged();

            this.trigger("childAdded", newNodes, index);
            $.each(newNodes, function SplitNode_addChildren_triggerInsertedNodes(i, node) {
                node.trigger("inserted");
            });
            return this.children;
        },
        removeChild: function SplitNode_removeChild(child) {
            var index = this.indexOfChild(child);
            this.children.splice(index, 1);
            this.trigger("childRemoved", child, index);
            child.trigger("removed");
            this.childrenChanged();
            delete child.parentNode;
            delete child.width;
        },
        indexOfChild: function SplitNode_indexOfChild(child) {
            for (var i = 0, l = this.children.length; i < l; i++) {
                if (this.children[i] == child) 
                    return i;
            }
            throw new Error("trying to find indexOfChild for node that isn't a child");
        }
    });

    Node.include({
        index: function Node_index() {
            if (this.parentNode) {
                return this.parentNode.indexOfChild(this);
            } else {
                return - 1;
            }
        },
        lastSibling: function Node_lastSibling() {
            return this.index() == this.parentNode.children.length - 1;
        },
        next: function Node_next() {
            var index = this.index();
            if (index == this.parentNode.children.length - 1) 
                return null;
            return this.parentNode.children[index + 1];
        },
        prev: function Node_prev() {
            var index = this.index();
            if (index === 0) 
                return null;
            return this.parentNode.children[index - 1];
        }
    });

    Node.prototype.remove = function Node_remove() {
        if (!this.parentNode) 
            return;
        this.parentNode.removeChild(this);
    };

    Node.prototype.isLastChild = function Node_isLastChild() {
        if (!this.parentNode) 
            return false;
        return (this.index() == this.parentNode.children.length - 1);
    };

    PlaceholderNode.prototype.remove = function PlaceholderNode_remove() {
        var parent = this.parentNode;
        if (!parent) 
            return false;
        if (parent.children.length > 1) {
            Node.prototype.remove.call(this);
        } else {
            if (this.isOnlyNode()) 
                return false; // Can't delete the only placeholder
            // Remove the parent column
            parent.remove();
        }
    };

    FreebarNode.prototype.remove = function FreebarNode_remove() {
        if (!this.parentNode) 
            return false; // WTF. Why does this happen when building the tree?
        Node.prototype.remove.call(this);
    };

    Node.prototype.moveTo = function Node_moveTo(refNode, side) {
        this.remove(false);
        refNode.insert(this, side);
    };

    ModuleNode.prototype.moveTo = function ModuleNode_moveTo(refNode, side) {
        Node.prototype.moveTo.call(this, refNode, side);
        if (this.module) {
            this.module.dirty();
            this.save();
        }
    };



    // Inserting

    Tree.prototype.insert = function Tree_insert(node, side) {
        var col = node.wrapInColumn(),
        index = side == "top" ? 0 : this.children.length;
        this.addChild(col, index);
    };

    PlaceholderNode.prototype.insert = function PlaceholderNode_insert(newNode) {
        this.parentNode.addChild(newNode, 1);
    };

    Node.prototype.insert = function Node_insert(newNode, side) {
        var direction = (side == "left" || side == "right") ? "horizontal" : "vertical",
        delta = (side == "left" || side == "top") ? 0 : 1,
        dispatch = this.type + " " + newNode.type + " " + direction;
        dispatch = dispatch.replace(/placeholder/g, "module");
        Node.insertMethods[dispatch].call(undefined, this, newNode, delta);
    };

    // Multiple dispatch to be explicit about all cases
    Node.insertMethods = {
        // refNode, newNode, axis		     refNode, newNode, direction on axis
        "module module horizontal": function Node_insertMethods_ModuleModuleHorizontal(refNode, newNode, delta) {
            refNode.wrappingRow().addChild(newNode.wrapInColumn(), delta, refNode.parentNode);
        },
        "module module vertical": function Node_insertMethods_ModuleModuleVertical(refNode, newNode, delta) {
            refNode.parentNode.addChild(newNode, delta, refNode);
        },

        "column module horizontal": function Node_insertMethods_ColumnModuleHorizontal(refNode, newNode, delta) {
            refNode.wrappingRow().addChild(newNode.wrapInColumn(), delta, refNode);
        },
        "column module vertical": function Node_insertMethods_ColumnModuleVertical(refNode, newNode, delta) {
            var parent = refNode.parentNode;
            if (parent.type == "tree")
                parent.addChild(newNode.wrapInColumn(), delta, refNode);
            else
                refNode.addChild(newNode, (delta === 0) ? 0 : refNode.children.length);
        },

        "row module horizontal": function Node_insertMethods_RowModuleHorizontal(refNode, newNode, delta) {
            refNode.addChild(newNode.wrapInColumn(), (delta === 0) ? 0 : refNode.children.length);
        },
        "row module vertical": function Node_insertMethods_RowModuleVertical(refNode, newNode, delta) {
            refNode.wrappingColumn().addChild(newNode, delta, refNode);
        },

        // inserting a column
        "module column horizontal": function Node_insertMethods_ModuleColumnHorizontal(refNode, newNode, delta) {
            refNode.wrapInRow().addChild(newNode, delta);
        },
        "module column vertical": function Node_insertMethods_ModuleColumnVertical(refNode, newNode, delta) {
            refNode.parentNode.addChildren(newNode.children, delta, refNode);
        },

        "column column horizontal": function Node_insertMethods_ColumnColumnHorizontal(refNode, newNode, delta) {
            refNode.wrappingRow().addChild(newNode, delta, refNode);
        },
        "column column vertical": function Node_insertMethods_ColumnColumnVertical(refNode, newNode, delta) {
            var parent = refNode.parentNode;
            if (parent.type == "tree")
                parent.addChild(newNode, delta, refNode);
            else
                refNode.addChildren(newNode.children, (delta === 0) ? 0 : refNode.children.length);
        },

        "row column horizontal": function Node_insertMethods_RowColumnHorizontal(refNode, newNode, delta) {
            refNode.addChild(newNode.wrapInColumn(), (delta === 0) ? 0 : refNode.children.length);
        },
        "row column vertical": function Node_insertMethods_RowColumnVertical(refNode, newNode, delta) {
            refNode.parentNode.addChildren(newNode.children, delta, refNode);
        },

        // inserting a row
        "module row horizontal": function Node_insertMethods_ModuleRowHorizontal(refNode, newNode, delta) {
            refNode = refNode.wrapInRow();
            var child;
            /* jshint ignore:start */
            while (child = newNode.children[0])
                refNode.addChild(child, delta++);
            /* jshint ignore:end */
        },
        "module row vertical": function Node_insertMethods_ModuleRowVertical(refNode, newNode, delta) {
            refNode.parentNode.addChild(newNode, delta, refNode);
        },

        "column row horizontal": function Node_insertMethods_ColumnRowHorizontal(refNode, newNode, delta) {
            var wrappingRow = refNode.wrappingRow(), child;
            /* jshint ignore:start */
            while (child = newNode.children[0])
                wrappingRow.addChild(child, delta++, refNode);
            /* jshint ignore:end */
        },
        "column row vertical": function Node_insertMethods_ColumnRowVertical(refNode, newNode, delta) {
            var parent = refNode.parentNode;
            if (parent.type == "tree")
                parent.addChild(newNode.wrapInColumn(), delta, refNode);
            else
                refNode.addChild(newNode, (delta === 0) ? 0 : refNode.children.length);
        },

        "row row horizontal": function Node_insertMethods_RowRowHorizontal(refNode, newNode, delta) {
            // Add the newNode's children to the beginning or end of ref row
            if (delta == 1) 
                delta = refNode.children.length;
            var child;
            /* jshint ignore:start */
            while (child = newNode.children[0])
                refNode.addChild(child, delta++);
            /* jshint ignore:end */
        },
        "row row vertical": function Node_insertMethods_RowRowVertical(refNode, newNode, delta) {
            refNode.parentNode.addChild(newNode, delta, refNode);
        }
    };

    /* An array of arguments to send to insert to move the node to where it is */
    Node.prototype.insertMethod = function Node_insertMethod() {
        if (!this.parentNode) 
            throw new Error("Can't insert node without parent");

        var parent = this.parentNode,
        siblings = parent.children,
        index = this.index(),
        atEnd = siblings.length == index + 1,
        alone = siblings.length == 1,
        refNode = alone ? parent : (atEnd ? siblings[index - 1] : siblings[index + 1]),
        side = parent.type == "row" ? (atEnd ? "right" : "left") : (atEnd ? "bottom" : "top");
        if (!refNode || !side) 
            throw new Error("finding insert method failed to return a node or side");
        return [refNode, side];
    };

    PlaceholderNode.prototype.insertMethod = function PlaceholderNode_insertMethod() {
        return false;
    };
    Tree.prototype.insertMethod = function Tree_insertMethod() {
        return [this, "top"];
    };



    /*
    	Width
    	*/


    SplitNode.fn.childRemoved = function SplitNode_childRemoved() {};

    // If a column in a row, give our width to the neighboring column
    RowNode.fn.childRemoved = function RowNode_childRemoved(child, index) {
        if (child.width) {
            var i = Math.max(index - 1, 0),
            node = this.children[i];
            if (!node) 
                return;
            node.width += child.width;
            node.trigger("widthChanged");
        }
    };

    SplitNode.fn.childAdded = function SplitNode_childAdded() {};

    /* When a child is added, redistribute the whole width among all of them */
    RowNode.fn.childAdded = function RowNode_childAdded(node, index) {
        // Don't change widths if we are loading children for the first time
        if (node.length == this.children.length) 
            return false;

        var kids = this.children,
        count = kids.length,
        total = 100,
        each = parseInt(total / count, 10),
        last = 100 - (each * (count - 1));

        $.each(kids, function RowNode_childAdded_eachKids(i, node) {
            var width = (i == count - 1) ? last : each;
            node.width = width;
            node.trigger("widthChanged");
        });
    };

    /*
    	Persistence
    	*/
    ModuleNode.fn.setId = function ModuleNode_setId(newId) {
        if (this.id && this.id != newId) {
            log.warn("Trying to set the ID of a module node that already has an ID!", this.id, newId);
            return false;
        }
        if (this.id == newId) {
            log.debug("Trying to set the ID of a module node to the same ID", this.id, newId);
            return false;
        }

        this.id = newId;

        // NB: module might have been deleted.
        var tree = this.tree();
        if (tree) 
            tree.dirty();

        return this;
    };

    // Save the module data
    ModuleNode.prototype.save = function ModuleNode_save(opts) {
        // TODO: Be smart about when to save active node (only when dirty)
        // Idea: To track dirtiness, keep a copy of the active node's data and compare it every time we try to save
        var module = this.module;

        if (!this.id) {
            if (this.willBeSaved) 
                return false;
            this.willBeSaved = true;
            module.dirty();
        }

        if (module.isDirty()
            ) {
            this.data = module.data = module.getData();
            require('persist').push(this);
            log.trigger("Modules", "info", 'saving active module', this.data);
        }
        module.dirty(false);
    };

    // Get data for saving the tree
    SplitNode.prototype.toJSON = function SplitNode_toJSON() {
        var json = {
            type: this.type,
            children: []
        };
        $.map(this.children, function SplitNode_toJSON_mapKids(n) {
            var kidJson = n.toJSON();
            if (kidJson) 
                json.children.push(kidJson);
        });
        return json;
    };

    ColumnNode.fn.toJSON = function ColumnNode_toJSON() {
        var json = SplitNode.fn.toJSON.call(this);
        json.width = this.width;
        return json;
    };

    ModuleNode.fn.toJSON = function ModuleNode_toJSON() {
        return {
            type: "module",
            moduleId: this.id,
            moduleType: this.moduleType 
        };
    };

    Node.fn.toJSON = function Node_toJSON() {
        return;
    };

    Tree.fn.toJSON = function Tree_toJSON() {
        var json = SplitNode.fn.toJSON.call(this);
        json.id = this.id;
        return json;
    };

    /**
    		* When serializing a Tree, we don't include all the module data
    		* However, this method will serialize the module alone, with all of it's data
    		*/
    ModuleNode.fn.toModuleJSON = function ModuleNode_toModuleJSON() {
        return {
            id: this.id,
            moduleType: this.moduleType,
            content: this.data 
        };
    };

    /*

    	Global tree API
    	*/
    // Track extant trees
    Tree.extend({
        instances: {},
        all: function Tree_all() {
            var ret = [];
            for (var id in this.instances) {
                if (this.instances.hasOwnProperty(id)) 
                    ret.push(this.instances[id]);
            }
            return ret;
        },
        each: function Tree_each(callback) {
            for (var id in this.instances) {
                if (this.instances.hasOwnProperty(id)) 
                    callback(this.instances[id]);
            }
            return this;
        }
    });

    Tree.extend({
        get: function Tree_get(id) {
            if (id in this.instances) 
                return this.instances[id];
            throw new Error("Attempting to find tree with unknown id");
        }
    });

    // Track saved/dirty status
    // Classy syntax to move to Spine:
    //Tree.defaultHandler("initializing", function(){
    //	this._dirty = false;
    //});
    Tree.include({
        dirty: function Tree_dirty(val) {
            if (typeof(val) == 'undefined') 
                val = true;
            if (val) 
                require("persist").push(this);
            this._dirty = !!val;
        },
        isDirty: function Tree_isDirty(val) {
            return this._dirty;
        }
    });

    Tree.include({
        _removable: null,
        isRemovable: function Tree_isRemovable() {
            var _role;
            if (this._removable === null) {
                _role = this.controller.el.data("role");
                this._removable = _role.match(/webs-header|webs-subheader|webs-body|webs-footer/) ? false : true;
            }
            return this._removable;
        },
        hasSinglePlaceholder: function Tree_hasSinglePlaceholder() {
            return this.children.length === 1 && this.children[0].children &&
            this.children[0].children.length === 1 && this.children[0].children[0].isPlaceholder();
        },
        hasSingleFreebar: function Tree_hasSingleFreebar () {
            return this.children.length === 1 && this.children[0].children.length === 1 &&
            this.children[0].children[0].freebar;
        }
    });

    Tree.fn.acceptsDrop = function Tree_acceptsDrop() {
        return !this.isLocked();
    };

    Tree.fn.isLocked = function Tree_isLocked() {
        if (this.controller.el.data("role") == "webs-footer" && webs.site.editableFooter === false) {
            return true;
        } else {
            return this._isLocked;
        }
    };

    /*

    	Show and hide placeholders
    	*/

    ColumnNode.fn.childrenChanged = function ColumnNode_childrenChanged() {
        var l = this.children.length;
        if (l === 0) {
            this.addChild(PlaceholderNode.init());
        } else if (l > 1) {
            for (var i = 0; i < l; i++) {
                var kid = this.children[i];
                if (kid.isPlaceholder()) {
                    if (!kid.freebar) {
                        kid.remove();
                        i--;
                        l--;
                    } else if (webs.site.editableFooter && kid.freebar) {
                        kid.controller.remove();
                        i--;
                        l--;
                        this.freebarRemoved = true;
                    }
                }
            }
        }
        SplitNode.fn.childrenChanged.call(this);

        // FIXME: unsplits, removing unused rows, etc.
    };

    RowNode.fn.childrenChanged = function RowNode_childrenChanged() {
        if (!this.parentNode) 
            return;
        var l = this.children.length;
        if (l == 1) {
            // Insert the child beneath this row, then delete the row.

            var child = this.children[0],
            parent = this.parentNode;

            this.insert(child, 'bottom');
            this.children = [];
            this.remove();
        }

        SplitNode.fn.childrenChanged.call(this);
    };

    Tree.fn.childrenChanged = function Tree_childrenChanged() {
        var l = this.children.length;
        if (l === 0) {
            this.addChild(PlaceholderNode.init().wrapInColumn());
        } else if (l > 1) {
            for (var i = 0; i < l; i++) {
                var kid = this.children[i],
                grandchild = kid && kid.children[0];
                if (grandchild && grandchild.isPlaceholder()) {
                    kid.remove();
                    i--;
                    l--;
                }
            }
        }

        SplitNode.fn.childrenChanged.call(this);
    };

    SplitNode.fn.childrenChanged = function SplitNode_childrenChanged() {
        this.trigger("childrenChanged");
        if (!this.initing) {
            var tree = this.tree();
            if (tree) 
                tree.dirty(true);
        }
    };



    /* Splits and unsplits */


    /* Utilities */

    // Walk through tree breadth-first
    Node.include({
        visit: function Node_visit(f) {
            f(this);
        }
    });

    SplitNode.include({
        visit: function SplitNode_visit(f) {
            f(this);
            for (var i = 0, l = this.children.length; i < l; i++)
                this.children[i].visit(f);
        }
    });

    // Get depth of node from its root tree
    Node.include({
        depth: function Node_depth() {
            var node = this, n = 0;
            while (node.parentNode) {
                n++;
                node = node.parentNode;
            }
            return (node.parent == Tree) ? n : undefined;
        },
        tree: function Node_tree() {
            var node = this;
            while (node.parentNode)
                node = node.parentNode;
            return (node.parent == Tree) ? node : undefined;
        },

        // node is the only remain node in the tree
        isOnlyNode: function Node_isOnlyNode() {
            return (
            this.parentNode.children.length === 1 && // node is an only child
            this.parentNode.parentNode.type == 'tree' && // node's grandparent is the root
            this.tree().children.length === 1 // root only has one child, thus node's parent (column) is the only child of root
            );
        },

        // node is the only remain node and not a placeholder. This is used before a move/remove to determine if we should replace it with a placeholder
        isOnlyNonPlaceholder: function Node_isOnlyNonPlaceholder() {
            return this.isPlaceholder() && (this.isOnlyNode() || (this.parentNode.parentNode.type === 'row' && this.parentNode.children.length === 1));
        }
    });

    /*
    	Type conversions
    	*/
    // Wrap in column
    Node.prototype.wrapInColumn = function Node_wrapInColumn() {
        var parent = this.parentNode,
        index = this.index(),
        col = ColumnNode.init({
            children: [this]
        });
        if (parent) {
            parent.addChild(col, index);
        }
        return col;
    };
    ColumnNode.prototype.wrapInColumn = function ColumnNode_wrapInColumn() {
        return this;
    };

    // Wrap in row
    Node.prototype.wrapInRow = function Node_wrapInRow() {
        var parent = this.parentNode,
        index = this.index(),
        column = this.wrapInColumn(),
        row = RowNode.init({
            children: [column]
        });
        if (parent) {
            parent.addChild(row, index);
        }
        return row;
    };
    ColumnNode.prototype.wrapInRow = function ColumnNode_wrapInRow() {
        var parent = this.parentNode;
        if (parent && parent.tree() != parent) 
            return Node.fn.wrapInRow.call(this);

        // wrap in new top-level column, but return row
        var index = this.index(),
        row = RowNode.init({
            children: [this]
        }),
        topCol = ColumnNode.init({
            children: [row]
        });

        parent.addChild(topCol, index);
        return row;
    };
    RowNode.prototype.wrapInRow = function RowNode_wrapInRow() {
        return this.wrapInColumn().wrapInRow();
    };

    // Return existing parent row or new row wrapping this
    // Keep in mind, this will only use an existing row if this node is an only-child
    Node.prototype.wrappingRow = function Node_wrappingRow() {
        var parent = this.parentNode,
        grandparent = parent && parent.parentNode;
        if (parent && parent.type == "row" && this.type == "column" && this.children.length == 1) 
            return parent;
        if (grandparent && grandparent.type == "row" && parent.children.length == 1) 
            return grandparent;
        else 
            return this.wrapInRow();
    };

    Node.prototype.wrappingColumn = function Node_wrappingColumn() {
        if (this.parentNode.type == "column") 
            return this.parentNode;
        else 
            return this.wrapInColumn();
    };


    /*
    	Exports
    	*/
    return {
        Node: Node,
        RowNode: RowNode,
        ModuleNode: ModuleNode,
        Tree: Tree
    };
});

define('internal/sitebuilder/builderChrome/dragController', [
'jquery',
'require',
'spine',
'internal/sitebuilder/common/log',
'internal/sitebuilder/builderChrome/nodes',
'internal/sitebuilder/common/eventBuffer',
'internal/sitebuilder/builderChrome/chromeController'
], function($, require, Spine, log, nodes, eventBuffer) {
    var DragController = Spine.Controller.create({
        events: {
            'mousemove': 'mousemove',
            'mouseup': 'mouseup',
            'DOMMouseScroll': 'mousewheel',
            'mousewheel': 'mousewheel'
        },

        init: function() {
            this.leafDown = false; // Flag which indicates if a leaf (draggable tab) is moused down
            this.insideFrame = false; // whether or not we're currently inside the frame
            this.nodeInfo = null; // contains node references in current viewport along with width, height, and every edge with respect to top window
            this.scrollTimer = false; // Page scrolling flag
            this.dragTarget = null; // Reference to item we dragged on the dock (so we can animate back to it, etc.)
            this.scrollAreaHeight = 50; // Number of pixels from the top and bottom of iframe where autoscroll can occur;

            this.ghost = {
                x: 0,
                y: 0,
                // Position of mouse within the element
                tx: 0,
                ty: 0,
                // Absolute position of el when you mousedown. This is to animate the toast back.
                tParent: null,
                // so we know where to append el back to later
                hasTarget: false,
                // flag indicating if ghost is over a drop target
                el: $('<div/>').addClass('bldr-ghost').appendTo(document.body)
            };

            // Flag which allows scroll checking (when mouse near top/bottom of iframe) to happen.
            // Gets set to false on pageenter and true when user is out of scrollAreaHeight range.
            // Prevents automatic scrolling since toasts are within scrollAreaHeight range.
            var firstTimePageEnter;
            this.checkScrollArea = false;
            this.bind('pageenter', function() {
                if (firstTimePageEnter) {
                    this.checkScrollArea = false;
                    firstTimePageEnter = false;
                }
            });
            this.bind('pageleave', function() {
                this.clearScrollTimer();
            });
            this.bind('dragstart', function() {
                firstTimePageEnter = true;
            });
        },

        getChromeController: function() {
            if (!this.chromeController) 
                this.chromeController = require('internal/sitebuilder/builderChrome/chromeController');
            return this.chromeController;
        },

        showGhost: function(e, target) {
            var targetOffset = target.offset(),
            targetLeft = targetOffset.left,
            targetTop = targetOffset.top;

            this.ghost.x = e.clientX - targetLeft;
            this.ghost.y = e.clientY - targetTop;
            this.ghost.tx = targetLeft;
            this.ghost.ty = targetTop;
            this.ghost.tParent = target.parent();
            this.ghost.hasTarget = false;

            this.ghost.el.css({
                'left': targetLeft + 'px',
                'top': targetTop + 'px'
            }).show();
            this.ghost.el.append(target);
        },

        hideGhost: function() {
            this.ghost.el.hide();
            this.getChromeController().dom.cover.hide();
        },

        clearScrollTimer: function() {
            if (typeof this.scrollTimer !== 'undefined') {
                clearInterval(this.scrollTimer);
                this.scrollTimer = undefined;
            }
        },

        scrollPage: function(vel) {
            var newScrollPosition,
            $iframeWin = bldr.pageController.dom.$win,
            scrollHeight = $iframeWin.scrollTop(),
            velMax = 2500, // this.scrollAreaHeight^2

            // capping velocity
            velAbs = Math.abs(vel);
            if (velAbs > velMax) 
                vel = velMax * vel / velAbs;

            // Exponential instead of linear scale
            vel = Math.pow(vel, 3) / velMax;


            newScrollPosition = scrollHeight + vel;
            if (newScrollPosition < 0) 
                newScrollPosition = 0;
            $iframeWin.scrollTop(newScrollPosition);
        },

        getAllTrees: function() {
            if (!nodes) 
                nodes = require('internal/sitebuilder/builderChrome/nodes');
            return nodes.Tree.all();
        },

        /** @private
        		 *  Is the current mouse within content area?
        		 */
        getTreeFromPoint: function(x, y) {
            var trees = this.getAllTrees();
            for (var i in trees) {
                var tree = trees[i];
                var container = tree.controller && tree.controller.el;

                if (!container) 
                    continue;

                // TODO: Move collision detection logic to TreeController
                var
                containerOffset = container.offset(),
                containerTop = this.getChromeController().iframeAbsY(containerOffset.top + parseInt(container.css('padding-top'), 10)),
                containerBottom = containerTop + container.height(),
                containerLeft = containerOffset.left + parseInt(container.css('padding-left'), 10),
                containerRight = containerLeft + container.width();

                if (containerTop - 20 < y && y < containerBottom && containerLeft < x && x < containerRight) 
                    return tree;
            }

            return null;
        },

        emptyNodeInfo: function() {
            this.nodeInfo = {}; // refresh nodeInfo each drag operation.
        },

        /**
        		 *	Grabs DOM position, offset, and dimension from given tree without any conditions
        		 *	such as the existence of nodeInfo. Should only be called from getViewportNodeInfo()
        		 */
        getTreeNodeInfo: function(tree) {
            var self = this,
            nodeInfo = this.nodeInfo[tree.id];
            if (!nodeInfo) {
                this.nodeInfo[tree.id] = nodeInfo = [];
                tree.visit(function(node) {
                    if (!node.controller) 
                        return false;
                    if (!node.parentNode) 
                        return false;

                    var width = node.controller.el.width(),
                    height = node.controller.el.height(),
                    offset = node.controller.el.offset(),
                    left = offset.left,
                    right = left + width,
                    top = offset.top + self.getChromeController().pageBoundary.top,
                    bottom = top + height,
                    last = node.lastSibling();

                    nodeInfo.push({
                        node: node,
                        width: width,
                        height: height,
                        left: left,
                        right: right,
                        top: top,
                        bottom: bottom,
                        last: last
                    });
                    return true;
                });
            }
            return nodeInfo;
        },

        /** @public
        		 *  Grabs all the nodes and computes top, left, bottom, right edges
        		 *  This is cached in the nodeInfo variable.
        		 *
        		 *  TODO: Only grab nodes currently in viewport
        		 */
        getViewportNodeInfo: function(tree) {
            if (!this.nodeInfo) 
                this.nodeInfo = {};

            // Grab all nodes in specified tree
            return this.getTreeNodeInfo(tree);
        },

        /**
        		 * @param nodeInfo			object with reference to node, dimension, and position
        		 * @param filter			string, either zero, parent, row, column, or bin
        		 * @return nodeInfo
        		 */
        filterNodeInfo: function(nodeInfo, filter) {
            var newNodeInfo = [],
            activeTree;
            for (var i = 0; i < nodeInfo.length; i++) {
                var node = nodeInfo[i].node,
                accept = false;

                // Our nodeInfo may span multiple trees. Grab the tree everytime to be safe  //-if(typeof activeTree === 'undefined')
                activeTree = node.tree();

                if (filter === 'zero' && node.parentNode == activeTree) {
                    accept = true;
                } else if (node.children) {
                    if (filter === 'parent' || filter === node.type) {
                        accept = true;
                    }
                } else {
                    if (filter === 'bin') 
                        accept = true;
                }

                if (accept) 
                    newNodeInfo.push(nodeInfo[i]);
            }

            return newNodeInfo;
        },

        /** @private
        		 *  determine if the given x,y coordinate falls in a drop target.
        		 */
        findDropTarget: function(x, y) {
            var i,
            activeTree = this.getTreeFromPoint(x, y);

            // makes sure cursor is over a tree
            if (!activeTree || !activeTree.acceptsDrop()) 
                return bldr.pageController.hideDropLocation();

            y += bldr.pageController.dom.$win.scrollTop();

            var nodeInfo = this.getViewportNodeInfo(activeTree);

            /*			// checking if cursor is between 0th level parent
            			var zerothNodeInfo = this.filterNodeInfo(nodeInfo, 'zero');
            			for(i=0; i<zerothNodeInfo.length; i++){
            				var zerothNode = zerothNodeInfo[i].node,
            					zerothLevelMargin = 20,
            					tree = zerothNode.tree(),
            					firstTopLevel = tree && (zerothNode == tree.children[0]);

            				// currently moving, don't show for active bin
            				// TODO: make sure it also doesn't show up for sibbling's respective side
            				if(bldr.pageController.isMoving() && zerothNodeInfo[i].node == bldr.pageController.movingNode) continue;

            				if(zerothNodeInfo[i].bottom < y && y < zerothNodeInfo[i].bottom + zerothLevelMargin) {
            					bldr.pageController.showDropLocation({ $el: zerothNode.controller.el, side: 'bottom', zeroth: true });
            					return true;
            				} else if( firstTopLevel &&  zerothNodeInfo[i].top - zerothLevelMargin < y && y < zerothNodeInfo[i].top) {
            					bldr.pageController.showDropLocation({ $el: zerothNode.controller.el, side: 'top', zeroth: true});
            					return true;
            				}
            			}
            */

            // checking if cursor is between two rows
            var rowNodeInfo = this.filterNodeInfo(nodeInfo, 'row'),
            rowInfo, rowNode;
            for (i = 0; i < rowNodeInfo.length; i++) {
                rowInfo = rowNodeInfo[i];
                rowNode = rowInfo.node;
                if (rowInfo.left < x && x < rowInfo.right) {

                    // is cursor above a row?
                    if (Math.abs(rowInfo.top - y) < 20) {
                        bldr.pageController.showDropLocation({
                            $el: rowNode.controller.el,
                            node: rowNode,
                            side: "top",
                            zeroth: true
                        });
                        return true;

                        // or below the last row?
                    } else if (rowInfo.last) {
                        var dist = Math.abs(rowInfo.bottom - y);
                        if (dist > 10 && dist < 30) {
                            bldr.pageController.showDropLocation({
                                $el: rowNode.controller.el,
                                node: rowNode,
                                side: "bottom",
                                zeroth: true
                            });
                            return true;
                        }
                    }
                }
            }

            // checking if cursor is within a bin edge.
            // Will escape this method (findDropTarget) if mouse is at least on a bin & not within edge
            var binNodeInfo = this.filterNodeInfo(nodeInfo, 'bin');
            for (i = 0; i < binNodeInfo.length; i++) {
                var edgeMatch = this.checkDropTargetBinEdge(x, y, binNodeInfo[i]); // performs the checking

                if (edgeMatch) {
                    // if user is hovered over an edge, place a marker on that edge
                    if (typeof edgeMatch.side === "string") {

                        // currently moving, don't show for active bin
                        if (bldr.pageController.isMoving() && edgeMatch.$el.data('node') == bldr.pageController.movingNode) 
                            return false;

                        if (edgeMatch.side === 'replace') {
                            bldr.pageController.showDropPlaceholder(edgeMatch.$el);
                        } else {
                            if (edgeMatch.zeroth) 
                                edgeMatch.$el = edgeMatch.$el.parent();
                            bldr.pageController.showDropLocation({
                                $el: edgeMatch.$el,
                                node: edgeMatch.node,
                                side: edgeMatch.side,
                                zeroth: edgeMatch.zeroth
                            });
                        }
                    }
                    return true;
                }
            }


            // checking if cursor is inside drop box location (blank space after row parent's last child)
            // By this point, we've already filtered out non-content area and all bins, the only container the mouse could be on now are column blanks
            var blankBinRef = null;
            for (i = 0; i < rowNodeInfo.length; i++) {
                rowInfo = rowNodeInfo[i];
                rowNode = rowInfo.node;

                if (rowInfo.left < x && x < rowInfo.right && rowInfo.top < y && y < rowInfo.bottom) {

                    var columns = rowNode.children;
                    for (var j = 0; j < columns.length; j++) {
                        var node = columns[j],
                        columnChild = node.controller.el,
                        columnChildOffset = columnChild.offset(),
                        columnChildLeft = columnChildOffset.left,
                        columnChildRight = columnChildLeft + columnChild.width();

                        if (columnChildLeft < x && x < columnChildRight) {

                            // left and right edges for empty spaces
                            var farLeft = x < columnChildLeft + 30,
                            farRight = x > columnChildRight - 30;

                            if (farLeft || farRight) {
                                bldr.pageController.showDropLocation({
                                    $el: node.controller.el,
                                    node: node,
                                    side: (farLeft ? 'left' : 'right')
                                });
                                return true;
                            }

                            blankBinRef = columnChild;
                            break;
                        }
                    }
                }
            }
            if (blankBinRef) {
                bldr.pageController.showDropBlock(blankBinRef.parent(), blankBinRef);
                return true;
            }

            // Finally, check if they're dropping in the bottom "dead space" of a tree
            var lastTopLevel = activeTree.children[activeTree.children.length - 1],
            lastChild = lastTopLevel.children[lastTopLevel.children.length - 1],
            bottomOfContent = this.getChromeController().pageBoundary.top + lastChild.controller.el.offset().top + lastChild.controller.el.height() + 1;
            if (y > bottomOfContent) {
                bldr.pageController.showDropBlock(lastTopLevel.controller.el, lastChild.controller.el);
                return true;
            }

            // no match
            return false;
        },

        /** @private
        		 *  Creates a virtual triangle drop target space inside a bin and checks if the mouse falls within that triangle
        		 *
        		 * @returns {String} Side (left or right) in which the mouse falls. Null if the mouse does not fall within the target space.
        		 */
        getTriangulatedSide: function(x, y, nodeInfo) {
            var width = nodeInfo.width,
            height = nodeInfo.height,
            vertexWidth = width / 4, // percentage of bin width at triangle vertex
            slope = (height / 2) / (vertexWidth); // slope is with respect to top left corner

            y = y - nodeInfo.top;
            x = x - nodeInfo.left;

            if (y < height / 2) {
                // in upper quadrant
                if (y > slope * x) {
                    return 'left';
                }
                if (y > - slope * x + 2 * height) {
                    return 'right';
                }
            } else {
                // in lower quadrant
                if (y < - slope * x + height) {
                    return 'left';
                }
                if (y < slope * x - height) {
                    return 'right';
                }
            }

            return null;
        },

        /**
        		 * @private
        		 * checks whether or not the user is within a bin (and subsequently an edge of a bin) -> valid location to add a new bin in
        		 * @return {obj} with bin, node, & side that matches this particular bin,  obj with side == null if it's on a bin but not on a side, or false if no match
        		 */
        checkDropTargetBinEdge: function(x, y, nodeInfo) {
            if (!(nodeInfo.left <= x && x < nodeInfo.right && nodeInfo.top <= y && y < nodeInfo.bottom)) 
                return null;

            // current bin is a placeholder
            if (nodeInfo.node.isPlaceholder()) {
                return {
                    side: 'replace',
                    node: nodeInfo.node,
                    $el: nodeInfo.node.controller.el 
                };
            }

            var node = nodeInfo.node,
            parentNode = node.parentNode,
            $el = node.controller.el,
            activeTree = node.tree(),
            topLevelParent = parentNode == activeTree,
            // can't put on top or bottom of a toplevel parent unless it's a row.
            checkTopAndBottom = !topLevelParent || parentNode.type === 'row',
            zeroth = false,
            returnObj = null,
            // check if mouse falls within LEFT or RIGHT area of specified bin
            side = this.getTriangulatedSide(x, y, nodeInfo);


            // if mouse is too far to an edge, make the full vertcal span of that respective top level
            if (side && node.parentNode.parentNode != activeTree) {
                var delta = side === 'left' ? x - nodeInfo.left : nodeInfo.right - x;

                if (delta < 10 && node.parentNode != activeTree &&
                ((side === 'left' && !node.parentNode.prev()) || (side === 'right' && !node.parentNode.next()) )) {
                    while (node.parentNode && node.parentNode != activeTree) 
                        node = node.parentNode;
                    $el = node.controller.el;
                }
            }

            if (!side) {
                if (y < nodeInfo.top + nodeInfo.height / 2) 
                    side = 'top'; // if current mouse falls within TOP area of specified bin
                else 
                    side = 'bottom'; // if current mouse falls within BOTTOM area of specified bin

                // falls within top or bottom of top level. Uncomment to disallow "inside singular top level" feedback
                // if(!checkTopAndBottom) zeroth = true;
            }

            if (side) 
                returnObj = {
                    side: side,
                    node: node,
                    $el: $el,
                    zeroth: zeroth 
                };

            return returnObj;
        },


        dragstart: function(e, target) {
            this.leafDown = true;
            this.showGhost(e, target);
            this.dragTarget = $(target);
            this.initialClientY = e.pageY || e.clientY; // Used to compare against first move's pageY
            this.getChromeController().showCover();

            this.trigger('dragstart');
        },

        mousemove: function(e) {
            try {
                if (this.leafDown || (window.bldr && bldr.pageController && bldr.pageController.isMoving())) {
                    if (this.leafDown) 
                        this.ghost.el.css({
                            'left': e.clientX - this.ghost.x + 'px',
                            'top': e.clientY - this.ghost.y + 'px'
                        });

                    // user is inside the content iframe
                    var chromeController = this.getChromeController(),
                    wasInsideFrame = this.insideFrame,
                    eventY = e.pageY || e.clientY;

                    // First time mousemove won't do anything unless direction is up
                    if (this.initialClientY) {
                        if (this.initialClientY > eventY) 
                            this.initialClientY = null;
                        return true;
                    }

                    this.insideFrame = this.getChromeController().isInsideFrame(e);


                    if (this.insideFrame) {
                        this.dragStarted = false;

                        if (!wasInsideFrame) 
                            this.trigger('pageenter');

                        var mouseX = e.clientX + chromeController.dom.win.scrollLeft(),
                        mouseY = e.clientY + chromeController.dom.win.scrollTop(),
                        scrollAreaBottom = chromeController.pageBoundary.bottom - this.scrollAreaHeight;

                        if (this.checkScrollArea) {
                            // autoscroll page when dragging near top or bottom
                            var scrollAreaTop = chromeController.pageBoundary.top + this.scrollAreaHeight,
                            scrollInterval = 10,
                            scrollVelocity;

                            bldr.pageController.dom.$body.stop(true, false);
                            this.clearScrollTimer();

                            var self = this;
                            if (mouseY < scrollAreaTop) {
                                scrollVelocity = (mouseY - chromeController.pageBoundary.top) - this.scrollAreaHeight;
                                this.scrollTimer = setInterval(function() {
                                    self.scrollPage(scrollVelocity);
                                }, scrollInterval);
                            } else if (scrollAreaBottom < mouseY && mouseY < chromeController.pageBoundary.bottom + 55) {
                                scrollVelocity = this.scrollAreaHeight + (mouseY - chromeController.pageBoundary.bottom);
                                this.scrollTimer = setInterval(function() {
                                    self.scrollPage(scrollVelocity);
                                }, scrollInterval);
                            } else {
                                this.ghost.hasTarget = this.findDropTarget(mouseX, mouseY);

                                bldr.pageController.$('html,body').stop();
                            }
                        } else {
                            if (mouseY < scrollAreaBottom) 
                                this.checkScrollArea = true;
                            this.findDropTarget(mouseX, mouseY);
                        }

                    } else if (wasInsideFrame) {
                        // Clear current dropTarget indication
                        this.findDropTarget( - 1000, - 1000);

                        this.trigger('pageleave');
                    }
                }
            } catch (err) {
                log.error('Error in mousemove!', err, err.stack);
            }
        },

        mouseup: function() {
            var self = this,
            $dt = self.dragTarget;

            if (!self.leafDown && bldr && bldr.pageController && !bldr.pageController.isMoving()) 
                return true;

            self.clearScrollTimer();
            if (!self.dragTarget) 
                return;

            this.emptyNodeInfo();

            this.trigger('dragend');

            if (!bldr.pageController.isMoving()) {
                var type = self.dragTarget.data('moduletype');
                try {
                    bldr.pageController.ondrop(type);
                } catch (e) {
                    // If anything goes wrong with the drop we should still hide the ghost
                    // and exit the dragging state.
                    self.ghost.hasTarget = false;
                    log.error("Failed to drop module type: " + type, e.stack);
                    // FIXME: Remove before launch, add real error messages
                    alert("We were unable to display the " + type + " module.");
                }
            }

            if (!self.ghost.hasTarget && self.ghost.tParent) {
                eventBuffer.trigger("module:drop:failed", {
                    moduleType: self.dragTarget.data('moduletype') 
                });

                var elOffset = self.ghost.el.offset(),
                xDistance = self.ghost.tx - elOffset.left,
                yDistance = self.ghost.ty - elOffset.top;

                self.ghost.el.animate({
                    left: self.ghost.tx,
                    top: self.ghost.ty 
                }, 500, function() {
                    self.ghost.tParent.append($dt);
                    self.hideGhost();
                });
                // Animate a ball bounce motion when moving toast back into toaster
                /*
                				self.ghost.el.animate({ left: self.ghost.tx }, {
                					duration: 500,
                					step: function(x, fx) {
                						var y, nx = (x-elOffset.left)/xDistance; // percent of x-distance covered

                						if(Math.abs(nx) < .3){
                							y = self.ghost.ty + yDistance*(nx-1);
                						} else {
                							y = self.ghost.ty - yDistance*(1 - Math.pow(nx-.3, 2));
                						}
                						self.ghost.el.css('top', y);
                					},
                					complete: function() {
                						self.ghost.tParent.append($dt);
                						self.hideGhost();
                					}
                				});*/

            } else {
                self.ghost.tParent.append($dt);
                self.hideGhost();
            }

            // Reset state variables
            self.leafDown = false;
            self.dragTarget = null;
            self.insideFrame = false;
            self.nodeInfo = null;

        },

        mousewheel: function(e) {
            // Don't scroll when there's a popover window active
            if (websover && websover.active) 
                return true;

            var delta = 0;
            if (e.wheelDelta) {
                /* IE/Opera. */
                delta = e.wheelDelta / 120;
                /** In Opera 9, delta differs in sign as compared to IE.
                			         */
                if (window.opera) 
                    delta = - delta;
            } else if (e.detail) {
                /** Mozilla case. */
                /** In Mozilla, sign of delta is different than in IE.
                			         * Also, delta is multiple of 3.
                			         */
                delta = - e.detail / 3;
            }

            var $dropdown = $(e.target).parents(".w-dropdown-ul");
            var $moreContainer = $(e.target).parents(".w-more_container");
            if ($dropdown.length || $moreContainer.length) {
                // Target is inside something we expect to be scrollable
                return true;
            } else {
                /** If delta is nonzero, handle it.
                				 * Basically, delta is now positive if wheel was scrolled up,
                				 * and negative, if wheel was scrolled down.
                				 */
                if (delta) {
                    if (bldr.pageController) {
                        var $win = bldr.pageController.$(bldr.pageController.win);
                        $win.scrollTop($win.scrollTop() - (delta * 30));
                    }
                    this.nodeInfo = null;
                    return false;
                }
            }

        }
    });

    return DragController.init({
        el: document 
    });
});

define('internal/sitebuilder/builderChrome/chromeController', [
'jquery',
'require',
'internal/sitebuilder/common/eventBuffer',
'sb3Branding',
'translate!webs.bldr',
'internal/sitebuilder/builderChrome/dragController',
'internal/sitebuilder/builderChrome/Helptip',
'internal/apps/webstore',
'spine',
'spine.tabs',
'internal/sitebuilder/common/dockPane',
'bread', // bread is printed to the page in chrome.jsp
'spine.manager'
], function($, require, eventBuffer, sb3Branding, translate, dragController, Helptip, webstore, Spine, SpineTabs, dockPane, bread) {

    var ChromeController = Spine.Controller.create({
        events: {
            'resize': 'fixFrame'
        },

        init: function() {
            this.dom = {
                header: $("#header"),
                pageOptionsAnchor: $("#page_options_anchor"),
                container: $("#container"),
                cover: $("#iframe_cover"),

                bottomBlock: $("#interface_bottom"),
                leafWrap: $("#leaf_wrap"),
                leafDock: $("#leaf_dock"),
                leafContainer: $("#leaf_container"),

                win: $(window),
                doc: $(document)
            };

            this.pageBoundary = {
                top: this.dom.container.position().top,
                bottom: 1000
            };

            $(document).ready(this.proxy(this.fixFrame));

            // Prevents backspace from moving browser history back
            this.dom.doc.bind("keydown", function(e) {
                var doPrevent;
                if (e.keyCode == 8) {
                    // Backspace
                    var
                    target = e.target,
                    isInput = target.tagName.toUpperCase() == 'INPUT',
                    isTextarea = target.tagName.toUpperCase() == 'TEXTAREA';

                    doPrevent = (isInput || isTextarea) ? target.readOnly || target.disabled : true;
                } else 
                    doPrevent = false;

                if (doPrevent) 
                    e.preventDefault();
            });

            var toggleGrid = $('#toggle_grid');
            toggleGrid.click(function() {
                bldr.pageController.toggleGrid();
                toggleGrid.toggleClass('active');
                return false;
            });

            function showElementPopover($el) {
                new Popover($el.attr('href'), {
                    width: $el.data('width'),
                    height: $el.data('height'),
                    heading: $el.text() 
                }).show();
            }

            $('#page_options_ul a, #show_module_configs').click(function(e) {
                var $el = $(this);
                $el.parents("li").removeClass("active");
                if (!$el.hasClass('w-menu-disable')) {
                    // TODO: INTL - This is no good
                    if ($el.text() == translate('webs.bldr.chrome.settings.navbar.show')) {
                        var
                        page_id = 0,
                        re1 = '(pages)',
                        re2 = '(\\/)',
                        re3 = '(\\d+)',
                        re4 = '(\\/)',
                        re = new RegExp(re1 + re2 + re3 + re4, ["i"]),
                        m = re.exec(window.location);
                        if (m !== null) {
                            page_id = m[3];
                        }

                        // Forked from hide.jsp
                        $.ajax({
                            dataType: 'json',
                            url: "/s/page/" + page_id + "/hide",
                            data: {
                                hidden: false
                            },
                            success: function(data) {
                                if (data.success) {
                                    toShow = $("#website", top.document).contents().find('.webs-nav a[href$="' + page_id + '"], .webs-nav a[href$="' + page_id + '/"]');
                                    if (toShow.length > 0) {
                                        toShow.show();
                                        $el.find("span").text(translate('webs.bldr.chrome.settings.navbar.hide'));
                                        $el.removeClass("w-icon-eye-open").addClass("w-icon-eye");
                                    } else {
                                        top.location.reload(true);
                                    }
                                } else
                                    alert(data.message);
                            },
                            error: function() {
                                log.trigger("Saving", "error", "Error hiding page with ID " + page_id);
                                // TODO: INTL
                                alert("There was an error submitting your changes.");
                            }
                        });
                    } else if ($el.attr('id') === 'showTour') {
                        //remove the div ghost cover for users getting the step-by-step tour
                        $('.w-more_cover.active').last().removeClass('active');

                        //we don't want to show up the popover for show tour and we capture the click link in chrome.js
                        return true;
                    } else {
                        showElementPopover($el);
                    }
                }
                e.preventDefault();
                return false;
            });

            $('#bldr_publish:not(.inactive)').click(function() {
                // TODO: INTL - heading text in Popover should be localized
                new Popover("/s/sitebuilder/dialog/publish", {
                    width: 480,
                    height: 325,
                    heading: translate('webs.bldr.dialog.publish.publishTitle')
                }).show();
                $('body').trigger('publishedSite');
                return false;
            });

            if (sb3Branding.getBannerAd)
                $(".global-header").append(sb3Branding.getBannerAd());

            this.setupMouseEventSharing();

            // handle auto-show for popovers
            var $autoPopup = $('#show_module_configs.autoShowPopover');
            if ($autoPopup.length > 0)
                showElementPopover($autoPopup.removeClass('autoShowPopover'));


            // Sandboxing Test
            var emailDomain = webs.site.publicEmail ? webs.site.publicEmail.split('@')[1] : 'fightingArtichokes';
            if (emailDomain == 'sandbox.webs.com') {
                var showSignupPop = function() {
                    new Popover('/s/sitebuilder/settings/sandboxSignup', {
                        width: 350,
                        height: 400,
                        heading: 'Signup to Continue' 
                    }).show();
                };
                if (webs.partner.isDefaultPartner && webs.locale == "en-US") {
                    var self = this;
                    $('header.global-header').find(':not(#help, #help *, #websid_dropdown_logout)').on('click', function(e) {
                        e.preventDefault();
                        e.stopImmediatePropagation();
                        showSignupPop();
                        eventBuffer.trigger("loaded:sandboxSignup");
                    });
                }
                webs.showPremiumDialog = showSignupPop;
                $('.support-btn').attr('onclick', 'webs.showPremiumDialog()');
                eventBuffer.trigger("loaded:sandbox");
            }

        },

        setupMouseEventSharing: function() {
            $(document).bind("mouseup", function(e) {
                if (bldr.pageController) {
                    bldr.pageController.dom.$body.trigger("mouseup");
                }
            });
        },


        /**
        			 * There should always be a "webs-body" tree on the page, it might take some time
        			 * for the tree controller to initialize the model, so we'll run a timeout
        			 * (with an escape condition)
        			 */
        pageLoad: function(tries) {
            var
            self = this,
            bodyTree = bldr.pageController.trees.find("webs-body"),
            model = bodyTree.model;

            if (typeof tries === "undefined") 
                tries = 0;
            if (tries === 30) 
                return;
            if (!model) {
                setTimeout(function() {
                    self.pageLoad(++tries);
                }, 200);
            } else {
                // If the page is blank, show a helptip pointing to the toaster
                // If this is the first time they're hitting builder, don't show it,
                // because they'll get it at the end of the tour.
                if (!webs.site.firstTime && model.hasSinglePlaceholder()) {
                    this.showToasterHelptip();
                }
            }
        },

        /**
        			 * shows helptip to indicate that you can drag toasts into page
        			 */
        showToasterHelptip: function() {
            var helptip = require("internal/sitebuilder/builderChrome/Helptip").init({
                detachable: true
            });
            helptip.show({
                ref: this.dom.leafDock,
                msg: "<h2>" + translate('webs.bldr.start.title') + "</h2><p id='letsStartHelptip'>" + translate('webs.bldr.start.text') + "</p>",
                arrow: "bottom",
                bounce: true,
                offsetTop: - 160,
                offsetLeft: 14
            });
            require("internal/sitebuilder/builderChrome/dragController").bind("dragstart", function() {
                helptip.hide();
            });
            dockController.bind("toggleControls", function() {
                helptip.hide();
            });

            // if a mousedown, hide the help tip
            this.dom.doc.bind("mousedown", function(e) {
                helptip.hide();
            });
        },

        fixFrame: function() {
            var winHeight = this.dom.win.height(),
            bottomHeight = this.dom.bottomBlock.height();

            this.dom.container.height(winHeight - this.pageBoundary.top - bottomHeight);

            this.pageBoundary.bottom = winHeight - this.pageBoundary.top - bottomHeight;
            this.pageBoundary.width = this.dom.win.width();

            this.pageBoundary.dockLeft = this.dom.leafDock.offset().left - 52; // is width of dock's slope edge
            this.pageBoundary.dockRight = this.pageBoundary.dockLeft + this.dom.leafDock.width() + 104;
        },

        isInsideFrame: function(e, padding) {
            if (typeof padding !== "number") 
                padding = 0;

            return e.clientY > 0 && //this.pageBoundary.top && // greater than top boundary
            (e.clientY < this.pageBoundary.bottom || // less than bottom boundary (including dock)
            (e.clientY < this.pageBoundary.bottom + 55 + padding && // less than bottom boundary (excluding dock - 55 is the height of dock)
            (e.clientX < this.pageBoundary.dockLeft || e.clientX > this.pageBoundary.dockRight))); // outside of dock's vertical edges
        },

        /** @public
        			 *  Returns the absolute Y position of an element inside the iframe with respect to the main content window
        			 *  Expects param representing the absolute Y value of the element with respect to the iframe
        			 */
        iframeAbsY: function(elY) {
            return elY - bldr.pageController.dom.$win.scrollTop() + this.pageBoundary.top;
        },

        showCover: function() {
            this.dom.cover.show();
        },

        hideCover: function() {
            this.dom.cover.hide();
        },

        toggleControls: function(show) {
            dockController.toggleControls(show);
        },

        _pageOptionsElCache: {},
        showPageOptionsHelptip: function(opts) {
            var pageOptionsHelptip = Helptip.init({
                detachable: true 
            });
            var id = opts.id, msg = opts.msg, _el;
            if (typeof this._pageOptionsElCache[id] === "undefined") {
                _el = $("#" + id);
                this._pageOptionsElCache[id] = _el.length ? _el : null;
            }
            if (typeof this._pageOptionsElCache[id] === null) 
                return;

            this.dom.pageOptionsAnchor.click();
            pageOptionsHelptip.show({
                ref: this._pageOptionsElCache[id],
                msg: msg,
                arrow: "right",
                bounce: true,
                width: opts.width,
                offsetLeft: opts.offsetLeft,
                offsetTop: opts.offsetTop
            });
        }
    }),
    DraggableDockController = Spine.Controller.create({
        tag: 'ul',

        events: {
            'mousedown .bldr-draggable': 'mousedown'
        },

        init: function(options) {
            this.label = options.label;
            var moduleTypes = options.modules || [];
            for (var i = 0, len = moduleTypes.length; i < len; i++) {
                this.addOne(moduleTypes[i]);
            }

            this.el.addClass('leaf_type');
            $('#leaf_container').append(this.el);
        },

        activate: function() {
            this.el.addClass('active');
            return this;
        },

        deactivate: function() {
            this.el.removeClass('active');
            return this;
        },

        mousedown: function(e) {
            var dragController = require('internal/sitebuilder/builderChrome/dragController');
            dragController.ghost.el.stop(true, true);
            dragController.dragstart(e, $(e.currentTarget));
            return false;
        },

        addOne: function(item) {
            if (typeof item === "undefined") 
                return false;
            var label;
            if (!item.slug || item.slug.indexOf('app-sidebar') >= 0) {
                // app sidebars (and weird stuff) shouldn't get translated
                label = item.label;
            } else {
                label = translate(item.label);
            }

            var newView =
            $('<li/>').append(
            $('<div/>').addClass('bldr-draggable').attr('id', 'bldr-drgb-' + item.slug).data('moduletype', item.slug).append(
            $('<div/>').addClass('bldr-drgb_icon').append('<span/>')
            ).append(
            $('<div/>').addClass('bldr-drgb_desc-container').append(
            $('<span/>').addClass('bldr-drgb_desc').html(label)
            )
            )
            );

            if (item.icon)
                newView.find(".bldr-drgb_icon span").css("background", "transparent url(" + item.icon + ") no-repeat 50% 50%");

            this.el.append(newView);
        },
        addAd: function(ad) {
            if (typeof ad === "undefined") 
                return false;
            var adEl = $('<li/>').addClass("ad").append(
            $('<div/>').addClass('toasterAdWrapper').append(
            $('<div/>').addClass('icon').addClass("icon-" + ad.icon)
            ).append(
            $('<div/>').addClass('messageContainer').append(
            $('<div/>').addClass('message').html(ad.text)
            ).append(
            $('<a/>').addClass('w-btn1').addClass('w-btn1-' + ad.buttonColor || 'silver').append(
            $('<span/>').html(ad.buttonText).append(
            $('<div/>').addClass('buttonArrow')
            )
            )
            )
            )
            ).appendTo(this.el);
            if (typeof ad.target == "string") {
                adEl.find('a').mousedown(function() {
                    eventBuffer.trigger("ad:toaster:" + ad.eventName + ":click");

                    if (ad.eventName === "webStore" && webstore.shouldDisallowInstall()) {
                        return webstore.showUpsell();
                    }

                    top.document.location.href = ad.target;
                });
            }
        },
        addIframeAd: function(ad) {
            if (typeof ad === "undefined") 
                return false;
            var adEl = $('<li></li>').addClass("ad").append(
            $('<iframe></iframe>')
            .attr({
                'src': ad.url,
                'frameBorder': '0',
                'allowTransparency': true
            })
            .css({
                width: "100%",
                height: "94px"
            })
            ).appendTo(this.el);
            if (ad.id)
                adEl.attr("id", ad.id);
        }
    }),
    DockController = Spine.Tabs.create({

        init: function(options) {
            Spine.Tabs.fn.init.call(this, options);
            var self = this,
            dragController = require('internal/sitebuilder/builderChrome/dragController');
            this.controlsAnchor = $('#controls_anchor');
            this.hideControls = $('#hide_controls');
            this.controlsVisible = true;

            this.hideControls.click(function() {
                self.toggleControls();
                return false;
            });

            // When dragging within the page, hide the dock items
            dragController.bind('pageenter', function() {
                self.toggleControls(false);
            });

            // When dragging back to the chrome, show the dock items
            dragController.bind('pageleave', function() {
                self.toggleControls(true);
            });

            // When we're done dragging, show the dock items
            dragController.bind('dragend', function() {
                self.toggleControls(true);
            });
        },

        toggleControls: function(show) {
            if (typeof(show) === 'undefined') 
                show = !this.controlsVisible;
            var position = (show ? - 18 : - 86);
            var timeout = (show ? 260 : 360);

            if (this.controlsVisible === show) 
                return false;

            if (Modernizr.cssanimations) {
                if (show) 
                    chromeController.dom.leafContainer.addClass('toasterUp');
                else 
                    chromeController.dom.leafContainer.addClass('toasterDown');
                setTimeout(function() {
                    chromeController.dom.leafContainer.removeClass('toasterUp toasterDown').css('bottom', position);
                }, timeout);
            } else {
                chromeController.dom.leafContainer.stop().animate({
                    'bottom': position
                }, timeout);
            }

            if (show) {
                if (bldr.pageController) {
                    bldr.pageController.dom.$body.removeClass('hide_resize');
                }
                this.hideControls.children().html('Hide');
                this.hideControls.addClass('w-btn-minus').removeClass('w-icon-plus');
                this.controlsVisible = true;
            } else {
                if (bldr.pageController) {
                    bldr.pageController.dom.$body.addClass('hide_resize');
                }
                this.hideControls.children().html('Show');
                this.hideControls.removeClass('w-btn-minus').addClass('w-icon-plus');
                this.controlsVisible = false;
            }
            this.trigger("toggleControls");
        },

        // Add some bread to the toaster: should have a label and an array of modules.
        addBread: function(options) {
            var label = options.label,
            bread = DraggableDockController.init({
                label: label,
                modules: options.modules
            });
            if (!this.toaster) {
                this.toaster = Spine.Manager.init(bread);
                this.bread = {};
            } else {
                this.toaster.add(bread);
            }

            this.bread[label] = bread;

            this.connect(label, bread);
            $('#leaf_types').append($('<li/>').attr('data-name', label).append($('<a/>').addClass('leaf_type_btn').html(translate(label))));
        },

        addModule: function(bread_name, module) {
            var bread = this.bread[bread_name];
            if (!bread) 
                return this.addBread({
                    label: bread_name,
                    modules: [module]
                });
            return bread.addOne(module);
        },

        addAd: function(bread_name, ad) {
            if (!this.bread[bread_name]) 
                this.addBread({
                    label: bread_name,
                    modules: []
                });
            this.bread[bread_name].addAd(ad);
        },

        addIframeAd: function(bread_name, ad) {
            if (!this.bread[bread_name]) 
                this.addBread({
                    label: bread_name,
                    modules: []
                });
            this.bread[bread_name].addIframeAd(ad);
        },

        addAds: function() {
            if (sb3Branding && "addAds" in sb3Branding && typeof sb3Branding.addAds === 'function') {
                sb3Branding.addAds(this);
            }
        }
    }),
    chromeController = ChromeController.init({
        el: window 
    }),
    dockController = DockController.init({
        el: $('#leaf_types') 
    });

    $.each(bread, function(i, data) {
        dockController.addBread(data);
    });


    dockController.render();
    chromeController.dockController = dockController;

    return chromeController;
});

/* jshint ignore:start */
define('internal/sitebuilder/builderChrome/toolbar', [
'jquery',
'internal/sitebuilder/builderChrome/chromeController',
'internal/sitebuilder/common/fontsController',
'internal/sitebuilder/common/fontsDropdownController',
'internal/sitebuilder/builderChrome/frames',
'internal/sitebuilder/builderChrome/iconsets',
'translate!webs.bldr',
'translate!webs.toolbar',
'internal/sitebuilder/common/jquery.customSelect',
'jquery.placeholder',
'jquery.customDropdown',
'jquery.numberInput',
'iDropper',
'internal/common/websover'
], function($, chromeController, fontsController, fontsDropdownController, _frames, _iconsets, translate) {

    function localizeToolbarText( string ) {
        var localizedText = string;
        var htmlEntityPattern = /^&(?:[a-z]+|#x?\d+);$/gi;

        if ( typeof string !== 'undefined' && string.length > 0 && !htmlEntityPattern.test(string) && string !== '+') {
            localizedText = translate('webs.bldr.toolbar.text.' + string.replace(/\s/g, ''));
        }

        return localizedText;
    }


    var

    /**
    	 * hash of slug pointing to jQuery container holding the particular set
    	 */
    $frames, $iconsets,

    /**
    	 * Toolbar container's container
    	 */
    mtbContainer = $('#module_toolbar_container'),

    /**
    	 * Reference to the bar holding all the toolbars
    	 */
    mtb = $('#module_toolbar'),

    isAnimating = false,

    /**
    	 * A hash of toolbar ID key to its JSON data. Doens't get built until "create"
    	 */
    toolbarJSON = {},
    /**
    	 * A hash of toolbar ID key to its jQuery <menu/> reference element
    	 */
    toolbars = {},

    /**
    	 * The current active toolbar, gets set when toolbarInst.show() is called
    	 */
    activeToolbar,

    /**
    	 * Button dom classes
    	 */

    buttonPrefix = "w-btn2",
    buttonGroupClass = buttonPrefix + "-group",
    idPrefix = "w-tbui-",

    getActiveToolbar = function() {
        return activeToolbar;
    },

    /**
    	 * This is a bit hacky and we may want to change later.
    	 * Since createUI may be used in other places such as ModuleBar (and since it performs all the event triggering),
    	 * the instance can pass in itself for "trigger" to grab its event listeners, otherwise activeToolbar will be used.
    	 * @param 	name 	name of listener to trigger
    	 * @param 	val 	val to trigger with
    	 * @param 	inst 	instance that calls the change method
    	 */
    trigger = function(name, val, inst) {
        if (typeof inst !== 'undefined') {
            inst.change(name, val);
        } else if (activeToolbar) {
            activeToolbar.change(name, val);
        }
    },
    getRecentColorKey = function() {
        return 'webs-recentColors-' + webs.site.id + '-' + webs.theme.slug;
    },
    getRecentColors = function() {
        var colorList = [], lsVal;
        try {
            lsVal = JSON.parse(window.localStorage.getItem(getRecentColorKey()));
            // only use what's in localStorage if it's an array
            if (lsVal instanceof Array) {
                colorList = lsVal;
            }
        } catch (e) {
            // nothing extra to do here, just swallow any exception caused by a bad value in localStorage
        }

        while (colorList.length < 6) {
            colorList.push('#ffffff');
        }
        return colorList;
    },
    setRecentColors = function(colorList) {
        window.localStorage.setItem(getRecentColorKey(), JSON.stringify(colorList));
    },
    saveRecentColor = function(hex, container) {
        var colorList = getRecentColors();
        if ($.inArray(hex, colorList) === - 1) {
            colorList.splice(0, 0, hex);
        }
        if (colorList.length > 6) {
            colorList.pop();
        }
        setRecentColors(colorList);
        container.trigger('colorUpdate');
    },

    /**
    	 * Creates corresponding UI element. Appends to container if container is defined.
    	 * @param 	opts 		options to create the UI with
    	 * @param 	container 	container to place the UI element in
    	 * @param 	inst 		instance that will trigger the action associated with this UI element. If undefined, activeToolbar will be used
    	 * @return 	$element 	jQuery reference to the element created
    	 */
    createUI = function(opts, container, inst) {

        /**
        		 * Return markup for a tooltip next to a label (only currently enabled for dropdown and switch-bare)
        		 * Uses parent scope opts and looks for opts.tooltip which is appended to webs.bldr.toolbar.text in localizer
        		 */
        var hoverHelperMarkup = function(label) {

            if (opts.tooltip) {
                label += '<dfn class="tooltip" data-tooltip="' + localizeToolbarText(opts.tooltip) + '">';
            }
            return label;
        };

        // If no type is specified, button will be used
        var type = opts.type || 'button';
        var button,
        btnGroupClass = opts.btnGroupClass || buttonGroupClass;

        if (typeof opts.btnPrefix !== 'string') 
            opts.btnPrefix = buttonPrefix;

        switch (type) {
        case 'text':
            return $('<div/>').html('<span>' + localizeToolbarText(opts.text) + '</span>').appendTo(container).addClass('w-btnbare w-btnbare-text');

        case 'title':
            return $("<h3>").addClass("title").text(localizeToolbarText(opts.text)).appendTo(container);

        case 'divider':
            return container.addClass('vertical_divider');
        case 'divider-horiz':
            return container.addClass('horizontal_divider');

        case 'link':
            var link = $('<a/>').attr('href', '#' + opts.value).html('<span>' + localizeToolbarText(opts.label) + '</span>').click(function() {
                trigger(opts.name || opts.name, opts.value, inst);
                return false;
            }).appendTo(container);

            return link;

        case 'colorpicker':
            opts.type = "more";
            container.addClass('w-more-colorpicker');

            var state = $('<em/>').addClass('w-colorstate').attr('name', opts.name),
            moreContainer = createUI(opts, container, inst),
            tabContainer = $('<ul class="w-colorpicker-tabs"><li class="w-colorpicker-tab-popular">' + localizeToolbarText('popular') + '</li><li class="w-colorpicker-tab-custom">' + localizeToolbarText('custom') + '</li></ul>'),
            iDropper,
            moreLink = container.find(".w-more_link"),
            iDropperContainer,
            iDropperStart,
            iDropperReset = $('<button class="w-button small gray w-colorpicker-reset">' + localizeToolbarText('reset') + '</button>'),
            swatchPickerContainer = $('<div/>'),
            recentColorContainer = $('<div class="w-recent-color-container"/>'),
            updateColor = function(hex, el) {
                state.css('background-color', hex);
                trigger(opts.name, hex, inst);
            },
            // update the color and save it to the recent color list
            saveColor = function(hex) {
                // only save the color if the user changed it
                if (iDropper.hex !== iDropperStart) {
                    saveRecentColor(hex, recentColorContainer);
                }
            };

            setIdentifier(moreContainer, opts.name);
            moreContainer.addClass('w-colorpicker-container').iDropper({
                size: 151,
                onDrag: updateColor,
                onChange: updateColor
            });
            iDropper = moreContainer.data('iDropper');
            iDropper.set(opts.value, true);
            moreContainer.find('.iD-preview-input').append(iDropperReset);

            if (webs.site.colors.length !== 0) {
                // Hide iDropper and show only colors allowed by CoBrand. (Can't remove iD, wired directly into wizzy)
                if (webs.site.allowCustomColors) {
                    iDropperContainer = moreContainer.find('.iD');
                    swatchPickerContainer.insertAfter(iDropperContainer);
                    tabContainer.insertBefore(iDropperContainer);
                    tabContainer.find('.w-colorpicker-tab-popular').addClass('active').on('click', function() {
                        iDropperContainer.hide();
                        saveColor(iDropper.hex);
                        swatchPickerContainer.show();
                        $(this).addClass('active').siblings().removeClass('active');
                    });
                    tabContainer.find('.w-colorpicker-tab-custom').on('click', function() {
                        swatchPickerContainer.hide();
                        iDropperContainer.show();
                        iDropperStart = iDropper.hex;
                        $(this).addClass('active').siblings().removeClass('active');
                    });
                    iDropperContainer.hide();
                } else {
                    swatchPickerContainer = moreContainer;
                }
                createUI({
                    type: 'swatchpicker',
                    value: opts.value,
                    update: updateColor,
                    hideinput: true,
                    recentColorContainer: recentColorContainer,
                    iDropper: iDropper
                }, swatchPickerContainer, inst);
            }

            iDropperReset.on('click', function() {
                if (typeof iDropperStart !== 'undefined') {
                    iDropper.set(iDropperStart);
                }
            });

            createUI({
                type: 'swatchpicker',
                isRecentColorPicker: true,
                swatches: getRecentColors(),
                value: opts.value,
                update: updateColor,
                hideinput: true,
                iDropper: iDropper
            }, recentColorContainer, inst);
            recentColorContainer.prepend('<div class="w-more-title">' + localizeToolbarText('recentcolors') + '</div>');
            moreContainer.append(recentColorContainer);

            // trigger the recent color list to update when we toggle the colorpicker
            moreLink.on('click', function() {
                recentColorContainer.trigger('colorUpdate');
            });
            // if some other object tells the color picker to update, forward the event to the recent color list
            container.on('colorUpdate', function(e) {
                recentColorContainer.trigger('colorUpdate');
            });

            // when the container click event is fired (and is not active), save the current iDropper color
            container.on('click', function(e) {

                // let the current call stack complete (let the colorpicker hide) before checking the state of the container
                window.setTimeout(function() {

                    if (container.hasClass('active')) {
                        if (moreContainer[0].getBoundingClientRect().top < 100) {
                            moreContainer.addClass('force-down');
                        }
                    }

                    if (!container.hasClass('active')) {
                        saveColor(iDropper.hex);
                    }
                }, 0);
            });

            container.children('a.w-tb-button').append(state);
            return moreContainer;

        case 'swatchpicker':
            var
            original = opts.value,
            swatches = opts.swatches || webs.site.colors,
            $preview = $('<div class="w-swatchpicker-preview-input"><div class="w-swatchpicker-preview-input"><div class="w-swatchpicker-preview" style="background-color: ' + original + '; "></div><div class="w-swatchpicker-input-container"><input class="w-swatchpicker-input-field" type="text" disabled="disabled" value="' + original + '" /></div></div>'),
            $swatches = $('<ul>').addClass('w-swatchpicker-swatches'),
            $picker = $('<div class="w-swatchpicker"></div>').append($preview).append($swatches),
            updateColor = function(newColor) {
                $preview.find('.w-swatchpicker-input-field').val(newColor.substr(1));
                $preview.find('.w-swatchpicker-preview').css('background-color', newColor);
                if (webs.site.allowCustomColors && opts.iDropper) {
                    opts.iDropper.set(newColor, true);
                }
                opts.update(newColor);
                if (opts.recentColorContainer) {
                    saveRecentColor(newColor, opts.recentColorContainer);
                }
            },
            buildSwatch = function(i, hex) {
                return '<li style="' + ((i + 1)%6 === 0 ? 'margin-right:0; ' : '') + ((hex == '#ffffff') ? 'border: 1px solid #d1d1d1;-moz-box-sizing:border-box;box-sizing:border-box;' : '') + 'background-color:' + hex + ';cursor:pointer" title="' + hex + '"></li>';
            };

            if (opts.hideinput === true) {
                $preview.hide();
            }
            $.each(swatches, function(i, hex) {
                var $thisSwatch = $(buildSwatch(i, hex));
                if (i < 6) {
                    $thisSwatch.css('margin-bottom', '8px');
                }
                $swatches.append($thisSwatch);
            });
            $swatches.delegate('li', 'click', function() {
                updateColor($(this).attr('title'));
            });
            /*container.parents('.w-more-colorpicker').bind('click', function(){
            					updateColor(opts.iDropper.utils.RgbToHex(container.parent().find('.w-colorstate').css('background-color')));
            				});*/
            container.addClass('w-swatchpicker-container').append($picker);
            var updateRecent = function() {
                swatches = getRecentColors();
                $swatches.empty();
                $.each(swatches, function(i, hex) {
                    $swatches.append(buildSwatch(i, hex));
                });
            };

            if (opts.isRecentColorPicker) {
                container.on('colorUpdate', function(e) {
                    // prevent any unneeded event bubbling
                    e.stopPropagation();
                    e.preventDefault();
                    swatches = getRecentColors();
                    $swatches.empty();
                    $.each(swatches, function(i, hex) {
                        $swatches.append(buildSwatch(i, hex));
                    });
                });
            }
            return container;

        case 'colorpicker-menu':
            // Setting up label. Most likely this is used inside "more" dropdown and has a label
            var colorpickerLabel = $('<span/>').addClass('w-btnbare').addClass('w-dropdown').html(localizeToolbarText(opts.label));
            if (opts.display) {
                if (opts.display === 'inline') 
                    container.addClass('w-more-inline');
                else if (opts.display === 'hint') 
                    container.addClass('w-more-hint').addClass('clearfix');
            }
            if (typeof opts.labelWidth === 'number') 
                colorpickerLabel.width(opts.labelWidth);
            if (opts.label !== 'undefined') {
                container.append(colorpickerLabel);
            }

            opts.type = "colorpicker";
            var title = localizeToolbarText(opts.menuLabel);
            delete opts.menuLabel;
            var moreContainer = createUI(opts, container, inst);

            container.removeClass('w-more-colorpicker').addClass('colorpicker-menu');

            // move the input field and preview swatch from the iDropper to the form,
            // and attach the iDropper to the preview swatch
            var $moreLink = container.find(".w-more_link");
            var $iDPreview = container.find(".iD-preview");
            var $iDInputContainer = container.find(".iD-input-container");
            var $iDPicker = container.find(".iD-layout-bar");
            $iDInputContainer.addClass("w-more-top").appendTo(container);
            $moreLink.removeClass("w-icon-more w-tb-button w-btn2").appendTo($iDInputContainer);
            $iDPreview.appendTo(container.find("a"));

            // tell the color picker to update its recent colors when we toggle its visibility
            $moreLink.on('click', function() {
                moreContainer.trigger('colorUpdate');
            });

            return moreContainer;

        case 'switch':
            button = $('<a/>').addClass('w-switch').attr("name", opts.name).html('<span>' + localizeToolbarText(opts.label) + '</span>').appendTo(container);
            button.mousedown(function() {
                var active = button.hasClass('active');
                button[active ? 'removeClass' : 'addClass']('active');

                // Forcing a reflow for IE8 after the class toggle
                if (bldr.IE <= 8) 
                    button.hide().show();

                trigger(opts.name, !active, inst);
                return false;
            });

            createUIHelper(button, opts);
            setIdentifier(button, opts.name);

            return button;

        case 'numberInput':

            var $wrapper = $('<span/>').addClass('w-numberInput').appendTo(container),
            $label = $('<span></span>').html(localizeToolbarText(opts.label)).appendTo($wrapper);
            if (opts.display && opts.display === 'inline') 
                container.addClass('w-more-inline');
            if (typeof opts.labelWidth === 'number') 
                $label.width(opts.labelWidth);

            var $root = $('<input type="number">').appendTo($wrapper);
            if (isFinite(opts.width)) 
                $root.width(parseFloat(opts.width));
            if (isFinite(opts.min)) 
                $root.attr("min", parseFloat(opts.min));
            if (isFinite(opts.max)) 
                $root.attr("max", parseFloat(opts.max));
            if (isFinite(opts.step)) 
                $root.attr("step", parseFloat(opts.step));
            if (isFinite(opts.value)) 
                $root.attr("value", parseFloat(opts.value));

            var $numberInput = $root.numberInput().attr("name", opts.name);
            setIdentifier($numberInput, opts.name);

            $numberInput.bind("change", function() {
                trigger(opts.name, $root.val(), inst);
            });

            return $numberInput;

        case 'switch-bare':
            var $label = $('<span/>').addClass('btn-bare').html(hoverHelperMarkup(localizeToolbarText(opts.label))).appendTo(container);

            if (opts.display && opts.display === 'inline') 
                container.addClass('w-more-inline');
            if (typeof opts.labelWidth === 'number') 
                $label.width(opts.labelWidth);

            opts.type = "switch";
            return createUI(opts, container, inst).addClass('w-switch-bare');


            // There are only one frameset and one iconset containers. It gets appended to the correct toolbar during a switchToolbar.
            // Here we're just creating a button to trigger it
        case 'iconsets':
            setIdentifier(container, "icon");
            opts.type = "more";
            if (opts.hideAlignment) 
                container.addClass('w-more-iconpicker-hidealignment');
            return createUI(opts, container.addClass('w-more-iconpicker'), inst).addClass("bldr-iconsets");

        case 'framesets':
            opts.type = "more";
            return createUI(opts, container.addClass('w-more-framepicker'), inst).addClass("bldr-framesets");


        case 'button':
            var label = (typeof opts.labelIntl === "string") ? translate(opts.label) : localizeToolbarText(opts.label);
            var title = (opts.title) ? localizeToolbarText(opts.title) : label;

            button = $('<a/>').addClass('w-tb-button ' + opts.btnPrefix).prepend($('<span/>').html(label)).attr('title', title).appendTo(container);

            if (opts.iconElement) {
                button.append($('<div/>').addClass('icon'));
            }

            createUIHelper(button, opts);
            setIdentifier(button, opts);


            if (typeof opts.icon === "string") {
                var iconSet = opts.iconSet || "w-btn-icon";
                button.addClass(opts.btnPrefix + "-icon " + iconSet + " w-icon-" + opts.icon);
                if (opts.showLabel) 
                    button.addClass(opts.btnPrefix + "-text");
            } else {
                button.addClass(opts.btnPrefix + "-text");
            }

            if (opts.btnColor) {
                button.addClass(opts.btnPrefix + "-" + opts.btnColor);
            }

            if (opts.more) {
                button.addClass(opts.btnPrefix + "-icon w-btn-icon w-icon-more w-more_link");
            } else {
                if (opts.name) {
                    var identifier = opts.name;
                    if (typeof(opts.value) === "string") 
                        identifier += '-' + opts.value;
                    button.attr("href", '#' + identifier).data({
                        'name': opts.name,
                        'value': opts.value
                    });
                }

                if (opts.fullSpan) {
                    button.addClass('webs-btn_full');
                }

                if (opts.click) {
                    button.click(opts.click);
                } else if (opts.dialog) {
                    if (opts.dialog.localizeHeading) {
                        opts.dialog.heading = translate(opts.dialog.localizeHeading);
                    }
                    var url = top.webs.useIR && opts.dialog.ir_url ? opts.dialog.ir_url : opts.dialog.url,
                    popover = new Popover(url, $.extend({}, opts.dialog)).bind('submit', function(obj) {
                        popover.data = obj;
                        button.data('value', obj);
                        trigger(opts.name, obj, inst);
                    });
                    button.data("dialog", popover);

                    /**
                    						 * If inst exist, then the instance isn't a toolbar (probably modulebar)
                    						 * In this case, we still want reference to it so that during the button's click event
                    						 * the proper feedback is loaded and dialog callback is fired
                    						 */
                    if (typeof inst !== 'undefined') 
                        button.data('tb-instance', inst);

                    button.data('popover', popover);
                    button.click(function(e) {
                        var inst = button.data('tb-instance') || getActiveToolbar();

                        if (inst && inst.feedback) {
                            popover.options.feedback = inst.feedback;
                            popover.options.feedback.offset = {
                                left: 0,
                                top: $('#header').height() 
                            };
                        }
                        popover.data = button.data('value');
                        popover.show(inst);
                        return false;
                    });
                } else {
                    var event = "click";
                    if (typeof opts.event === "string") 
                        event = opts.event;

                    button.bind(event, function(e) {
                        trigger(opts.name, opts.value || !button.hasClass('active'), inst);
                        // Update active selection
                        if (opts.clearActive)
                            $(this).parent().parent().parent().find(".currentSelection").removeClass("currentSelection");
                        if (opts.setActive)
                            $(this).parent().addClass("currentSelection");

                        // press button if sticky
                        if (opts.sticky) 
                            activeToolbar.set(opts.name, opts.value);
                        else {
                            var group = $(this).parents("." + buttonGroupClass);
                            if (group.length > 0) {
                                if (group.data('sticky')) {
                                    activeToolbar.set(opts.name, opts.value, true);
                                }
                            }
                        }

                        return false;
                    });
                }
            }

            return button;


        case 'button-cancel':
            var item1 = $.extend(opts, {
                type: 'button'
            }),
            item2 = $.extend(opts.cancel, {
                classNames: 'bldr-cancel-button'
            }),
            group = {
                classNames: opts.groupClass,
                type: 'button-group',
                items: [ item1, item2]
            };

            return createUI(group, container, inst).addClass('bldr-button-cancel-group canceled');


        case 'button-group':
            var group = $('<ul/>').addClass(buttonGroupClass).appendTo(container);
            createUIHelper(group, opts);

            if (opts.sticky) 
                group.data('sticky', true);
            if (opts.distinct) 
                group.data('distinct', true);

            for (var i = 0; i < opts.items.length; i++) {
                createUI(opts.items[i], $('<li/>').appendTo(group).addClass(i === opts.items.length - 1 ? 'last-child' : ''));
            }
            return group;


        case 'dropdown_fonts':

            var fontsDropdown = fontsDropdownController.init({
                el: container 
            }),
            ul = fontsDropdown.renderList({
                width: 180,
                preventInitCall: true
            });

            fontsDropdown.bind("change", function(val) {
                if (val) {
                    val = val.replace(/-recent$/, "");
                    fontsController.loadFont(val);
                }
                trigger(opts.name, val, inst);
            });

            ul.addClass('webs-ui-dropdown');
            setIdentifier(ul, opts.name);
            container.addClass('w-fonts-container');

            var newItem = container.find(".w-dropdown-container");
            setIdentifier(newItem, opts.name);
            newItem.data("dropdown", ul.data("dropdown"));

            return ul;

        case 'dropdown_font_size':
            //This special case is required to ensure that the theme's default font size is included in the dropdown list.
            var defaultFontSize,
            options = opts.options;
            try {
                defaultFontSize = webs.theme.variables[opts.dataType].size;
            } catch (e) {
                defaultFontSize = opts.selectedValue;
            }

            //Determine if the default font size from the theme exists in the list of options. If not, add it.
            var fontSizeFoundOrAdded = false;
            if ($.isArray(options)) {
                $.each(options, function(i, option) {
                    if (defaultFontSize == option.value) {
                        option.classNames = "default";
                        fontSizeFoundOrAdded = true;
                        return false;
                    }
                    if (defaultFontSize < option.value) {
                        options.splice(i, 0, {
                            label: defaultFontSize,
                            value: defaultFontSize,
                            classNames : 'default' 
                        });
                        fontSizeFoundOrAdded = true;
                        return false;
                    }
                });
            }
            //If the default font size was not found or added, append it to the end of the list.
            if (!fontSizeFoundOrAdded) {
                options.push({
                    label: defaultFontSize,
                    value: defaultFontSize,
                    classNames : 'default' 
                });
            }
            //Continue on with regular 'dropdown' processing.
            opts.type = 'dropdown';
            return createUI(opts, container, inst);

        case 'dropdown':
            var ul = $('<ul/>').addClass('webs-ui-dropdown'),
            dropdownLabel = $('<span/>').addClass('w-btnbare').addClass('w-dropdown').html(hoverHelperMarkup(localizeToolbarText(opts.label))),
            options = opts.options,
            li;

            setIdentifier(ul, opts.name);

            if ($.isArray(options)) {
                $.each(options, function(i, option) {
                    li = $('<li/>').html('<span>' + localizeToolbarText(option.label) + '</span>').appendTo(ul);

                    li.attr('title', localizeToolbarText(option.value)).data('value', option.value);

                    // Determine initial selected value.
                    // Equality operator instead of identity for loose number/string comparison
                    if (opts.selectedValue == option.value) 
                        li.addClass('selected');

                    if (typeof option._id === 'string') 
                        li.attr('id', option._id);
                    if (typeof option.classNames !== "undefined") {
                        if (option.classNames instanceof Array) 
                            li.addClass(option.classNames.join(' '));
                        else if (typeof option.classNames === "string") 
                            li.addClass(option.classNames);
                    }
                });
            } else if (options.jquery) {
                // if options is a jquery object (assuming li $ array), just append it to the UL
                ul.append(options);
            }


            if (typeof container !== 'undefined') {
                if (opts.label !== 'undefined') {
                    container.append(dropdownLabel);
                }
                container.append(ul);
                if (ul.customDropdown) {
                    ul.customDropdown({
                        width: opts.width,
                        preventInitCall: true,
                        fn: typeof opts.fn === 'function' ? opts.fn : function(val) {
                            trigger(opts.name, val, inst);
                        }
                    });
                    var newItem = container.find(".w-dropdown-container");
                    setIdentifier(newItem, opts.name);
                    newItem.data("dropdown", ul.data("dropdown"));
                }
                if (opts.display && opts.display === 'inline') 
                    container.addClass('w-more-inline');
                if (typeof opts.labelWidth === 'number') 
                    dropdownLabel.width(opts.labelWidth);
            }

            return ul;


        case 'select':
            var selectDropdown = $('<select/>').addClass('webs-ui-select').attr('name', opts.name),
            dropdownLabel = $('<span/>').addClass('w-btnbare').html(localizeToolbarText(opts.label)),
            options = opts.options;

            setIdentifier(selectDropdown, opts.name);
            $.each(options, function(index, option) {
                var $option = $('<option/>').data('value', option.value).html(localizeToolbarText(option.label));

                // defaut value for select dropdown
                if (opts.selectedValue == option.value) 
                    $option.attr('selected', true);

                selectDropdown.append($option);
            });

            if (typeof container !== 'undefined') {
                if (opts.label !== 'undefined') {
                    container.append(dropdownLabel);
                }
                container.append(selectDropdown);
                if (selectDropdown.customSelect)
                    selectDropdown.customSelect({
                        width: opts.width
                    });

                if (opts.display && opts.display === 'inline') 
                    container.addClass('w-more-inline');
                if (typeof opts.labelWidth === 'number') 
                    dropdownLabel.width(opts.labelWidth);
            }

            selectDropdown.change(function() {
                trigger(opts.name, $('option:selected', selectDropdown).data('value'), inst);
            });

            return selectDropdown;

        case 'textfield':
            var container = $("<div/>")
            .addClass("w-toolbar-textfield")
            .appendTo(container),
            field = $("<input type='text'>")
            .addClass("w-toolbar-textfield-input")
            .attr('name', opts.name)
            .css('width', opts.width);


            if (typeof opts.label === "string") {
                container.addClass("w-toolbar-textfield-haslabel").append(
                $("<label/>").addClass("w-toolbar-textfield-label").html(localizeToolbarText(opts.label))
                );
            }
            container.append(field);
            setIdentifier(field, opts.name);

            if (opts.placeholder)
                field.attr('placeholder', localizeToolbarText(opts.placeholder)).placeholder();

            field.keydown("return", function() {
                trigger(opts.name, field.val(), inst);
            });
            field.blur(function() {
                trigger(opts.name, field.val(), inst);
            });

            return field;

        case 'submit':
            var button = $("<input type='submit'/>").attr("name", opts.name).addClass('w-toolbar-submit').val(localizeToolbarText(opts.label)).appendTo(container);
            button.click(function() {
                var target = $("[name=" + opts["for"] + "]", container.parents("#edit_toolbar"));
                trigger(opts["for"], target.val(), inst);
            });
            return button;

        case 'more':
            var moreContainer, moreButton, isString, isArray;
            container.addClass('w-more');

            if (typeof opts.labelIntl === "string")
                opts.label = opts.labelIntl;
            moreButton = createUI($.extend({}, opts, {
                type: 'button',
                more: true
            }), container);
            moreContainer = $('<div/>').addClass('w-more_container').appendTo(container);

            if (typeof opts.menuLabel === "string") {
                moreContainer.append(
                '<div class="w-more-title">' + localizeToolbarText(opts.menuLabel) + '</div>',
                '<div class="w-more-divider"></div>');
            }

            isString = typeof opts.menuPosition === "string";
            isArray = opts.menuPosition instanceof Array;
            if (isString || isArray) {
                if (opts.menuPosition instanceof Array) 
                    container.addClass('w-more-' + opts.menuPosition.join(' w-more-'));
                else 
                    container.addClass('w-more-' + opts.menuPosition);

                if (opts.menuPosition === 'center' || opts.menuPosition.indexOf('center') !== - 1) {
                    if (typeof opts.width === 'number') 
                        moreContainer.css('left', - opts.width / 2);
                }
            }

            isString = isArray = null;
            isString = typeof opts.menuClassNames === "string";
            isArray = opts.menuClassNames instanceof Array;
            if (isString || isArray) {
                if (isArray) 
                    moreContainer.addClass(opts.menuClassNames.join(' '));
                else 
                    moreContainer.addClass(opts.menuClassNames);
            }

            return moreContainer;


        case 'more-divider':
            return container.addClass('w-more-divider');

        case 'radio':
            opts.type = 'more';
            var name = opts.name;
            delete opts.name;
            var moreContainer = createUI(opts, container, inst);
            $.each(opts.options, function(index, option) {
                $("<div/>").
                data("option_value", option.value).
                addClass(opts.menuItemClassNames).
                addClass('w-menu-radio-item').
                append($("<img/>").attr("src", option.icon).css({
                    "position": "relative",
                    "top": option.top
                })).
                appendTo(moreContainer).
                click(function() {
                    activeToolbar.set(name, option.value, false);
                    trigger(name, option.value, inst);
                });
            });
            container.addClass('w-menu-radio');
            setIdentifier(container, name);
            return moreContainer;

        case 'button-grid':
            opts.type = 'more';
            var buttonContainer = createUI(opts, container, inst);
            var instances = processItems(buttonContainer, opts.items, inst);
            buttonContainer.data('toolbar_instances', instances);
            return buttonContainer;

        case 'radio-set':

            opts.type = 'more';
            var name = opts.name;
            var moreContainer = createUI(opts, container, inst),
            setContainer = $("<div/>").
            addClass("w-radio-set-container"),
            dropdownItems = createRadioSetDropdown(opts, moreContainer, setContainer);

            $('<div/>')
            .addClass('w-more-divider').
            appendTo(setContainer);

            $.each(opts.options, function(key, options) {
                var currContainer = $("<div/>").
                addClass(opts.menuOptionClass).
                addClass(opts.menuOptionClass + "-" + key).
                data("dropdown-item", key);

                if (opts.selectedValue === key) {
                    currContainer.
                    removeClass("w-radio-set").
                    addClass("w-radio-set-selected");
                }

                currContainer.appendTo(setContainer);

                $.each(options, function(index, option) {
                    //create lists here
                    $("<div/>").
                    data("option_value", option.value).
                    addClass(opts.menuItemClassNames).
                    addClass('w-menu-radio-item').
                    append($("<img/>").attr("src", option.icon).css({
                        "position": "relative"
                    })).
                    appendTo(currContainer).
                    click(function() {
                        activeToolbar.set(name, option.value, false); //display active state in toolbar UI
                        trigger(name, option.value, inst); //changes divider itself
                    });
                });
            });
            setContainer.appendTo(moreContainer);
            container.addClass('w-menu-radio').addClass('w-menu-radio-set');
            setIdentifier(container, name);
            return moreContainer;
        }
    },
    createRadioSetDropdown = function(opts, container, setContainer) {
        var dropdownOptions = {};

        // Marshal data
        dropdownOptions.label = opts.dropdownTitle;
        dropdownOptions.type = 'dropdown';
        dropdownOptions.options = [];
        dropdownOptions.name = opts.name + "-drop-down";


        var i = 0;
        $.each(opts.options, function(key, val) {
            dropdownOptions.options[i] = {
                "label": key,
                "value": key
            };
            i++;
        });

        dropdownOptions.selectedValue = (typeof opts.selectedValue !== "undefined") ? opts.selectedValue : dropdownOptions.options[0];

        var dropdownItems = createUI(dropdownOptions,
        container,
        {
            change: function(name, val) {
                setContainer.children().
                removeClass("w-radio-set-selected").
                addClass("w-radio-set");

                setContainer.find(".w-radio-set-" + val).
                removeClass("w-radio-set").
                addClass("w-radio-set-selected");
            }
        });

        return dropdownItems;
    },
    /**
    	 * Shared logic among most UI types such as setting class names, ID, css, etc.
    	 */
    createUIHelper = function(el, opts) {
        if (typeof opts.css === "object") 
            el.css(opts.css);
        if (typeof opts._id === "string") 
            el.attr("id", opts._id);
        if (typeof opts.style === 'string') 
            el.addClass(opts.btnPrefix + '-' + opts.style);

        if (typeof opts.classNames !== "undefined") {
            if (opts.classNames instanceof Array) 
                el.addClass(opts.classNames.join(' '));
            else if (typeof opts.classNames === "string") 
                el.addClass(opts.classNames);
        }
    },
    /**
    	 * sets a unique class name in the scope of a certain toolbar using opts.name and opts.val
    	 */
    setIdentifier = function(el, opts) {
        return el.addClass(getIdentifier(opts));
    },
    getIdentifier = function(name, value) {
        var id;
        if (typeof name === "object") {
            value = name.value;
            name = name.name;
        }
        if (typeof name === "string") {
            id = idPrefix + name;
            if (typeof value === "string") 
                id += "-" + value;
        }
        return id;
    },
    /**
    	 * Iterate through each toolbar item and create the UI
    	 * this id different from createUI in that it can creates an interactive layer with many UI elements
    	 * @param 	tbc 	toolbar container
    	 * @param 	items 	toolbar items
    	 */
    processItems = function(tbc, items, self) {

        var itemMap = {};

        $.each(items, function(index, item) {
            var tbi = $('<li/>').appendTo(tbc), // toolbar item
            menu = item.menu,
            type = item.type,
            moreContainer, moreList;

            if (typeof type !== 'string') 
                type = item.type = 'button'; // set default button

            if (type === 'menu') {
                // If type is menu, we create a "w-more" dropdown
                moreContainer = createUI($.extend({}, item, {
                    type: 'more'
                }), tbi);
                moreList = $('<ul/>').addClass('w-more_list').appendTo(moreContainer);

                if (item.width) {
                    moreList.width(item.width);
                    moreContainer.width(item.width);
                }

                // Build "w-more" menu items
                $.each(menu, function(index, menuItem) {
                    var moreItem = $('<li/>').addClass('clearfix').appendTo(moreList);
                    var menuInstnace;
                    if (menuItem instanceof Array) {
                        // if menu item is array, recursively process items
                        var menuContainer = $('<ul/>').appendTo(moreItem).addClass('more_item_container');
                        menuInstance = processItems(menuContainer, menuItem, self);
                    } else {
                        if (typeof menuItem.type !== 'string') 
                            menuItem.type = 'link';
                        if (!menuItem.name) 
                            menuItem.name = item.name;
                        menuInstance = createUI(menuItem, moreItem, self);
                    }
                    if (item.name) 
                        itemMap[item.name] = menuInstance;
                });

            } else {
                var itemInstance = createUI(item, tbi, self);
                if (item.name) 
                    itemMap[item.name] = itemInstance;
            }

        });

        return itemMap;
    },

    /**
    	 * Builds the toolbar UI
    	 * @param 	menu 	JSON object to build
    	 * @param 	type 	String ID of the toolbar
    	 * @return 	el 		jQuery reference to the <menu/> element of the toolbar UI
    	 */
    build = function(menu, type) {
        var
        // create Toolbar Container
        toolbarContainer = $('<menu/>', {
            'class': 'left_tools',
            'id': 'edit_toolbar_' + type,
            'type': 'toolbar'
        }),
        icon = menu.icon,
        items = menu.items,
        title = translate( "webs.bldr.modules." + type + ".toolbar.tooltip" );

        toolbarIcon = $('<li/>').addClass('toolbar_icon').appendTo(toolbarContainer);
        toolbarIconLink = $("<a>").attr({
            title: title 
        }).css({
            display: "block",
            width: "100%",
            height: "100%" 
        }).appendTo(toolbarIcon);

        mtb.append(toolbarContainer);

        // Setting toolbar icon
        if (typeof icon === 'string') {
            toolbarIcon.addClass('toolbar_icon_' + icon);
        } else if (typeof icon === 'object') {
            toolbarIcon.css(icon);
        }

        if (items) 
            processItems(toolbarContainer, items);

        return toolbarContainer;
    },



    /**
    	 * Prototypal methods for the toolbar class
    	 */
    inheritedMethods = {


        /**
        		 * Shows the toolbar UI, sets active toolbar to the instance calling this
        		 */
        show: function(state) {
            var self = this;

            // Different toolbar instance. Collapse everything
            if (this !== activeToolbar) {
                this.collapse(); //find(".w-dropdown-container, .w-more, .iD-input-container").removeClass("active");
            }
            pub.switchToolbar(this);
            if (typeof(state) === 'object') {
                $.each(state, function(name, val) {
                    self.set(name, val);
                });
            }
        },

        /**
        		 * Closes all expanded items in this toolbar
        		 */
        collapse: function collapse() {
            this.find(".w-dropdown-container, .w-more, .iD-input-container").removeClass("active");
        },

        /**
        		 * Sets popover feedback
        		 */
        setFeedback: function($el) {
            if (!$el.jquery) 
                return false;
            this.feedback = {
                ref : $el 
            };
            return true;
        },

        find: function(selector) {
            return toolbars[this.type].find(selector);
        },

        /**
        		 * Grabs the toolbar ui
        		 */
        get$Toolbar: function() {
            return toolbars[this.type];
        },


        /**
        		 * Gets Popover instance tied to a "name"
        		 */
        getDialog: function(name) {
            return this.find("." + getIdentifier(name)).data("popover");
        },


        /**
        		 * A bit different from find in that you don't pass a jQuery selector, you pass the static types
        		 * Example: typeface ul, frames container, and iconset container all have predictable classes
        		 */
        getElement: function(type) {
            if (typeof type !== "string") 
                return null;
            if (type === "Fonts Dropdown") 
                return this.find(".w-fonts-container .w-dropdown-ul");
        },

        /**
        		 * Allows easy retrieval of instatiated dropdown
        		 */
        callDropdown: function(type, method, param) {
            var dropdownElement = this.getElement(type),
            dropdownController = dropdownElement.data('dropdown');
            if (dropdownElement && dropdownController) 
                return dropdownController[method](param);
        },

        /**
        		 * Allows certain UI items to be updated with new content
        		 * For instance, changing the text of a link or replacing the dropdown options
        		 * TODO: Current assumes "key" is the "name" identifier. For buttons, we use value as well as name
        		 * to yield unique identifier.
        		 */
        updateUI: function(opts) {
            var element;
            for (var name in opts) {
                if (opts.hasOwnProperty(name)) {
                    // Grabs element identifier
                    element = this.find("." + getIdentifier(name));

                    // Element update logic. Look in set() for identifier reference
                    if (element.hasClass("webs-ui-dropdown")) {
                        element.data("dropdown").replaceOptions(opts[name]);
                    }
                }
            }

        },

        /**
        		 * Set values associated with a given "name" on the toolbar
        		 */
        set: function(name, val, justPressed) {
            this.suspendListeners = true;

            // Identify type:
            var element = [], self = this;
            try {
                element = this.find("." + getIdentifier(name, val));
            } catch (e) {}
            if (!element.length) 
                element = this.find("." + getIdentifier(name));
            if (element.hasClass("w-menu-radio")) {
                element.find(".selected").removeClass("selected");
                $.each(element.find(".w-menu-radio-item"), function(index, item) {
                    if ($(item).data("option_value") === val) {
                        $(item).addClass('selected');
                        if (element.hasClass("w-menu-radio-set")) {
                            var dropdown = top.$("." + getIdentifier(name + "-drop-down")).
                            data("dropdown").
                            callOption($(item).parent().data("dropdown-item"));
                        }
                    }
                });
            } else if (element.hasClass("webs-ui-dropdown")) {
                if (typeof val === "boolean") 
                    val = val.toString();
                element.data("dropdown").setOption(val);
            } else if (element.hasClass("webs-ui-select")) {
                element.val(val);
                element.change();
            } else if (element.hasClass("w-toolbar-textfield-input")) {
                element.val(val);
            } else if (element.hasClass("w-switch")) {
                element[val ? "addClass" : "removeClass"]("active");
                if (bldr.IE <= 8) 
                    element.hide().show(); // Force reflow in IE8
            } else if (element.hasClass("numberInput" || element.hasClass("w-numberInput"))) {
                element.data('numberInput').set(val);
            } else if (element.hasClass("w-colorpicker-container") || element.hasClass("colorpicker-menu")) {
                element.data("iDropper").set(val);
            } else if (element.hasClass("w-tb-button")) {

                // set popover data
                if (element.data('popover')) 
                    element.data('value', val);

                var cancelGroup = element.parent('.bldr-button-cancel-group');
                if (cancelGroup.length) {
                    // button with attached cancel button
                    cancelGroup[val ? "removeClass" : "addClass"]("canceled");
                } else {

                    // stickiness
                    var active = justPressed ? element.hasClass('active') : !val;
                    var group = element.parents("." + buttonGroupClass);
                    if (group.length > 0 && group.data('distinct')) {
                        // if it's in a distinct group, depress all others in the group
                        group.find('a.active').removeClass('active');
                    }

                    // if it's already active, and it's not in a distinct group, depress it
                    var activeIndistinct = active && (group.length === 0 || !group.data('distinct'));
                    element[activeIndistinct ? "removeClass" : "addClass"]("active");
                }
            } else {
                if (name === "icon") {
                    var li = this.find("li." + getIdentifier("icon"));
                    li.find(".currentSelection").removeClass("currentSelection");
                    $.each(li.find(".select_li"), function(i, item) {
                        if (val && val.set && $(item).html().toLowerCase() === val.set) {
                            var $originalSelect = li.find("select");
                            $originalSelect[0].selectedIndex = $(item).attr('rel');
                            $originalSelect.change();
                            li.find(".bldr-iconSet-ul-" + val.set).find("[title='" + val.slug + "']").parent().addClass("currentSelection")
                        }
                    });
                }
            }

            this.suspendListeners = false;
        },


        /**
        		 * Trigger click event on the specified name
        		 * @param 	name 	Name of link specified in JSON object during build
        		 * @param 	val 	Value of link specified in JSON object
        		 */
        click: function(name, val) {
            $('a[href="#' + name + '"]', toolbars[this.type]).click();
        },


        /**
        		 * Press button with specified name-val, appends active class
        		 * @param 	name 	Name of link specified in JSON object during build
        		 * @param 	val 	Value of link specified in JSON object
        		 */
        press: function(name, val) {
            $('a[href="#' + name + '-' + val + '"]', toolbars[this.type]).addClass('active');
        },


        /**
        		 * Depress the button
        		 * @param 	name 	Name of link specified in JSON object during build
        		 * @param 	val 	Value of link specified in JSON object
        		 */
        depress: function(name, val) {
            $('a[href="#' + name + '-' + val + '"]', toolbars[this.type]).removeClass('active');
        },


        /**
        		 * Depress all buttons on the toolbar and set them to their default state.
        		 */
        clear: function() {
            $('.active', toolbars[this.type]).removeClass('active');
        },


        /**
        		 * You can pass in a listener as a function and perform case check
        		 * OR you can pass in an event name and listener function
        		 * OR you can pass in a JSON map of event names to listener functions
        		 * TODO: create an unbind method
        		 */
        addListener: function(event, fn) {
            if (!this.eventListeners) 
                this.eventListeners = {
                    "default": [] 
                };

            var self = this,
            events = this.eventListeners;


            if (typeof event === 'object') {
                for (var key in event) {
                    if (event.hasOwnProperty(key))
                        this.addListener(key, event[key]);
                }
            } else if (typeof event === 'string') {
                if (typeof events[event] !== 'object' || !(events[event] instanceof Array)) 
                    events[event] = [];
                events[event].push(fn);
            } else if (typeof event === 'function') {
                events['default'].push(event);
            }

            return this;
        },


        /**
        		 * Triggers the attached listener with value
        		 * @param 	name 	Listener to fire
        		 * @param 	val 	parameter to fire the listener with
        		 */
        change: function(event, param) {
            if (this.suspendListeners) 
                return;
            if (!this.eventListeners) 
                this.eventListeners = {
                    "default": [] 
                };

            var events = this.eventListeners,
            originalEvent = event;

            if (typeof events[event] !== 'object' || !(events[event] instanceof Array)) 
                event = 'default';

            for (var i = 0; i < events[event].length; i++) {
                if (typeof events[event][i] === 'function') 
                    events[event][i](param, originalEvent);
            }
        },

        /**
        		 * Adding bind and trigger since that's what we call it everywhere else
        		 */
        bind: function(event, fn) {
            return this.addListener(event, fn);
        },
        trigger: function(event, param) {
            return this.change(event, param);
        },


        /**
        		 * Clear all event listeners
        		 */
        reset: function() {
            this.clear();
            this.eventListeners = null;
        }
    };


    /**
    	 * Building shared UI. Only one copy of these are created and
    	 * appended into the toolbar during a switchToolbar
    	 */
    (function createFramesets() {
        $frames = $('<ul/>').addClass('bldr-framesets-ul');

        // fixing the frameset data so that it's createUI-compatible
        var _framesList = [];
        for (var slug in _frames) {
            if (_frames.hasOwnProperty(slug)) {
                _frames[slug].name = 'setFrame';
                _frames[slug].value = slug;
                _frames[slug].classNames = ['w-frame-' + slug, 'w-frame'];
                _frames[slug].css = {
                    'background-image': 'url(' + _frames[slug].preview + ')' 
                };
                _framesList.push(_frames[slug]);
            }
        }

        $frames.append(
        $('<li/>').addClass('w-more-title').html(translate('webs.bldr.toolbar.text.framePicker')),
        $('<li/>').addClass('w-more-divider'));
        var frameWrap = $('<li/>').addClass('bldr-frame-wrap').appendTo($frames);
        var setList = $('<ul/>').addClass('bldr-frame-ul').appendTo(frameWrap);
        var removeFrame = createUI({
            type: 'button',
            label: 'Remove Frame',
            name: 'setFrame',
            value: null,
            classNames: ['w-frame', 'w-frame-none']
        }, $('<li/>').appendTo(setList));

        processItems(setList, _framesList);
        setList.find('a').removeClass(buttonPrefix + ' ' + buttonPrefix + '-text w-tb-button');

    })();

    (function createIconsets() {
        $iconsets = $('<ul/>').addClass('bldr-iconsets-ul');
        $.each(_iconsets, function(i, set) {
            set.value = set.slug;
        });

        var setList, iconsets = {},
        iconStyleContainer = $('<div/>').addClass('bldr-icon-style'),
        iconAlignContainer = $('<div/>').addClass('bldr-icon-alignment');

        // Set selection dropdown
        var customDropdown = createUI({
            "type": "select",
            "name": "iconStyle",
            "width": 108,
            "options": _iconsets
        }, iconStyleContainer, {
            change: function(name, val) {
                iconWrap.children().removeClass('active');
                iconsets[val].addClass('active');
                $(iconsets[val]).css({
                    "max-height": ($(window).height() - 250) + "px",
                    "overflow-x": "hidden",
                    "overflow-y": "auto"
                });
            }
        });
        $iconsets.data("customDropdown", customDropdown);

        // Alignment
        createUI({
            type: 'button-group',
            sticky: true,
            distinct: true,
            items: [
            {
                label: 'Left',
                style: 'silver',
                icon: 'align_left',
                name: 'positionIcon',
                value: 'left' 
            },
            {
                label: 'Right',
                style: 'silver',
                icon: 'align_right',
                name: 'positionIcon',
                value: 'right' 
            }
            ]
        }, iconAlignContainer);

        // Fix style on silver alignment icons
        iconAlignContainer.find('.w-btn-icon').removeClass('w-btn-icon').addClass('w-btnstates');


        $iconsets.append(
        $('<li/>').addClass('w-more-title').html(translate('webs.bldr.toolbar.text.iconPicker')),
        $('<li/>').addClass('w-more-divider'),
        $('<li/>').addClass('clearfix').append(iconStyleContainer, iconAlignContainer),
        $('<li/>').addClass('w-more-divider')
        );





        var iconWrap = $('<li/>').addClass('bldr-icon-wrap').appendTo($iconsets);
        $.each(_iconsets, function(i, set) {
            setList = $('<ul/>').addClass('bldr-icon-ul').addClass('bldr-iconSet-ul-' + set.slug).appendTo(iconWrap);
            if (i === 0) 
                setList.addClass('active');

            iconsets[set.slug] = setList;

            // fixing the iconset data so that it's createUI-compatible
            var path = set.path || top.webs.props.staticServer + '/static/projects/finch/images/icon_sets/' + set.slug + '/';
            $.each(set.items, function(i, item) {
                item.setActive = true;
                item.clearActive = true;
                item.name = 'setIcon';
                item.value = {
                    enable: true,
                    set: set.slug,
                    slug: item.slug 
                };
                item.css = {
                    'background-image' : 'url(' + path + '/' + item.slug + '.png)' 
                };
            });

            // Remove Icon Button
            createUI({
                clearActive: true,
                type: 'button',
                label: 'Remove Icon',
                name: 'removeIcon',
                classNames: 'w-icon-none'
            }, $('<li/>').addClass("removeIcon").appendTo(setList));

            // Build the rest of the icon buttons
            processItems(setList, set.items);
        });
        iconWrap.find('a').removeClass(buttonPrefix + ' ' + buttonPrefix + '-text w-tb-button');

    })();

    var pub = {

        /**
        		 * Exposing createUI. Currently ModuleBar also uses it
        		 */
        createUI: createUI,


        /**
        		 * Creates an instance of a toolbar type. The UI is already available from register.
        		 * @param 	type 	String ID of toolbar to create
        		 * @param	klass 	object to merge into the instance of toolbar
        		 * @return 	inst 	new toolbar instance
        		 */
        create: function(type, klass) {

            // lazy build toolbars
            if (!toolbars[type]) {
                if (!toolbarJSON[type]) 
                    return false;
                toolbars[type] = build(toolbarJSON[type], type);
            }

            var inst = Object.create($.extend(inheritedMethods, klass));
            inst.type = type;

            return inst;
        },


        /**
        		 * Registers a toolbar type.
        		 * @param	type 	String ID of toolbar to register
        		 * @param	JSON 	JSON object of toolbar UI to build
        		 */
        register: function(type, JSON) {
            toolbarJSON[type] = JSON;
        },


        /**
        		 * Getter method for toolbar
        		 * @param 	type 	String ID of toolbar to retrieve
        		 */
        getToolbar: function(type) {
            return toolbars[type];
        },


        /**
        		 * Determine whether or not any toolbar is currently active.
        		 * @return {Boolean} true if a toolbar is currently displayed
        		 */
        isActive: function() {
            return !!activeToolbar;
        },

        /**
        		 * Called from show, slides the current toolbar out and the new one in if the toolbar types are different
        		 * @param 	toolbar 	new toolbar instance to switch to
        		 */
        switchToolbar: function(toolbar) {

            // If switching from one toolbar to another too quickly, we need to stop animaiton and fast forward
            if (isAnimating) {
                isAnimating = false;
                mtb.stop(true, true);
            }


            // no toolbar passed in, hide mtb
            if (typeof toolbar === 'undefined') {
                if (activeToolbar) {
                    mtbContainer.addClass('overflow');
                    mtb.animate({
                        top: - 32
                    }, 200, function() {
                        $('.left_tools.active').removeClass('active');
                        $('#edit_toolbar').css({
                            display: "none"
                        });
                        mtb.css('top', - 32);
                        isAnimating = false;
                    });
                    isAnimating = true;
                } else {
                    $('.left_tools.active').removeClass('active');
                    $('#edit_toolbar').css({
                        display: "none"
                    });
                }
                activeToolbar = null;
                return false;
            } else {
                $('#edit_toolbar').css({
                    display: "block"
                });
            }

            $('.more_wrap').hide();


            // Current toolbar UI is the one shown, just update active Toolbar
            if (activeToolbar && toolbar.type === activeToolbar.type) {
                activeToolbar = toolbar;
                return false;
            }


            // preparing for animation
            var newToolbar = toolbars[toolbar.type];
            mtbContainer.addClass('overflow');


            isAnimating = true;
            if (!activeToolbar) {
                newToolbar.addClass('active');
                activeToolbar = toolbar;
                mtb.animate({
                    top: 0
                }, 200, function() {
                    mtbContainer.removeClass('overflow');
                    isAnimating = false;
                });
            } else {
                activeToolbar = toolbar;
                mtb.animate({
                    top: - 30
                }, 200, function() {
                    $('.left_tools.active').removeClass('active');
                    newToolbar.addClass('active');
                    mtbContainer.addClass('overflow');
                    mtb.css('top', - 30);

                    mtb.animate({
                        top: 0
                    }, 200, function() {
                        mtbContainer.removeClass('overflow');
                        mtb.css('top', 0);
                        isAnimating = false;
                    });
                });
            }

            // activating shared toolbar items
            var framesContainer = newToolbar.find('.bldr-framesets');
            if (framesContainer.length) 
                framesContainer.append($frames);

            var iconsContainer = newToolbar.find('.bldr-iconsets');
            if (iconsContainer.length) 
                iconsContainer.append($iconsets);

        }
    };

    return pub;

});
/* jshint ignore:end */
;
define('internal/sitebuilder/builderChrome/toolbar.text', ['internal/sitebuilder/builderChrome/toolbar'], function(toolbar) {
    toolbar.register('text', {
        icon: 'text',
        items: [
        {
            "type": "dropdown_font_size",
            "width": 50,
            "selectedValue": 14,
            //This may be overridden by the theme"s font-size.
            "name": "wzSetFontSize",
            "dataType": "text",
            "options": [
            {
                "label": "fontSize.8",
                "value": "8" 
            },
            {
                "label": "fontSize.10",
                "value": "10" 
            },
            {
                "label": "fontSize.11",
                "value": "11" 
            },
            {
                "label": "fontSize.12",
                "value": "12" 
            },
            {
                "label": "fontSize.14",
                "value": "14" 
            },
            {
                "label": "fontSize.16",
                "value": "16" 
            },
            {
                "label": "fontSize.18",
                "value": "18" 
            },
            {
                "label": "fontSize.24",
                "value": "24" 
            },
            {
                "label": "fontSize.36",
                "value": "36" 
            },
            {
                "label": "fontSize.48",
                "value": "48" 
            },
            {
                "label": "fontSize.72",
                "value": "72" 
            }
            ]
        },
        {
            type: 'colorpicker',
            icon: 'text_color',
            menuLabel: 'Text Color',
            menuPosition: 'left',
            label: 'Color',
            name: 'wzForeColor',
            value: '#069FF0'
        },
        {
            type: 'button-group',
            sticky: true,
            distinct: false,
            items: [
            {
                label: 'Bold',
                icon: 'bold',
                name: 'bold' 
            },
            {
                label: 'Italic',
                icon: 'italic',
                name: 'italic' 
            },
            {
                label: 'Underline',
                icon: 'underline',
                name: 'underline' 
            },
            {
                label: 'Strikethrough',
                icon: 'strike',
                name: 'strikethrough' 
            }
            ]
        },
        {
            type: 'button-group',
            sticky: true,
            distinct: true,
            items: [
            {
                label: 'Align Left',
                icon: 'align_left',
                name: 'JustifyLeft',
                value: 'left' 
            },
            {
                label: 'Align Center',
                icon: 'align_center',
                name: 'JustifyCenter',
                value: 'center' 
            },
            {
                label: 'Align Right',
                icon: 'align_right',
                name: 'JustifyRight',
                value: 'right' 
            },
            {
                label: 'Align Justify',
                icon: 'align_justify',
                name: 'JustifyFull',
                value: 'justify' 
            }
            ]
        },
        {
            type: 'button-group',
            items: [
            {
                label: 'Outdent',
                icon: 'outdent',
                name: 'outdent' 
            },
            {
                label: 'Indent',
                icon: 'indent',
                name: 'indent' 
            }
            ]
        },
        {
            icon: 'list',
            type: 'menu',
            label: 'List',
            name: 'wzList',
            menuClassNames: 'w-more-bullet',
            menu: [
            {
                label: 'None',
                value: 'none'
            },
            {
                label: '&#9679;',
                // &#8226;
                value: 'disc'
            },
            {
                label: '&#9675;',
                value: 'circle'
            },
            {
                label: '&#9632;',
                value: 'square'
            },
            {
                label: 'bullet.decimal',
                value: 'decimal'
            },
            {
                label: 'bullet.upperAlpha',
                value: 'upper-alpha'
            },
            {
                label: 'bullet.lowerAlpha',
                value: 'lower-alpha'
            },
            {
                label: 'bullet.upperRoman',
                value: 'upper-roman'
            },
            {
                label: 'bullet.lowerRoman',
                value: 'lower-roman'
            }
            ]
        },
        {
            type: 'button',
            icon: 'eraser',
            label: 'Clear Formatting',
            name: 'RemoveFormat'
        },
        {
            type: 'button-cancel',
            icon: 'link',
            label: 'Link',
            showLabel: true,
            name: 'wzLink',
            groupClass: 'w-wizzy-linkgroup',
            classNames: 'w-wizzy-linkbutton',
            dialog: {
                url: '/s/sitebuilder/dialogs/link',
                localizeHeading: "webs.bldr.dialog.link.popover.heading",
                width: 590,
                height: 366
            },
            cancel: {
                style: 'red',
                icon: 'unlink',
                label: 'Remove Link',
                name: 'wzUnlink'
            }
        }
        ]
    });
});
define('internal/sitebuilder/builderChrome/toolbar.text_fonts', ['internal/sitebuilder/builderChrome/toolbar'], function(toolbar) {
    toolbar.register('text_fonts', {
        icon: 'text',
        items: [
        {
            type: "dropdown_fonts",
            name: "SetFont"
        },
        {
            type: 'dropdown_font_size',
            width: 50,
            selectedValue: 14,
            //This may be overridden by the theme's font-size.
            name: 'wzSetFontSize',
            dataType: 'text',
            options: [
            {
                label: 'fontSize.8',
                value: '8' 
            },
            {
                label: 'fontSize.10',
                value: '10' 
            },
            {
                label: 'fontSize.11',
                value: '11' 
            },
            {
                label: 'fontSize.12',
                value: '12' 
            },
            {
                label: 'fontSize.14',
                value: '14' 
            },
            {
                label: 'fontSize.16',
                value: '16' 
            },
            {
                label: 'fontSize.18',
                value: '18' 
            },
            {
                label: 'fontSize.24',
                value: '24' 
            },
            {
                label: 'fontSize.36',
                value: '36' 
            },
            {
                label: 'fontSize.48',
                value: '48' 
            },
            {
                label: 'fontSize.72',
                value: '72' 
            }
            ]
        },
        {
            type: 'colorpicker',
            icon: 'text_color',
            menuLabel: 'Text Color',
            menuPosition: 'left',
            label: 'Color',
            name: 'wzForeColor',
            value: '#069FF0'
        },
        {
            type: 'button-group',
            sticky: true,
            distinct: false,
            items: [
            {
                label: 'Bold',
                icon: 'bold',
                name: 'bold' 
            },
            {
                label: 'Italic',
                icon: 'italic',
                name: 'italic' 
            },
            {
                label: 'Underline',
                icon: 'underline',
                name: 'underline' 
            },
            {
                label: 'Strikethrough',
                icon: 'strike',
                name: 'strikethrough' 
            }
            ]
        },
        {
            type: 'button-group',
            sticky: true,
            distinct: true,
            items: [
            {
                label: 'Align Left',
                icon: 'align_left',
                name: 'JustifyLeft',
                value: 'left' 
            },
            {
                label: 'Align Center',
                icon: 'align_center',
                name: 'JustifyCenter',
                value: 'center' 
            },
            {
                label: 'Align Right',
                icon: 'align_right',
                name: 'JustifyRight',
                value: 'right' 
            },
            {
                label: 'Align Justify',
                icon: 'align_justify',
                name: 'JustifyFull',
                value: 'justify' 
            }
            ]
        },
        {
            type: 'button-group',
            items: [
            {
                label: 'Outdent',
                icon: 'outdent',
                name: 'outdent' 
            },
            {
                label: 'Indent',
                icon: 'indent',
                name: 'indent' 
            }
            ]
        },
        {
            icon: 'list',
            type: 'menu',
            label: 'List',
            name: 'wzList',
            menuClassNames: 'w-more-bullet',
            menu: [
            {
                label: 'None',
                value: 'none'
            },
            {
                label: '&#9679;',
                // &#8226;
                value: 'disc'
            },
            {
                label: '&#9675;',
                value: 'circle'
            },
            {
                label: '&#9632;',
                value: 'square'
            },
            {
                label: 'bullet.decimal',
                value: 'decimal'
            },
            {
                label: 'bullet.upperAlpha',
                value: 'upper-alpha'
            },
            {
                label: 'bullet.lowerAlpha',
                value: 'lower-alpha'
            },
            {
                label: 'bullet.upperRoman',
                value: 'upper-roman'
            },
            {
                label: 'bullet.lowerRoman',
                value: 'lower-roman'
            }
            ]
        },
        {
            type: 'button',
            icon: 'eraser',
            label: 'Clear Formatting',
            name: 'RemoveFormat'
        },
        {
            type: 'button-cancel',
            icon: 'link',
            label: 'Link',
            showLabel: true,
            name: 'wzLink',
            groupClass: 'w-wizzy-linkgroup',
            classNames: 'w-wizzy-linkbutton',
            dialog: {
                url: '/s/sitebuilder/dialogs/link',
                localizeHeading: "webs.bldr.dialog.link.popover.heading",
                width: 590,
                height: 366
            },
            cancel: {
                style: 'red',
                icon: 'unlink',
                label: 'Remove Link',
                name: 'wzUnlink'
            }
        }
        ]
    });
});
define('internal/sitebuilder/builderChrome/toolbar.title', ['internal/sitebuilder/builderChrome/toolbar'], function(toolbar) {
    toolbar.register('title', {
        icon: 'title',
        items: [
        {
            type: "dropdown_fonts",
            name: "SetFont"
        },
        {
            type: 'dropdown_font_size',
            width: 50,
            selectedValue: 18,
            //This may be overridden by the theme's font-size.
            name: 'wzSetFontSize',
            dataType: 'title',
            options: [
            {
                label: 'fontSize.8',
                value: '8' 
            },
            {
                label: 'fontSize.10',
                value: '10' 
            },
            {
                label: 'fontSize.11',
                value: '11' 
            },
            {
                label: 'fontSize.12',
                value: '12' 
            },
            {
                label: 'fontSize.14',
                value: '14' 
            },
            {
                label: 'fontSize.16',
                value: '16' 
            },
            {
                label: 'fontSize.18',
                value: '18' 
            },
            {
                label: 'fontSize.24',
                value: '24' 
            },
            {
                label: 'fontSize.36',
                value: '36' 
            },
            {
                label: 'fontSize.48',
                value: '48' 
            },
            {
                label: 'fontSize.72',
                value: '72' 
            }
            ]
        },
        {
            icon: 'star',
            type: 'iconsets',
            menuPosition: 'left',
            label: 'Icon',
            name: 'setIcon',
            hideAlignment: true,
            width: 170
        },
        {
            type: 'colorpicker',
            icon: 'text_color',
            menuLabel: 'Text Color',
            menuPosition: 'left',
            label: 'Color',
            name: 'wzForeColor',
            value: '#069FF0'
        },
        {
            type: 'button-group',
            sticky: true,
            distinct: false,
            items: [
            {
                label: 'Bold',
                icon: 'bold',
                name: 'bold' 
            },
            {
                label: 'Italic',
                icon: 'italic',
                name: 'italic' 
            },
            {
                label: 'Underline',
                icon: 'underline',
                name: 'underline' 
            },
            {
                label: 'Strikethrough',
                icon: 'strike',
                name: 'strikethrough' 
            }
            ]
        },
        {
            type: 'button-group',
            sticky: true,
            distinct: true,
            items: [
            {
                label: 'Align Left',
                icon: 'align_left',
                name: 'align',
                value: 'left' 
            },
            {
                label: 'Align Center',
                icon: 'align_center',
                name: 'align',
                value: 'center' 
            },
            {
                label: 'Align Right',
                icon: 'align_right',
                name: 'align',
                value: 'right' 
            }
            ]
        },
        {
            type: 'button',
            icon: 'eraser',
            label: 'Clear Formatting',
            name: 'RemoveFormat'
        },
        {
            type: 'button-cancel',
            icon: 'link',
            label: 'Link',
            showLabel: true,
            name: 'wzLink',
            groupClass: 'w-wizzy-linkgroup',
            classNames: 'w-wizzy-linkbutton',
            dialog: {
                url: '/s/sitebuilder/dialogs/link',
                localizeHeading: "webs.bldr.dialog.link.popover.heading",
                width: 590,
                height: 366
            },
            cancel: {
                style: 'red',
                icon: 'unlink',
                label: 'Remove Link',
                name: 'wzUnlink'
            }
        }

        ]
    });
});
define('internal/sitebuilder/builderChrome/toolbar.text_condensed', ['internal/sitebuilder/builderChrome/toolbar'], function(toolbar) {
    toolbar.register('text_condensed', {
        icon: 'text',
        items: [
        {
            "type": "dropdown_font_size",
            "width": 50,
            "selectedValue": 14,
            //This may be overridden by the theme"s font-size.
            "name": "wzSetFontSize",
            "dataType": "text",
            "options": [
            {
                "label": "fontSize.8",
                "value": "8" 
            },
            {
                "label": "fontSize.10",
                "value": "10" 
            },
            {
                "label": "fontSize.11",
                "value": "11" 
            },
            {
                "label": "fontSize.12",
                "value": "12" 
            },
            {
                "label": "fontSize.14",
                "value": "14" 
            },
            {
                "label": "fontSize.16",
                "value": "16" 
            },
            {
                "label": "fontSize.18",
                "value": "18" 
            },
            {
                "label": "fontSize.24",
                "value": "24" 
            },
            {
                "label": "fontSize.36",
                "value": "36" 
            },
            {
                "label": "fontSize.48",
                "value": "48" 
            },
            {
                "label": "fontSize.72",
                "value": "72" 
            }
            ]
        },
        {
            type: 'colorpicker',
            icon: 'text_color',
            menuLabel: 'Text Color',
            menuPosition: 'left',
            label: 'Color',
            name: 'wzForeColor',
            value: '#069FF0'
        },
        {
            type: 'button-group',
            sticky: true,
            distinct: false,
            items: [
            {
                label: 'Bold',
                icon: 'bold',
                name: 'bold' 
            },
            {
                label: 'Italic',
                icon: 'italic',
                name: 'italic' 
            },
            {
                label: 'Underline',
                icon: 'underline',
                name: 'underline' 
            },
            {
                label: 'Strikethrough',
                icon: 'strike',
                name: 'strikethrough' 
            }
            ]
        },
        {
            type: 'button',
            icon: 'eraser',
            label: 'Clear',
            name: 'RemoveFormat'
        },
        {
            type: 'button-cancel',
            icon: 'link',
            label: 'Link',
            name: 'wzLink',
            groupClass: 'w-wizzy-linkgroup',
            classNames: 'w-wizzy-linkbutton',
            dialog: {
                url: '/s/sitebuilder/dialogs/link',
                localizeHeading: "webs.bldr.dialog.link.popover.heading",
                width: 590,
                height: 366
            },
            cancel: {
                style: 'red',
                icon: 'unlink',
                label: 'Remove Link',
                name: 'wzUnlink'
            }
        }
        ]
    });
});
define('internal/sitebuilder/builderChrome/toolbar.title_condensed', ['internal/sitebuilder/builderChrome/toolbar'], function(toolbar) {
    toolbar.register('title_condensed', {
        icon: 'title',
        items: [
        {
            type: "dropdown_fonts",
            name: "SetFont"
        },
        {
            type: 'dropdown_font_size',
            width: 50,
            selectedValue: 18,
            //This may be overridden by the theme's font-size.
            name: 'wzSetFontSize',
            dataType: 'title',
            options: [
            {
                label: 'fontSize.8',
                value: '8' 
            },
            {
                label: 'fontSize.10',
                value: '10' 
            },
            {
                label: 'fontSize.11',
                value: '11' 
            },
            {
                label: 'fontSize.12',
                value: '12' 
            },
            {
                label: 'fontSize.14',
                value: '14' 
            },
            {
                label: 'fontSize.16',
                value: '16' 
            },
            {
                label: 'fontSize.18',
                value: '18' 
            },
            {
                label: 'fontSize.24',
                value: '24' 
            },
            {
                label: 'fontSize.36',
                value: '36' 
            },
            {
                label: 'fontSize.48',
                value: '48' 
            },
            {
                label: 'fontSize.72',
                value: '72' 
            }
            ]
        },
        {
            icon: 'star',
            type: 'iconsets',
            menuPosition: 'left',
            label: 'Icon',
            name: 'setIcon',
            hideAlignment: true,
            width: 170
        },
        {
            type: 'colorpicker',
            icon: 'text_color',
            menuLabel: 'Text Color',
            menuPosition: 'left',
            label: 'Color',
            name: 'wzForeColor',
            value: '#069FF0'
        },
        {
            type: 'button-group',
            sticky: true,
            distinct: false,
            items: [
            {
                label: 'Bold',
                icon: 'bold',
                name: 'bold' 
            },
            {
                label: 'Italic',
                icon: 'italic',
                name: 'italic' 
            },
            {
                label: 'Underline',
                icon: 'underline',
                name: 'underline' 
            },
            {
                label: 'Strikethrough',
                icon: 'strike',
                name: 'strikethrough' 
            }
            ]
        },
        {
            type: 'button',
            icon: 'eraser',
            label: 'Clear Formatting',
            name: 'RemoveFormat'
        },
        {
            type: 'button-cancel',
            icon: 'link',
            label: 'Link',
            showLabel: false,
            name: 'wzLink',
            groupClass: 'w-wizzy-linkgroup',
            classNames: 'w-wizzy-linkbutton',
            dialog: {
                url: '/s/sitebuilder/dialogs/link',
                localizeHeading: "webs.bldr.dialog.link.popover.heading",
                width: 590,
                height: 366
            },
            cancel: {
                style: 'red',
                icon: 'unlink',
                label: 'Remove Link',
                name: 'wzUnlink'
            }
        }

        ]
    });
});

define('internal/sitebuilder/builderChrome/toolbar.image', ['internal/sitebuilder/builderChrome/toolbar', 'translate!webs.bldr.modules.image.toolbar'], function(toolbar, translate) {
    toolbar.register('image', {
        icon: 'image',
        items: [
        {
            type: 'button',
            style: 'blue',
            label: 'Change Image',
            name: 'image',
            dialog: {
                url: '/s/sitebuilder/dialogs/image',
                heading: translate('webs.bldr.modules.image.toolbar.Change Image'),
                width: 650,
                height: 230
            }
        },
        {
            "icon": "border",
            "type": "framesets",
            "label": "Frame",
            "name": "frame",
            "width": 170
        },
        {
            type: 'button-group',
            sticky: true,
            distinct: true,
            items: [
            {
                label: 'Left',
                icon: 'align_left',
                name: 'position',
                value: 'left' 
            },
            {
                label: 'Center',
                icon: 'align_center',
                name: 'position',
                value: 'center' 
            },
            {
                label: 'Right',
                icon: 'align_right',
                name: 'position',
                value: 'right' 
            }
            ]
        },
        {
            type: 'button-cancel',
            icon: 'link',
            label: 'Link',
            showLabel: true,
            name: 'link',
            groupClass: 'w-image-linkgroup',
            classNames: 'w-image-linkbutton',
            dialog: {
                url: '/s/sitebuilder/dialogs/link?image=true',
                localizeHeading: "webs.bldr.dialog.link.popover.heading",
                width: 590,
                height: 366
            },
            cancel: {
                style: 'red',
                icon: 'unlink',
                label: 'Remove Link',
                name: 'unlink'
            }
        }
        ]
    });
});
define('internal/sitebuilder/builderChrome/toolbar.button', ['internal/sitebuilder/builderChrome/toolbar'], function(toolbar) {
    toolbar.register('button', {
        icon: 'button',
        items: [
        {
            type: 'button',
            icon: 'link',
            style: 'blue',
            label: 'Link',
            showLabel: true,
            name: 'link',
            dialog: {
                url: '/s/sitebuilder/dialogs/link',
                localizeHeading: "webs.bldr.dialog.link.popover.heading",
                width: 590,
                height: 366
            }
        },
        {
            "type": "dropdown_font_size",
            "width": 50,
            "selectedValue": 14,
            //This may be overridden by the theme"s font-size.
            "name": "wzSetFontSize",
            "dataType": "text",
            "options": [
            {
                "label": "fontSize.8",
                "value": "8" 
            },
            {
                "label": "fontSize.10",
                "value": "10" 
            },
            {
                "label": "fontSize.11",
                "value": "11" 
            },
            {
                "label": "fontSize.12",
                "value": "12" 
            },
            {
                "label": "fontSize.14",
                "value": "14" 
            },
            {
                "label": "fontSize.16",
                "value": "16" 
            },
            {
                "label": "fontSize.18",
                "value": "18" 
            },
            {
                "label": "fontSize.24",
                "value": "24" 
            },
            {
                "label": "fontSize.36",
                "value": "36" 
            },
            {
                "label": "fontSize.48",
                "value": "48" 
            },
            {
                "label": "fontSize.72",
                "value": "72" 
            }
            ]
        },
        {
            icon: 'color',
            type: 'colorpicker',
            menuPosition: 'left',
            menuLabel: 'Button Color',
            label: 'Background',
            name: 'BGColor',
            value: '#8a0000'
        },

        {
            icon: 'star',
            type: 'iconsets',
            menuPosition: 'left',
            label: 'Icon',
            name: 'setIcon',
            width: 170
        },
        {
            type: 'button-group',
            sticky: true,
            distinct: true,
            items: [
            {
                label: 'Left',
                icon: 'button-align_left',
                name: 'buttonPosition',
                value: 'left' 
            },
            {
                label: 'Center',
                icon: 'button-align_center',
                name: 'buttonPosition',
                value: 'center' 
            },
            {
                label: 'Right',
                icon: 'button-align_right',
                name: 'buttonPosition',
                value: 'right' 
            }
            ]
        },
        {
            type: 'divider' 
        },

        {
            type: 'button-group',
            sticky: true,
            distinct: false,
            items: [
            {
                label: 'Bold',
                icon: 'bold',
                name: 'bold' 
            },
            {
                label: 'Italic',
                icon: 'italic',
                name: 'italic' 
            },
            {
                label: 'Underline',
                icon: 'underline',
                name: 'underline' 
            }
            ]
        },
        {
            type: 'colorpicker',
            icon: 'text_color',
            label: 'Text Color',
            menuLabel: 'Text Color',
            name: 'wzForeColor',
            value: '#fff'
        }


        ]
    });
});

define('internal/sitebuilder/builderChrome/controls.text', [
'jquery',
'internal/sitebuilder/builderChrome/controls',
'internal/sitebuilder/builderChrome/toolbar',
'internal/sitebuilder/builder/wizzy',
'internal/sitebuilder/builder/wizzy.ui',
'internal/sitebuilder/builder/wizzy.paste'
], function($, controls, toolbar) {
    controls.register('text', {
        init: function(options) {
            var self = this,
            $ = bldr.pageController.$,
            SetFont = function(val) {
                if (self.data.font) 
                    self.el.removeClass('w-font-' + self.data.font);
                if (val) 
                    self.el.addClass('w-font-' + val);
                self.data.font = val;
                self.options.data.font = val;
            },
            setFontSize = function(size) {
                var listItems = self.toolbar.get$Toolbar().find('.w-tbui-wzSetFontSize .w-dropdown-ul li');
                listItems.removeClass('selected').filter('[title=' + size + ']').addClass('selected');
                self.toolbar.get$Toolbar().find('div.w-tbui-wzSetFontSize .w-dropdown-selected span').html(size);
            };

            wizzyExec = function(val, name) {
                if (self.wizzy) 
                    self.wizzy.exec(name, val);
            };

            options.wizzy = options.wizzy || {};
            this.options = options;
            options.data = options.data || {};
            this.options = options;
            this.data = options.data;
            this.el = options.el;
            this.wizzyExec = wizzyExec;

            var textToolbarName = options && typeof options.toolbarName === 'string' ? options.toolbarName : 'text';
            this.toolbar = toolbar.create(textToolbarName);
            this.toolbar.addListener({
                "default": wizzyExec,
                SetFont: SetFont
            });

            // Setting font dropdown
            this.toolbar.callDropdown("Fonts Dropdown", "setOption", this.data.font || '');

            /* Setting up toolbar to initialize Wizzy
            			This will allow Wizzy to automatically set active states using queryCommandState */
            var defaultFontSize = this.toolbar.get$Toolbar().find('.default span').html();
            this.wizzy = this.options.el.wizzy({
                linksData: options.linksData,
                setFontSize: setFontSize,
                defaultFontSize: defaultFontSize 
            }).data('wizzy');
            this.wizzy.extend('ui', {
                toolbar: this.toolbar,
                enableTypefaceUpdate: options.enableTypefaceUpdate,
                enableAlignment: options.wizzy.enableAlignment
            });
            var wizzyOpts = $.extend({}, options.wizzy);
            this.wizzy.extend('paste', wizzyOpts);

            this.wizzy.getRangeFontSize();

            return self;
        },

        // Same as "enable"
        show: function(showData) {
            var self = this;
            showData = showData || {
                SetFont: self.options.data.font || "__default__"
            };
            this.toolbar.show(showData);


            setTimeout(function() {
                self.wizzy.show();
                if (self.options.html === null) 
                    self.wizzy.selectAll();
            }, 100);
        },

        // Same as "disable"
        hide: function() {
            this.options.el.unbind('keydown');
            this.wizzy.hide();
        },

        /**
        	 * Removes all events and references to wizzy to be gc-ed
        	 * We may want to remove the hide method above. It's left there now in case something breaks
        	 */
        destroy: function() {
            if (this.wizzy) {
                this.wizzy.destroy();
                this.wizzy = null;
            }
            return true;
        },

        getLinksData: function() {
            if (this.wizzy) 
                return this.wizzy.getLinksData();
            return this.options.linksData;
        },

        getData: function() {
            if (this.wizzy) {
                var html = this.wizzy.getData();
                if (html === this.options.el.data('placeholder') || $.trim(this.options.el.text()) === '') {
                    html = null;
                }
                return {
                    html: html,
                    font: this.data.font
                };
            }
            return null;
        }
    });
});
define('internal/sitebuilder/builderChrome/controls.title', [
'jquery',
'internal/sitebuilder/builderChrome/controls',
'internal/sitebuilder/builderChrome/toolbar',
'internal/sitebuilder/builder/wizzy.paste'
], function($, controls, toolbar) {
    controls.register('title', {
        init: function(options) {
            var self = this,
            $ = bldr.pageController.$,
            wizzyExec = function(val, name) {
                if (self.wizzy) {
                    self.wizzy.exec(name, val);
                }
            },
            /**
            			 * Certain versions of chrome (14.0.835.202 and possibly lower) crashes when clearing
            			 * text format if there are classes/styles set on the text's parent container
            			 */
            removeFormat = function(val, name) {
                // When removing format, check to see if the whole container is selected
                // If so, we also remove the typeface
                var currRange = self.wizzy.getRange();
                var fullRange = currRange.cloneRange();
                fullRange.selectNodeContents(self.wizzy.el);
                if (fullRange.equals(currRange)) {
                    /* jshint ignore:start */
                    SetFont("__default__");
                    /* jshint ignore:end */
                    self.toolbar.set("SetFont", "__default__");
                }

                var classes = options.el.attr('class');
                options.el.attr('class', '');
                self.wizzy.exec(name, val);
                options.el.attr('class', classes);
            },
            sizeExec = function(val, name) {
                if (name === 'grow') 
                    self.wizzy.exec('wzIncreaseFontSize', val);
                if (name === 'shrink') 
                    self.wizzy.exec('wzDecreaseFontSize', val);
                if (name === 'wzSetFontSize') 
                    self.wizzy.exec('wzSetFontSize', val);
            },
            SetFont = function(val) {
                if (self.data.font) 
                    self.el.removeClass('w-font-' + self.data.font);
                if (val) 
                    self.el.addClass('w-font-' + val);
                self.data.font = val;
            },
            align = function(val) {
                if (self.data.align) 
                    options.el.removeClass('webs-title-align-' + self.data.align);
                if (val) 
                    options.el.addClass('webs-title-align-' + val);
                self.data.align = val;
            },
            linkExec = function(linkObj) {
                self.wizzy.exec('CreateLink', linkObj.url);
            },
            setFontSize = function(size) {
                var listItems = self.toolbar.get$Toolbar().find('.w-tbui-wzSetFontSize .w-dropdown-ul li');
                listItems.removeClass('selected').filter('[title=' + size + ']').addClass('selected');
                self.toolbar.get$Toolbar().find('div.w-tbui-wzSetFontSize .w-dropdown-selected span').html(size);
            };

            options.data = options.data || {};
            options.wizzy = options.wizzy || {};
            this.options = options;
            this.data = options.data;
            this.heading = options.el;
            this.el = options.el.find('.w-text');
            this.iconContainer = options.el.find('.w-icon');
            this.level = parseInt(options.el[0].nodeName.substring(1), 10);

            var titleToolbarName = options && typeof options.toolbarName === 'string' ? options.toolbarName : 'title';
            this.toolbar = toolbar.create(titleToolbarName);

            this.toolbar.addListener({
                "default": wizzyExec,
                "RemoveFormat": removeFormat,
                link: linkExec,
                grow: sizeExec,
                shrink: sizeExec,
                wzSetFontSize: sizeExec,
                SetFont: SetFont,
                align: align,
                setIcon: function(obj) {
                    self.setIcon(obj);
                },
                removeIcon: function() {
                    self.removeIcon();
                }
            });

            // Setting font dropdown
            this.toolbar.callDropdown("Fonts Dropdown", "setOption", this.data.font || '');

            // Showing and hiding icon picker
            var iconpickerContainer = this.toolbar.find('.w-more-iconpicker');
            if (options.enableIcon) 
                iconpickerContainer.show();
            else 
                iconpickerContainer.hide();

            var defaultFontSize = this.toolbar.get$Toolbar().find('.default span').html();
            this.wizzy = this.el.wizzy({
                linksData: this.data.linksData,
                setFontSize: setFontSize,
                defaultFontSize: defaultFontSize
            }).data('wizzy');
            this.wizzy.extend('ui', {
                toolbar: this.toolbar 
            });
            var wizzyOpts = $.extend({}, options.wizzy);
            this.wizzy.extend('paste', wizzyOpts);

            //Set font size
            this.wizzy.getRangeFontSize();

        },

        setIcon: function(obj) {
            if (this.options.enableIcon) {
                this.data.icon = obj;
                this.iconContainer.attr('class', 'w-icon w-iconset-' + obj.set + ' w-icon-' + obj.slug).show();
                this.heading.addClass("webs-title-has_icon");
            }
        },

        removeIcon: function() {
            this.data.icon.enable = false;
            this.heading.removeClass("webs-title-has_icon");
            if (this.iconContainer) 
                this.iconContainer.hide();
        },

        show: function() {
            var self = this;
            this.toolbar.show({
                icon: self.options.data.icon,
                SetFont: self.options.data.font || "__default__"
            });

            setTimeout(function() {
                self.wizzy.show();
                if (self.options.data.html === null) 
                    self.wizzy.selectAll();
            }, 100);

        },

        hide: function() {
            this.wizzy.hide();
        },
        destroy: function() {
            if (this.wizzy) {
                this.wizzy.destroy();
                this.wizzy = null;
            }
            return true;
        },

        getLinksData: function() {
            if (this.wizzy) 
                return this.wizzy.getLinksData();
            return this.data.linksData;
        },

        getData: function() {
            var html = this.wizzy ? this.wizzy.getData() : this.el.html();

            if (html === this.el.data('placeholder') || $.trim(this.el.text()) === "") {
                html = null;
            }

            return {
                html: html,
                font: this.data.font,
                level: parseInt(this.el[0].tagName.substring(1), 10),
                icon: this.data.icon,
                align: this.data.align,
                linksData: this.wizzy ? this.wizzy.getLinksData() : this.data.linksData
            };
        }
    });
});
define('internal/sitebuilder/builderChrome/controls.image', [
'jquery',
'internal/sitebuilder/builderChrome/controls',
'internal/sitebuilder/builderChrome/toolbar',
'internal/sitebuilder/builderChrome/imageManipulation',
'translate!webs.bldr'
], function($, controls, toolbar, imageManipulation, translate) {

    var $zoomTT = null,
    $bodyWidthTT = null,
    $sideWidthTT = null,
    $h_cropTT = null,
    $v_cropTT = null;

    controls.register('image', {
        /**
        	 * Required 'options':
        	 *    container: jQuery container holding image. Must not be removed from page during module.render since it's a delegation element
        	 *    el:        String image wrapper selector. Container's delegate & find will happen on this element.
        	 */
        init: function(options) {
            var self = this,
            data = options.data;

            this.options = options;
            this.attributes = {};
            this.attributes.align = data.align || 'left';
            this.attributes.frame = data.frame || null;
            this.attributes.height = data.height;

            if (!options.disableImageToolbar) {
                this.toolbar = toolbar.create('image');
            }

            this.frameWidth = options.frameWidth;

            // will also hold maxWidth, maxHeight (full_width), and ratio after readImageBounds() call
            this.bounds = {
                minWidth: 16,
                minHeight: 16
            };
        },


        /**
        	 * Note: be careful doing anything that may cause the view to change (module.render())
        	 * You will lose all controls and will have to set $wrap and $img again before reattaching controls.
        	 */
        show: function() {
            var $ = bldr.pageController.$,
            self = this,
            opts = this.options,
            $container = opts.container,
            $frame;

            if (!$zoomTT)
                $zoomTT = bldr.pageController.$.tooltip({
                    style: "warn",
                    content: translate('webs.bldr.image.max_resolution')
                });
            if (!$bodyWidthTT)
                $bodyWidthTT = bldr.pageController.$.tooltip({
                    style: "warn",
                    content: translate('webs.bldr.image.max_container_width')
                });
            if (!$sideWidthTT)
                $sideWidthTT = bldr.pageController.$.tooltip({
                    style: "warn",
                    content: translate('webs.bldr.image.max_sidebar_width')
                });
            if (!$h_cropTT)
                $h_cropTT = bldr.pageController.$.tooltip({
                    style: "warn",
                    content: translate('webs.bldr.image.max_width')
                });
            if (!$v_cropTT)
                $v_cropTT = bldr.pageController.$.tooltip({
                    style: "warn",
                    content: translate('webs.bldr.image.max_height')
                });

            this.showHasLink(this.options.data.linkInfo);

            /**
            		 * Set required references in case the view has changed (triggered by module.render())
            		 */
            var setReferences = function() {
                self.$wrap = $container.find(opts.el);
                self.$img = $('img', self.$wrap);

                if (!opts.disableImageToolbar) {
                    self.$wrap.find(".webs-image-crop").dblclick(function(e) {
                        self.toolbar.click('image');
                    });
                }

                if (!opts.data.url) {
                    self.readImageBounds();
                } else {
                    self.$img.load(function(e) {
                        self.readImageBounds();
                    });
                }

                $frame = opts.data.frame ? $container.find('.webs-frame') : self.$wrap;

                if (!opts.disableImageToolbar) {
                    self.toolbar.setFeedback(self.$img.parent());
                }
            };
            setReferences();



            /**
            		 * Toolbar event bindings
            		 */
            var toolbarBindings = {
                panelStyle: function(style) {
                    opts.data.frameStyle = style;
                },
                setFrame: function(slug) {
                    if (typeof slug !== 'string') {
                        if (opts.data.frame) 
                            delete opts.data.frame;
                        self.trigger('setFrame', null);
                    } else {
                        opts.data.frame = slug;
                        self.trigger('setFrame', slug);
                    }
                    setTimeout(function() {
                        setReferences();
                        if (opts.data.url) 
                            attachControls();
                    }, 1);
                },
                position: function(align) {
                    if (opts.beforeChange) 
                        opts.beforeChange();
                    $frame.removeClass('webs-align-' + self.attributes.align).addClass('webs-align-' + align);
                    self.attributes.align = align;
                    opts.data.align = align;
                },
                image: function(obj) {
                    if (opts.beforeChange) {
                        opts.beforeChange();
                    }

                    var src;

                    opts.data.imageType = obj.imageType;
                    opts.data.url = obj.url;
                    src = imageManipulation.getImageUrl(obj);

                    opts.data.imageType = obj.imageType;
                    if ("webs" in obj)
                        opts.data.webs = obj.webs;
                    else
                        delete opts.data.webs;
                    if (obj[opts.data.imageType]) {
                        // Copy type-specific info (webs fileId, flickr photoId, etc.)
                        opts.data[opts.data.imageType] = obj[opts.data.imageType];
                    }
                    var $img = self.$img;
                    if (obj.uploading) {
                        self.$wrap.addClass('uploading');
                        $('<progress/>').addClass('upload-progress').appendTo(self.$wrap);

                        top.uploadcallback = function(uploadList) {
                            var o = (uploadList instanceof Array) ? uploadList[0] : uploadList;
                            $img.attr('src', o.url);

                            $('.upload-progress', self.$wrap).attr({
                                'max': 100,
                                'value': 100
                            }).animate({
                                'opacity': 0
                            }, {
                                complete: function() {
                                    self.$wrap.removeClass('uploading');
                                    $(this).remove();
                                }
                            });
                        };
                    }

                    // update the src and resize to new height
                    // put loading class on, then set the actual image src only
                    // after it's been loaded to an image (not on the dom)
                    var $crop = $img.parent();
                    if ($img.attr("src") === src) {
                        $img.css({
                            opacity: 1
                        });
                        self.trigger("settingImage");
                        setTimeout(function() {
                            self.$wrap.trigger("imageChange");
                            self.trigger("setImage");
                        }, 2);
                        $crop.removeClass("bldr-placeholder-loading");
                    } else {
                        var $offscreenImage = $("<img>");
                        $img.css({
                            opacity: 0
                        });
                        self.trigger("settingImage");
                        $offscreenImage.bind("load", function() {
                            $img.attr('src', src).css({
                                opacity: 1
                            });
                            $offscreenImage.unbind("load");
                            setTimeout(function() {
                                self.$wrap.trigger("imageChange");
                                self.trigger("setImage");
                            }, 2);
                            $crop.trigger('spinner.destroy');
                        }).attr('src', src);
                        $crop.loadingSpinner();
                    }
                    $crop.removeClass("bldr-placeholder-element bldr-placeholder-image");

                    delete obj.imageWasJustUploaded;

                    // FIXME: wtf is this not extend? Also, why ooes it sometimes not work with extend?
                    $.merge(opts.data, obj);
                },
                link: function(obj) {
                    if (typeof opts.beforeChange == "function") 
                        opts.beforeChange();
                    opts.data.linkInfo = obj;
                    self.showHasLink(true);
                },

                unlink: function() {
                    delete opts.data.linkInfo;
                    self.showHasLink(false);
                }
            };

            if (!opts.disableImageToolbar) {

                this.toolbar.bind(toolbarBindings);
                this.toolbar.show({
                    'frame': opts.data.frame,
                    'panelStyle': opts.data.frameStyle,
                    'position': this.attributes.align,
                    'image': {
                        url: this.$img.attr('src'),
                        imageType: opts.data.imageType,
                        webs: opts.data.webs
                    },
                    'link': opts.data.linkInfo || false
                });
            }




            /**
            		 * Attach image controls. Remember to call setReferences() before calling this function
            		 */
            var attachControls = function() {
                var oldWidth = self.$img.width();
                self.$img.css('width', 'auto'); // to get the actual width of the full image
                var imgWidth = self.$img.width(),
                imgHeight = self.$img.height();
                self.bounds.ratio = imgWidth / imgHeight;

                // setting bounds. OR operator is used in case coming from a setFrame, we can't fetch image info, but we can use old bounds
                self.bounds.maxWidth = self.$img.width() || self.bounds.maxWidth; // actual width of the full image
                self.bounds.maxHeight = self.$img.height() || self.bounds.maxHeight; // actual height of the full image


                self.$img.css('width', (oldWidth / self.$wrap.width() * 100) + '%'); // set the image back to the proper percentage width

                self.zoomRange = self.$wrap.find('input[type=range]');

                self.updateMaxCropWidth();

                self.readAttributes();
                self.setPosition(self.attributes.top, self.attributes.left); // set the top and left as a percent

                if (!opts.data.inBucket) {
                    self.$wrap.resizer({
                        reference: self.$wrap,
                        corners: ['left', 'right'],
                        centered: self.attributes.align === 'center',
                        maxWidth: parseInt(Math.min(self.bounds.maxWidth / self.attributes.zoomRatio, self.bounds.maxCropWidth - self.frameWidth()), 10),
                        minWidth: self.bounds.minWidth,
                        minHeight: self.bounds.minHeight,
                        onMove: function(corner, newWidth, newHeight) {
                            self.zoomRange.attr('min', Math.max(newWidth, Math.round(self.bounds.ratio * newHeight)) ).val(self.$img.width());
                            if (newWidth == parseInt(self.bounds.maxWidth / self.attributes.zoomRatio, 10)) {
                                $zoomTT.addClass("active");
                            } else if (newWidth == self.bounds.maxCropWidth - self.frameWidth()) {
                                if (self.$img.parents(".webs-sidebar").length) {
                                    $sideWidthTT.addClass("active");
                                } else {
                                    $bodyWidthTT.addClass("active");
                                }
                            } else {
                                $zoomTT.removeClass("active");
                                $sideWidthTT.removeClass("active");
                                $bodyWidthTT.removeClass("active");
                            }
                        },
                        onStart: function() {
                            if (typeof opts.beforeChange == "function") 
                                opts.beforeChange();
                        },
                        onEnd: function() {
                            self.readAttributes();
                            $zoomTT.removeClass("active");
                            $sideWidthTT.removeClass("active");
                            $bodyWidthTT.removeClass("active");
                        }
                    });

                    self.$wrap.cropper({
                        reference: self.$wrap,
                        target: self.$img,
                        sides: ['right', 'bottom', 'left'],
                        centered: self.attributes.align === 'center',
                        maxWidth: self.bounds.maxCropWidth - self.frameWidth(),
                        onMove: function(side, newWidth, newHeight) {
                            self.zoomRange.attr('min', parseInt(Math.max(self.attributes.width, self.bounds.ratio * newHeight), 10));
                            if (side == 'bottom') {
                                if (newHeight == self.$img.height()) {
                                    $v_cropTT.addClass("active");
                                } else {
                                    $v_cropTT.removeClass("active");
                                }
                            } else {
                                if (newWidth == self.$img.width()) {
                                    $h_cropTT.addClass("active");
                                } else if (newWidth == self.bounds.maxCropWidth - self.frameWidth()) {
                                    if (self.$img.parents(".webs-sidebar").length) {
                                        $sideWidthTT.addClass("active");
                                    } else {
                                        $bodyWidthTT.addClass("active");
                                    }
                                } else {
                                    $bodyWidthTT.removeClass("active");
                                    $sideWidthTT.removeClass("active");
                                    $h_cropTT.removeClass("active");
                                }
                            }
                        },
                        onEnd: function() {
                            $h_cropTT.removeClass("active");
                            $v_cropTT.removeClass("active");
                            $sideWidthTT.removeClass("active");
                            $bodyWidthTT.removeClass("active");
                            self.readAttributes();
                        },
                        onStart: function() {
                            if (typeof opts.beforeChange == "function") 
                                opts.beforeChange();
                        },
                        onImageChange: function(dimensions) {
                            self.attributes.top = 0;
                            self.attributes.left = 0;
                            self.attributes.width = dimensions.width;
                            self.attributes.height = dimensions.height;
                            self.setPosition(0, 0);
                            self.$img.height(dimensions.height).width(dimensions.width);
                        }
                    });
                }

                self.$img.panner({
                    reference: self.$wrap,
                    onStart: function() {
                        if (typeof opts.beforeChange == "function") 
                            opts.beforeChange();
                    },
                    onEnd: function() {
                        var pos = self.$img.position();
                        // convert to percent
                        self.setPosition(pos.top, pos.left);
                        self.readAttributes();
                    }
                });


                self.bounds.minWidth = Math.max(self.attributes.width, self.bounds.ratio * self.attributes.height) || self.bounds.minWidth;
                if (self.bounds.maxWidth > self.attributes.width) {
                    self.$img.zoomer({
                        reference: self.$wrap,
                        min: self.bounds.minWidth,
                        max: self.bounds.maxWidth,
                        onStart: function () {
                            if (typeof opts.beforeChange == "function") 
                                opts.beforeChange();
                        },
                        onChange: function (val) {
                            self.setZoom(val);
                            self.readAttributes();
                        }
                    });
                }

            };

            attachControls();
        },

        readImageBounds: function() {

            var $img = this.$img,
            width = $img.width();

            // figure out the bounds of image
            $img.css('width', 'auto'); // to get the actual width of the full image
            var imgWidth = $img.width(),
            imgHeight = $img.height();

            this.bounds.maxWidth = imgWidth; // actual width of the full image
            this.bounds.maxHeight = imgHeight; // actual height of the full image
            this.bounds.ratio = imgWidth / imgHeight;

            // reset the image
            $img.css('width', width); // set the image back to the proper percentage width

            this.readAttributes();

            // make sure the cropping is not larger than the image it contains
            if (this.attributes.width > this.bounds.maxWidth) 
                this.$wrap.width(this.bounds.maxWidth);
            if (this.attributes.height > $img.height()) 
                this.$wrap.height($img.height());

            if (this.attributes.left + $img.width() < this.attributes.width) {
                var newLeft = Math.min(0, this.attributes.width - $img.width());
                this.setPosition(null, newLeft);
            }
            if (this.attributes.top + $img.height() < this.attributes.height) {
                var newTop = Math.min(0, this.attributes.height - $img.height());
                this.setPosition(newTop, null);
            }

            this.readAttributes();

            // fixes zoom range
            if (this.zoomRange && this.zoomRange.jquery) 
                this.zoomRange.attr('max', this.bounds.maxWidth);

        },

        updateMaxCropWidth: function(changed) {
            if (!this.options.data.inBucket) {
                // these won't exist
                var oldMax = this.bounds.maxCropWidth;
                this.bounds.maxCropWidth = this.options.containerWidth - (this.$wrap.outerWidth(true) - this.$img.parent().width());
                if (changed) {
                    var diff = oldMax - this.bounds.maxCropWidth;
                    if (this.attributes.width > this.bounds.maxCropWidth) {
                        this.$wrap.width(this.bounds.maxCropWidth);
                        this.readAttributes();
                    }

                    this.$wrap.cropper('setOptions', {
                        maxWidth: this.bounds.maxCropWidth
                    });

                    this.$wrap.resizer('setOptions', {
                        maxWidth: Math.min(this.bounds.maxWidth / this.attributes.zoomRatio, this.bounds.maxCropWidth - this.frameWidth())
                    });
                }
            }
        },

        readAttributes: function() {
            // reset reference for buckets module
            this.$img = this.options.container.find("img");
            this.$wrap = this.options.container.find(".webs-image-wrapper-1");
            var imgPos = this.$img.position();

            this.attributes.imageWidth = this.$img.width();
            this.attributes.width = this.$wrap.width();

            // If values returned for imageWidth returned from dom don't make sense, use passed in values only once
            var calculatedImageWidth = Math.round((this.options.data.imageWidth / 100) * this.attributes.width);
            if (!this.attributes.zoomRatio && calculatedImageWidth && calculatedImageWidth != this.$img.width()) {
                this.attributes.imageWidth = calculatedImageWidth;
            }

            this.attributes.height = this.$wrap.height();
            this.attributes.imageHeight = this.$img.height();

            if (imgPos) {
                this.attributes.left = imgPos.left;
                this.attributes.top = imgPos.top;
            }
            this.attributes.zoomRatio = this.attributes.imageWidth / this.attributes.width;
            this.attributes.frame = this.options.data.frame;
            this.attributes.frameColor = this.options.data.frameColor;
            this.attributes.panelStyle = this.options.data.panelStyle;

            // set the image's width as a percentage
            this.$img.css('width', (this.attributes.imageWidth / this.attributes.width * 100).toFixed(2) + '%');

            // set the top position as a percentage
            this.setPosition(this.attributes.top, this.attributes.left);

            if (!this.options.data.inBucket) {
                this.$wrap.resizer('setOptions', {
                    maxWidth: Math.min(this.bounds.maxWidth / this.attributes.zoomRatio, this.bounds.maxCropWidth - this.frameWidth())
                });
            }
        },

        setPosition: function(top, left) {
            this.$img.css({
                'left': left,
                'top': top
            });
        },

        showHasLink: function(hasLink) {

            if (!this.options.disableImageToolbar) {
                var linkGroup = this.toolbar.find('.w-image-linkgroup'),
                linkButton = this.toolbar.find('.w-image-linkbutton');
                linkButton[hasLink ? 'addClass' : 'removeClass']("active");
                linkGroup[hasLink ? 'removeClass' : 'addClass']("canceled");
            }
        },

        setZoom: function(newWidth) {
            newWidth = parseFloat(newWidth);
            if (newWidth < this.attributes.width) 
                return;
            else if (newWidth > this.bounds.maxWidth) 
                return;

            var widthPercent = Math.round((newWidth / this.attributes.width) * 10000) / 100,
            newHeight = this.$img.css('width', widthPercent + '%').height(),
            dwidth = newWidth - this.attributes.imageWidth,
            dheight = newHeight - this.attributes.imageHeight,
            newLeft = this.attributes.left + Math.round( (this.attributes.left - this.attributes.width / 2) / this.attributes.imageWidth * dwidth ),
            newTop = this.attributes.top + Math.round( (this.attributes.top - this.attributes.height / 2) / this.attributes.imageHeight * dheight );

            if (newTop + newHeight < this.attributes.height) {
                newTop = this.attributes.height - newHeight;
            }
            if (newTop > 0) 
                newTop = 0;
            if (newLeft + newWidth < this.attributes.width) {
                newLeft = this.attributes.width - newWidth;
            }
            if (newLeft > 0) 
                newLeft = 0;

            // convert to percent
            this.setPosition(newTop, newLeft);

            this.maxWidth = newWidth;
            this.maxHeight = newHeight;
        },

        hide: function() {
            if (!this.$img) 
                return;
            if (!this.options.data.inBucket) {
                this.$wrap.cropper('destroy');
                this.$wrap.resizer('destroy');
            }
            this.$img.panner('destroy');
            this.$img.zoomer('destroy');
            this.$img.unbind();
        },

        getData: function() {
            if (!this.$img) 
                return false;

            var imageType = this.options.data.imageType,
            data = {
                url: this.options.data.url,
                imageType: imageType,
                path: this.options.data.path,
                top: this.attributes.top,
                left: this.attributes.left,
                width: this.attributes.width,
                height: this.attributes.height,
                imageWidth: Math.round(this.attributes.imageWidth / this.attributes.width * 10000) / 100,
                imageHeight: this.attributes.imageHeight,
                align: this.attributes.align,
                frame: this.options.data.frame,
                frameColor: this.options.data.frameColor,
                link: this.options.data.link,
                linkInfo: this.options.data.linkInfo
            };

            if (this.options.data[imageType]) {
                data[imageType] = this.options.data[imageType];
            }

            return data;
        }
    });
});
define('internal/sitebuilder/builderChrome/controls.button', [
'jquery',
'internal/sitebuilder/builderChrome/controls',
'internal/sitebuilder/builderChrome/toolbar'
], function($, controls, toolbar) {
    controls.register('button', {
        init: function(options) {
            var self = this, $ = bldr.pageController.$;

            this.options = options;
            this.data = options.data;

            this.el = options.el;

            this.toolbar = toolbar.create('button');
            this.toolbar.bind({
                'default': function(val, name) {
                    self.wizzy.exec(name, val);
                    self.toolbar.press(name, val);
                },
                link: function(linkObj) {
                    self.options.data.linkInfo = linkObj;
                },
                ForeColor: function(hex) {
                    self.wizzy.exec('forecolor', hex);
                },
                buttonPosition: function(align) {
                    self.el.find('.webs-align-' + self.options.data.align).removeClass('webs-align-' + self.options.data.align).addClass('webs-align-' + align);
                    self.options.data.align = align;
                },
                BGColor: function(hex) {
                    self.$button.css('background-color', hex);
                    self.options.data.bgcolor = hex;
                },
                setIcon: function(obj) {
                    self.getData();
                    if (typeof self.options.data.icon !== "object")
                        self.options.data.icon = {
                            "position": self.volatileIconAlignment || "left"
                        };
                    $.extend(self.options.data.icon, obj);
                    if (self.options.render) 
                        self.options.render();
                    self.setReferences();
                    self.attachControls();
                },
                positionIcon: function(position) {
                    self.getData();
                    // Save their position choice temporarily, even if they haven't selected an icon yet.
                    if (typeof self.options.data.icon !== "object") {
                        self.volatileIconAlignment = position;
                    } else {
                        self.options.data.icon.position = position;
                        if (self.options.render) 
                            self.options.render();
                        self.setReferences();
                        self.attachControls();
                    }
                },
                removeIcon: function() {
                    self.getData();
                    if (typeof self.options.data.icon === "object")
                        self.volatileIconAlignment = self.options.data.icon.position;
                    delete self.options.data.icon;
                    if (self.options.render) 
                        self.options.render();
                    self.setReferences();
                    self.attachControls();
                }
            });


            // Showing and hiding icon picker
            var iconpickerContainer = this.toolbar.find('.w-more-iconpicker');
            if (options.enableIcon) 
                iconpickerContainer.show();
            else 
                iconpickerContainer.hide();

            this.setReferences();
            this.attachControls();
        },

        setReferences: function() {
            var self = this;
            this.$text = this.el.find('.w-button-text');
            this.$button = this.el.find('.w-button');
        },

        attachControls: function() {
            var self = this;


            var setFontSize = function(size) {
                var listItems = self.toolbar.get$Toolbar().find('.w-tbui-wzSetFontSize .w-dropdown-ul li');
                listItems.removeClass('selected').filter('[title=' + size + ']').addClass('selected');
                self.toolbar.get$Toolbar().find('div.w-tbui-wzSetFontSize .w-dropdown-selected span').html(size);
            };
            var defaultFontSize = this.toolbar.get$Toolbar().find('.default span').html();

            this.destroy();
            this.wizzy = this.$text.wizzy({
                setFontSize: setFontSize,
                defaultFontSize: defaultFontSize 
            }).data('wizzy');
            this.wizzy.extend('ui', {
                toolbar: this.toolbar
            });

            // TODO: implement a length limit
            this.wizzy.extend('paste', {
                plainText: true
            });

            if (self.options.data.linkFrozen) {
                $(".w-icon-link.w-btn2-blue").hide();
            } else {
                $(".w-icon-link.w-btn2-blue").show();
                self.el.closest('.w-button').dblclick(function(e) {
                    self.toolbar.click('link');
                }).click(function(e) {
                    if (e.altKey) 
                        window.location = self.el.closest('.w-button').attr('href');
                });
            }
        },

        show: function() {
            this.toolbar.setFeedback(this.el);
            var BGColor = this.options.data.bgcolor;
            if (!BGColor) {
                // Make a copy and grab the color from that, to get around :hover states
                var $copy = this.el.clone().insertBefore(this.el);
                BGColor = $copy.find(".w-button").css("background-color");
                $copy.remove();
            }
            this.toolbar.show({
                'buttonPosition': this.options.data.align,
                'link': this.options.data.linkInfo,
                'icon': this.options.data.icon,
                'panelStyle': this.options.data.iconStyle,
                'BGColor': BGColor
            });
            this.wizzy.show();
        },

        hide: function() {
            this.wizzy.hide();
        },

        destroy: function() {
            if (this.wizzy) {
                this.getData();
                this.wizzy.destroy();
                this.wizzy = null;
            }
            return true;
        },

        getData: function() {
            if (this.wizzy) {
                var html = this.wizzy.getData();
                if (html === this.$text.data('placeholder') || $.trim(this.options.el.text()) === '') {
                    html = null;
                }
                this.data.html = html;
            }
            return this.data;
        }
    });
});
/* jshint ignore:start */
define('internal/sitebuilder/builderChrome/bldr.modules', [
'jquery',
'moduleVersions',
'internal/sitebuilder/common/log',
'internal/sitebuilder/common/ThemeVariable',
'internal/sitebuilder/builderChrome/toolbar',
'internal/sitebuilder/builderChrome/undoer',
'internal/sitebuilder/builderChrome/chromeController',
'internal/sitebuilder/common/ModuleClassLoader',
'internal/sitebuilder/builderChrome/Helptip',
'translate!webs.module',
'internal/sitebuilder/common/themeService',
'internal/sitebuilder/common/webs.modules',
'internal/sitebuilder/builderChrome/toolbar.text',
'internal/sitebuilder/builderChrome/toolbar.text_fonts',
'internal/sitebuilder/builderChrome/toolbar.title',
'internal/sitebuilder/builderChrome/toolbar.text_condensed',
'internal/sitebuilder/builderChrome/toolbar.title_condensed',
'internal/sitebuilder/builderChrome/toolbar.image',
'internal/sitebuilder/builderChrome/toolbar.button',
'internal/sitebuilder/builderChrome/controls.text',
'internal/sitebuilder/builderChrome/controls.title',
'internal/sitebuilder/builderChrome/controls.image',
'internal/sitebuilder/builderChrome/controls.button',
'internal/sitebuilder/common/fontsController',
'less',
'handlebars',
'handlebars.helpers',
'internal/sitebuilder/builderChrome/utilities',
'http://cdnjs.cloudflare.com/ajax/libs/jquery-ajaxtransport-xdomainrequest/1.0.2/jquery.xdomainrequest.min.js'
], function($, moduleVersions, log, ThemeVariable, toolbar, undoer, chromeController, ModuleClassLoader, Helptip, translate, themeService) {


    // in Builder, the modules path is always relative to the root URL:
    ModuleClassLoader.MODULES_URL = '/s/modules/';
    ModuleClassLoader.CACHED_MODULES_URL = webs.props.dynamicAssetServer + '/s/modules/';

    var nodeForRedraw = $('<div/>').css({
        width: '100%',
        height: '100%',
        position: 'absolute',
        background: 'transparent',
        left: 0,
        top: 0
    })[0];

    /**
     * Helper function for unimplemented functions.
     */
    var stub = function(name) {
        return function() {
            log.trigger("Modules", "debug", "Unimplemented function '" + name + "' for module '" + this.parent.slug + "'.",
            this,
            arguments);
        };
    };

    /*
    * This file contains methods for edit-mode only.
    * For methods shared between edit and view mode, use webs.modules.js
    */

    webs.modules.CompositeModule.include({

        render: function() {
            var html = this.html();
            this.el.html(html);
            this.trigger("rendered", html);

            this.bindSubmodules();
            $.each(this.submoduleInstances, function(name, submodule) {
                submodule.render();
            });

            if (this.isActivated()) {
                this.attachControls();
            } else {
                delete this.activeSubmodule;
            }
            return this;
        },

        activateSubmodule: function(name) {
            if (name == this.activeSubmodule) 
                return;
            if (this.activeSubmodule) {
                this.submoduleInstances[this.activeSubmodule].deactivate();
                delete this.activeSubmodule;
            }
            if (name) {
                this.activeSubmodule = name;
                this.submoduleInstances[name].activate();
            }
        },

        deactivateSubmodules: function() {
            if (this.activeSubmodule) {
                if (this.activeSubmodule in this.submoduleInstances) {
                    this.submoduleInstances[this.activeSubmodule].deactivate();
                }
                delete this.activeSubmodule;
            }
        },

        attachControls: function() {
            this.attachCompositeControls();
            if (this.activeSubmodule) {
                this.activateSubmodule(this.activeSubmodule);
            }
        },

        beforeUndo: function() {
            this.bindSubmodules();
            if (this.activeSubmodule) {
                var submodule = this.submoduleInstances[this.activeSubmodule];
                submodule.afterUndo && submodule.beforeUndo();
            }
        },

        afterUndo: function() {
            this.bindSubmodules();
            if (this.activeSubmodule) {
                var submodule = this.submoduleInstances[this.activeSubmodule];
                submodule.afterUndo && submodule.afterUndo();
            }
        },

        /** Subclasses MUST override this function */
        attachCompositeControls: stub("attachCompositeControls")
    });

    webs.modules.WidgetModule.include({

        onActivate: function() {
            this.toolbar = toolbar.create(this.parent.slug);
            this.toolbar.show(this.data);
            var self = this,
            listeners = {};
            $.each(this.parent.defaultData, function(key, prop) {
                listeners[key] = function(val) {
                    self.data[key] = val;
                    self.render();
                };
            });
            this.toolbar.addListener(listeners);
            this.toolbar.addListener(
            {
                "settingsDialog": function showSettingsDialog() {
                    self.showSettingsDialog();
                }
            });
            this.el.bind("click", function(e) {
                e.preventDefault();
                return false;
            });
            this.el.bind("dblclick", function() {
                self.showSettingsDialog();
            });
            if (this.helptip && this.helptip.fieldName) {
                if (!this.data[this.helptip.fieldName] || this.data[this.helptip.fieldName] === this.parent.defaultData[this.helptip.fieldName]) {
                    this.showHelptip(this.helptip.message);
                }
            }
        },

        onDeactivate: function() {},
        attachControls: function() {},

        fit: function (newWidth, persist) {
            if (persist && this.data._width != newWidth) {
                this.data._width = newWidth;
                this.render();
                this.dirty();
            }
        },

        hasSettingsDialog: function() {
            return this.parent.popoverConfig;
        },
        showSettingsDialog: function() {
            var self = this;
            this.showDialog({
                url: "/s/sitebuilder/dialogs/widget",
                heading: this.parent.popoverConfig.title,
                width: 750,
                height: 500,
                dialogData: {
                    data: this.data,
                    widgetConfig: this.parent.popoverConfig,
                    html: this.parent.template
                },
                callback: function(obj) {
                    self.data = obj;
                    self.dirty();
                    self.render();
                }
            });
        },
        render: function() {
            var html = this.html();
            this.el.addClass("widget-container")
            .html(html)
            .append($("<div class='widget-cover'></div>"));
            this.trigger("rendered", html);
            if (this.isActivated()) {
                this.attachControls();
            }
            return this;
        }

    });

    webs.modules.Module.include({
        init: function(options) {
            this.data = options.data;
            this.el = bldr.pageController.$(this.el[0]);
            var self = this;
            if (this.parent.styles) 
                this._initStyle(this.data._style);
            this.safeOneLoaded();
        },

        /**
        	* Render or re-render the module.
        	* When complete, this method must trigger the "rendered" event
        	*/
        render: function() {
            var html = this.html();
            this.el.html(html);
            this.trigger("rendered", html);
            if (this.isActivated()) {
                this.attachControls();
            }
            return this;
        },

        /**
        	 * Grabs an array of styles and their labels (or just the slug)
        	 * This is different from webs.modules.getStyle which returns the full style reference
        	 */
        getStyles: function(slugOnly) {
            if (!this._styles_) {
                var _styles = this.parent.styles, styles = [], styleSlugs = [];
                for (var style in _styles) {
                    if (_styles.hasOwnProperty(style) && _styles[style].name) {
                        styles.push({
                            slug: style,
                            label: _styles[style].name
                        });
                        styleSlugs.push(style);
                    }
                }
                this._styles_ = styles;
                this._styleSlugs_ = styleSlugs;
            }
            return slugOnly ? this._styleSlugs_ : this._styles_;
        },

        getCurrentStyle: function() {
            return this.parent.styles[this.data._style] || this.parent.defaultStyle;
        },

        chooseDarkOrLightStyle: function(dark, light) {
            var self = this;
            if (typeof this.data._style == 'undefined') {
                // Ugly hack because we're not on the DOM yet, but we will be in 1ms (when the stack winds down)
                setTimeout(function() {
                    if (self.shouldUseDarkStyle(self.el)) {
                        newStyle = dark;
                    } else {
                        newStyle = light;
                    }
                    self.setStyle(newStyle, true);
                }, 1);
            }
        },

        shouldUseDarkStyle: function(el) {
            var dropTarget = el.closest('.webs-content');

            // Bins are constructed off the DOM, so we'll just use the body.
            if (typeof dropTarget != 'object' || dropTarget.length != 1)
                dropTarget = $('.webs-body', window.frames['website'].document);

            var
            tempText = $('<span class="webs-text"></span>').appendTo(dropTarget),
            lightness = 0;
            if (typeof tempText == 'object' && tempText.length == 1)
                lightness = this.RgbToHsl(tempText.css('color').match(/\d+/g))[2];
            tempText.remove();
            return lightness > .4;
        },
        RgbToHsl: function(rgb) {
            var
            r = parseInt(rgb[0]) / 255,
            g = parseInt(rgb[1]) / 255,
            b = parseInt(rgb[2]) / 255,
            max = Math.max(r, g, b),
            min = Math.min(r, g, b),
            d, h, s, l = (max + min) / 2;
            if (max === min) {
                h = s = 0;
            } else {
                d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
                }
                h *= 60;
            }
            return [h, s, l];
        },

        // Unfortunately, this only happens when the module is initialized
        // To set the style after initialization, call setStyle
        _initStyle: function(styleSlug) {
            if (typeof(this.parent.defaultStyle) == 'undefined') {
                // This module doesn't have styles.
                return;
            }

            if (styleSlug !== this.parent.defaultStyle.slug) {
                // Only set the data if it's not the default
                this.data._style = styleSlug;
            }

            var self = this,
            style = this.getCurrentStyle();

            // Remove old style classes
            $.each(this.parent.styles, function(slug, it) {
                self.el.removeClass('w-' + self.parent.slug + '-' + it.slug);
            });

            // Add new style classes
            do {
                this.el.addClass('w-' + this.parent.slug + '-' + style.slug);
            }
            while (style = this.parent.styles[style.inherit]);
        },

        setStyle: function(styleSlug) {
            if (this.data._style == styleSlug) 
                return false;
            this.data._style = styleSlug;

            // controller is the nodeController
            // This is a dirty hack to get the controller. We should be able to just use this.model.controller
            var controller = this.el.closest(".webs-bin").data('controller'),
            wasActiveController = controller == bldr.pageController.getCurrentController();

            if (wasActiveController) {
                // Get rid of controls and whatnot, just to be safe
                this.deactivate();
            }

            var elParent = this.el.parent();
            this.el.remove() // Remove all event bindings, etc.
            .empty() // Erase anything in the element, in case the module added some elements or something. We'll re-render below.
            .appendTo(elParent); // Re-add el to the DOM

            // We're going to create a new Module with the proper class for this new style.
            var createOptions = {
                el: this.el,
                data: this.getData() 
            };

            // Create the new module
            ModuleClassLoader.create(this.parent.slug, createOptions).done(function(m) {
                // Update reference to the old module
                controller.model.module = m;

                m.render();
                if (wasActiveController) 
                    m.activate();
                m.dirty();
            });
        },

        updateInstanceLess: function() {
            var self = this,
            style = this.getCurrentStyle();
            var styles = [];
            while (style) {
                styles.push(style);
                style = this.parent.styles[style.inherit];
            }
            for (var i = styles.length - 1, style = styles[i]; i >= 0; i--) {
                if (style.hasOwnProperty("instance") && style.instance.hasOwnProperty("css")) {
                    var url = ModuleClassLoader.getModuleAssetURL(this.parent.slug, style.instance.css);
                    ModuleClassLoader.loadTextAsset(url).done(function(data) {
                        var parser = new (less.Parser)({
                            paths: [ url.replace(/\/[^\/]*$/, '/') ],
                            filename: url.replace(/.*\/s\//, '')
                        });
                        for (var key in self.data) {
                            if (self.data.hasOwnProperty(key) && (isFinite(self.data[key]) || typeof self.data[key] == "string")) {
                                var value = self.data[key];
                                if ((typeof value == "string" && (value.match(/^#[0-9a-fA-F]{6,8}$/) || value.match(/^rgba?\(.{6,}\)$/))) ||
                                (typeof value == "number" && isFinite(value)))
                                    data = "@" + key + ": " + value + ";\n" + data;
                                else if (value == null)
                                    data = "@" + key + ": \"\";\n" + data;
                                else if (typeof value === "string" && value.length < 100)
                                    data = "@" + key + ": \"" + value.replace("\"", "\\\"") + "\";\n" + data;
                            }
                        }
                        if (!self.instance_style_index)
                            self.instance_style_index = webs.modules.Module.instanceStyleSeries++;
                        self.el.addClass("w-module-instance_style-" + self.instance_style_index);
                        parser.parse(".w-module-instance_style-" + self.instance_style_index + "{" + data + "}", function(e, tree) {
                            bldr.pageController.dom.$head.find("#w-module-instance_style_def-" + self.instance_style_index).remove();
                            bldr.pageController.dom.$head.append('<style id="w-module-instance_style_def-' + self.instance_style_index + '" type="text/css">' + tree.toCSS({}, {}) + '</style>')
                        });
                    });
                }
            }
        },

        html: function() {
            var partials = {}, html,
            view = {
                _site: top.webs.site
            };

            if (this.parent.submodules) {
                $.each(this.parent.submodules, function(name, mod) {
                    // FIXME: make this an async callback to loader in case the submodule type isn't loaded yet
                    var subClass = ModuleClassLoader.getClass(mod.moduleType);
                    if (!subClass._compiledTemplate)
                        subClass._compiledTemplate = Handlebars.compile(subClass.template);
                    partials[name] = subClass.template;
                    Handlebars.registerPartial(name, partials[name]);
                });
            }

            // Compile the template (if necessary)
            if (!this.parent._compiledTemplate) 
                this.parent._compiledTemplate = Handlebars.compile(this.parent.template);

            // Fill in the data
            $.extend(view, this.data, this.viewData || {});

            try {
                html = this.parent._compiledTemplate(view);
            } catch (err) {
                log.trigger("Modules", "error", "Error when compiling module template", err);
                html = "<p>There was a problem rendering the module, please refresh the page</p>";
            }
            return html;
        },

        /**
        	 * Forcing a browser redraw to correct layout
        	 */
        redraw: function(element) {
            element = typeof element.jquery ? element[0] : element;
            element.appendChild(nodeForRedraw);
            (function() {
                if (nodeForRedraw.parentNode)
                    nodeForRedraw.parentNode.removeChild(nodeForRedraw);
            }).deferFn();
            return element;
        },


        /**
        	* Called after the HTML has been written to the page.
        	*/
        safeOneLoaded: stub("safeOneLoaded"),

        /**
        	* Given a new container width, resize this module if necessary
        	*/
        fit: stub("fit"),

        /**
        	* Every module MUST override this method.
        	* @Deprecated
        	*/
        edit: stub("edit"),

        activate: function(event) {
            bldr.pageController.dom.$body.addClass("bldr-active-module-" + this.parent.slug);
            this._isActivated = true;
            try {
                this.onActivate(event);
                this.attachControls();
                if (!this.el.parents(".webs-composite-module").length) {
                    this.startUndoable();
                    bldr.pageController.isUndoing = false;
                }
                this.trigger("activated");
            } catch (error) {
                log.trigger("Modules", "error", this.parent.slug + " threw error in activate", error);
            }
        },

        deactivate: function(event) {
            bldr.pageController.dom.$body.removeClass("bldr-active-module-" + this.parent.slug);
            this._isActivated = false;
            try {
                this.onDeactivate(event);
                var data = this.getData(); // Get data first before destorying controls
                this._pushUndoState();

                if (typeof this.destroy === "function") 
                    this.destroy();
                this.trigger("deactivated");
                this.trigger("blurred");
                if (!this.el.parents(".webs-composite-module").length) {
                    this.endUndoable();
                }
                this.render();
            } catch (error) {
                log.trigger("Modules", "error", this.parent.slug + " threw error in deactivate", error);
            }
        },

        isActivated: function() {
            return this._isActivated ? true : false;
        },

        /**
        	* Every module SHOULD override onActivate (i.e. focus) and onDeactivate (i.e. blur).
        	*/
        onActivate: function(event) {
            var handled = false;
            if (typeof this.edit === "function") {
                log.trigger("Modules", "warn", "Unimplemented function 'onActivate' for module '" + this.parent.slug + "', falling back to 'edit'.", this, event);
                this.edit(event);
                handled = true;
            }
            if (typeof this.focus === "function") {
                log.trigger("Modules", "warn", "Unimplemented 'onActivate' for module '" + this.parent.slug + "', falling back to 'focus'.", this, event);
                this.focus(event);
                handled = true;
            }
            if (!handled) {
                log.trigger("Modules", "warn", "Unimplemented function 'onActivate' for module '" + this.parent.slug + "' without 'edit' or 'focus' fallbacks.", this, event);
            }
        },
        onDeactivate: function(event) {
            if (typeof this.blur === "function") {
                log.trigger("Modules", "warn", "Unimplemented 'onDeactivate' for module '" + this.parent.slug + "', falling back to 'blur'.", this, event);
                this.blur();
            }
        },

        /**
        	* Every module MUST override this method.
        	*/
        getData: function() {
            return this.data;
        },

        attachControls: stub("attachControls"),

        getMinWidth: function() {
            return 50;
        },

        showDialog: function(settings) {
            if (settings.localizeHeading) {
                settings.heading = translate(settings.localizeHeading);
            }
            var popoverSettings = {
                "url": settings.url,
                "heading": settings.heading,
                "width": settings.width,
                "height": settings.height
            };
            $.extend(new Popover(popoverSettings.url, popoverSettings).bind('submit', settings.callback), settings.dialogData).show();
        },

        showHelptip: function showHelptip(message, opts) {
            var $ = top.$,
            self = this;

            setTimeout(function() {
                var toolbar = top.$("#edit_toolbar");
                var offsetLeft = 50;
                if (opts && opts.index) {
                    offsetLeft = 0;
                    var $lis = toolbar.find('li');
                    for (i = 0; i < opts.index; i++) {
                        offsetLeft += $lis.eq(i).outerWidth();
                    }
                }

                self.helptipBubble && self.helptipBubble.hide();
                self.helptipBubble = Helptip.init({
                    detachable: true
                });
                self.helptipBubble.setMessage(message);
                self.helptipBubble.show({
                    ref: toolbar,
                    width: opts && opts.width || null,
                    offsetLeft: offsetLeft,
                    offsetTop: 50,
                    arrow: "top",
                    bounce: true
                });
                self.helptipTimeout && clearTimeout(self.helptipTimeout);
                self.helptipTimeout = setTimeout($.proxy(self, "hideHelptip"), 4000);
                self.bind("blurred", function onBlur() {
                    self.hideHelptip();
                    self.unbind("blurred", onBlur);
                })
            }, 1);
            return;
        },
        hideHelptip: function hideHelptip() {
            if (this.helptipBubble) {
                this.helptipBubble.hide();
                delete this.helptipBubble;
            }
        },
        rightClick: function rightClick(e) {
            var self = this;
            if (toolbar.isActive()) {
                self.showHelptip('<div style="text-align: center">' + translate('webs.module.editToolbarHelptip') + '</div>', {
                    width: 160
                });
            }
        }

    });

    webs.modules.Module.extend({
        instanceStyleSeries: 1
    });

    // Dirty-Related Methods
    webs.modules.Module.include({
        /**
        	* Have changes been made since the last time this was saved?
        	*/
        _dirty: false,

        isDirty: function() {
            return this._dirty;
        },

        dirty: function(makeDirty) {
            if (typeof(makeDirty) !== 'boolean') 
                makeDirty = true;
            var oldDirty = this._dirty;
            this._dirty = makeDirty;
            if (!oldDirty && makeDirty) 
                this.trigger("dirty");
        }
    });

    // Undo-Related Methods
    webs.modules.Module.include({
        /**
        	* Module undo API
        	*/
        startUndoable: function() {
            this._pushUndoState();
            this._undoInterval = setInterval(this.proxy(this._pushUndoState), 1000);
        },

        beforeChange: function() {
            this._pushUndoState();
        },

        endUndoable: function() {
            clearInterval(this._undoInterval);
        },

        /**
        	 * Carry out undo operation:
        	 *  - set module data
        	 *  - add redo
        	 *  - don't add an undo state for this change.
        	*/
        doUndo: function(data, redo) {
            var oldData = this._lastUndoState;

            if (typeof this.beforeUndo === 'function') {
                this.beforeUndo();
            }

            bldr.pageController.isUndoing = true;

            /**
            		 * bldr.pageController.currentActiveModule is set at the end of an undo.
            		 * If "this" does not equal it, we've just jumped between two module's edit mode.
            		 */
            bldr.pageController.currentActiveModule = bldr.pageController.currentActiveModule || this;
            var undoBetweenTwo = this != bldr.pageController.currentActiveModule;
            if (undoBetweenTwo) {
                bldr.pageController.clearCurrentController();
            }

            this.init({
                data: data,
                el: this.el
            });

            /**
            		 * If we're jumping between module's edit mode, we need to call setCurrentController on it's controller
            		 * Otherwise, just render and let the active module's edit mode handle the rest (through afterUndo method)
            		 */
            var currentController = this.el.parent().parent().data('controller');
            if (undoBetweenTwo) {
                bldr.pageController.setCurrentController(currentController);
            } else {
                if (!bldr.pageController.isActive()) 
                    bldr.pageController.setCurrentController(currentController);
                else 
                    this.render();
            }
            if (typeof this.afterUndo === 'function') 
                this.afterUndo();

            this._lastUndoState = $.extend(true, {}, data);
            undoer.pushAction(this.doUndo, [oldData, !redo], this);

            bldr.pageController.currentActiveModule = this;
            this.dirty(true);
        },

        getModuleController: function() {
            if (!this.moduleController) 
                this.moduleController = this.el.parent().parent().data("controller");
            return this.moduleController;
        },

        _pushUndoState: function() {
            var data = $.extend(true, {}, this.getData()),
            oldData = this._lastUndoState;

            for (var k in data) {
                if (data[k] === undefined) 
                    delete data[k];
            }
            if (theSame(data, oldData)) 
                return false;
            if (!oldData) {
                this._lastUndoState = data;
                return data;
            }

            this.dirty(true);

            undoer.pushAction(this.doUndo, [oldData], this);
            this._lastUndoState = data;
            return data;
        }
    });

    // Class Methods
    webs.modules.Module.extend({
        shouldShowCover: function() {
            return false;
        }
    });

    /* ********** App Modules ********** */

    webs.modules.AppModule.include({
        init: function(options) {
            this.el = options.el;
        },
        fit: function() {},
        render: function() {
            var self = this;
            this.withContent(function(content) {
                self.el.html(content);
            });

            // Don't let them click anything in the module
            this.el.click(function() {
                return false;
            });

            this.trigger("rendered");
        },
        withContent: function(callback) {
            if (this.content) 
                return callback(this.content);
            if (this.waitingForContent) 
                return this.waitingForContent.push(callback);

            // set queue and content on class, only fetched once
            this.parent.fn.waitingForContent = [callback];
            var self = this,
            url = "/s/sitebuilder/api/appmodules/" + this.id + "/html";
            $.ajax({
                url: url,
                success: function(result) {
                    self.parent.fn.content = result;
                    $.each(self.waitingForContent, function(i, fn) {
                        fn(result);
                    });
                },
                error: function() {
                    var result = "App Content Temporarily Unavailable.";
                    self.parent.fn.content = result;
                    $.each(self.waitingForContent, function(i, fn) {
                        fn(result);
                    });
                    log.error("Unable to load AppModule HTML. ID:", self.id);
                }
            });
        }
    });

    webs.modules.AppModule.extend({
        subclass: function(data) {
            var klass = this.create({
                id: data.id,
                name: data.appName,
                title: data.title,
                slug: "app-sidebar-" + data.id,
                icon: data.appIconURL.replace("icon", "icon-large")
            });

            // add to toaster
            chromeController.dockController.addModule("webs.bldr.dock.ads.appfeeds", {
                label: klass.fn.title,
                slug: klass.fn.slug,
                icon: klass.fn.icon
            });

            // add to global modules
            ModuleClassLoader.classes[klass.fn.slug] = klass;
        },
        fetch: function(callback) {
            var url = "/s/sitebuilder/api/appmodules/";
            $.ajax({
                url: url,
                dataType: 'json',
                cache: false,
                success: this.initAll
            });
        },
        initAll: function(data) {
            this.instances = $.map(data, function(datum) {
                return webs.modules.AppModule.subclass(datum);
            });
            chromeController.dockController.addAds();
        }
    });


    /* ********** Custom Modules ********** */

    webs.modules.CustomModule.include({});

    /* ********** Composite Modules ********** */

    webs.modules.CompositeModule.include({

        init: function(options) {

            webs.modules.CustomModule.fn.init.call(this, options);

        }

    });

    /* ********** Iframe Modules ********** */

    webs.modules.IframeModule.include({
        /**
        	* Called after the HTML has been written to the page.
        	*/
        safeOneLoaded: function() {},

        /**
        	* To edit an iframe module, we just open a popover with the proper content.
        	*/
        edit: function(event) {
            log.trigger("Modules", "debug", "IframeModule.edit called instead of .activated", this, event);
            this.activated(event);
        },
        activated: function(event) {
            var openIframe = this.proxy(this.openIframe),
            toolbar = toolbar.create('iframe');

            toolbar.addListener('edit', openIframe);
            this.el.dblclick(openIframe);

            toolbar.show({});

            /*
            		* When the user is done interacting with the iframe,
            		* the 3rd party sends them to our callback URL,
            		* which then calls widgetComplete
            		*/
            top.widgetComplete = this.proxy(function(result) {
                top.websover.hide();
                if (this.parent.iframe.data_key) 
                    this.data[this.parent.iframe.data_key] = result;
                else 
                    this.data = result;
                this.dirty(true);
                this.render();
            });
        },

        render: function() {
            this.el.html('<iframe></iframe>');
            this.el.children('iframe').css('max-width', '100%').css('border', 0);
            var self = this,
            iframe = this.el[0].firstChild,
            frameDoc;

            if (iframe.contentWindow) {
                frameDoc = iframe.contentWindow.document;
            } else {
                if (iframe.contentDocument) {
                    frameDoc = iframe.contentDocument.document || iframe.contentDocument;
                }
            }

            this.written = false;
            if (frameDoc) {
                frameDoc.open();
                frameDoc.write(this.html());
                frameDoc.close();
                $(frameDoc.body).css('margin', 0).css('padding', 0);
                this.written = true;

                $(frameDoc).unbind('ready').ready(function() {
                    setTimeout(function() {
                        if (frameDoc.body) 
                            self.el.children('iframe').height(frameDoc.body.scrollHeight).width(frameDoc.body.scrollWidth);
                    }, 50);
                });
            }

            this.trigger("rendered");
        },

        fit: function() {
            var self = this,
            iframe = this.el[0].firstChild,
            frameDoc;

            if (iframe.contentWindow) {
                frameDoc = iframe.contentWindow.document;
            } else {
                if (iframe.contentDocument) {
                    frame = iframe.contentDocument.document || iframe.contentDocument;
                }
            }

            if (frameDoc) {
                if (!this.written) {
                    frameDoc.open();
                    frameDoc.write(this.html());
                    frameDoc.close();
                    $(frameDoc.body).css('margin', 0).css('padding', 0);
                    this.written = true;
                }

                $(frameDoc).unbind('ready').ready(function() {
                    setTimeout(function() {
                        if (frameDoc.body) 
                            self.el.children('iframe').height(frameDoc.body.scrollHeight).width(frameDoc.body.scrollWidth);
                    }, 50);
                });
            }
        },

        openIframe: function() {
            var config = this.parent.iframe,
            callbackUrl = 'http://members.webs.com/MembersB/WidgetBank/widgetCallback.jsp',
            url = Handlebars.compile(config.url)({
                data: this.data,
                site: webs.site,
                callback_url: callbackUrl 
            }),
            popover = new Popover(url, {
                heading: this.name,
                width: config.width,
                height: config.height,
                feedback: {
                    ref: this.el
                }
            });

            popover.show();
        }
    });

    var RESOLVED_PROMISE = $.Deferred().resolve().promise(),
    consolidatedLessPromises = {},
    jsLoading = false,
    lessLoading = false,
    lessVariablesBySlug = {};

    /**
     * Get the Less variables for the module slug specified in the url
     *
     * This code segment was removed from the ModuleClassLoader.loadLess() function defined
     * below so that it could be invoked from multiple places in the code. This was necessary
     * because the new endpoint that loads the less/Javascript for all modules will return less
     * for modules that exist on pages other than the home page.
     */
    var getLessVariablesForSlug = function(moduleSlug) {
        lessVariablesBySlug[moduleSlug] = themeService.getThemeLessVariables(bldr.theme);
    };

    ModuleClassLoader.parent.include({
        loadJs: function(moduleSlug) {
            if (this.shouldConsolidateAssets(moduleSlug)) {
                if (!jsLoading) {
                    var url = this.CACHED_MODULES_URL + 'assets/edit?modulesVersion=' + webs.props.modulesVersion;;
                    require([url], function() {
                        jsLoading = false;
                    });
                    jsLoading = true;
                }
            } else {
                require([this.getModuleAssetURL(moduleSlug, moduleSlug + '_edit.js')], null);
            }
        },

        cssPath: function(slug) {
            return this.getModuleAssetURL(slug, 'edit.packaged.less');
        },

        loadCss: function(url) {
            if (url.indexOf('.less') === url.length - 5) {
                return this.loadLess(url);
            } else {
                bldr.pageController.dom.$head.append('<link rel="stylesheet" href="' +
                url + '" type="text/css" />');
                return RESOLVED_PROMISE;
            }
        },

        loadLess: function(url) {

            var moduleLessPromise = $.Deferred(),
            originalUrl = url,
            moduleSlug = this.getModuleSlugFromUrl(url),
            dataType = 'text';

            url = webs.props.dynamicAssetServer + url;
            if (this.shouldConsolidateAssets(moduleSlug)) {
                if (consolidatedLessPromises[moduleSlug]) {
                    return consolidatedLessPromises[moduleSlug].promise();
                }
                if (url.indexOf("modules") > - 1) {
                    if (lessLoading) {
                        consolidatedLessPromises[moduleSlug] = moduleLessPromise;
                        return consolidatedLessPromises[moduleSlug].promise();
                    }
                    //Use 1 promise to rule all requests
                    url = this.CACHED_MODULES_URL + 'assets/edit.packaged.less?modulesVersion=' + webs.props.modulesVersion;
                    dataType = 'json';
                    lessLoading = true;
                }
            }
            consolidatedLessPromises[moduleSlug] = moduleLessPromise;
            $.ajax({
                url: url,
                dataType: dataType,
                cache: true,
                success: function(data, textStatus, jqXHR) {
                    if (typeof data == "string") {
                        var realdata = {};
                        realdata[moduleSlug] = data;
                        data = realdata;
                    }
                    var accumulatedCSS = '';
                    for (var slug in data) {
                        if (lessVariablesBySlug[slug] === undefined) {
                            //The slug represents a module that was not requested by SiteBuilder.
                            //This can occur because the endpoint returns all modules for the site,
                            //regardless of whether they exist on the home page.
                            getLessVariablesForSlug(slug);
                        }
                        var parser = new (less.Parser)({
                            paths: [ originalUrl.replace(moduleSlug + "/v" + moduleVersions[moduleSlug], slug + "/v" + moduleVersions[slug]).replace(/\/[^\/]*$/, '/') ],
                            filename: originalUrl.replace(moduleSlug + "/v" + moduleVersions[moduleSlug], slug + "/v" + moduleVersions[slug]).replace(/.*\/s\//, '')
                        });
                        parser.parse(data[slug], function(e, tree) {
                            var cssString = tree ? tree.toCSS({}, lessVariablesBySlug[slug] || {}) : "";
                            accumulatedCSS += cssString + '\n';
                        });
                        if (!consolidatedLessPromises[slug]) {
                            consolidatedLessPromises[slug] = moduleLessPromise;
                        }
                        consolidatedLessPromises[slug].resolve();
                    }
                    bldr.pageController.dom.$head.append(
                    '<style type="text/css">' + accumulatedCSS + '</style>'
                    );
                    lessLoading = false;
                },
                error: function(jqXHR, textStatus, errorThrown) {
                    // Uh oh.. What do we do now?
                    moduleLessPromise.reject(jqXHR, textStatus, errorThrown);
                    log.trigger("Modules", "error", 'Unable to load ' + url);
                }
            });
            return moduleLessPromise.promise();
        },

        loadTextAsset: function(url) {
            var deferred = $.Deferred();
            require(["text!" + url], deferred.resolve);
            return deferred.promise();
        }
    });

    ModuleClassLoader.bind('created', function(module) {
        // Load fonts for modules as they are rendered
        module.bind('rendered', function(html) {
            var re = /w-font-(\w+)/g,
            match;
            while (match = re.exec(html)) {
                require('internal/sitebuilder/common/fontsController').loadFont(match[1]);
            }
        });
    });

    // util
    //
    // Are two things the same? If they are equal, or they are both NaN
    // this is just $.isEqual but with special case for NaN
    function theSame(a, b) {
        if (a === b) 
            return true; //object identity
        var atype = typeof a;
        var btype = typeof b;
        if (atype != btype) 
            return false; //check types
        if (a == b) 
            return true; //basic equality
        if ((!a && b) || (a && !b)) 
            return false; //one falsy and other truthy
        if (a.isEqual) 
            return a.isEqual(b); //one implement isEqual?
        if (top.$.isDate(a) && top.$.isDate(b)) 
            return a.getTime() === b.getTime(); //dates
        if (top.$.isNumber(a) && isNaN(a) && top.$.isNumber(b) && isNaN(b)) 
            return true; //NaNs?
        if (top.$.isRegExp(a) && top.$.isRegExp(b)) {
            //regexps?
            return a.source === b.source &&
            a.global === b.global &&
            a.ignoreCase === b.ignoreCase &&
            a.multiline === b.multiline;
        }
        if (atype !== 'object') 
            return false; //not an object, can't handle it
        if (a.length && (a.length !== b.length)) 
            return false; //diff array length?

        var aKeys = top.$.keys(a);
        var bKeys = top.$.keys(b);
        if (aKeys.length != bKeys.length) 
            return false; //different object sizes?

        //recursive comparison of contents
        for (var key in a) {
            if (!(key in b) || !theSame(a[key], b[key])) {
                return false;
            }
        }

        return true;
    }


    // Load app modules
    webs.modules.AppModule.fetch();

    return webs.modules;
});
/* jshint ignore:end */
;
(function() {

    // titlebar: draggy tabby closey one (sometimes settings)
    // module bar: cover, spans the page, module can add buttons
    // toolbar: comes down from the top, generated by controls

    var eventBufferGlobal;

    define('internal/sitebuilder/builderChrome/PageController', [
    'jquery',
    'require',
    'spine',
    'internal/sitebuilder/common/eventBuffer',
    'internal/sitebuilder/builderChrome/ColumnResizeController',
    'internal/sitebuilder/common/log',
    'internal/sitebuilder/builderChrome/chromeController',
    'internal/sitebuilder/builderChrome/nodes',
    'internal/sitebuilder/builderChrome/nodeControllers',
    'internal/sitebuilder/common/ModuleClassLoader',
    'internal/sitebuilder/builderChrome/binaryPlane',
    'internal/sitebuilder/builderChrome/dragController',
    'internal/sitebuilder/builderChrome/undoer',
    'internal/common/tooltip',
    'sb3Branding',
    'translate!webs.bldr',
    'internal/sitebuilder/common/themeService',
    'less',
    'tracking/trackingHub',
    // Non-arg requirements
    'tracking/googleAnalyticsSender'
    ], function($, require, Spine, eventBuffer, ColumnResizeController, log, chromeController, nodes, nodeControllers, ModuleClassLoader, binaryPlane, dragController, undoer, tooltip, sb3Branding, translate, themeService, less, trackingHub) {
        eventBufferGlobal = eventBuffer;

        var CLASSES = {
            TREE: 'webs-content',
            BINPARENT: 'webs-parent',
            ROW: 'webs-row',
            COLUMN: 'webs-col',
            TOPLEVEL: 'webs-parent-0',

            BIN: 'webs-bin',
            BINWRAP: 'webs-bin-wrap',
            BINACTIVE: 'webs-bin-active',
            CONTAINER: 'webs-container',
            EDGE: 'bldr-edge',

            BINOVERLAY: 'bldr-bin-overlay',
            COVER: 'bldr-canvas-cover'
        };


        var PageController = Spine.Controller.create({
            elements: {
                "#bldr-canvas-cover": "cover",
                "#bldr-canvas-cover-top": "coverTop",
                "#bldr-canvas-cover-bottom": "coverBottom",
                "#bldr-canvas-cover-left": "coverLeft",
                "#bldr-canvas-cover-right": "coverRight"
            },

            events: {
                "mousedown": "pageBodyClick",
                "mouseenter .webs-bin": "mouseEnterNode",
                "mouseleave .webs-bin": "mouseLeaveNode",
                "mouseenter .webs-row": "mouseEnterRow",
                "mouseleave .webs-row": "mouseLeaveRow",
                "click .bldr-canvas-cover": "clearCurrentController"
            },

            proxied: ["clearCurrentController", "setCurrentController", "mouseEnterNode", "mouseLeaveNode", "mouseEnterRow", "mouseLeaveRow"],

            init: function(obj) {
                var self = this;

                this.$ = obj.$;
                this.doc = obj.doc;
                this.win = obj.win;
                this.parent = obj.parent;

                this.dom = {
                    $win: this.$(this.win),
                    $doc: this.$(this.doc),
                    $body: this.$(this.doc.body),
                    $html: this.$('html'),
                    $htmlbody: this.$('html,body'),
                    $head: this.$('head'),
                    $header: this.$('#webs-header'),
                    $trees: this.$('.' + CLASSES.TREE),
                    $bin: this.$('.' + CLASSES.BIN)
                };

                this._treesLoadedDeferred = new $.Deferred();
                this.treesLoadedPromise = this._treesLoadedDeferred.promise();

                this.el = this.dom.$body;
                this.delegateEvents();

                this.renderCover();
                this.renderBinOverlay();
                this.refreshElements();

                bldr.theme = top.webs.theme = this.win.webs.theme;

                if (top.webs.frontendCSS) {
                    this.innerFrameStyledPromise = this.styleInnerFrame();
                } else {
                    var cssDeferred = $.Deferred();
                    cssDeferred.resolve();
                    this.innerFrameStyledPromise = cssDeferred.promise();
                }

                setTimeout(function() {
                    $("body").trigger("bldr:page:load");
                    if (sb3Branding.onEdit)
                        sb3Branding.onEdit();
                    self.display();
                    chromeController.pageLoad();
                }, 10);


                // Prevents backspace from moving browser history back
                this.dom.$doc.bind("keydown", function(e) {
                    var doPrevent;
                    if (e.keyCode == 8) {
                        // Backspace
                        var
                        target = e.target,
                        isInput = target.tagName.toUpperCase() == 'INPUT',
                        isTextarea = target.tagName.toUpperCase() == 'TEXTAREA',
                        $target = $(target),
                        isEditableContainer = $target.is(".w-text, .webs-text") ||
                        $target.parents(".w-text, .webs-text").length ||
                        $target.is('[contenteditable="true"]') ||
                        $target.parents('[contenteditable="true"]').length;

                        doPrevent = (isInput || isTextarea || isEditableContainer) ? target.readOnly || target.disabled : true;
                    } else 
                        doPrevent = false;

                    if (doPrevent) 
                        e.preventDefault();
                });


                /* Titlebar */
                var makeTitlebar = function() {
                    var CLASSES = {
                        TREE: 'webs-content',
                        BINPARENT: 'webs-parent',
                        ROW: 'webs-row',
                        COLUMN: 'webs-col',
                        TOPLEVEL: 'webs-parent-0',

                        BIN: 'webs-bin',
                        BINWRAP: 'webs-bin-wrap',
                        BINACTIVE: 'webs-bin-active',
                        CONTAINER: 'webs-container',
                        EDGE: 'bldr-edge',

                        BINOVERLAY: 'bldr-bin-overlay',
                        COVER: 'bldr-canvas-cover'
                    };

                    var activeBin = null,
                    toolTip = null, toolTipEvents = null, toolTipTimeout = null,
                    container = $('<div/>').addClass('bldr-titlebar'),
                    wrap = $('<div/>').addClass('bldr-titlebar-wrap'),
                    moveButton = $('<a/>').addClass('bldr-titlebar-move bldr-titlebar-button').attr('data-tooltip-text', translate('webs.bldr.canvas.titlebar.drag')),
                    deleteButton = $('<a/>').addClass('bldr-titlebar-delete bldr-titlebar-button').attr('data-tooltip-text', translate('webs.bldr.canvas.titlebar.delete')),
                    settingsButton = $('<a/>').addClass('bldr-titlebar-settings bldr-titlebar-button').attr('data-tooltip-text', translate('webs.bldr.canvas.titlebar.settings')),
                    moveTooltip = $('<div/>').addClass('bldr-titlebar-tooltip'),
                    resetActiveBin = function() {
                        activeBin.children('.' + CLASSES.BINWRAP).removeClass('bldr-move-active');
                    },
                    offset = {
                        x: undefined,
                        y: undefined 
                    },
                    undoer = require('internal/sitebuilder/builderChrome/undoer'),
                    chromeController = require('internal/sitebuilder/builderChrome/chromeController'),
                    dragController = require('internal/sitebuilder/builderChrome/dragController'),
                    /**
                    					 * Allows binding to the delete element
                    					 */
                    bindDelete = function(fn, type, unbind) {
                        if (typeof type === "undefined") 
                            type = "mousedown";
                        if (typeof unbind === "undefined") 
                            unbind = true;

                        if (unbind) 
                            deleteButton.unbind(type);
                        deleteButton.bind(type, fn);
                    },
                    /**
                    					 * Bindings for when delete button is clicked, page options menu is shown
                    					 * to indicate that a page layout can be changed
                    					 */
                    bindPageLayout = function(controller) {
                        show(controller, {
                            disableMove: true,
                            deleteFn: function() {
                                hide();
                                require('internal/sitebuilder/builderChrome/chromeController').showPageOptionsHelptip({
                                    id: "change_page_layout",
                                    msg: translate('webs.bldr.canvas.pages.delete.msg'),
                                    width: 200,
                                    offsetLeft: - (200 + 30),
                                    offsetTop: - 20
                                });
                                return false;
                            }
                        });
                    },
                    /**
                    					* Hide the titlebar.
                    					*/
                    hide = function() {
                        container.removeClass('active');
                    },
                    /**
                    					* Show the titlebar on the given bin.
                    					* opts allow you to override delete function and disable move binding
                    					*/
                    show = function(controller, opts) {
                        opts = opts || {};
                        var node = controller.model,
                        bin = controller.el,
                        showSettingsButton =
                        node &&
                        node.module &&
                        (
                        (node.module.hasSettingsDialog ? node.module.hasSettingsDialog() : node.module.showSettingsDialog) ||
                        (
                        node.module.parent &&
                        node.module.parent.settingsDialog
                        )
                        ),
                        showDeleteButton = node.isRemovable();

                        if (showSettingsButton || showDeleteButton || node.isMovable()) {

                            toolTip = toolTip || bldr.pageController.$.tooltip({
                                content: "",
                                style: "mini"
                            });

                            toolTipEvents = {
                                'mouseenter.ttip' : function() {
                                    toolTip.html($(this).data("tooltip-text"));
                                    toolTip.addClass("active");
                                    window.clearTimeout(toolTipTimeout);
                                },
                                'mouseleave.ttip' : function() {
                                    toolTip.removeClass("active");

                                    // throw tooltip off screen after opacity transition (fixes issue in IE9)
                                    // ideally, some solution should be incorporated into tooltip.js
                                    toolTipTimeout = window.setTimeout(function() {
                                        toolTip.css({
                                            top: '-9999px',
                                            left: '-9999px'
                                        });
                                    }, 200);
                                },
                                'mousedown.ttip' : function() {
                                    toolTip.removeClass("active");

                                    // throw tooltip off screen after opacity transition (fixes issue in IE9)
                                    // ideally, some solution should be incorporated into tooltip.js
                                    toolTipTimeout = window.setTimeout(function() {
                                        toolTip.css({
                                            top: '-9999px',
                                            left: '-9999px'
                                        });
                                    }, 200);
                                }
                            };


                            bin.append(container);
                            container.addClass('active').removeClass('bldr-titlebar-moving bldr-titlebar-with-tooltip');

                            if (showDeleteButton) {
                                deleteButton
                                .addClass('active')
                                .unbind('mouseenter.ttip mouseleave.ttip mousedown.ttip')
                                .bind(toolTipEvents);
                                var deleteFn = opts.deleteFn || function(e) {
                                    if (e.which === 1) {
                                        if (bldr.pageController.isActive()) {
                                            bldr.pageController.clearCurrentController();
                                        }

                                        controller.remove();

                                        //make sure tooltip is hidden on mousedown
                                        toolTip.removeClass('active');
                                        return false;
                                    }
                                };
                                bindDelete(deleteFn);
                                deleteButton.show();
                            } else {
                                deleteButton
                                .hide()
                                .unbind('mouseenter.ttip mouseleave.ttip mousedown.ttip')
                                .removeClass('active');
                            }

                            if (showSettingsButton) {
                                settingsButton
                                .show()
                                .addClass('active')
                                .unbind('mousedown mouseenter.ttip mouseleave.ttip')
                                .bind(toolTipEvents)
                                .bind('mousedown', function(e) {
                                    if (e.which === 1) {
                                        var module = node.module;

                                        // activate the current controller when settings button is clicked
                                        bldr.pageController.setCurrentController(node.controller);

                                        if (typeof module.showSettingsDialog === "function") {
                                            node.module.showSettingsDialog();
                                        } else {
                                            module.showDialog($.extend(
                                            {
                                                dialogData: {
                                                    data: module.data
                                                },
                                                callback: function(obj) {
                                                    module.data = obj;
                                                    module.dirty();
                                                    module.render();
                                                }
                                            },
                                            module.parent.settingsDialog
                                            ));
                                        }
                                        return false;
                                    }
                                });
                            } else {
                                settingsButton
                                .hide()
                                .unbind('mouseenter.ttip mouseleave.ttip mousedown.ttip')
                                .removeClass('active');
                            }

                            if (node.isMovable() && !opts.disableMove) {
                                moveButton
                                .removeClass('bldr-titlebar-move-nomove')
                                .unbind('mousedown mouseenter.ttip mouseleave.ttip')
                                .bind(toolTipEvents)
                                .bind('mousedown', function(e) {
                                    if (e.which === 1) {
                                        undoer.startGroup("moving node");
                                        if (eventBufferGlobal)
                                            eventBufferGlobal.trigger("module:move", {
                                                moduleType: node.moduleType 
                                            });

                                        var cOffset = container.offset();
                                        offset.x = e.clientX - cOffset.left - container.width() / 2;
                                        offset.y = e.clientY - (cOffset.top + 25) - 18 / 2;
                                        offset.savedScroll = bldr.pageController.dom.$win.scrollTop(); // hang on to this value since the page could scroll off at any time

                                        //						bldr.canvas.insertRef = activeBin.data('node');

                                        bldr.pageController.showGrid();

                                        dragController.offsetX = 0;
                                        dragController.offsetY = 0;

                                        container
                                        .appendTo(bldr.pageController.dom.$body)
                                        .addClass('bldr-titlebar-moving')
                                        .css({
                                            left: e.clientX - offset.x,
                                            top: e.clientY - offset.y
                                        });

                                        if (bldr.pageController.isActive()) {
                                            bldr.pageController.clearCurrentController();
                                        }

                                        $('.' + CLASSES.EDGE).removeClass('active');
                                        activeBin.children('.' + CLASSES.BINWRAP).addClass('bldr-move-active');
                                        bldr.pageController.cover.show();
                                        bldr.pageController.dom.$body.addClass('moving');
                                        bldr.pageController.moving = true;
                                        bldr.pageController.movingNode = activeBin.data('controller').model;

                                        settingsButton.animate({
                                            'left': 22
                                        }, 150);
                                        deleteButton.animate({
                                            'right': 22
                                        }, 150, function() {
                                            settingsButton.hide();
                                            deleteButton.hide();
                                            container.addClass('bldr-titlebar-with-tooltip');
                                        });
                                        bldr.pageController.dom.$body.mousemove(moveMousemove);
                                        bldr.pageController.dom.$body.mouseup(moveMouseup);
                                        //						dragController.bind('dragend', moveMouseup);
                                        return false;
                                    }
                                });
                            } else {
                                moveButton
                                .addClass('bldr-titlebar-move-nomove')
                                .unbind('mousedown mouseenter.ttip mouseleave.ttip')
                                .bind('mousedown', function() {
                                    return false;
                                });
                            }
                        }
                        if (container.html() === "") 
                            appendChildren();
                        activeBin = bin;
                        return false;
                    },
                    moveMousemove = function(e) {
                        var scrollDiff = bldr.pageController.dom.$win.scrollTop() - offset.savedScroll,
                        left = e.clientX - offset.x,
                        top = e.clientY - offset.y + scrollDiff;

                        container.css({
                            left: left,
                            top: top 
                        });

                        // because brush.winMousemove knows how to handle a mousemove event and draw the blue lines, etc.
                        e.clientY += chromeController.pageBoundary.top;
                        dragController.mousemove(e);
                    },
                    moveMouseup = function() {
                        var pageController = bldr.pageController;

                        bldr.pageController.setGrid();

                        // removes inline style property
                        // Wait 150 ms in case user performs quick click, delete and settings btn will reset after set
                        setTimeout(function() {
                            container.css({
                                left: '',
                                top: '' 
                            });
                            deleteButton.css('right', '');
                            settingsButton.css('left', '');
                        }, 150);

                        //			pageController.unbind('dragend', moveMouseup);
                        pageController.dom.$body.removeClass('moving').unbind('mousemove', moveMousemove).unbind('mouseup', moveMouseup);
                        pageController.moving = false;
                        pageController.cover.hide();
                        chromeController.toggleControls(true);

                        // make sure titlebar and active look and feel are removed
                        hide();
                        pageController.$('.bldr-move-active').removeClass('bldr-move-active');

                        var bin = activeBin,
                        nodeController = bin.data('controller'),
                        node = nodeController.model,
                        binOverlay = pageController.binOverlay;

                        // add container onto the page
                        if (binOverlay.overBin && binOverlay.side) {
                            var referenceNode = binOverlay.overBin.data('controller').model,
                            side = binOverlay.side;

                            // Dropping into the footer requires premium services
                            // TODO: This could be cleaner. Ideally it should ask the treeController if we're allowed to drop
                            if (!webs.site.editableFooter && referenceNode.tree().controller.el.data('role') == 'webs-footer') {
                                bldr.pageController.hideDropLocation();
                                webs.showPremiumDialog('footer');
                                return false;
                            }

                            if (node != referenceNode) {
                                nodeController.moveTo(referenceNode, side);
                            }
                            pageController.hideDropLocation();
                            self.show(nodeController);
                        }

                        dragController.hideGhost();
                        dragController.emptyNodeInfo();

                        undoer.endGroup("moving node");
                    },
                    appendChildren = function() {
                        container.append(
                        wrap.append(
                        $('<div/>').addClass('bldr-titlebar-padding'),
                        settingsButton,
                        deleteButton,
                        moveButton.html('<span class="icon"></span>'),
                        moveTooltip.html('<span class="icon"></span>' + translate('webs.bldr.canvas.drag.msg'))
                        )
                        );
                    };

                    appendChildren();



                    var self = {
                        container: container,
                        show: show,
                        hide: hide,
                        bindPageLayout: bindPageLayout,
                        getActiveBin: function() {
                            return activeBin;
                        },
                        getOffset: function() {
                            return offset;
                        },
                        resetActiveBin: resetActiveBin
                    };
                    return self;
                };

                // canvas API
                this.insertRef = null;
                this.moduleBar = null;

                this.gridActive = false;
                this.moving = false;
                this.animateFeedback = false;
                this.activeTitlebar = makeTitlebar();
                this.hoverTitlebar = makeTitlebar();
                this.activeTitlebar.container.addClass('bldr-titlebar-active');
                this.hoverTitlebar.container.addClass('bldr-titlebar-hover');

                var dragController = require('internal/sitebuilder/builderChrome/dragController');
                // When we're dragging, we want to leave edit mode of any module we're editing
                dragController.bind('dragstart', this.clearCurrentController);

                // Show grid when dragging, set its toggle when done, and scroll to and highlight drop targets
                dragController.bind('dragstart', function() {
                    self.showGrid();
                    self.obscureAllButDropTargets();
                    self.scrollToDropTarget();
                });
                dragController.bind('dragend', function() {
                    self.deobscureAllButDropTargets();
                    self.setGrid();
                });

                self.columnResizeController = ColumnResizeController.init({
                    el: self.win,
                    pageController: self
                });
                // FIXME: Hack to load ColumnResizeController until we can require it properly.
                //			define('crazyhack', ['ColumnResizeController'], function(ColumnResizeController){
                //			});

                // Remove nav functionality (Haroon wants it for the demo, we whould revisit this... so we see it when grepping later, TODO:)
                //this.$('#nav a').click(function(){ return false; });
            },

            styleInnerFrame: function() {
                var lessVariables = themeService.getThemeLessVariables(bldr.theme),
                styleLessURL = webs.props.dynamicAssetServer + bldr.theme.url + "/" + bldr.theme.style.css,
                themeLessDeferred = new $.Deferred();
                $.ajax({
                    url: styleLessURL,
                    type: "GET",
                    cache: true,
                    success: $.proxy(function(styleLess) {
                        var parser = new less.Parser({
                            paths: [styleLessURL.replace(/[^\/]*$/, "")]
                        });
                        parser.parse(styleLess, $.proxy(function(e, tree) {
                            var css = tree.toCSS({}, lessVariables);
                            this.$("<style></style>").appendTo(this.dom.$head)[0].innerHTML = css;
                            themeLessDeferred.resolve();
                        }, this));

                    }, this)
                });
                return themeLessDeferred.promise();
            },

            treeContainers: function() {
                if (typeof(this._treeContainers) === 'undefined') {
                    _treeContainers = this.$(".webs-content");
                }
                return _treeContainers;
            },
            display: function() {
                ModuleClassLoader.loadAll(['title', 'text', 'image', 'text_image']);

                this.trees = $.map(this.treeContainers(), function(treeContainer) {
                    var treeEl = $(treeContainer);
                    if (treeEl.data('websLocked')) {
                        treeEl.addClass('webs-tree-locked');
                    }

                    var treeData = webs.page.sections[treeEl.context.id];
                    return nodeControllers.TreeController.init({
                        el: treeEl,
                        treeData: treeData
                    });
                });

                var treeLoadPromises = $.map(this.trees, function(treeController) {
                    return treeController.treeLoadedPromise;
                });
                window._performanceLabels = window._performanceLabels || [];
                $.when.apply($, treeLoadPromises).done(function() {
                    window._performanceLabels.push("treeLoadSuccess");
                }).fail(function() {
                    window._performanceLabels.push("treeLoadFailure");
                });
                $.when.apply($, $.map(this.trees, function(treeController) {
                    return treeController.treeLoadedIgnoringErrorsPromise;
                })).done(this._treesLoadedDeferred.resolve);
                this.trees._roleHash = {};
                this.trees.find = function(role) {
                    var hash = this._roleHash;
                    if (typeof hash[role] === "undefined") {
                        for (var i = 0, len = this.length; i < len; i++) {
                            if (this[i].role === role) 
                                hash[role] = this[i];
                        }
                        if (!hash[role]) 
                            hash[role] = null;
                    }
                    return hash[role];
                };

                this.dom.$body.attr("spellcheck", "false");
            },

            renderBinOverlay: function() {
                return (this.binOverlay = this.binOverlay ||
                {
                    el: $('<div/>').attr('id', CLASSES.BINOVERLAY).append(
                    $('<div/>').addClass(CLASSES.BINOVERLAY + '-nub1'),
                    $('<div/>').addClass(CLASSES.BINOVERLAY + '-nub2'),
                    $('<div/>').addClass(CLASSES.BINOVERLAY + '-arrow')
                    ),
                    overBin: null,
                    // which bin is the border over?
                    side: null,
                    // which side is the bin border covering? top/right/bottom/left
                    width: 13,
                    height: 13
                });
            },

            renderCover: function() {
                /* jshint ignore:start */
                return (this.cover = (this.cover && this.cover.length > 0) ? this.cover :
                $("<div id=\"bldr-canvas-cover\"></div>\
                <div class=\"bldr-canvas-cover\" id=\"bldr-canvas-cover-top\"></div>\
                <div class=\"bldr-canvas-cover\" id=\"bldr-canvas-cover-bottom\"></div>\
                <div class=\"bldr-canvas-cover\" id=\"bldr-canvas-cover-left\"></div>\
                <div class=\"bldr-canvas-cover\" id=\"bldr-canvas-cover-right\"></div>").prependTo(this.dom.$body));
                /* jshint ignore:end */
            },

            showCover: function(controller) {
                var container = (controller && controller.el) || (this.currentController && this.currentController.el);
                if (!container || container.length === 0) 
                    return false;

                var parent = container.parent(),
                offset = container.offset(),
                _width = container.width(),
                _height = container.height(),
                $body = this.dom.$body,
                bodyHeight = $body.height(),
                bodyWidth = $body.width();

                this.coverTop.css({
                    display: "block",
                    top: - offset.top - 1,
                    left: - offset.left - 1,
                    width: bodyWidth,
                    height: offset.top + 1
                });
                this.coverLeft.css({
                    display: "block",
                    top: 0,
                    left: - offset.left - 1,
                    width: offset.left + 1,
                    height: bodyHeight - offset.top
                });
                this.coverRight.css({
                    display: "block",
                    top: 0,
                    left: _width,
                    width: bodyWidth - (offset.left + 1 + _width),
                    height: bodyHeight - offset.top
                });
                this.coverBottom.css({
                    display: "block",
                    top: _height,
                    left: 0,
                    width: _width,
                    height: bodyHeight - offset.top - _height
                });
                container.prepend(this.coverTop, this.coverBottom, this.coverLeft, this.coverRight);
                return this.cover;
            },

            hideCover: function() {
                this.dom.$body.find('.bldr-canvas-cover').hide();
            },


            /* filler for brush api */
            isMoving: function() {
                return this.moving;
            },
            getModuleBar: function() {
                return this.moduleBar;
            },

            /**
            		* Show the grid, regardless of whether the user has chosen to show it or not
            		* (Used when a user is dragging stuff. We force the grid as a guide)
            		*/
            showGrid: function() {
                this.fixTreeHeights();
                this.dom.$body.addClass('grid_on');
            },
            /**
            		* Set grid back to it's user-selected state (after a showGrid)
            		*/
            setGrid: function() {
                this.dom.$body[this.gridActive ? 'addClass' : 'removeClass']('grid_on');
                this.autoTreeHeights();
            },
            /**
            		* Set the user preference for always showing the grid.
            		*/
            toggleGrid: function() {
                this.dom.$body.toggleClass('grid_on');
                this.gridActive = !this.gridActive;
            },

            /**
            		* Maximize tree heights so the user can drag to the bottom of a tree easily.
            		* Inverse of autoTreeHeights
            		*/
            fixTreeHeights: function(emptyOnly) {
                nodes.Tree.each(function(tree) {
                    if (emptyOnly && tree.hasSinglePlaceholder()) 
                        return;
                    tree.controller.fixHeight();
                });
            },

            scrollToDropTarget: function scrollToDropTarget() {
                var minimumTop = Infinity,
                ignoredPixelsAboveToast = 40,
                pixelsForToolbar = 35,
                scrollSpeed = 300,
                visibleBottom = this.dom.$win.scrollTop() + $(this.win).height() - chromeController.dom.leafContainer.height() - ignoredPixelsAboveToast;
                nodes.Tree.each(function(tree) {
                    if (!tree.isLocked())
                        minimumTop = Math.min(minimumTop, tree.controller.el.offset().top);
                });
                if (visibleBottom < minimumTop)
                    this.$("html,body").animate({
                        scrollTop: minimumTop - pixelsForToolbar
                    }, scrollSpeed);
            },

            /* jshint ignore:start */
            obscureAllButDropTargets: function obscureAllButDropTargets() {
                var cover = new binaryPlane({
                    width: this.dom.$body.width(),
                    height: this.dom.$body.height(),
                    padding: 6,
                    paddingBottom: 20
                });
                nodes.Tree.each(function(tree) {
                    if (!tree.isLocked() && tree.controller.el.is(":visible"))
                        cover.remove(new binaryPlane(tree.controller.el));
                });
                this.$negativeSpaceCover = this.$("<div>").addClass("w-negativeSpaceContainer").appendTo(this.$("body"));
                var self = this;
                cover.eachBox(function(box) {
                    self.$("<div>").addClass("w-negativeSpaceCover").css({
                        left: box.getLeft() + "px",
                        top: box.getTop() + "px"
                    }).
                    height(box.getHeight()).
                    width(box.getWidth()).
                    appendTo(self.$negativeSpaceCover);
                });
                setTimeout(function() {
                    if (self.$negativeSpaceCover) 
                        self.$negativeSpaceCover.addClass("active");
                }, 1);
            },
            /* jshint ignore:end */
            deobscureAllButDropTargets: function deobscureAllButDropTargets() {
                if (this.$negativeSpaceCover) {
                    var cover = this.$negativeSpaceCover,
                    self = this;
                    delete self.$negativeSpaceCover;
                    cover.removeClass("active");
                    setTimeout(function() {
                        cover.remove();
                    }, 300);
                }
            },

            /**
            		* Bring tree heights back to normal.
            		* Inverse of fixTreeHeights
            		*/
            autoTreeHeights: function() {
                nodes.Tree.each(function(tree) {
                    if (tree.hasSinglePlaceholder()) {
                        tree.controller.autoHeight();
                        tree.controller.fixHeight();
                    } else {
                        tree.controller.autoHeight();
                    }
                });
            },

            /* Active state */

            isActive: function() {
                return !!this.currentController;
            },
            getCurrentController: function() {
                return this.currentController;
            },

            pageBodyClick: function(e) {
                var $target = this.$(e.target), controller;
                if (!$target.closest(".bldr-prevent-clear")[0]) {
                    controller = $target.closest("." + CLASSES.BIN).data('controller');
                    if (controller) {
                        this.setCurrentController(controller, e);
                        if (e.which === 3) {
                            controller.rightClick(e);
                        }
                    } else 
                        this.clearCurrentController();
                }
                return true;
            },

            setCurrentController: function(controller, e) {
                if (controller == this.currentController) 
                    return true;

                this.clearCurrentController({
                    transition: true
                });

                this.currentController = controller;
                this.currentController.activate({
                    event: e
                });
                this.dom.$body.addClass('active');
                return controller;
            },

            clearCurrentController: function(opts) {
                if (this.currentController) 
                    this.currentController.deactivate(opts);
                this.currentController = null;
                this.dom.$body.removeClass('active');
            },

            mouseEnterNode: function(e) {
                var controller = this.$(e.currentTarget).data("controller");
                if (controller) 
                    controller.mouseEnter(e);
            },

            mouseLeaveNode: function(e) {
                var controller = this.$(e.currentTarget).data("controller");
                if (controller) 
                    controller.mouseLeave(e);
            },

            mouseEnterRow: function(e) {
                var controller = this.$(e.currentTarget).data("controller");
                if (controller) 
                    controller.mouseEnter(e);
            },

            mouseLeaveRow: function(e) {
                var controller = this.$(e.currentTarget).data("controller");
                if (controller) 
                    controller.mouseLeave(e);
            }
        });

        PageController.fn.insertRow = function(n, target, side) {
            var row = nodes.RowNode.loadWithColumns(n);
            target.insert(row, side);
        };

        /* Stuff related to drawing drop targets */
        PageController.include({
            /**
            		 * @public
            		 */
            ondrop: function(moduleType) {
                try {
                    var bin = this.binOverlay.overBin;

                    if (!bin) 
                        return;
                    var side = this.binOverlay.side;
                    var target = bin.data('controller');

                    if (bin.length > 1 && side == "bottom")
                        target = bin.last().data("controller");


                    if (!target || !side) 
                        return;

                    // Dropping into the footer requires premium services
                    // TODO: This could be cleaner. Ideally it should ask the treeController if we're allowed to drop
                    if (!webs.site.editableFooter && target.model.tree().controller.el.data('role') == 'webs-footer') {
                        bldr.pageController.hideDropLocation();
                        webs.showPremiumDialog('footer');
                        return false;
                    }

                    eventBuffer.trigger("module:drop", {
                        moduleType: moduleType,
                        side: side 
                    });

                    log.info('Dropping ' + moduleType + ' ' + this.binOverlay.side + ' of ', target.model);

                    if (moduleType.slice(2) == "columns") {
                        this.insertRow(parseInt(moduleType[0], 10), target, this.binOverlay.side);
                    } else {
                        var module = nodes.ModuleNode.load({
                            moduleType: moduleType
                        });
                        target.insert(module, this.binOverlay.side);

                        // glow animation on drop: removed when module is initted
                        module.controller.el.addClass('loading').addClass("blink");
                    }
                    bldr.pageController.hideDropLocation();
                } catch (e) {
                    bldr.pageController.hideDropLocation();
                    throw e;
                }
            },

            /**
            		 * @public
            		 * Places overlay into a placeholder-typed bin
            		 * @param {nodeInfo} object containing node and its respective width, height and position
            		 */
            showDropPlaceholder: function($el) {
                this.binOverlay.el.appendTo($el).attr('class', CLASSES.BINOVERLAY + '-full').css({
                    'position': 'absolute',
                    'display': 'block',
                    'width': $el.width() - 4,
                    'height': $el.height() - 4,
                    'margin': 0,
                    'top': 0,
                    'left': 0
                });
                this.binOverlay.overBin = $el;
                this.binOverlay.side = 'replace';
            },

            /** @public
            		 *  Places overlay into a blank space where parent is a column parent and bin is the particular column with the extra space
            		 */
            showDropBlock: function(parent, bin) {
                var blockWidth = bin.width() - 4,
                blockHeight = parent.height() - (bin.position().top + bin.height());

                this.binOverlay.overBin = bin;
                this.binOverlay.side = 'bottom';

                this.binOverlay.el.appendTo(parent).attr('class', CLASSES.BINOVERLAY + '-full').css({
                    'position': 'absolute',
                    'display': 'block',
                    'width': blockWidth,
                    'height': blockHeight,
                    'top': 'auto',
                    'bottom': 0,
                    'left': bin.offset().left - parent.offset().left
                });
            },

            /** @public
            		 *  Uses bldr.canvas.BINOVERLAY, overlays a border on top of a bin to indicate where the new bin will appear
            		 *  obj expects absLeft & absTop (absolute left and top of mouse) and bin (jQuery element)
            		 */
            showDropLocation: function(obj) {

                var isColumn,
                side = obj.side,
                node = obj.node,
                $el = obj.$el,
                elcss = {
                    'position': 'relative',
                    'display': 'block',
                    'width': 'auto',
                    'left': 'auto',
                    'right': 'auto',
                    'height': 'auto',
                    'float': 'none'
                };

                this.binOverlay.overBin = $el;
                this.binOverlay.side = side;
                this.binOverlay.el.hide();

                //-------------- adding above or below a zeroeth level parent
                if (typeof obj.zeroth !== 'undefined' && obj.zeroth) {
                    this.binOverlay.el.attr('class', CLASSES.BINOVERLAY + '-horizontal').css($.extend(elcss, {
                        'margin': '-17px -1px 3px' // this is under the assumption top-level parent margin = 20 and how tall binOverlay.el is
                    }));
                    if (side == 'top') 
                        $el.before(this.binOverlay.el);
                    if (side == 'bottom') 
                        $el.after(this.binOverlay.el);

                    //-------------- non zeroth level bins
                } else {

                    if (side == 'left' || side == 'right') {
                        var $elParent = $el.parent(),
                        elOffset = $el.offset(),
                        parentOffset = $elParent.offset(),
                        hasPrev = node.prev(),
                        hasNext = node.next(),
                        binHeight = isColumn ? $elParent.height() : $el.height(),
                        binLeft = elOffset.left - parentOffset.left;

                        isColumn = node.parent.type === 'row';

                        if (side == 'left') {
                            elcss.left = !hasPrev || !isColumn ? 0 : binLeft - 7;
                        } else {
                            if (!hasNext || !isColumn) {
                                elcss.right = 0;
                            } else {
                                elcss.left = binLeft + $el.width() - 7;
                            }
                        }

                        this.binOverlay.el.attr('class', CLASSES.BINOVERLAY + '-vertical').css(
                        $.extend(elcss, {
                            'position': 'absolute',
                            'top' : 0,
                            'margin' : - 1,
                            'height': binHeight
                        })
                        );

                    } else {
                        this.binOverlay.el.attr('class', CLASSES.BINOVERLAY + '-horizontal').css($.extend(elcss, {
                            'margin' : '-1px 0 -1px -1px' 
                        }));
                    }

                    if (side == 'left' || side == 'right') {
                        if (isColumn && node.parent.$el) 
                            node.parent.$el.append(this.binOverlay.el);
                        else 
                            $el.append(this.binOverlay.el);
                    } else if (side == 'top') {
                        $el.children('.' + CLASSES.BINWRAP).before(this.binOverlay.el);
                    } else 
                        $el.children('.' + CLASSES.BINWRAP).after(this.binOverlay.el);
                }
                return true;
            },

            /** @private
            		 *  hides the border that appears on top of a bin
            		 */
            hideDropLocation: function() {
                this.binOverlay.side = null;
                this.binOverlay.el.css({
                    'width': 0,
                    'height': 0,
                    'display': 'none'
                });
                return false;
            }
        });

        return PageController;
    });

})();

/* global require:false, webs:false, bldr:false */
require([
'require',
'jquery',
'underscore',
'tracking/trackingHub',
'internal/sitebuilder/common/log',
// Non-arg requirements
'tracking/googleAnalyticsSender',
'internal/sitebuilder/common/base',
'internal/sitebuilder/common/finchUi',
'internal/sitebuilder/builderChrome/bldr.modules',
'internal/common/websover',
'persist',
'internal/sitebuilder/builderChrome/controls',
'internal/sitebuilder/builderChrome/toolbar',
'internal/sitebuilder/builderChrome/PageController',
'internal/sitebuilder/common/trackEvents',
'internal/sitebuilder/common/css_browser_selector',
'internal/sitebuilder/common/jquery.loadingSpinner' // required by the non-bundled persist/persistGlimpse resources
],
function define_chrome(require, $, _, trackingHub, log) {
    "use strict";

    function showTour() {
        require(['sb3Branding', 'internal/sitebuilder/builderChrome/firstTimeExperience'], function(sb3Branding, firstTimeExperience) {
            var shown = false;
            if (sb3Branding && typeof(sb3Branding.showFirstTimeExperience) === 'function' ) {
                shown = sb3Branding.showFirstTimeExperience();
            }
            if (!shown) {
                // only show tour to english-speaking Webs users.
                if (webs && /^en/.test(webs.locale)) {
                    firstTimeExperience.init({
                        el: $("<div>")[0]
                    });
                    // if locale is not an english language, just show the toaster help tip:
                } else {
                    require("internal/sitebuilder/builderChrome/chromeController").showToasterHelptip();
                }
            }
        });
        removeFirstTimeExperienceFlag();
    }

    function removeFirstTimeExperienceFlag() {
        // Notify the back-end that we've seen it and not to show it again.
        $.ajax({
            url: '/s/sitebuilder/api/firsttimeexperience',
            type: 'DELETE'
        });
    }

    // Events for help menu
    $(function() {
        $("#help-options-tour").click(function(e) {
            $(this).parents(".w-more").removeClass("active");
            showTour();
            e.preventDefault();
        });
        $("#help-options-ticket").click(function(e) {
            $(this).parents(".w-more").removeClass("active");
        });
        $("#help-options-chat").click(function(e) {
            var $el = $(this);
            $el.parents(".w-more").removeClass("active");
            if ($el.data('upsell')) {
                top.webs.showPremiumDialog('chat');
            } else {
                // The help link is generated onto the page, so just return true.
                return;
            }
            e.preventDefault();
        });
        $("#help_options_anchor").click(function(e) {
            var pathname = window.location.pathname;
            if (pathname.indexOf("/s/sitebuilder/pages/") >= 0) {
                pathname = "/s/sitebuilder/pages/"; // This feels hacky to me.
            }
            if (typeof(window.mpq) === 'undefined') {
                window.mpq = [];
            }
            window.mpq.push(['track', 'Help Button Pushed', {
                "path": pathname,
                "host": window.location.host
            }
            ]);
        });
    });

    // Upon publish, show the revert to published link
    $(function () {
        $('body').bind('publishedSite', function() {
            $("#revertPageli").show();
        });
    });


    // Track the explicitly-worded "Preview" button
    $(function() {
        $('#preview-button').bind('click', function() {
            if (window.mixpanel && typeof window.mixpanel.push === 'function') {
                window.mixpanel.push(['track', 'previewTextButtonClick', {
                    siteId: webs.site.id
                }
                ]);
            }
            return true;
        });
    });


    var pub = {
        controls: require('internal/sitebuilder/builderChrome/controls'),
        toolbar: require('internal/sitebuilder/builderChrome/toolbar'),

        IE: ($.browser.msie ? parseFloat($.browser.version) : NaN),

        initPageController: function chrome_initPageController(pageInfo) {
            delete pub.initPageController;
            pub.pageController = require('internal/sitebuilder/builderChrome/PageController').init(pageInfo);

            if (window.webs && webs.fixNavWrap) 
                webs.fixNavWrap(pageInfo.$);

            setInterval(require('persist').save, 1000);

            $.when(pub.pageController.treesLoadedPromise, pub.pageController.innerFrameStyledPromise).done(function() {
                window._performanceLabels = window._performanceLabels || [];
                window._performanceLabels.push(webs.site.firstTime ? "newVisitor" : "returnVisitor");
                // Clear call stack to give other components that depend on the above promise to add labels.
                setTimeout(function() {
                    trackingHub.track("trackTiming", {
                        category: "SB3_load",
                        variable: "SB3_loading_cover_removed",
                        label: _.uniq(window._performanceLabels).sort().join(","),
                        upperBound: 3600000
                    });
                }, 1);
                $("#container").removeClass("loading");
            });

            return pub.pageController;
        },
        dockPaneShown: function() {
            return $("#builder a.active").length === 0;
        }
    };

    window.bldr = pub;

    //initial ability to revert changes based on whether the site has been published
    if (!window.webs.site.allowRevert)
    {
        $("#revertPageli").hide();
    }

    // Show first time experience
    $(function() {
        if (webs.site.firstTime) {
            if (bldr.dockPaneShown()) {
                // attach to builder click
                $("#builder, #hide_controls").on("click.firstTime", function() {
                    $("#builder, #hide_controls").off(".firstTime");
                    showTour();
                });
            } else {
                showTour();
            }
        }

        //bind click to show first time tour in settings menu
        $("#showTour").on('click', function() {
            if (typeof(window.mpq) === 'undefined') {
                window.mpq = [];
            }
            //track it in mixpanel
            window.mpq.push(['track', 'showTourFromSettings', {
                siteId: webs.site.id
            }
            ]);

            //show the actual tour
            showTour();
        });
    });

    return pub;
});

define("internal/sitebuilder/builderChrome/builderChrome.app", function() {});

