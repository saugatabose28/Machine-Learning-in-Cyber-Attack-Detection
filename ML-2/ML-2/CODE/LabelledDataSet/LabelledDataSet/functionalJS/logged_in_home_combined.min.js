!function() {
    var a = window, b = document, c = a.MooTools.version.substring(0, 3), d = "1.2" === c || "1.1" === c, e = d || "1.3" === c, f = a.$extend || function() {
        return Object.append.apply(Object, arguments)
    };
    a.HighchartsAdapter = {
        init: function(a) {
            var b = Fx.prototype, c = b.start, d = Fx.Morph.prototype, e = d.compute;
            b.start = function(b) {
                var d = this, e = d.element;
                return b.d && (d.paths = a.init(e, e.d, d.toD)), c.apply(d, arguments), this
            }, d.compute = function(b, c, d) {
                var f = this, g = f.paths;
                return g ? void f.element.attr("d", a.step(g[0], g[1], d, f.toD)) : e.apply(f, arguments)
            }
        },
        adapterRun: function(a, b) {
            return "width" === b || "height" === b ? parseInt(document.id(a).getStyle(b), 10) : void 0
        },
        getScript: function(a, c) {
            var d = b.getElementsByTagName("head")[0], e = b.createElement("script");
            e.type = "text/javascript", e.src = a, e.onload = c, d.appendChild(e)
        },
        animate: function(b, c, d) {
            var e, g = b.attr, h = d && d.complete;
            g&&!b.setStyle && (b.getStyle = b.attr, b.setStyle = function() {
                var a = arguments;
                this.attr.call(this, a[0], a[1][0])
            }, b.$family = function() {
                return !0
            }, b.getComputedStyle = function() {
                return b.element.getComputedStyle.apply(b.element, arguments)
            }), a.HighchartsAdapter.stop(b), e = new Fx.Morph(g ? b : document.id(b), f({
                transition: Fx.Transitions.Quad.easeInOut
            }, d)), g && (e.element = b), c.d && (e.toD = c.d), h && e.addEvent("complete", h), e.start(c), b.fx = e
        },
        each: function(a, b) {
            return d ? $each(a, b) : Array.each(a, b)
        },
        map: function(a, b) {
            return a.map(b)
        },
        grep: function(a, b) {
            return a.filter(b)
        },
        inArray: function(a, b, c) {
            return b ? b.indexOf(a, c) : - 1
        },
        offset: function(a) {
            var b = a.getPosition();
            return {
                left: b.x,
                top: b.y
            }
        },
        extendWithEvents: function(a) {
            a.addEvent || (a.nodeName ? a = document.id(a) : f(a, new Events))
        },
        addEvent: function(b, c, d) {
            "string" == typeof c && ("unload" === c && (c = "beforeunload"), a.HighchartsAdapter.extendWithEvents(b), b.addEvent(c, d))
        },
        removeEvent: function(a, b, c) {
            "string" != typeof a && a.addEvent && (b ? ("unload" === b && (b = "beforeunload"), c ? a.removeEvent(b, c) : a.removeEvents && a.removeEvents(b)) : a.removeEvents())
        },
        fireEvent: function(a, b, c, d) {
            var g = {
                type: b,
                target: a
            };
            b = e ? new Event(g) : new DOMEvent(g), b = f(b, c), !b.target && b.event && (b.target = b.event.target), b.preventDefault = function() {
                d = null
            }, a.fireEvent && a.fireEvent(b.type, b), d && d(b)
        },
        washMouseEvent: function(a) {
            return a.page && (a.pageX = a.page.x, a.pageY = a.page.y), a
        },
        stop: function(a) {
            a.fx && a.fx.cancel()
        }
    }
}(), function() {
    function a(a, b) {
        var c;
        a || (a = {});
        for (c in b)
            a[c] = b[c];
        return a
    }
    function b() {
        var a, b, c = arguments, d = {}, e = function(a, b) {
            var c, d;
            "object" != typeof a && (a = {});
            for (d in b)
                b.hasOwnProperty(d) && (c = b[d], a[d] = c && "object" == typeof c && "[object Array]" !== Object.prototype.toString.call(c) && "renderTo" !== d && "number" != typeof c.nodeType ? e(a[d] || {}, c) : b[d]);
            return a
        };
        for (c[0]===!0 && (d = c[1], c = Array.prototype.slice.call(c, 2)
            ), b = c.length, a = 0;
        b > a;
        a++)d = e(d, c[a]);
        return d
    }
    function c() {
        for (var a = 0, b = arguments, c = b.length, d = {}; c > a; a++)
            d[b[a++]] = b[a];
        return d
    }
    function d(a, b) {
        return parseInt(a, b || 10)
    }
    function e(a) {
        return "string" == typeof a
    }
    function f(a) {
        return "object" == typeof a
    }
    function g(a) {
        return "[object Array]" === Object.prototype.toString.call(a)
    }
    function h(a) {
        return "number" == typeof a
    }
    function i(a) {
        return nb.log(a) / nb.LN10
    }
    function j(a) {
        return nb.pow(10, a)
    }
    function k(a, b) {
        for (var c = a.length; c--;)
            if (a[c] === b) {
                a.splice(c, 1);
                break
            }
    }
    function l(a) {
        return a !== Q && null !== a
    }
    function m(a, b, c) {
        var d, g;
        if (e(b))
            l(c) ? a.setAttribute(b, c) : a && a.getAttribute && (g = a.getAttribute(b));
        else if (l(b) && f(b))
            for (d in b)
                a.setAttribute(d, b[d]);
        return g
    }
    function n(a) {
        return g(a) ? a : [a]
    }
    function o() {
        var a, b, c = arguments, d = c.length;
        for (a = 0; d > a; a++)
            if (b = c[a], "undefined" != typeof b && null !== b)
                return b
    }
    function p(b, c) {
        Ab&&!Gb && c && c.opacity !== Q && (c.filter = "alpha(opacity=" + 100 * c.opacity + ")"), a(b.style, c)
    }
    function q(b, c, d, e, f) {
        var g = lb.createElement(b);
        return c && a(g, c), f && p(g, {
            padding: 0,
            border: Xb,
            margin: 0
        }), d && p(g, d), e && e.appendChild(g), g
    }
    function r(b, c) {
        var d = function() {};
        return d.prototype = new b, a(d.prototype, c), d
    }
    function s(a, b, c, e) {
        var f = U.lang, g =+ a || 0, h =- 1 === b ? (g.toString().split(".")[1] || "").length : isNaN(b = tb(b)) ? 2 : b, i = void 0 === c ? f.decimalPoint : c, j = void 0 === e ? f.thousandsSep : e, k = 0 > g ? "-" : "", l = String(d(g = tb(g).toFixed(h))), m = l.length > 3 ? l.length%3 : 0;
        return k + (m ? l.substr(0, m) + j : "") + l.substr(m).replace(/(\d{3})(?=\d)/g, "$1" + j) + (h ? i + tb(g - l).toFixed(h).slice(2) : "")
    }
    function t(a, b) {
        return new Array((b || 2) + 1 - String(a).length).join(0) + a
    }
    function u(a, b, c) {
        var d = a[b];
        a[b] = function() {
            var a = Array.prototype.slice.call(arguments);
            return a.unshift(d), c.apply(this, a)
        }
    }
    function v(a, b) {
        var c, d = /f$/, e = /\.([0-9])/, f = U.lang;
        return d.test(a) ? (c = a.match(e), c = c ? c[1] : - 1, null !== b && (b = s(b, c, f.decimalPoint, a.indexOf(",")>-1 ? f.thousandsSep : ""))) : b = V(a, b), b
    }
    function w(a, b) {
        for (var c, d, e, f, g, h, i, j = "{", k=!1, l = []; - 1 !== (i = a.indexOf(j));) {
            if (c = a.slice(0, i), k) {
                for (d = c.split(":"), e = d.shift().split("."), g = e.length, h = b, f = 0; g > f; f++)
                    h = h[e[f]];
                d.length && (h = v(d.join(":"), h)), l.push(h)
            } else 
                l.push(c);
            a = a.slice(i + 1), k=!k, j = k ? "}" : "{"
        }
        return l.push(a), l.join("")
    }
    function x(a) {
        return nb.pow(10, pb(nb.log(a) / nb.LN10))
    }
    function y(a, b, c, d) {
        var e, f;
        for (c = o(c, 1), e = a / c, b || (b = [1, 2, 2.5, 5, 10], d && d.allowDecimals===!1 && (1 === c ? b = [1, 2, 5, 10] : .1 >= c && (b = [1 / c]))), f = 0; f < b.length && (a = b[f], !(e <= (b[f] + (b[f + 1] || b[f])) / 2)); f++);
        return a*=c
    }
    function z() {
        this.color = 0, this.symbol = 0
    }
    function A(a, b) {
        var c, d, e = a.length;
        for (d = 0; e > d; d++)
            a[d].ss_i = d;
        for (a.sort(function(a, d) {
            return c = b(a, d), 0 === c ? a.ss_i - d.ss_i : c
        }), d = 0; e > d; d++)
            delete a[d].ss_i
    }
    function B(a) {
        for (var b = a.length, c = a[0]; b--;)
            a[b] < c && (c = a[b]);
        return c
    }
    function C(a) {
        for (var b = a.length, c = a[0]; b--;)
            a[b] > c && (c = a[b]);
        return c
    }
    function D(a, b) {
        var c;
        for (c in a)
            a[c] && a[c] !== b && a[c].destroy && a[c].destroy(), delete a[c]
    }
    function E(a) {
        T || (T = q(Qb)), a && T.appendChild(a), T.innerHTML = ""
    }
    function F(a, b) {
        var c = "Highcharts error #" + a + ": www.highcharts.com/errors/" + a;
        if (b)
            throw c;
        mb.console && console.log(c)
    }
    function G(a) {
        return parseFloat(a.toPrecision(14))
    }
    function H(a, b) {
        W = o(a, b.animation)
    }
    function I() {
        var a = U.global.useUTC, b = a ? "getUTC": "get", c = a ? "setUTC": "set";
        _ = 6e4 * (a && U.global.timezoneOffset || 0), $ = a ? Date.UTC : function(a, b, c, d, e, f) {
            return new Date(a, b, o(c, 1), o(d, 0), o(e, 0), o(f, 0)).getTime()
        }, ab = b + "Minutes", bb = b + "Hours", cb = b + "Day", db = b + "Date", eb = b + "Month", fb = b + "FullYear", gb = c + "Minutes", hb = c + "Hours", ib = c + "Date", jb = c + "Month", kb = c + "FullYear"
    }
    function J(a) {
        return U = b(!0, U, a), I(), U
    }
    function K() {
        return U
    }
    function L() {}
    function M(a, b, c, d) {
        this.axis = a, this.pos = b, this.type = c || "", this.isNew=!0, c || d || this.addLabel()
    }
    function N() {
        this.init.apply(this, arguments)
    }
    function O() {
        this.init.apply(this, arguments)
    }
    function P(a, b, c, d, e) {
        var f = a.chart.inverted;
        this.axis = a, this.isNegative = c, this.options = b, this.x = d, this.total = null, this.points = {}, this.stack = e, this.alignOptions = {
            align: b.align || (f ? c ? "left" : "right" : "center"),
            verticalAlign: b.verticalAlign || (f ? "middle" : c ? "bottom" : "top"),
            y: o(b.y, f ? 4 : c ? 14 : - 6),
            x: o(b.x, f ? c?-6 : 6 : 0)
        }, this.textAlign = b.textAlign || (f ? c ? "right" : "left" : "center")
    }
    var Q, R, S, T, U, V, W, X, Y, Z, $, _, ab, bb, cb, db, eb, fb, gb, hb, ib, jb, kb, lb = document, mb = window, nb = Math, ob = nb.round, pb = nb.floor, qb = nb.ceil, rb = nb.max, sb = nb.min, tb = nb.abs, ub = nb.cos, vb = nb.sin, wb = nb.PI, xb = 2 * wb / 360, yb = navigator.userAgent, zb = mb.opera, Ab = /msie/i.test(yb)&&!zb, Bb = 8 === lb.documentMode, Cb = /AppleWebKit/.test(yb), Db = /Firefox/.test(yb), Eb = /(Mobile|Android|Windows Phone)/.test(yb), Fb = "http://www.w3.org/2000/svg", Gb=!!lb.createElementNS&&!!lb.createElementNS(Fb, "svg").createSVGRect, Hb = Db && parseInt(yb.split("Firefox/")[1], 10) < 4, Ib=!Gb&&!Ab&&!!lb.createElement("canvas").getContext, Jb = {}, Kb = 0, Lb = function() {}, Mb = [], Nb = 0, Ob = "Highcharts", Pb = "4.0.1", Qb = "div", Rb = "absolute", Sb = "relative", Tb = "hidden", Ub = "highcharts-", Vb = "visible", Wb = "px", Xb = "none", Yb = "M", Zb = "L", $b = /^[0-9]+$/, _b = "", ac = "hover", bc = "select", cc = "millisecond", dc = "second", ec = "minute", fc = "hour", gc = "day", hc = "week", ic = "month", jc = "year", kc = "stroke-width", lc = {}, mc = mb.Highcharts = mb.Highcharts ? F(16, !0) : {};
    V = function(b, c, d) {
        if (!l(c) || isNaN(c))
            return "Invalid date";
        b = o(b, "%Y-%m-%d %H:%M:%S");
        var e, f = new Date(c - _), g = f[bb](), h = f[cb](), i = f[db](), j = f[eb](), k = f[fb](), m = U.lang, n = m.weekdays, p = a({
            a: n[h].substr(0, 3),
            A: n[h],
            d: t(i),
            e: i,
            b: m.shortMonths[j],
            B: m.months[j],
            m: t(j + 1),
            y: k.toString().substr(2, 2),
            Y: k,
            H: t(g),
            I: t(g%12 || 12),
            l: g%12 || 12,
            M: t(f[ab]()),
            p: 12 > g ? "AM": "PM",
            P: 12 > g ? "am": "pm",
            S: t(f.getSeconds()),
            L: t(ob(c%1e3), 3)
        }, mc.dateFormats);
        for (e in p)
            for (; - 1 !== b.indexOf("%" + e);)
                b = b.replace("%" + e, "function" == typeof p[e] ? p[e](c) : p[e]);
        return d ? b.substr(0, 1).toUpperCase() + b.substr(1) : b
    }, z.prototype = {
        wrapColor: function(a) {
            this.color >= a && (this.color = 0)
        },
        wrapSymbol: function(a) {
            this.symbol >= a && (this.symbol = 0)
        }
    }, Y = c(cc, 1, dc, 1e3, ec, 6e4, fc, 36e5, gc, 864e5, hc, 6048e5, ic, 26784e5, jc, 31556952e3), X = {
        init: function(a, b, c) {
            b = b || "";
            var d, e, f, g, h, i = a.shift, j = b.indexOf("C")>-1, k = j ? 7: 3, l = b.split(" "), m = [].concat(c), n = function(a) {
                for (f = a.length; f--;)
                    a[f] === Yb && a.splice(f + 1, 0, a[f + 1], a[f + 2], a[f + 1], a[f + 2])
            };
            if (j && (n(l), n(m)), a.isArea && (g = l.splice(l.length - 6, 6), h = m.splice(m.length - 6, 6)), i <= m.length / k && l.length === m.length)
                for (; i--;)
                    m = [].concat(m).splice(0, k).concat(m);
            if (a.shift = 0, l.length)
                for (d = m.length; l.length < d;)
                    e = [].concat(l).splice(l.length - k, k), j && (e[k - 6] = e[k - 2], e[k - 5] = e[k - 1]), l = l.concat(e);
            return g && (l = l.concat(g), m = m.concat(h)), [l, m]
        },
        step: function(a, b, c, d) {
            var e, f = [], g = a.length;
            if (1 === c)
                f = d;
            else if (g === b.length && 1 > c)
                for (; g--;)
                    e = parseFloat(a[g]), f[g] = isNaN(e) ? a[g] : c * parseFloat(b[g] - e) + e;
            else 
                f = b;
            return f
        }
    }, function(b) {
        mb.HighchartsAdapter = mb.HighchartsAdapter || b && {
            init: function(a) {
                var c, d = b.fx, f = d.step, g = b.Tween, h = g && g.propHooks, i = b.cssHooks.opacity;
                b.extend(b.easing, {
                    easeOutQuad: function(a, b, c, d, e) {
                        return - d * (b/=e) * (b - 2) + c
                    }
                }), b.each(["cur", "_default", "width", "height", "opacity"], function(a, b) {
                    var c, e = f;
                    "cur" === b ? e = d.prototype : "_default" === b && g && (e = h[b], b = "set"), c = e[b], c && (e[b] = function(d) {
                        var e;
                        return d = a ? d : this, "align" !== d.prop ? (e = d.elem, e.attr ? e.attr(d.prop, "cur" === b ? Q : d.now) : c.apply(this, arguments)) : void 0
                    })
                }), u(i, "get", function(a, b, c) {
                    return b.attr ? b.opacity || 0 : a.call(this, b, c)
                }), c = function(b) {
                    var c, d = b.elem;
                    b.started || (c = a.init(d, d.d, d.toD), b.start = c[0], b.end = c[1], b.started=!0), d.attr("d", a.step(b.start, b.end, b.pos, d.toD))
                }, g ? h.d = {
                    set: c
                } : f.d = c, this.each = Array.prototype.forEach ? function(a, b) {
                    return Array.prototype.forEach.call(a, b)
                } : function(a, b) {
                    for (var c = 0, d = a.length; d > c; c++)
                        if (b.call(a[c], a[c], c, a)===!1)
                            return c
                }, b.fn.highcharts = function() {
                    var a, b, c, d = "Chart", f = arguments;
                    return this[0] && (e(f[0]) && (d = f[0], f = Array.prototype.slice.call(f, 1)), a = f[0], a !== Q && (a.chart = a.chart || {}, a.chart.renderTo = this[0], c = new mc[d](a, f[1]), b = this), a === Q && (b = Mb[m(this[0], "data-highcharts-chart")])), b
                }
            },
            getScript: b.getScript,
            inArray: b.inArray,
            adapterRun: function(a, c) {
                return b(a)[c]()
            },
            grep: b.grep,
            map: function(a, b) {
                for (var c = [], d = 0, e = a.length; e > d; d++)
                    c[d] = b.call(a[d], a[d], d, a);
                return c
            },
            offset: function(a) {
                return b(a).offset()
            },
            addEvent: function(a, c, d) {
                b(a).bind(c, d)
            },
            removeEvent: function(a, c, d) {
                var e = lb.removeEventListener ? "removeEventListener": "detachEvent";
                lb[e] && a&&!a[e] && (a[e] = function() {}), b(a).unbind(c, d)
            },
            fireEvent: function(c, d, e, f) {
                var g, h = b.Event(d), i = "detached" + d;
                !Ab && e && (delete e.layerX, delete e.layerY, delete e.returnValue), a(h, e), c[d] && (c[i] = c[d], c[d] = null), b.each(["preventDefault", "stopPropagation"], function(a, b) {
                    var c = h[b];
                    h[b] = function() {
                        try {
                            c.call(h)
                        } catch (a) {
                            "preventDefault" === b && (g=!0)
                        }
                    }
                }), b(c).trigger(h), c[i] && (c[d] = c[i], c[i] = null), !f || h.isDefaultPrevented() || g || f(h)
            },
            washMouseEvent: function(a) {
                var b = a.originalEvent || a;
                return b.pageX === Q && (b.pageX = a.pageX, b.pageY = a.pageY), b
            },
            animate: function(a, c, d) {
                var e = b(a);
                a.style || (a.style = {}), c.d && (a.toD = c.d, c.d = 1), e.stop(), c.opacity !== Q && a.attr && (c.opacity += "px"), e.animate(c, d)
            },
            stop: function(a) {
                b(a).stop()
            }
        }
    }(mb.jQuery);
    var nc = mb.HighchartsAdapter, oc = nc || {};
    nc && nc.init.call(nc, X);
    var pc = oc.adapterRun, qc = oc.getScript, rc = oc.inArray, sc = oc.each, tc = oc.grep, uc = oc.offset, vc = oc.map, wc = oc.addEvent, xc = oc.removeEvent, yc = oc.fireEvent, zc = oc.washMouseEvent, Ac = oc.animate, Bc = oc.stop, Cc = {
        enabled: !0,
        x: 0,
        y: 15,
        style: {
            color: "#606060",
            cursor: "default",
            fontSize: "11px"
        }
    };
    U = {
        colors: ["#7cb5ec", "#434348", "#90ed7d", "#f7a35c", "#8085e9", "#f15c80", "#e4d354", "#8085e8", "#8d4653", "#91e8e1"],
        symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
        lang: {
            loading: "Loading...",
            months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            decimalPoint: ".",
            numericSymbols: ["k", "M", "G", "T", "P", "E"],
            resetZoom: "Reset zoom",
            resetZoomTitle: "Reset zoom level 1:1",
            thousandsSep: ","
        },
        global: {
            useUTC: !0,
            canvasToolsURL: "http://code.highcharts.com/4.0.1/modules/canvas-tools.js",
            VMLRadialGradientURL: "http://code.highcharts.com/4.0.1/gfx/vml-radial-gradient.png"
        },
        chart: {
            borderColor: "#4572A7",
            borderRadius: 0,
            defaultSeriesType: "line",
            ignoreHiddenSeries: !0,
            spacing: [10, 10, 15, 10],
            backgroundColor: "#FFFFFF",
            plotBorderColor: "#C0C0C0",
            resetZoomButton: {
                theme: {
                    zIndex: 20
                },
                position: {
                    align: "right",
                    x: - 10,
                    y: 10
                }
            }
        },
        title: {
            text: "Chart title",
            align: "center",
            margin: 15,
            style: {
                color: "#333333",
                fontSize: "18px"
            }
        },
        subtitle: {
            text: "",
            align: "center",
            style: {
                color: "#555555"
            }
        },
        plotOptions: {
            line: {
                allowPointSelect: !1,
                showCheckbox: !1,
                animation: {
                    duration: 1e3
                },
                events: {},
                lineWidth: 2,
                marker: {
                    lineWidth: 0,
                    radius: 4,
                    lineColor: "#FFFFFF",
                    states: {
                        hover: {
                            enabled: !0
                        },
                        select: {
                            fillColor: "#FFFFFF",
                            lineColor: "#000000",
                            lineWidth: 2
                        }
                    }
                },
                point: {
                    events: {}
                },
                dataLabels: b(Cc, {
                    align: "center",
                    enabled: !1,
                    formatter: function() {
                        return null === this.y ? "" : s(this.y, - 1)
                    },
                    verticalAlign: "bottom",
                    y: 0
                }),
                cropThreshold: 300,
                pointRange: 0,
                states: {
                    hover: {
                        marker: {},
                        halo: {
                            size: 10,
                            opacity: .25
                        }
                    },
                    select: {
                        marker: {}
                    }
                },
                stickyTracking: !0,
                turboThreshold: 1e3
            }
        },
        labels: {
            style: {
                position: Rb,
                color: "#3E576F"
            }
        },
        legend: {
            enabled: !0,
            align: "center",
            layout: "horizontal",
            labelFormatter: function() {
                return this.name
            },
            borderColor: "#909090",
            borderRadius: 0,
            navigation: {
                activeColor: "#274b6d",
                inactiveColor: "#CCC"
            },
            shadow: !1,
            itemStyle: {
                color: "#333333",
                fontSize: "12px",
                fontWeight: "bold"
            },
            itemHoverStyle: {
                color: "#000"
            },
            itemHiddenStyle: {
                color: "#CCC"
            },
            itemCheckboxStyle: {
                position: Rb,
                width: "13px",
                height: "13px"
            },
            symbolPadding: 5,
            verticalAlign: "bottom",
            x: 0,
            y: 0,
            title: {
                style: {
                    fontWeight: "bold"
                }
            }
        },
        loading: {
            labelStyle: {
                fontWeight: "bold",
                position: Sb,
                top: "1em"
            },
            style: {
                position: Rb,
                backgroundColor: "white",
                opacity: .5,
                textAlign: "center"
            }
        },
        tooltip: {
            enabled: !0,
            animation: Gb,
            backgroundColor: "rgba(249, 249, 249, .85)",
            borderWidth: 1,
            borderRadius: 3,
            dateTimeLabelFormats: {
                millisecond: "%A, %b %e, %H:%M:%S.%L",
                second: "%A, %b %e, %H:%M:%S",
                minute: "%A, %b %e, %H:%M",
                hour: "%A, %b %e, %H:%M",
                day: "%A, %b %e, %Y",
                week: "Week from %A, %b %e, %Y",
                month: "%B %Y",
                year: "%Y"
            },
            headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
            pointFormat: '<span style="color:{series.color}">●</span> {series.name}: <b>{point.y}</b><br/>',
            shadow: !0,
            snap: Eb ? 25: 10,
            style: {
                color: "#333333",
                cursor: "default",
                fontSize: "12px",
                padding: "8px",
                whiteSpace: "nowrap"
            }
        },
        credits: {
            enabled: !0,
            text: "Highcharts.com",
            href: "http://www.highcharts.com",
            position: {
                align: "right",
                x: - 10,
                verticalAlign: "bottom",
                y: - 5
            },
            style: {
                cursor: "pointer",
                color: "#909090",
                fontSize: "9px"
            }
        }
    };
    var Dc = U.plotOptions, Ec = Dc.line;
    I();
    var Fc = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/, Gc = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/, Hc = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/, Ic = function(a) {
        function c(a) {
            a && a.stops ? j = vc(a.stops, function(a) {
                return Ic(a[1])
            }) : (i = Fc.exec(a), i ? k = [d(i[1]), d(i[2]), d(i[3]), parseFloat(i[4], 10)] : (i = Gc.exec(a), i ? k = [d(i[1], 16), d(i[2], 16), d(i[3], 16), 1] : (i = Hc.exec(a), i && (k = [d(i[1]), d(i[2]), d(i[3]), 1]))))
        }
        function e(c) {
            var d;
            return j ? (d = b(a), d.stops = [].concat(d.stops), sc(j, function(a, b) {
                d.stops[b] = [d.stops[b][0], a.get(c)]
            })) : d = k&&!isNaN(k[0]) ? "rgb" === c ? "rgb(" + k[0] + "," + k[1] + "," + k[2] + ")" : "a" === c ? k[3] : "rgba(" + k.join(",") + ")" : a, d
        }
        function f(a) {
            if (j)
                sc(j, function(b) {
                    b.brighten(a)
                });
            else if (h(a) && 0 !== a) {
                var b;
                for (b = 0; 3 > b; b++)
                    k[b] += d(255 * a), k[b] < 0 && (k[b] = 0), k[b] > 255 && (k[b] = 255)
            }
            return this
        }
        function g(a) {
            return k[3] = a, this
        }
        var i, j, k = [];
        return c(a), {
            get: e,
            brighten: f,
            rgba: k,
            setOpacity: g
        }
    };
    L.prototype = {
        init: function(a, b) {
            var c = this;
            c.element = "span" === b ? q(b) : lb.createElementNS(Fb, b), c.renderer = a
        },
        opacity: 1,
        animate: function(a, c, d) {
            var e = o(c, W, !0);
            Bc(this), e ? (e = b(e, {}), d && (e.complete = d), Ac(this, a, e)) : (this.attr(a), d && d())
        },
        colorGradient: function(a, c, d) {
            var e, f, h, i, j, k, m, n, o, p, q, r = this.renderer, s = [];
            if (a.linearGradient ? f = "linearGradient" : a.radialGradient && (f = "radialGradient"), f) {
                h = a[f], i = r.gradients, k = a.stops, o = d.radialReference, g(h) && (a[f] = h = {
                    x1: h[0],
                    y1: h[1],
                    x2: h[2],
                    y2: h[3],
                    gradientUnits: "userSpaceOnUse"
                }), "radialGradient" === f && o&&!l(h.gradientUnits) && (h = b(h, {
                    cx: o[0] - o[2] / 2 + h.cx * o[2],
                    cy: o[1] - o[2] / 2 + h.cy * o[2],
                    r: h.r * o[2],
                    gradientUnits: "userSpaceOnUse"
                }));
                for (p in h)
                    "id" !== p && s.push(p, h[p]);
                for (p in k)
                    s.push(k[p]);
                s = s.join(","), i[s] ? q = i[s].attr("id") : (h.id = q = Ub + Kb++, i[s] = j = r.createElement(f).attr(h).add(r.defs), j.stops = [], sc(k, function(a) {
                    var b;
                    0 === a[1].indexOf("rgba") ? (e = Ic(a[1]), m = e.get("rgb"), n = e.get("a")) : (m = a[1], n = 1), b = r.createElement("stop").attr({
                        offset: a[0],
                        "stop-color": m,
                        "stop-opacity": n
                    }).add(j), j.stops.push(b)
                })), d.setAttribute(c, "url(" + r.url + "#" + q + ")")
            }
        },
        attr: function(a, b) {
            var c, d, e, f, g = this.element, h = this;
            if ("string" == typeof a && b !== Q && (c = a, a = {}, a[c] = b), "string" == typeof a)
                h = (this[a + "Getter"] || this._defaultGetter).call(this, a, g);
            else {
                for (c in a)
                    d = a[c], f=!1, this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(c) && (e || (this.symbolAttr(a), e=!0), f=!0), !this.rotation || "x" !== c && "y" !== c || (this.doTransform=!0), f || (this[c + "Setter"] || this._defaultSetter).call(this, d, c, g), this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(c) && this.updateShadows(c, d);
                this.doTransform && (this.updateTransform(), this.doTransform=!1)
            }
            return h
        },
        updateShadows: function(a, b) {
            for (var c = this.shadows, d = c.length; d--;)
                c[d].setAttribute(a, "height" === a ? rb(b - (c[d].cutHeight || 0), 0) : "d" === a ? this.d : b)
        },
        addClass: function(a) {
            var b = this.element, c = m(b, "class") || "";
            return - 1 === c.indexOf(a) && m(b, "class", c + " " + a), this
        },
        symbolAttr: function(a) {
            var b = this;
            sc(["x", "y", "r", "start", "end", "width", "height", "innerR", "anchorX", "anchorY"], function(c) {
                b[c] = o(a[c], b[c])
            }), b.attr({
                d: b.renderer.symbols[b.symbolName](b.x, b.y, b.width, b.height, b)
            })
        },
        clip: function(a) {
            return this.attr("clip-path", a ? "url(" + this.renderer.url + "#" + a.id + ")" : Xb)
        },
        crisp: function(a) {
            var b, c, d = this, e = {}, f = a.strokeWidth || d.strokeWidth || d.attr && d.attr("stroke-width") || 0;
            c = ob(f)%2 / 2, a.x = pb(a.x || d.x || 0) + c, a.y = pb(a.y || d.y || 0) + c, a.width = pb((a.width || d.width || 0) - 2 * c), a.height = pb((a.height || d.height || 0) - 2 * c), a.strokeWidth = f;
            for (b in a)
                d[b] !== a[b] && (d[b] = e[b] = a[b]);
            return e
        },
        css: function(b) {
            var c, e, f, g = this, h = g.styles, i = {}, j = g.element, k = "", l=!h;
            if (b && b.color && (b.fill = b.color), h)
                for (e in b)
                    b[e] !== h[e] && (i[e] = b[e], l=!0);
            if (l) {
                if (c = g.textWidth = b && b.width && "text" === j.nodeName.toLowerCase() && d(b.width), h && (b = a(h, i)), g.styles = b, c && (Ib ||!Gb && g.renderer.forExport) && delete b.width, Ab&&!Gb)
                    p(g.element, b);
                else {
                    f = function(a, b) {
                        return "-" + b.toLowerCase()
                    };
                    for (e in b)
                        k += e.replace(/([A-Z])/g, f) + ":" + b[e] + ";";
                    m(j, "style", k)
                }
                c && g.added && g.renderer.buildText(g)
            }
            return g
        },
        on: function(a, b) {
            var c = this, d = c.element;
            return S && "click" === a ? (d.ontouchstart = function(a) {
                c.touchEventFired = Date.now(), a.preventDefault(), b.call(d, a)
            }, d.onclick = function(a) {
                ( - 1 === yb.indexOf("Android") || Date.now() - (c.touchEventFired || 0) > 1100) && b.call(d, a)
            }) : d["on" + a] = b, this
        },
        setRadialReference: function(a) {
            return this.element.radialReference = a, this
        },
        translate: function(a, b) {
            return this.attr({
                translateX: a,
                translateY: b
            })
        },
        invert: function() {
            var a = this;
            return a.inverted=!0, a.updateTransform(), a
        },
        updateTransform: function() {
            var a, b = this, c = b.translateX || 0, d = b.translateY || 0, e = b.scaleX, f = b.scaleY, g = b.inverted, h = b.rotation, i = b.element;
            g && (c += b.attr("width"), d += b.attr("height")), a = ["translate(" + c + "," + d + ")"], g ? a.push("rotate(90) scale(-1,1)") : h && a.push("rotate(" + h + " " + (i.getAttribute("x") || 0) + " " + (i.getAttribute("y") || 0) + ")"), (l(e) || l(f)) && a.push("scale(" + o(e, 1) + " " + o(f, 1) + ")"), a.length && i.setAttribute("transform", a.join(" "))
        },
        toFront: function() {
            var a = this.element;
            return a.parentNode.appendChild(a), this
        },
        align: function(a, b, c) {
            var d, f, g, h, i, j = {}, l = this.renderer, m = l.alignedObjects;
            return a ? (this.alignOptions = a, this.alignByTranslate = b, (!c || e(c)) && (this.alignTo = i = c || "renderer", k(m, this), m.push(this), c = null)) : (a = this.alignOptions, b = this.alignByTranslate, i = this.alignTo), c = o(c, l[i], l), d = a.align, f = a.verticalAlign, g = (c.x || 0) + (a.x || 0), h = (c.y || 0) + (a.y || 0), ("right" === d || "center" === d) && (g += (c.width - (a.width || 0)) / {
                right: 1,
                center: 2
            }
            [d]), j[b ? "translateX": "x"] = ob(g), ("bottom" === f || "middle" === f) && (h += (c.height - (a.height || 0)) / ({
                bottom: 1,
                middle: 2
            }
            [f] || 1)), j[b ? "translateY": "y"] = ob(h), this[this.placed ? "animate": "attr"](j), this.placed=!0, this.alignAttr = j, this
        },
        getBBox: function() {
            var b, c, d, e = this, f = e.bBox, g = e.renderer, h = e.rotation, i = e.element, j = e.styles, k = h * xb, l = e.textStr;
            if (("" === l || $b.test(l)) && (d = "num." + l.toString().length + (j ? "|" + j.fontSize + "|" + j.fontFamily : "")), d && (f = g.cache[d]), !f) {
                if (i.namespaceURI === Fb || g.forExport) {
                    try {
                        f = i.getBBox ? a({}, i.getBBox()) : {
                            width: i.offsetWidth,
                            height: i.offsetHeight
                        }
                    } catch (m) {}(!f || f.width < 0) && (f = {
                        width: 0,
                        height: 0
                    })
                } else 
                    f = e.htmlGetBBox();
                g.isSVG && (b = f.width, c = f.height, Ab && j && "11px" === j.fontSize && "16.9" === c.toPrecision(3) && (f.height = c = 14), h && (f.width = tb(c * vb(k)) + tb(b * ub(k)), f.height = tb(c * ub(k)) + tb(b * vb(k)))), e.bBox = f, d && (g.cache[d] = f)
            }
            return f
        },
        show: function(a) {
            return a && this.element.namespaceURI === Fb ? (this.element.removeAttribute("visibility"), this) : this.attr({
                visibility: a ? "inherit": Vb
            })
        },
        hide: function() {
            return this.attr({
                visibility: Tb
            })
        },
        fadeOut: function(a) {
            var b = this;
            b.animate({
                opacity: 0
            }, {
                duration: a || 150,
                complete: function() {
                    b.hide()
                }
            })
        },
        add: function(a) {
            var b, c, e, f, g, h = this.renderer, i = a || h, j = i.element || h.box, k = this.element, n = this.zIndex;
            if (a && (this.parentGroup = a), this.parentInverted = a && a.inverted, void 0 !== this.textStr && h.buildText(this), n && (i.handleZ=!0, n = d(n)), i.handleZ)for (b = j.childNodes, f = 0; f < b.length; f++)
                if (c = b[f], e = m(c, "zIndex"), c !== k && (d(e) > n ||!l(n) && l(e))) {
                    j.insertBefore(k, c), g=!0;
                    break
                }
            return g || j.appendChild(k), this.added=!0, this.onAdd && this.onAdd(), this
        },
        safeRemoveChild: function(a) {
            var b = a.parentNode;
            b && b.removeChild(a)
        },
        destroy: function() {
            var a, b, c, d = this, e = d.element || {}, f = d.shadows, g = d.renderer.isSVG && "SPAN" === e.nodeName && d.parentGroup;
            if (e.onclick = e.onmouseout = e.onmouseover = e.onmousemove = e.point = null, Bc(d), d.clipPath && (d.clipPath = d.clipPath.destroy()), d.stops) {
                for (c = 0; c < d.stops.length; c++)
                    d.stops[c] = d.stops[c].destroy();
                d.stops = null
            }
            for (d.safeRemoveChild(e), f && sc(f, function(a) {
                d.safeRemoveChild(a)
            }); g && 0 === g.div.childNodes.length;)
                a = g.parentGroup, d.safeRemoveChild(g.div), delete g.div, g = a;
            d.alignTo && k(d.renderer.alignedObjects, d);
            for (b in d)
                delete d[b];
            return null
        },
        shadow: function(a, b, c) {
            var d, e, f, g, h, i, j = [], k = this.element;
            if (a) {
                for (g = o(a.width, 3), h = (a.opacity || .15) / g, i = this.parentInverted ? "(-1,-1)" : "(" + o(a.offsetX, 1) + ", " + o(a.offsetY, 1) + ")", d = 1; g >= d; d++)
                    e = k.cloneNode(0), f = 2 * g + 1 - 2 * d, m(e, {
                        isShadow: "true",
                        stroke: a.color || "black",
                        "stroke-opacity": h * d,
                        "stroke-width": f,
                        transform: "translate" + i,
                        fill: Xb
                    }), c && (m(e, "height", rb(m(e, "height") - f, 0)), e.cutHeight = f), b ? b.element.appendChild(e) : k.parentNode.insertBefore(e, k), j.push(e);
                this.shadows = j
            }
            return this
        },
        xGetter: function(a) {
            return "circle" === this.element.nodeName && (a = {
                x: "cx",
                y: "cy"
            }
            [a] || a), this._defaultGetter(a)
        },
        _defaultGetter: function(a) {
            var b = o(this[a], this.element ? this.element.getAttribute(a) : null, 0);
            return /^[0-9\.]+$/.test(b) && (b = parseFloat(b)), b
        },
        dSetter: function(a, b, c) {
            a && a.join && (a = a.join(" ")), /(NaN| {2}|^$)/.test(a) && (a = "M 0 0"), c.setAttribute(b, a), this[b] = a
        },
        dashstyleSetter: function(a) {
            var b;
            if (a = a && a.toLowerCase()) {
                for (a = a.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(","), b = a.length; b--;)
                    a[b] = d(a[b]) * this.element.getAttribute("stroke-width");
                a = a.join(","), this.element.setAttribute("stroke-dasharray", a)
            }
        },
        alignSetter: function(a) {
            this.element.setAttribute("text-anchor", {
                left: "start",
                center: "middle",
                right: "end"
            }
            [a])
        },
        opacitySetter: function(a, b, c) {
            this[b] = a, c.setAttribute(b, a)
        },
        "stroke-widthSetter": function(a, b, c) {
            0 === a && (a = 1e-5), this.strokeWidth = a, c.setAttribute(b, a)
        },
        titleSetter: function(a) {
            var b = this.element.getElementsByTagName("title")[0];
            b || (b = lb.createElementNS(Fb, "title"), this.element.appendChild(b)), b.textContent = a
        },
        textSetter: function(a) {
            a !== this.textStr && (delete this.bBox, this.textStr = a, this.added && this.renderer.buildText(this))
        },
        fillSetter: function(a, b, c) {
            "string" == typeof a ? c.setAttribute(b, a) : a && this.colorGradient(a, b, c)
        },
        zIndexSetter: function(a, b, c) {
            c.setAttribute(b, a), this[b] = a
        },
        _defaultSetter: function(a, b, c) {
            c.setAttribute(b, a)
        }
    }, L.prototype.yGetter = L.prototype.xGetter, L.prototype.translateXSetter = L.prototype.translateYSetter = L.prototype.rotationSetter = L.prototype.verticalAlignSetter = L.prototype.scaleXSetter = L.prototype.scaleYSetter = function(a, b) {
        this[b] = a, this.doTransform=!0
    }, L.prototype.strokeSetter = L.prototype.fillSetter;
    var Jc = function() {
        this.init.apply(this, arguments)
    };
    Jc.prototype = {
        Element: L,
        init: function(a, b, c, d, e) {
            var f, g, h, i = this, j = location;
            f = i.createElement("svg").attr({
                version: "1.1"
            }).css(this.getStyle(d)), g = f.element, a.appendChild(g), - 1 === a.innerHTML.indexOf("xmlns") && m(g, "xmlns", Fb), i.isSVG=!0, i.box = g, i.boxWrapper = f, i.alignedObjects = [], i.url = (Db || Cb) && lb.getElementsByTagName("base").length ? j.href.replace(/#.*?$/, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20") : "", h = this.createElement("desc").add(), h.element.appendChild(lb.createTextNode("Created with " + Ob + " " + Pb)), i.defs = this.createElement("defs").add(), i.forExport = e, i.gradients = {}, i.cache = {}, i.setSize(b, c, !1);
            var k, l;
            Db && a.getBoundingClientRect && (i.subPixelFix = k = function() {
                p(a, {
                    left: 0,
                    top: 0
                }), l = a.getBoundingClientRect(), p(a, {
                    left: qb(l.left) - l.left + Wb,
                    top: qb(l.top) - l.top + Wb
                })
            }, k(), wc(mb, "resize", k))
        },
        getStyle: function(b) {
            return this.style = a({
                fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
                fontSize: "12px"
            }, b)
        },
        isHidden: function() {
            return !this.boxWrapper.getBBox().width
        },
        destroy: function() {
            var a = this, b = a.defs;
            return a.box = null, a.boxWrapper = a.boxWrapper.destroy(), D(a.gradients || {}), a.gradients = null, b && (a.defs = b.destroy()), a.subPixelFix && xc(mb, "resize", a.subPixelFix), a.alignedObjects = null, null
        },
        createElement: function(a) {
            var b = new this.Element;
            return b.init(this, a), b
        },
        draw: function() {},
        buildText: function(a) {
            for (var b, c, e, f = a.element, g = this, h = g.forExport, i = o(a.textStr, "").toString(), j =- 1 !== i.indexOf("<"), k = f.childNodes, l = m(f, "x"), n = a.styles, q = a.textWidth, r = n && n.lineHeight, s = k.length, t = function(a) {
                return r ? d(r) : g.fontMetrics(/(px|em)$/.test(a && a.style.fontSize) ? a.style.fontSize : n && n.fontSize || g.style.fontSize || 12).h
            }; s--;)
                f.removeChild(k[s]);
            return j||-1 !== i.indexOf(" ") ? (c = /<.*style="([^"]+)".*>/, e = /<.*href="(http[^"]+)".*>/, q&&!a.added && this.box.appendChild(f), b = j ? i.replace(/<(b|strong)>/g, '<span style="font-weight:bold">').replace(/<(i|em)>/g, '<span style="font-style:italic">').replace(/<a/g, "<span").replace(/<\/(b|strong|i|em|a)>/g, "</span>").split(/<br.*?>/g) : [i], "" === b[b.length - 1] && b.pop(), sc(b, function(b, d) {
                var i, j = 0;
                b = b.replace(/<span/g, "|||<span").replace(/<\/span>/g, "</span>|||"), i = b.split("|||"), sc(i, function(b) {
                    if ("" !== b || 1 === i.length) {
                        var k, o = {}, r = lb.createElementNS(Fb, "tspan");
                        if (c.test(b) && (k = b.match(c)[1].replace(/(;| |^)color([ :])/, "$1fill$2"), m(r, "style", k)), e.test(b)&&!h && (m(r, "onclick", 'location.href="' + b.match(e)[1] + '"'), p(r, {
                            cursor: "pointer"
                        })), b = (b.replace(/<(.|\n)*?>/g, "") || " ").replace(/&lt;/g, "<").replace(/&gt;/g, ">"), " " !== b && (r.appendChild(lb.createTextNode(b)), j ? o.dx = 0 : d && null !== l && (o.x = l), m(r, o), !j && d && (!Gb && h && p(r, {
                            display: "block"
                        }), m(r, "dy", t(r), Cb && r.offsetHeight)), f.appendChild(r), j++, q))
                            for (var s, u, v, w = b.replace(/([^\^])-/g, "$1- ").split(" "), x = w.length > 1 && "nowrap" !== n.whiteSpace, y = a._clipHeight, z = [], A = t(), B = 1; x && (w.length || z.length);)
                                delete a.bBox, v = a.getBBox(), u = v.width, !Gb && g.forExport && (u = g.measureSpanWidth(r.firstChild.data, a.styles)), s = u > q, s && 1 !== w.length ? (r.removeChild(r.firstChild), z.unshift(w.pop())) : (w = z, z = [], w.length && (B++, y && B * A > y ? (w = ["..."], a.attr("title", a.textStr)) : (r = lb.createElementNS(Fb, "tspan"), m(r, {
                                    dy: A,
                                    x: l
                                }), k && m(r, "style", k), f.appendChild(r), u > q && (q = u)))), w.length && r.appendChild(lb.createTextNode(w.join(" ").replace(/- /g, "-")))
                    }
                })
            }), void 0) : void f.appendChild(lb.createTextNode(i))
        },
        button: function(c, d, e, f, g, h, i, j, k) {
            var l, m, n, o, p, q, r = this.label(c, d, e, k, null, null, null, null, "button"), s = 0, t = {
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 1
            };
            return g = b({
                "stroke-width": 1,
                stroke: "#CCCCCC",
                fill: {
                    linearGradient: t,
                    stops: [[0, "#FEFEFE"], [1, "#F6F6F6"]]
                },
                r: 2,
                padding: 5,
                style: {
                    color: "black"
                }
            }, g), n = g.style, delete g.style, h = b(g, {
                stroke: "#68A",
                fill: {
                    linearGradient: t,
                    stops: [[0, "#FFF"], [1, "#ACF"]]
                }
            }, h), o = h.style, delete h.style, i = b(g, {
                stroke: "#68A",
                fill: {
                    linearGradient: t,
                    stops: [[0, "#9BD"], [1, "#CDF"]]
                }
            }, i), p = i.style, delete i.style, j = b(g, {
                style: {
                    color: "#CCC"
                }
            }, j), q = j.style, delete j.style, wc(r.element, Ab ? "mouseover" : "mouseenter", function() {
                3 !== s && r.attr(h).css(o)
            }), wc(r.element, Ab ? "mouseout" : "mouseleave", function() {
                3 !== s && (l = [g, h, i][s], m = [n, o, p][s], r.attr(l).css(m))
            }), r.setState = function(a) {
                r.state = s = a, a ? 2 === a ? r.attr(i).css(p) : 3 === a && r.attr(j).css(q) : r.attr(g).css(n)
            }, r.on("click", function() {
                3 !== s && f.call(r)
            }).attr(g).css(a({
                cursor: "default"
            }, n))
        },
        crispLine: function(a, b) {
            return a[1] === a[4] && (a[1] = a[4] = ob(a[1]) - b%2 / 2), a[2] === a[5] && (a[2] = a[5] = ob(a[2]) + b%2 / 2), a
        },
        path: function(b) {
            var c = {
                fill: Xb
            };
            return g(b) ? c.d = b : f(b) && a(c, b), this.createElement("path").attr(c)
        },
        circle: function(a, b, c) {
            var d = f(a) ? a: {
                x: a,
                y: b,
                r: c
            }, e = this.createElement("circle");
            return e.xSetter = function(a) {
                this.element.setAttribute("cx", a)
            }, e.ySetter = function(a) {
                this.element.setAttribute("cy", a)
            }, e.attr(d)
        },
        arc: function(a, b, c, d, e, g) {
            var h;
            return f(a) && (b = a.y, c = a.r, d = a.innerR, e = a.start, g = a.end, a = a.x), h = this.symbol("arc", a || 0, b || 0, c || 0, c || 0, {
                innerR: d || 0,
                start: e || 0,
                end: g || 0
            }), h.r = c, h
        },
        rect: function(a, b, c, d, e, g) {
            e = f(a) ? a.r : e;
            var h = this.createElement("rect"), i = f(a) ? a: a === Q ? {}
            : {
                x: a,
                y: b,
                width: rb(c, 0),
                height: rb(d, 0)
            };
            return g !== Q && (i.strokeWidth = g, i = h.crisp(i)), e && (i.r = e), h.rSetter = function(a) {
                m(this.element, {
                    rx: a,
                    ry: a
                })
            }, h.attr(i)
        },
        setSize: function(a, b, c) {
            var d = this, e = d.alignedObjects, f = e.length;
            for (d.width = a, d.height = b, d.boxWrapper[o(c, !0) ? "animate": "attr"]({
                width: a,
                height: b
            }); f--;)
                e[f].align()
        },
        g: function(a) {
            var b = this.createElement("g");
            return l(a) ? b.attr({
                "class": Ub + a
            }) : b
        },
        image: function(b, c, d, e, f) {
            var g, h = {
                preserveAspectRatio: Xb
            };
            return arguments.length > 1 && a(h, {
                x: c,
                y: d,
                width: e,
                height: f
            }), g = this.createElement("image").attr(h), g.element.setAttributeNS ? g.element.setAttributeNS("http://www.w3.org/1999/xlink", "href", b) : g.element.setAttribute("hc-svg-href", b), g
        },
        symbol: function(b, c, d, e, f, g) {
            var h, i, j, k, l, m = this.symbols[b], n = m && m(ob(c), ob(d), e, f, g), o = /^url\((.*?)\)$/;
            return n ? (h = this.path(n), a(h, {
                symbolName: b,
                x: c,
                y: d,
                width: e,
                height: f
            }), g && a(h, g)) : o.test(b) && (l = function(a, b) {
                a.element && (a.attr({
                    width: b[0],
                    height: b[1]
                }), a.alignByTranslate || a.translate(ob((e - b[0]) / 2), ob((f - b[1]) / 2)))
            }, j = b.match(o)[1], k = Jb[j], h = this.image(j).attr({
                x: c,
                y: d
            }), h.isImg=!0, k ? l(h, k) : (h.attr({
                width: 0,
                height: 0
            }), i = q("img", {
                onload: function() {
                    l(h, Jb[j] = [this.width, this.height])
                },
                src: j
            }))), h
        },
        symbols: {
            circle: function(a, b, c, d) {
                var e = .166 * c;
                return [Yb, a + c / 2, b, "C", a + c + e, b, a + c + e, b + d, a + c / 2, b + d, "C", a - e, b + d, a - e, b, a + c / 2, b, "Z"]
            },
            square: function(a, b, c, d) {
                return [Yb, a, b, Zb, a + c, b, a + c, b + d, a, b + d, "Z"]
            },
            triangle: function(a, b, c, d) {
                return [Yb, a + c / 2, b, Zb, a + c, b + d, a, b + d, "Z"]
            },
            "triangle-down": function(a, b, c, d) {
                return [Yb, a, b, Zb, a + c, b, a + c / 2, b + d, "Z"]
            },
            diamond: function(a, b, c, d) {
                return [Yb, a + c / 2, b, Zb, a + c, b + d / 2, a + c / 2, b + d, a, b + d / 2, "Z"]
            },
            arc: function(a, b, c, d, e) {
                var f = e.start, g = e.r || c || d, h = e.end - .001, i = e.innerR, j = e.open, k = ub(f), l = vb(f), m = ub(h), n = vb(h), o = e.end - f < wb ? 0: 1;
                return [Yb, a + g * k, b + g * l, "A", g, g, 0, o, 1, a + g * m, b + g * n, j ? Yb: Zb, a + i * m, b + i * n, "A", i, i, 0, o, 0, a + i * k, b + i * l, j ? "": "Z"]
            },
            callout: function(a, b, c, d, e) {
                var f, g = 6, h = 6, i = sb(e && e.r || 0, c, d), j = i + h, k = e && e.anchorX, l = e && e.anchorY, m = ob(e.strokeWidth || 0)%2 / 2;
                return a += m, b += m, f = ["M", a + i, b, "L", a + c - i, b, "C", a + c, b, a + c, b, a + c, b + i, "L", a + c, b + d - i, "C", a + c, b + d, a + c, b + d, a + c - i, b + d, "L", a + i, b + d, "C", a, b + d, a, b + d, a, b + d - i, "L", a, b + i, "C", a, b, a, b, a + i, b], k && k > c && l > b + j && b + d - j > l ? f.splice(13, 3, "L", a + c, l - h, a + c + g, l, a + c, l + h, a + c, b + d - i) : k && 0 > k && l > b + j && b + d - j > l ? f.splice(33, 3, "L", a, l + h, a - g, l, a, l - h, a, b + i) : l && l > d && k > a + j && a + c - j > k ? f.splice(23, 3, "L", k + h, b + d, k, b + d + g, k - h, b + d, a + i, b + d) : l && 0 > l && k > a + j && a + c - j > k && f.splice(3, 3, "L", k - h, b, k, b - g, k + h, b, c - i, b), f
            }
        },
        clipRect: function(a, b, c, d) {
            var e, f = Ub + Kb++, g = this.createElement("clipPath").attr({
                id: f
            }).add(this.defs);
            return e = this.rect(a, b, c, d, 0).add(g), e.id = f, e.clipPath = g, e
        },
        text: function(a, b, c, d) {
            var e, f = this, g = Ib ||!Gb && f.forExport, h = {};
            return d&&!f.forExport ? f.html(a, b, c) : (h.x = Math.round(b || 0), c && (h.y = Math.round(c)), (a || 0 === a) && (h.text = a), e = f.createElement("text").attr(h), g && e.css({
                position: Rb
            }), d || (e.xSetter = function(a, b, c) {
                var d, e, f = c.childNodes;
                for (e = 1; e < f.length; e++)
                    d = f[e], d.getAttribute("x") === c.getAttribute("x") && d.setAttribute("x", a);
                c.setAttribute(b, a)
            }), e)
        },
        fontMetrics: function(a) {
            a = a || this.style.fontSize, a = /px/.test(a) ? d(a) : /em/.test(a) ? 12 * parseFloat(a) : 12;
            var b = 24 > a ? a + 4: ob(1.2 * a), c = ob(.8 * b);
            return {
                h: b,
                b: c
            }
        },
        label: function(c, d, e, f, g, h, i, j, k) {
            function m() {
                var b, c, d = z.element.style;
                q = (void 0 === r || void 0 === s || y.styles.textAlign) && z.textStr && z.getBBox(), y.width = (r || q.width || 0) + 2 * B + C, y.height = (s || q.height || 0) + 2 * B, v = B + x.fontMetrics(d && d.fontSize).b, w && (p || (b = ob( - A * B), c = j?-v : 0, y.box = p = f ? x.symbol(f, b, c, y.width, y.height, E) : x.rect(b, c, y.width, y.height, 0, E[kc]), p.attr("fill", Xb).add(y)), p.isImg || p.attr(a({
                    width: ob(y.width),
                    height: ob(y.height)
                }, E)), E = null)
            }
            function n() {
                var a, b = y.styles, c = b && b.textAlign, d = C + B * (1 - A);
                a = j ? 0 : v, l(r) && q && ("center" === c || "right" === c) && (d += {
                    center: .5,
                    right: 1
                }
                [c] * (r - q.width)), (d !== z.x || a !== z.y) && (z.attr("x", d), a !== Q && z.attr("y", a)), z.x = d, z.y = a
            }
            function o(a, b) {
                p ? p.attr(a, b) : E[a] = b
            }
            var p, q, r, s, t, u, v, w, x = this, y = x.g(k), z = x.text("", 0, 0, i).attr({
                zIndex: 1
            }), A = 0, B = 3, C = 0, D = 0, E = {};
            y.onAdd = function() {
                z.add(y), y.attr({
                    text: c || "",
                    x: d,
                    y: e
                }), p && l(g) && y.attr({
                    anchorX: g,
                    anchorY: h
                })
            }, y.widthSetter = function(a) {
                r = a
            }, y.heightSetter = function(a) {
                s = a
            }, y.paddingSetter = function(a) {
                l(a) && a !== B && (B = a, n())
            }, y.paddingLeftSetter = function(a) {
                l(a) && a !== C && (C = a, n())
            }, y.alignSetter = function(a) {
                A = {
                    left: 0,
                    center: .5,
                    right: 1
                }
                [a]
            }, y.textSetter = function(a) {
                a !== Q && z.textSetter(a), m(), n()
            }, y["stroke-widthSetter"] = function(a, b) {
                a && (w=!0), D = a%2 / 2, o(b, a)
            }, y.strokeSetter = y.fillSetter = y.rSetter = function(a, b) {
                "fill" === b && a && (w=!0), o(b, a)
            }, y.anchorXSetter = function(a, b) {
                g = a, o(b, a + D - t)
            }, y.anchorYSetter = function(a, b) {
                h = a, o(b, a - u)
            }, y.xSetter = function(a) {
                y.x = a, A && (a -= A * ((r || q.width) + B)), t = ob(a), y.attr("translateX", t)
            }, y.ySetter = function(a) {
                u = y.y = ob(a), y.attr("translateY", u)
            };
            var F = y.css;
            return a(y, {
                css: function(a) {
                    if (a) {
                        var c = {};
                        a = b(a), sc(["fontSize", "fontWeight", "fontFamily", "color", "lineHeight", "width", "textDecoration", "textShadow"], function(b) {
                            a[b] !== Q && (c[b] = a[b], delete a[b])
                        }), z.css(c)
                    }
                    return F.call(y, a)
                },
                getBBox: function() {
                    return {
                        width: q.width + 2 * B,
                        height: q.height + 2 * B,
                        x: q.x - B,
                        y: q.y - B
                    }
                },
                shadow: function(a) {
                    return p && p.shadow(a), y
                },
                destroy: function() {
                    xc(y.element, "mouseenter"), xc(y.element, "mouseleave"), z && (z = z.destroy()), p && (p = p.destroy()), L.prototype.destroy.call(y), y = x = m = n = o = null
                }
            })
        }
    }, R = Jc, a(L.prototype, {
        htmlCss: function(b) {
            var c = this, d = c.element, e = b && "SPAN" === d.tagName && b.width;
            return e && (delete b.width, c.textWidth = e, c.updateTransform()), c.styles = a(c.styles, b), p(c.element, b), c
        },
        htmlGetBBox: function() {
            var a = this, b = a.element, c = a.bBox;
            return c || ("text" === b.nodeName && (b.style.position = Rb), c = a.bBox = {
                x: b.offsetLeft,
                y: b.offsetTop,
                width: b.offsetWidth,
                height: b.offsetHeight
            }), c
        },
        htmlUpdateTransform: function() {
            if (!this.added)
                return void(this.alignOnAdd=!0);
            var a = this, b = a.renderer, c = a.element, e = a.translateX || 0, f = a.translateY || 0, g = a.x || 0, h = a.y || 0, i = a.textAlign || "left", j = {
                left: 0,
                center: .5,
                right: 1
            }
            [i], k = a.shadows;
            if (p(c, {
                marginLeft: e,
                marginTop: f
            }), k && sc(k, function(a) {
                p(a, {
                    marginLeft: e + 1,
                    marginTop: f + 1
                })
            }), a.inverted && sc(c.childNodes, function(a) {
                b.invertChild(a, c)
            }), "SPAN" === c.tagName) {
                var m, n, q = a.rotation, r = d(a.textWidth), s = [q, i, c.innerHTML, a.textWidth].join(",");
                s !== a.cTT && (n = b.fontMetrics(c.style.fontSize).b, l(q) && a.setSpanRotation(q, j, n), m = o(a.elemWidth, c.offsetWidth), m > r && /[ \-]/.test(c.textContent || c.innerText) && (p(c, {
                    width: r + Wb,
                    display: "block",
                    whiteSpace: "normal"
                }), m = r), a.getSpanCorrection(m, n, j, q, i)), p(c, {
                    left: g + (a.xCorr || 0) + Wb,
                    top: h + (a.yCorr || 0) + Wb
                }), Cb && (n = c.offsetHeight), a.cTT = s
            }
        },
        setSpanRotation: function(a, b, c) {
            var d = {}, e = Ab ? "-ms-transform": Cb ? "-webkit-transform": Db ? "MozTransform": zb ? "-o-transform": "";
            d[e] = d.transform = "rotate(" + a + "deg)", d[e + (Db ? "Origin" : "-origin")] = d.transformOrigin = 100 * b + "% " + c + "px", p(this.element, d)
        },
        getSpanCorrection: function(a, b, c) {
            this.xCorr =- a * c, this.yCorr =- b
        }
    }), a(Jc.prototype, {
        html: function(b, c, d) {
            var e = this.createElement("span"), f = e.element, g = e.renderer;
            return e.textSetter = function(a) {
                a !== f.innerHTML && delete this.bBox, f.innerHTML = this.textStr = a
            }, e.xSetter = e.ySetter = e.alignSetter = e.rotationSetter = function(a, b) {
                "align" === b && (b = "textAlign"), e[b] = a, e.htmlUpdateTransform()
            }, e.attr({
                text: b,
                x: ob(c),
                y: ob(d)
            }).css({
                position: Rb,
                whiteSpace: "nowrap",
                fontFamily: this.style.fontFamily,
                fontSize: this.style.fontSize
            }), e.css = e.htmlCss, g.isSVG && (e.add = function(b) {
                var c, d, h = g.box.parentNode, i = [];
                if (this.parentGroup = b, b) {
                    if (c = b.div, !c) {
                        for (d = b; d;)
                            i.push(d), d = d.parentGroup;
                        sc(i.reverse(), function(b) {
                            var d;
                            c = b.div = b.div || q(Qb, {
                                className: m(b.element, "class")
                            }, {
                                position: Rb,
                                left: (b.translateX || 0) + Wb,
                                top: (b.translateY || 0) + Wb
                            }, c || h), d = c.style, a(b, {
                                translateXSetter: function(a, c) {
                                    d.left = a + Wb, b[c] = a, b.doTransform=!0
                                },
                                translateYSetter: function(a, c) {
                                    d.top = a + Wb, b[c] = a, b.doTransform=!0
                                },
                                visibilitySetter: function(a, b) {
                                    d[b] = a
                                }
                            })
                        })
                    }
                } else 
                    c = h;
                return c.appendChild(f), e.added=!0, e.alignOnAdd && e.htmlUpdateTransform(), e
            }), e
        }
    });
    var Kc, Lc;
    if (!Gb&&!Ib) {
        mc.VMLElement = Lc = {
            init: function(a, b) {
                var c = this, d = ["<", b, ' filled="f" stroked="f"'], e = ["position: ", Rb, ";"], f = b === Qb;
                ("shape" === b || f) && e.push("left:0;top:0;width:1px;height:1px;"), e.push("visibility: ", f ? Tb : Vb), d.push(' style="', e.join(""), '"/>'), b && (d = f || "span" === b || "img" === b ? d.join("") : a.prepVML(d), c.element = q(d)), c.renderer = a
            },
            add: function(a) {
                var b = this, c = b.renderer, d = b.element, e = c.box, f = a && a.inverted, g = a ? a.element || a: e;
                return f && c.invertChild(d, g), g.appendChild(d), b.added=!0, b.alignOnAdd&&!b.deferUpdateTransform && b.updateTransform(), b.onAdd && b.onAdd(), b
            },
            updateTransform: L.prototype.htmlUpdateTransform,
            setSpanRotation: function() {
                var a = this.rotation, b = ub(a * xb), c = vb(a * xb);
                p(this.element, {
                    filter: a ? ["progid:DXImageTransform.Microsoft.Matrix(M11=", b, ", M12=", - c, ", M21=", c, ", M22=", b, ", sizingMethod='auto expand')"].join(""): Xb
                })
            },
            getSpanCorrection: function(a, b, c, d, e) {
                var f, g = d ? ub(d * xb): 1, h = d ? vb(d * xb): 0, i = o(this.elemHeight, this.element.offsetHeight), j = e && "left" !== e;
                this.xCorr = 0 > g&&-a, this.yCorr = 0 > h&&-i, f = 0 > g * h, this.xCorr += h * b * (f ? 1 - c : c), this.yCorr -= g * b * (d ? f ? c : 1 - c : 1), j && (this.xCorr -= a * c * (0 > g?-1 : 1), d && (this.yCorr -= i * c * (0 > h?-1 : 1)), p(this.element, {
                    textAlign: e
                }))
            },
            pathToVML: function(a) {
                for (var b = a.length, c = []; b--;)
                    h(a[b]) ? c[b] = ob(10 * a[b]) - 5 : "Z" === a[b] ? c[b] = "x" : (c[b] = a[b], !a.isArc || "wa" !== a[b] && "at" !== a[b] || (c[b + 5] === c[b + 7] && (c[b + 7] += a[b + 7] > a[b + 5] ? 1 : - 1), c[b + 6] === c[b + 8] && (c[b + 8] += a[b + 8] > a[b + 6] ? 1 : - 1)));
                return c.join(" ") || "x"
            },
            clip: function(a) {
                var b, c, d = this;
                return a ? (b = a.members, k(b, d), b.push(d), d.destroyClip = function() {
                    k(b, d)
                }, c = a.getCSS(d)) : (d.destroyClip && d.destroyClip(), c = {
                    clip: Bb ? "inherit": "rect(auto)"
                }), d.css(c)
            },
            css: L.prototype.htmlCss,
            safeRemoveChild: function(a) {
                a.parentNode && E(a)
            },
            destroy: function() {
                return this.destroyClip && this.destroyClip(), L.prototype.destroy.apply(this)
            },
            on: function(a, b) {
                return this.element["on" + a] = function() {
                    var a = mb.event;
                    a.target = a.srcElement, b(a)
                }, this
            },
            cutOffPath: function(a, b) {
                var c;
                return a = a.split(/[ ,]/), c = a.length, (9 === c || 11 === c) && (a[c - 4] = a[c - 2] = d(a[c - 2]) - 10 * b), a.join(" ")
            },
            shadow: function(a, b, c) {
                var e, f, g, h, i, j, k, l = [], m = this.element, n = this.renderer, p = m.style, r = m.path;
                if (r && "string" != typeof r.value && (r = "x"), i = r, a) {
                    for (j = o(a.width, 3), k = (a.opacity || .15) / j, e = 1; 3 >= e; e++)
                        h = 2 * j + 1 - 2 * e, c && (i = this.cutOffPath(r.value, h + .5)), g = ['<shape isShadow="true" strokeweight="', h, '" filled="false" path="', i, '" coordsize="10 10" style="', m.style.cssText, '" />'], f = q(n.prepVML(g), null, {
                            left: d(p.left) + o(a.offsetX, 1),
                            top: d(p.top) + o(a.offsetY, 1)
                        }), c && (f.cutOff = h + 1), g = ['<stroke color="', a.color || "black", '" opacity="', k * e, '"/>'], q(n.prepVML(g), null, null, f), b ? b.element.appendChild(f) : m.parentNode.insertBefore(f, m), l.push(f);
                    this.shadows = l
                }
                return this
            },
            updateShadows: Lb,
            setAttr: function(a, b) {
                Bb ? this.element[a] = b : this.element.setAttribute(a, b)
            },
            classSetter: function(a) {
                this.element.className = a
            },
            dashstyleSetter: function(a, b, c) {
                var d = c.getElementsByTagName("stroke")[0] || q(this.renderer.prepVML(["<stroke/>"]), null, null, c);
                d[b] = a || "solid", this[b] = a
            },
            dSetter: function(a, b, c) {
                var d, e = this.shadows;
                if (a = a || [], this.d = a.join(" "), c.path = a = this.pathToVML(a), e)
                    for (d = e.length; d--;)
                        e[d].path = e[d].cutOff ? this.cutOffPath(a, e[d].cutOff) : a;
                this.setAttr(b, a)
            },
            fillSetter: function(a, b, c) {
                var d = c.nodeName;
                "SPAN" === d ? c.style.color = a : "IMG" !== d && (c.filled = a !== Xb, this.setAttr("fillcolor", this.renderer.color(a, c, b, this)))
            },
            opacitySetter: Lb,
            rotationSetter: function(a, b, c) {
                var d = c.style;
                this[b] = d[b] = a, d.left =- ob(vb(a * xb) + 1) + Wb, d.top = ob(ub(a * xb)) + Wb
            },
            strokeSetter: function(a, b, c) {
                this.setAttr("strokecolor", this.renderer.color(a, c, b))
            },
            "stroke-widthSetter": function(a, b, c) {
                c.stroked=!!a, this[b] = a, h(a) && (a += Wb), this.setAttr("strokeweight", a)
            },
            titleSetter: function(a, b) {
                this.setAttr(b, a)
            },
            visibilitySetter: function(a, b, c) {
                "inherit" === a && (a = Vb), this.shadows && sc(this.shadows, function(c) {
                    c.style[b] = a
                }), "DIV" === c.nodeName && (a = a === Tb ? "-999em" : 0, Bb || (c.style[b] = a ? Vb : Tb), b = "top"), c.style[b] = a
            },
            xSetter: function(a, b, c) {
                this[b] = a, "x" === b ? b = "left" : "y" === b && (b = "top"), this.updateClipping ? (this[b] = a, this.updateClipping()) : c.style[b] = a
            },
            zIndexSetter: function(a, b, c) {
                c.style[b] = a
            }
        }, Lc = r(L, Lc), Lc.prototype.ySetter = Lc.prototype.widthSetter = Lc.prototype.heightSetter = Lc.prototype.xSetter;
        var Mc = {
            Element: Lc,
            isIE8: yb.indexOf("MSIE 8.0")>-1,
            init: function(b, c, d, e) {
                var f, g, h, i = this;
                if (i.alignedObjects = [], f = i.createElement(Qb).css(a(this.getStyle(e), {
                    position: Sb
                })), g = f.element, b.appendChild(f.element), i.isVML=!0, i.box = g, i.boxWrapper = f, i.cache = {}, i.setSize(c, d, !1), !lb.namespaces.hcv) {
                    lb.namespaces.add("hcv", "urn:schemas-microsoft-com:vml"), h = "hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } ";
                    try {
                        lb.createStyleSheet().cssText = h
                    } catch (j) {
                        lb.styleSheets[0].cssText += h
                    }
                }
            },
            isHidden: function() {
                return !this.box.offsetWidth
            },
            clipRect: function(b, c, d, e) {
                var g = this.createElement(), h = f(b);
                return a(g, {
                    members: [],
                    left: (h ? b.x : b) + 1,
                    top: (h ? b.y : c) + 1,
                    width: (h ? b.width : d) - 1,
                    height: (h ? b.height : e) - 1,
                    getCSS: function(b) {
                        var c = b.element, d = c.nodeName, e = "shape" === d, f = b.inverted, g = this, h = g.top - (e ? c.offsetTop : 0), i = g.left, j = i + g.width, k = h + g.height, l = {
                            clip: "rect(" + ob(f ? i : h) + "px," + ob(f ? k : j) + "px," + ob(f ? j : k) + "px," + ob(f ? h : i) + "px)"
                        };
                        return !f && Bb && "DIV" === d && a(l, {
                            width: j + Wb,
                            height: k + Wb
                        }), l
                    },
                    updateClipping: function() {
                        sc(g.members, function(a) {
                            a.element && a.css(g.getCSS(a))
                        })
                    }
                })
            },
            color: function(a, b, c, d) {
                var e, f, g, h = this, i = /^rgba/, j = Xb;
                if (a && a.linearGradient ? g = "gradient" : a && a.radialGradient && (g = "pattern"), g) {
                    var k, l, m, n, o, p, r, s, t, u, v, w, x = a.linearGradient || a.radialGradient, y = "", z = a.stops, A = [], B = function() {
                        f = ['<fill colors="' + A.join(",") + '" opacity="', s, '" o:opacity2="', r, '" type="', g, '" ', y, 'focus="100%" method="any" />'], q(h.prepVML(f), null, null, b)
                    };
                    if (v = z[0], w = z[z.length - 1], v[0] > 0 && z.unshift([0, v[1]]), w[0] < 1 && z.push([1, w[1]]), sc(z, function(a, b) {
                        i.test(a[1]) ? (e = Ic(a[1]), k = e.get("rgb"), l = e.get("a")) : (k = a[1], l = 1), A.push(100 * a[0] + "% " + k), b ? (s = l, t = k) : (r = l, u = k)
                    }), "fill" === c)
                        if ("gradient" === g)
                            m = x.x1 || x[0] || 0, n = x.y1 || x[1] || 0, o = x.x2 || x[2] || 0, p = x.y2 || x[3] || 0, y = 'angle="' + (90 - 180 * nb.atan((p - n) / (o - m)) / wb) + '"', B();
                        else {
                            var C, D = x.r, E = 2 * D, F = 2 * D, G = x.cx, H = x.cy, I = b.radialReference, J = function() {
                                I && (C = d.getBBox(), G += (I[0] - C.x) / C.width - .5, H += (I[1] - C.y) / C.height - .5, E*=I[2] / C.width, F*=I[2] / C.height), y = 'src="' + U.global.VMLRadialGradientURL + '" size="' + E + "," + F + '" origin="0.5,0.5" position="' + G + "," + H + '" color2="' + u + '" ', B()
                            };
                            d.added ? J() : d.onAdd = J, j = t
                        } else 
                            j = k
                } else if (i.test(a) && "IMG" !== b.tagName)
                    e = Ic(a), f = ["<", c, ' opacity="', e.get("a"), '"/>'], q(this.prepVML(f), null, null, b), j = e.get("rgb");
                else {
                    var K = b.getElementsByTagName(c);
                    K.length && (K[0].opacity = 1, K[0].type = "solid"), j = a
                }
                return j
            },
            prepVML: function(a) {
                var b = "display:inline-block;behavior:url(#default#VML);", c = this.isIE8;
                return a = a.join(""), c ? (a = a.replace("/>", ' xmlns="urn:schemas-microsoft-com:vml" />'), a =- 1 === a.indexOf('style="') ? a.replace("/>", ' style="' + b + '" />') : a.replace('style="', 'style="' + b)) : a = a.replace("<", "<hcv:"), a
            },
            text: Jc.prototype.html,
            path: function(b) {
                var c = {
                    coordsize: "10 10"
                };
                return g(b) ? c.d = b : f(b) && a(c, b), this.createElement("shape").attr(c)
            },
            circle: function(a, b, c) {
                var d = this.symbol("circle");
                return f(a) && (c = a.r, b = a.y, a = a.x), d.isCircle=!0, d.r = c, d.attr({
                    x: a,
                    y: b
                })
            },
            g: function(a) {
                var b, c;
                return a && (c = {
                    className: Ub + a,
                    "class": Ub + a
                }), b = this.createElement(Qb).attr(c)
            },
            image: function(a, b, c, d, e) {
                var f = this.createElement("img").attr({
                    src: a
                });
                return arguments.length > 1 && f.attr({
                    x: b,
                    y: c,
                    width: d,
                    height: e
                }), f
            },
            createElement: function(a) {
                return "rect" === a ? this.symbol(a) : Jc.prototype.createElement.call(this, a)
            },
            invertChild: function(a, b) {
                var c = this, e = b.style, f = "IMG" === a.tagName && a.style;
                p(a, {
                    flip: "x",
                    left: d(e.width) - (f ? d(f.top) : 1),
                    top: d(e.height) - (f ? d(f.left) : 1),
                    rotation: - 90
                }), sc(a.childNodes, function(b) {
                    c.invertChild(b, a)
                })
            },
            symbols: {
                arc: function(a, b, c, d, e) {
                    var f, g = e.start, h = e.end, i = e.r || c || d, j = e.innerR, k = ub(g), l = vb(g), m = ub(h), n = vb(h);
                    return h - g === 0 ? ["x"] : (f = ["wa", a - i, b - i, a + i, b + i, a + i * k, b + i * l, a + i * m, b + i * n], e.open&&!j && f.push("e", Yb, a, b), f.push("at", a - j, b - j, a + j, b + j, a + j * m, b + j * n, a + j * k, b + j * l, "x", "e"), f.isArc=!0, f)
                },
                circle: function(a, b, c, d, e) {
                    return e && (c = d = 2 * e.r), e && e.isCircle && (a -= c / 2, b -= d / 2), ["wa", a, b, a + c, b + d, a + c, b + d / 2, a + c, b + d / 2, "e"]
                },
                rect: function(a, b, c, d, e) {
                    return Jc.prototype.symbols[l(e) && e.r ? "callout": "square"].call(0, a, b, c, d, e)
                }
            }
        };
        mc.VMLRenderer = Kc = function() {
            this.init.apply(this, arguments)
        }, Kc.prototype = b(Jc.prototype, Mc), R = Kc
    }
    Jc.prototype.measureSpanWidth = function(a, b) {
        var c, d = lb.createElement("span"), e = lb.createTextNode(a);
        return d.appendChild(e), p(d, b), this.box.appendChild(d), c = d.offsetWidth, E(d), c
    };
    var Nc, Oc;
    Ib && (mc.CanVGRenderer = Nc = function() {
        Fb = "http://www.w3.org/1999/xhtml"
    }, Nc.prototype.symbols = {}, Oc = function() {
        function a() {
            var a, c = b.length;
            for (a = 0; c > a; a++)
                b[a]();
            b = []
        }
        var b = [];
        return {
            push: function(c, d) {
                0 === b.length && qc(d, a), b.push(c)
            }
        }
    }(), R = Nc), M.prototype = {
        addLabel: function() {
            var b, c, d, e, f = this, g = f.axis, i = g.options, k = g.chart, m = g.horiz, n = g.categories, p = g.names, q = f.pos, r = i.labels, s = g.tickPositions, t = m && n&&!r.step&&!r.staggerLines&&!r.rotation && k.plotWidth / s.length ||!m && (k.margin[3] || .33 * k.chartWidth), u = q === s[0], v = q === s[s.length - 1], w = n ? o(n[q], p[q], q): q, x = f.label, y = s.info;
            g.isDatetimeAxis && y && (e = i.dateTimeLabelFormats[y.higherRanks[q] || y.unitName]), f.isFirst = u, f.isLast = v, b = g.labelFormatter.call({
                axis: g,
                chart: k,
                isFirst: u,
                isLast: v,
                dateTimeLabelFormat: e,
                value: g.isLog ? G(j(w)): w
            }), c = t && {
                width: rb(1, ob(t - 2 * (r.padding || 10))) + Wb
            }, c = a(c, r.style), l(x) ? x && x.attr({
                text: b
            }).css(c) : (d = {
                align: g.labelAlign
            }, h(r.rotation) && (d.rotation = r.rotation), t && r.ellipsis && (d._clipHeight = g.len / s.length), f.label = l(b) && r.enabled ? k.renderer.text(b, 0, 0, r.useHTML).attr(d).css(c).add(g.labelGroup) : null)
        },
        getLabelSize: function() {
            var a = this.label, b = this.axis;
            return a ? a.getBBox()[b.horiz ? "height": "width"] : 0
        },
        getLabelSides: function() {
            var a = this.label.getBBox(), b = this.axis, c = b.horiz, d = b.options, e = d.labels, f = c ? a.width: a.height, g = c ? e.x - f * {
                left: 0,
                center: .5,
                right: 1
            }
            [b.labelAlign]: 0, h = c ? f + g: f;
            return [g, h]
        },
        handleOverflow: function(a, b) {
            var c, d, e, f, g, h=!0, i = this.axis, j = this.isFirst, k = this.isLast, l = i.horiz, m = l ? b.x : b.y, n = i.reversed, o = i.tickPositions, p = this.getLabelSides(), q = p[0], r = p[1], s = this.label.line || 0, t = i.labelEdge, u = i.justifyLabels && (j || k);
            if (t[s] === Q || m + q > t[s] ? t[s] = m + r : u || (h=!1), u) {
                g = i.justifyToPlot, c = g ? i.pos : 0, d = g ? c + i.len : i.chart.chartWidth;
                do 
                    a += j ? 1 : - 1, e = i.ticks[o[a]];
                while (o[a] && (!e || e.label.line !== s));
                f = e && e.label.xy && e.label.xy.x + e.getLabelSides()[j ? 0: 1], j&&!n || k && n ? c > m + q && (m = c - q, e && m + r > f && (h=!1)) : m + r > d && (m = d - r, e && f > m + q && (h=!1)), b.x = m
            }
            return h
        },
        getPosition: function(a, b, c, d) {
            var e = this.axis, f = e.chart, g = d && f.oldChartHeight || f.chartHeight;
            return {
                x: a ? e.translate(b + c, null, null, d) + e.transB: e.left + e.offset + (e.opposite ? (d && f.oldChartWidth || f.chartWidth) - e.right - e.left : 0),
                y: a ? g - e.bottom + e.offset - (e.opposite ? e.height : 0): g - e.translate(b + c, null, null, d) - e.transB
            }
        },
        getLabelPosition: function(a, b, c, d, e, f, g, h) {
            var i = this.axis, j = i.transA, k = i.reversed, m = i.staggerLines, n = i.chart.renderer.fontMetrics(e.style.fontSize).b, o = e.rotation;
            return a = a + e.x - (f && d ? f * j * (k?-1 : 1) : 0), b = b + e.y - (f&&!d ? f * j * (k ? 1 : - 1) : 0), o && 2 === i.side && (b -= n - n * ub(o * xb)), l(e.y) || o || (b += n - c.getBBox().height / 2), m && (c.line = g / (h || 1)%m, b += c.line * (i.labelOffset / m)), {
                x: a,
                y: b
            }
        },
        getMarkPath: function(a, b, c, d, e, f) {
            return f.crispLine([Yb, a, b, Zb, a + (e ? 0 : - c), b + (e ? c : 0)], d)
        },
        render: function(a, b, c) {
            var d, e, f, g = this, h = g.axis, i = h.options, j = h.chart, k = j.renderer, l = h.horiz, m = g.type, n = g.label, p = g.pos, q = i.labels, r = g.gridLine, s = m ? m + "Grid": "grid", t = m ? m + "Tick": "tick", u = i[s + "LineWidth"], v = i[s + "LineColor"], w = i[s + "LineDashStyle"], x = i[t + "Length"], y = i[t + "Width"] || 0, z = i[t + "Color"], A = i[t + "Position"], B = g.mark, C = q.step, D=!0, E = h.tickmarkOffset, F = g.getPosition(l, p, E, b), G = F.x, H = F.y, I = l && G === h.pos + h.len ||!l && H === h.pos?-1 : 1;
            this.isActive=!0, u && (d = h.getPlotLinePath(p + E, u * I, b, !0), r === Q && (f = {
                stroke: v,
                "stroke-width": u
            }, w && (f.dashstyle = w), m || (f.zIndex = 1), b && (f.opacity = 0), g.gridLine = r = u ? k.path(d).attr(f).add(h.gridGroup) : null), !b && r && d && r[g.isNew ? "attr": "animate"]({
                d: d,
                opacity: c
            })), y && x && ("inside" === A && (x =- x), h.opposite && (x =- x), e = g.getMarkPath(G, H, x, y * I, l, k), B ? B.animate({
                d: e,
                opacity: c
            }) : g.mark = k.path(e).attr({
                stroke: z,
                "stroke-width": y,
                opacity: c
            }).add(h.axisGroup)), n&&!isNaN(G) && (n.xy = F = g.getLabelPosition(G, H, n, l, q, E, a, C), g.isFirst&&!g.isLast&&!o(i.showFirstLabel, 1) || g.isLast&&!g.isFirst&&!o(i.showLastLabel, 1) ? D=!1 : h.isRadial || q.step || q.rotation || b || 0 === c || (D = g.handleOverflow(a, F)), C && a%C && (D=!1), D&&!isNaN(F.y) ? (F.opacity = c, n[g.isNew ? "attr": "animate"](F), g.isNew=!1) : n.attr("y", - 9999))
        },
        destroy: function() {
            D(this, this.axis)
        }
    }, mc.PlotLineOrBand = function(a, b) {
        this.axis = a, b && (this.options = b, this.id = b.id)
    }, mc.PlotLineOrBand.prototype = {
        render: function() {
            var a, c, d, e, f, g, h = this, j = h.axis, k = j.horiz, m = (j.pointRange || 0) / 2, n = h.options, p = n.label, q = h.label, r = n.width, s = n.to, t = n.from, u = l(t) && l(s), v = n.value, w = n.dashStyle, x = h.svgElem, y = [], z = n.color, A = n.zIndex, D = n.events, E = {}, F = j.chart.renderer;
            if (j.isLog && (t = i(t), s = i(s), v = i(v)), r)
                y = j.getPlotLinePath(v, r), E = {
                    stroke: z,
                    "stroke-width": r
                }, w && (E.dashstyle = w);
            else {
                if (!u)
                    return;
                t = rb(t, j.min - m), s = sb(s, j.max + m), y = j.getPlotBandPath(t, s, n), z && (E.fill = z), n.borderWidth && (E.stroke = n.borderColor, E["stroke-width"] = n.borderWidth)
            }
            if (l(A) && (E.zIndex = A), x)
                y ? x.animate({
                    d: y
                }, null, x.onGetPath) : (x.hide(), x.onGetPath = function() {
                    x.show()
                }, q && (h.label = q = q.destroy()));
            else if (y && y.length && (h.svgElem = x = F.path(y).attr(E).add(), D)) {
                a = function(a) {
                    x.on(a, function(b) {
                        D[a].apply(h, [b])
                    })
                };
                for (c in D)
                    a(c)
            }
            return p && l(p.text) && y && y.length && j.width > 0 && j.height > 0 ? (p = b({
                align: k && u && "center",
                x: k?!u && 4: 10,
                verticalAlign: !k && u && "middle",
                y: k ? u ? 16: 10: u ? 6: - 4,
                rotation: k&&!u && 90
            }, p), q || (E = {
                align: p.textAlign || p.align,
                rotation: p.rotation
            }, l(A) && (E.zIndex = A), h.label = q = F.text(p.text, 0, 0, p.useHTML).attr(E).css(p.style).add()), d = [y[1], y[4], o(y[6], y[1])], e = [y[2], y[5], o(y[7], y[2])], f = B(d), g = B(e), q.align(p, !1, {
                x: f,
                y: g,
                width: C(d) - f,
                height: C(e) - g
            }), q.show()) : q && q.hide(), h
        },
        destroy: function() {
            k(this.axis.plotLinesAndBands, this), delete this.axis, D(this)
        }
    }, Z = {
        getPlotBandPath: function(a, b) {
            var c = this.getPlotLinePath(b), d = this.getPlotLinePath(a);
            return d && c ? d.push(c[4], c[5], c[1], c[2]) : d = null, d
        },
        addPlotBand: function(a) {
            this.addPlotBandOrLine(a, "plotBands")
        },
        addPlotLine: function(a) {
            this.addPlotBandOrLine(a, "plotLines")
        },
        addPlotBandOrLine: function(a, b) {
            var c = new mc.PlotLineOrBand(this, a).render(), d = this.userOptions;
            return c && (b && (d[b] = d[b] || [], d[b].push(a)), this.plotLinesAndBands.push(c)), c
        },
        removePlotBandOrLine: function(a) {
            for (var b = this.plotLinesAndBands, c = this.options, d = this.userOptions, e = b.length; e--;)
                b[e].id === a && b[e].destroy();
            sc([c.plotLines || [], d.plotLines || [], c.plotBands || [], d.plotBands || []], function(b) {
                for (e = b.length; e--;)
                    b[e].id === a && k(b, b[e])
            })
        }
    }, N.prototype = {
        defaultOptions: {
            dateTimeLabelFormats: {
                millisecond: "%H:%M:%S.%L",
                second: "%H:%M:%S",
                minute: "%H:%M",
                hour: "%H:%M",
                day: "%e. %b",
                week: "%e. %b",
                month: "%b '%y",
                year: "%Y"
            },
            endOnTick: !1,
            gridLineColor: "#C0C0C0",
            labels: Cc,
            lineColor: "#C0D0E0",
            lineWidth: 1,
            minPadding: .01,
            maxPadding: .01,
            minorGridLineColor: "#E0E0E0",
            minorGridLineWidth: 1,
            minorTickColor: "#A0A0A0",
            minorTickLength: 2,
            minorTickPosition: "outside",
            startOfWeek: 1,
            startOnTick: !1,
            tickColor: "#C0D0E0",
            tickLength: 10,
            tickmarkPlacement: "between",
            tickPixelInterval: 100,
            tickPosition: "outside",
            tickWidth: 1,
            title: {
                align: "middle",
                style: {
                    color: "#707070"
                }
            },
            type: "linear"
        },
        defaultYAxisOptions: {
            endOnTick: !0,
            gridLineWidth: 1,
            tickPixelInterval: 72,
            showLastLabel: !0,
            labels: {
                x: - 8,
                y: 3
            },
            lineWidth: 0,
            maxPadding: .05,
            minPadding: .05,
            startOnTick: !0,
            tickWidth: 0,
            title: {
                rotation: 270,
                text: "Values"
            },
            stackLabels: {
                enabled: !1,
                formatter: function() {
                    return s(this.total, - 1)
                },
                style: Cc.style
            }
        },
        defaultLeftAxisOptions: {
            labels: {
                x: - 15,
                y: null
            },
            title: {
                rotation: 270
            }
        },
        defaultRightAxisOptions: {
            labels: {
                x: 15,
                y: null
            },
            title: {
                rotation: 90
            }
        },
        defaultBottomAxisOptions: {
            labels: {
                x: 0,
                y: 20
            },
            title: {
                rotation: 0
            }
        },
        defaultTopAxisOptions: {
            labels: {
                x: 0,
                y: - 15
            },
            title: {
                rotation: 0
            }
        },
        init: function(a, b) {
            var c = b.isX, d = this;
            d.horiz = a.inverted?!c : c, d.isXAxis = c, d.coll = c ? "xAxis" : "yAxis", d.opposite = b.opposite, d.side = b.side || (d.horiz ? d.opposite ? 0 : 2 : d.opposite ? 1 : 3), d.setOptions(b);
            var e = this.options, f = e.type, g = "datetime" === f;
            d.labelFormatter = e.labels.formatter || d.defaultLabelFormatter, d.userOptions = b, d.minPixelPadding = 0, d.chart = a, d.reversed = e.reversed, d.zoomEnabled = e.zoomEnabled!==!1, d.categories = e.categories || "category" === f, d.names = [], d.isLog = "logarithmic" === f, d.isDatetimeAxis = g, d.isLinked = l(e.linkedTo), d.tickmarkOffset = d.categories && "between" === e.tickmarkPlacement ? .5 : 0, d.ticks = {}, d.labelEdge = [], d.minorTicks = {}, d.plotLinesAndBands = [], d.alternateBands = {}, d.len = 0, d.minRange = d.userMinRange = e.minRange || e.maxZoom, d.range = e.range, d.offset = e.offset || 0, d.stacks = {}, d.oldStacks = {}, d.max = null, d.min = null, d.crosshair = o(e.crosshair, n(a.options.tooltip.crosshairs)[c ? 0: 1], !1);
            var h, k = d.options.events;
            - 1 === rc(d, a.axes) && (c&&!this.isColorAxis ? a.axes.splice(a.xAxis.length, 0, d) : a.axes.push(d), a[d.coll].push(d)), d.series = d.series || [], a.inverted && c && d.reversed === Q && (d.reversed=!0), d.removePlotBand = d.removePlotBandOrLine, d.removePlotLine = d.removePlotBandOrLine;
            for (h in k)
                wc(d, h, k[h]);
            d.isLog && (d.val2lin = i, d.lin2val = j)
        },
        setOptions: function(a) {
            this.options = b(this.defaultOptions, this.isXAxis ? {} : this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], b(U[this.coll], a))
        },
        defaultLabelFormatter: function() {
            var a, b, c = this.axis, d = this.value, e = c.categories, f = this.dateTimeLabelFormat, g = U.lang.numericSymbols, h = g && g.length, i = c.options.labels.format, j = c.isLog ? d: c.tickInterval;
            if (i)
                b = w(i, this);
            else if (e)
                b = d;
            else if (f)
                b = V(f, d);
            else if (h && j >= 1e3)
                for (; h--&&b === Q;)
                    a = Math.pow(1e3, h + 1), j >= a && null !== g[h] && (b = s(d / a, - 1) + g[h]);
            return b === Q && (b = tb(d) >= 1e4 ? s(d, 0) : s(d, - 1, Q, "")), b
        },
        getSeriesExtremes: function() {
            var a = this, b = a.chart;
            a.hasVisibleSeries=!1, a.dataMin = a.dataMax = null, a.buildStacks && a.buildStacks(), sc(a.series, function(c) {
                if (c.visible ||!b.options.chart.ignoreHiddenSeries) {
                    var d, e, f, g = c.options, h = g.threshold;
                    a.hasVisibleSeries=!0, a.isLog && 0 >= h && (h = null), a.isXAxis ? (d = c.xData, d.length && (a.dataMin = sb(o(a.dataMin, d[0]), B(d)), a.dataMax = rb(o(a.dataMax, d[0]), C(d)))) : (c.getExtremes(), f = c.dataMax, e = c.dataMin, l(e) && l(f) && (a.dataMin = sb(o(a.dataMin, e), e), a.dataMax = rb(o(a.dataMax, f), f)), l(h) && (a.dataMin >= h ? (a.dataMin = h, a.ignoreMinPadding=!0) : a.dataMax < h && (a.dataMax = h, a.ignoreMaxPadding=!0)))
                }
            })
        },
        translate: function(a, b, c, d, e, f) {
            var g, i = this, j = 1, k = 0, l = d ? i.oldTransA: i.transA, m = d ? i.oldMin: i.min, n = i.minPixelPadding, o = (i.options.ordinal || i.isLog && e) && i.lin2val;
            return l || (l = i.transA), c && (j*=-1, k = i.len), i.reversed && (j*=-1, k -= j * (i.sector || i.len)), b ? (a = a * j + k, a -= n, g = a / l + m, o && (g = i.lin2val(g))) : (o && (a = i.val2lin(a)), "between" === f && (f = .5), g = j * (a - m) * l + k + j * n + (h(f) ? l * f * i.pointRange : 0)), g
        },
        toPixels: function(a, b) {
            return this.translate(a, !1, !this.horiz, null, !0) + (b ? 0 : this.pos)
        },
        toValue: function(a, b) {
            return this.translate(a - (b ? 0 : this.pos), !0, !this.horiz, null, !0)
        },
        getPlotLinePath: function(a, b, c, d, e) {
            var f, g, h, i, j, k = this, l = k.chart, m = k.left, n = k.top, p = c && l.oldChartHeight || l.chartHeight, q = c && l.oldChartWidth || l.chartWidth, r = k.transB;
            return e = o(e, k.translate(a, null, null, c)), f = h = ob(e + r), g = i = ob(p - e - r), isNaN(e) ? j=!0 : k.horiz ? (g = n, i = p - k.bottom, (m > f || f > m + k.width) && (j=!0)) : (f = m, h = q - k.right, (n > g || g > n + k.height) && (j=!0)), j&&!d ? null : l.renderer.crispLine([Yb, f, g, Zb, h, i], b || 1)
        },
        getLinearTickPositions: function(a, b, c) {
            var d, e, f = G(pb(b / a) * a), g = G(qb(c / a) * a), i = [];
            if (b === c && h(b))
                return [b];
            for (d = f; g >= d && (i.push(d), d = G(d + a), d !== e);)
                e = d;
            return i
        },
        getMinorTickPositions: function() {
            var a, b, c, d = this, e = d.options, f = d.tickPositions, g = d.minorTickInterval, h = [];
            if (d.isLog)
                for (c = f.length, b = 1; c > b; b++)
                    h = h.concat(d.getLogTickPositions(g, f[b - 1], f[b], !0));
            else if (d.isDatetimeAxis && "auto" === e.minorTickInterval)
                h = h.concat(d.getTimeTicks(d.normalizeTimeTickInterval(g), d.min, d.max, e.startOfWeek)), h[0] < d.min && h.shift();
            else 
                for (a = d.min + (f[0] - d.min)%g; a <= d.max; a += g)
                    h.push(a);
            return h
        },
        adjustForMinRange: function() {
            var a, b, c, d, e, f, g, h, i = this, j = i.options, k = i.min, m = i.max, n = i.dataMax - i.dataMin >= i.minRange;
            if (i.isXAxis && i.minRange === Q&&!i.isLog && (l(j.min) || l(j.max) ? i.minRange = null : (sc(i.series, function(a) {
                for (e = a.xData, f = a.xIncrement ? 1 : e.length - 1, c = f; c > 0; c--)
                    d = e[c] - e[c - 1], (b === Q || b > d) && (b = d)
            }), i.minRange = sb(5 * b, i.dataMax - i.dataMin))), m - k < i.minRange) {
                var p = i.minRange;
                a = (p - m + k) / 2, g = [k - a, o(j.min, k - a)], n && (g[2] = i.dataMin), k = C(g), h = [k + p, o(j.max, k + p)], n && (h[2] = i.dataMax), m = B(h), p > m - k && (g[0] = m - p, g[1] = o(j.min, m - p), k = C(g))
            }
            i.min = k, i.max = m
        },
        setAxisTranslation: function(a) {
            var b, c, d = this, f = d.max - d.min, g = d.axisPointRange || 0, h = 0, i = 0, j = d.linkedParent, k=!!d.categories, m = d.transA;
            (d.isXAxis || k || g) && (j ? (h = j.minPointOffset, i = j.pointRangePadding) : sc(d.series, function(a) {
                var c = k ? 1: d.isXAxis ? a.pointRange: d.axisPointRange || 0, j = a.options.pointPlacement, m = a.closestPointRange;
                c > f && (c = 0), g = rb(g, c), h = rb(h, e(j) ? 0 : c / 2), i = rb(i, "on" === j ? 0 : c), !a.noSharedTooltip && l(m) && (b = l(b) ? sb(b, m) : m)
            }), c = d.ordinalSlope && b ? d.ordinalSlope / b : 1, d.minPointOffset = h*=c, d.pointRangePadding = i*=c, d.pointRange = sb(g, f), d.closestPointRange = b), a && (d.oldTransA = m), d.translationSlope = d.transA = m = d.len / (f + i || 1), d.transB = d.horiz ? d.left : d.bottom, d.minPixelPadding = m * h
        },
        setTickPositions: function(a) {
            var b, c, d, e, f = this, g = f.chart, j = f.options, k = f.isLog, m = f.isDatetimeAxis, n = f.isXAxis, p = f.isLinked, q = f.options.tickPositioner, r = j.maxPadding, s = j.minPadding, t = j.tickInterval, u = j.minTickInterval, v = j.tickPixelInterval, w = f.categories;
            if (p ? (f.linkedParent = g[f.coll][j.linkedTo], c = f.linkedParent.getExtremes(), f.min = o(c.min, c.dataMin), f.max = o(c.max, c.dataMax), j.type !== f.linkedParent.options.type && F(11, 1)) : (f.min = o(f.userMin, j.min, f.dataMin), f.max = o(f.userMax, j.max, f.dataMax)), k && (!a && sb(f.min, o(f.dataMin, f.min)) <= 0 && F(10, 1), f.min = G(i(f.min)), f.max = G(i(f.max))), f.range && l(f.max) && (f.userMin = f.min = rb(f.min, f.max - f.range), f.userMax = f.max, f.range = null), f.beforePadding && f.beforePadding(), f.adjustForMinRange(), w || f.axisPointRange || f.usePercentage || p ||!l(f.min) ||!l(f.max) || (b = f.max - f.min, b && (l(j.min) || l(f.userMin) ||!s ||!(f.dataMin < 0) && f.ignoreMinPadding || (f.min -= b * s), l(j.max) || l(f.userMax) ||!r ||!(f.dataMax > 0) && f.ignoreMaxPadding || (f.max += b * r))), h(j.floor) && (f.min = rb(f.min, j.floor)), h(j.ceiling) && (f.max = sb(f.max, j.ceiling)), f.min === f.max || void 0 === f.min || void 0 === f.max ? f.tickInterval = 1 : p&&!t && v === f.linkedParent.options.tickPixelInterval ? f.tickInterval = f.linkedParent.tickInterval : (f.tickInterval = o(t, w ? 1 : (f.max - f.min) * v / rb(f.len, v)
                ), !l(t) && f.len < v&&!this.isRadial&&!this.isLog&&!w && j.startOnTick && j.endOnTick && (e=!0, f.tickInterval/=4)), n&&!a && sc(f.series, function(a) {
                a.processData(f.min !== f.oldMin || f.max !== f.oldMax)
            }), f.setAxisTranslation(!0), f.beforeSetTickPositions && f.beforeSetTickPositions(), f.postProcessTickInterval && (f.tickInterval = f.postProcessTickInterval(f.tickInterval)), f.pointRange && (f.tickInterval = rb(f.pointRange, f.tickInterval)), !t && f.tickInterval < u && (f.tickInterval = u), m || k || t || (f.tickInterval = y(f.tickInterval, null, x(f.tickInterval), j)), f.minorTickInterval = "auto" === j.minorTickInterval && f.tickInterval ? f.tickInterval / 5 : j.minorTickInterval, f.tickPositions = d = j.tickPositions ? [].concat(j.tickPositions) : q && q.apply(f, [f.min, f.max]), d || (!f.ordinalPositions && (f.max - f.min) / f.tickInterval > rb(2 * f.len, 200) && F(19, !0), d = m ? f.getTimeTicks(f.normalizeTimeTickInterval(f.tickInterval, j.units), f.min, f.max, j.startOfWeek, f.ordinalPositions, f.closestPointRange, !0) : k ? f.getLogTickPositions(f.tickInterval, f.min, f.max) : f.getLinearTickPositions(f.tickInterval, f.min, f.max), e && d.splice(1, d.length - 2), f.tickPositions = d), !p) {
                var z, A = d[0], B = d[d.length - 1], C = f.minPointOffset || 0;
                j.startOnTick ? f.min = A : f.min - C > A && d.shift(), j.endOnTick ? f.max = B : f.max + C < B && d.pop(), 1 === d.length && (z = tb(f.max) > 1e13 ? 1 : .001, f.min -= z, f.max += z)
            }
        },
        setMaxTicks: function() {
            var a = this.chart, b = a.maxTicks || {}, c = this.tickPositions, d = this._maxTicksKey = [this.coll, this.pos, this.len].join("-");
            !this.isLinked&&!this.isDatetimeAxis && c && c.length > (b[d] || 0) && this.options.alignTicks!==!1 && (b[d] = c.length), a.maxTicks = b
        },
        adjustTickAmount: function() {
            var a = this, b = a.chart, c = a._maxTicksKey, d = a.tickPositions, e = b.maxTicks;
            if (e && e[c]&&!a.isDatetimeAxis&&!a.categories&&!a.isLinked && a.options.alignTicks!==!1 && this.min !== Q) {
                var f, g = a.tickAmount, h = d.length;
                if (a.tickAmount = f = e[c], f > h) {
                    for (; d.length < f;)
                        d.push(G(d[d.length - 1] + a.tickInterval));
                    a.transA*=(h - 1) / (f - 1), a.max = d[d.length - 1]
                }
                l(g) && f !== g && (a.isDirty=!0)
            }
        },
        setScale: function() {
            var a, b, c, d, e = this, f = e.stacks;
            if (e.oldMin = e.min, e.oldMax = e.max, e.oldAxisLength = e.len, e.setAxisSize(), d = e.len !== e.oldAxisLength, sc(e.series, function(a) {
                (a.isDirtyData || a.isDirty || a.xAxis.isDirty) && (c=!0)
            }), d || c || e.isLinked || e.forceRedraw || e.userMin !== e.oldUserMin || e.userMax !== e.oldUserMax) {
                if (!e.isXAxis)
                    for (a in f)
                        for (b in f[a])
                            f[a][b].total = null, f[a][b].cum = 0;
                e.forceRedraw=!1, e.getSeriesExtremes(), e.setTickPositions(), e.oldUserMin = e.userMin, e.oldUserMax = e.userMax, e.isDirty || (e.isDirty = d || e.min !== e.oldMin || e.max !== e.oldMax)
            } else if (!e.isXAxis) {
                e.oldStacks && (f = e.stacks = e.oldStacks);
                for (a in f)
                    for (b in f[a])
                        f[a][b].cum = f[a][b].total
            }
            e.setMaxTicks()
        },
        setExtremes: function(b, c, d, e, f) {
            var g = this, h = g.chart;
            d = o(d, !0), f = a(f, {
                min: b,
                max: c
            }), yc(g, "setExtremes", f, function() {
                g.userMin = b, g.userMax = c, g.eventArgs = f, g.isDirtyExtremes=!0, d && h.redraw(e)
            })
        },
        zoom: function(a, b) {
            var c = this.dataMin, d = this.dataMax, e = this.options;
            return this.allowZoomOutside || (l(c) && a <= sb(c, o(e.min, c)) && (a = Q), l(d) && b >= rb(d, o(e.max, d)) && (b = Q)), this.displayBtn = a !== Q || b !== Q, this.setExtremes(a, b, !1, Q, {
                trigger: "zoom"
            }), !0
        },
        setAxisSize: function() {
            var a = this.chart, b = this.options, c = b.offsetLeft || 0, d = b.offsetRight || 0, e = this.horiz, f = o(b.width, a.plotWidth - c + d), g = o(b.height, a.plotHeight), h = o(b.top, a.plotTop), i = o(b.left, a.plotLeft + c), j = /%$/;
            j.test(g) && (g = parseInt(g, 10) / 100 * a.plotHeight), j.test(h) && (h = parseInt(h, 10) / 100 * a.plotHeight + a.plotTop), this.left = i, this.top = h, this.width = f, this.height = g, this.bottom = a.chartHeight - g - h, this.right = a.chartWidth - f - i, this.len = rb(e ? f : g, 0), this.pos = e ? i : h
        },
        getExtremes: function() {
            var a = this, b = a.isLog;
            return {
                min: b ? G(j(a.min)): a.min,
                max: b ? G(j(a.max)): a.max,
                dataMin: a.dataMin,
                dataMax: a.dataMax,
                userMin: a.userMin,
                userMax: a.userMax
            }
        },
        getThreshold: function(a) {
            var b = this, c = b.isLog, d = c ? j(b.min): b.min, e = c ? j(b.max): b.max;
            return d > a || null === a ? a = d : a > e && (a = e), b.translate(a, 0, 1, 0, 1)
        },
        autoLabelAlign: function(a) {
            var b, c = (o(a, 0) - 90 * this.side + 720)%360;
            return b = c > 15 && 165 > c ? "right" : c > 195 && 345 > c ? "left" : "center"
        },
        getOffset: function() {
            var a, b, c, d, e, f, g, h, i, j, k, m, n, p = this, q = p.chart, r = q.renderer, s = p.options, t = p.tickPositions, u = p.ticks, v = p.horiz, w = p.side, x = q.inverted ? [1, 0, 3, 2][w]: w, y = 0, z = 0, A = s.title, B = s.labels, C = 0, D = q.axisOffset, E = q.clipOffset, F = [ - 1, 1, 1, - 1][w], G = 1, H = o(B.maxStaggerLines, 5), I = 2 === w ? r.fontMetrics(B.style.fontSize).b: 0;
            if (p.hasData = a = p.hasVisibleSeries || l(p.min) && l(p.max)&&!!t, p.showAxis = b = a || o(s.showEmpty, !0), p.staggerLines = p.horiz && B.staggerLines, p.axisGroup || (p.gridGroup = r.g("grid").attr({
                zIndex: s.gridZIndex || 1
            }).add(), p.axisGroup = r.g("axis").attr({
                zIndex: s.zIndex || 2
            }).add(), p.labelGroup = r.g("axis-labels").attr({
                zIndex: B.zIndex || 7
            }).addClass(Ub + p.coll.toLowerCase() + "-labels").add()), a || p.isLinked) {
                if (p.labelAlign = o(B.align || p.autoLabelAlign(B.rotation)), sc(t, function(a) {
                    u[a] ? u[a].addLabel() : u[a] = new M(p, a)
                }), p.horiz&&!p.staggerLines && H&&!B.rotation) {
                    for (f = p.reversed ? [].concat(t).reverse() : t; H > G;) {
                        for (g = [], h=!1, e = 0; e < f.length; e++)
                            i = f[e], j = u[i].label && u[i].label.getBBox(), m = j ? j.width : 0, n = e%G, m && (k = p.translate(i), g[n] !== Q && k < g[n] && (h=!0), g[n] = k + m);
                        if (!h)
                            break;
                        G++
                    }
                    G > 1 && (p.staggerLines = G)
                }
                sc(t, function(a) {
                    (0 === w || 2 === w || {
                        1: "left",
                        3: "right"
                    }
                    [w] === p.labelAlign) && (C = rb(u[a].getLabelSize(), C))
                }), p.staggerLines && (C*=p.staggerLines, p.labelOffset = C)
            } else 
                for (d in u)
                    u[d].destroy(), delete u[d];
            A && A.text && A.enabled!==!1 && (p.axisTitle || (p.axisTitle = r.text(A.text, 0, 0, A.useHTML).attr({
                zIndex: 7,
                rotation: A.rotation || 0,
                align: A.textAlign || {
                    low: "left",
                    middle: "center",
                    high: "right"
                }
                [A.align]
            }).addClass(Ub + this.coll.toLowerCase() + "-title").css(A.style).add(p.axisGroup), p.axisTitle.isNew=!0), b && (y = p.axisTitle.getBBox()[v ? "height": "width"], z = o(A.margin, v ? 5 : 10), c = A.offset), p.axisTitle[b ? "show": "hide"]()), p.offset = F * o(s.offset, D[w]), p.axisTitleMargin = o(c, C + z + (C && F * s.labels[v ? "y": "x"] - I)), D[w] = rb(D[w], p.axisTitleMargin + y + F * p.offset), E[x] = rb(E[x], 2 * pb(s.lineWidth / 2))
        },
        getLinePath: function(a) {
            var b = this.chart, c = this.opposite, d = this.offset, e = this.horiz, f = this.left + (c ? this.width : 0) + d, g = b.chartHeight - this.bottom - (c ? this.height : 0) + d;
            return c && (a*=-1), b.renderer.crispLine([Yb, e ? this.left: f, e ? g: this.top, Zb, e ? b.chartWidth - this.right: f, e ? g: b.chartHeight - this.bottom], a)
        },
        getTitlePosition: function() {
            var a = this.horiz, b = this.left, c = this.top, e = this.len, f = this.options.title, g = a ? b: c, h = this.opposite, i = this.offset, j = d(f.style.fontSize || 12), k = {
                low: g + (a ? 0 : e),
                middle: g + e / 2,
                high: g + (a ? e : 0)
            }
            [f.align], l = (a ? c + this.height : b) + (a ? 1 : - 1) * (h?-1 : 1) * this.axisTitleMargin + (2 === this.side ? j : 0);
            return {
                x: a ? k: l + (h ? this.width : 0) + i + (f.x || 0),
                y: a ? l - (h ? this.height : 0) + i: k + (f.y || 0)
            }
        },
        render: function() {
            var a, b, c, d, e = this, f = e.horiz, g = e.reversed, h = e.chart, i = h.renderer, k = e.options, m = e.isLog, n = e.isLinked, o = e.tickPositions, p = e.axisTitle, q = e.ticks, r = e.minorTicks, s = e.alternateBands, t = k.stackLabels, u = k.alternateGridColor, v = e.tickmarkOffset, w = k.lineWidth, x = h.hasRendered, y = x && l(e.oldMin)&&!isNaN(e.oldMin), z = e.hasData, A = e.showAxis, B = k.labels.overflow, C = e.justifyLabels = f && B!==!1;
            e.labelEdge.length = 0, e.justifyToPlot = "justify" === B, sc([q, r, s], function(a) {
                var b;
                for (b in a)
                    a[b].isActive=!1
            }), (z || n) && (e.minorTickInterval&&!e.categories && sc(e.getMinorTickPositions(), function(a) {
                r[a] || (r[a] = new M(e, a, "minor")), y && r[a].isNew && r[a].render(null, !0), r[a].render(null, !1, 1)
            }), o.length && (a = o.slice(), (f && g ||!f&&!g) && a.reverse(), C && (a = a.slice(1).concat([a[0]])), sc(a, function(b, c) {
                C && (c = c === a.length - 1 ? 0 : c + 1), (!n || b >= e.min && b <= e.max) && (q[b] || (q[b] = new M(e, b)), y && q[b].isNew && q[b].render(c, !0, .1), q[b].render(c, !1, 1))
            }), v && 0 === e.min && (q[ - 1] || (q[ - 1] = new M(e, - 1, null, !0)), q[ - 1].render( - 1))), u && sc(o, function(a, b) {
                b%2 === 0 && a < e.max && (s[a] || (s[a] = new mc.PlotLineOrBand(e)), c = a + v, d = o[b + 1] !== Q ? o[b + 1] + v : e.max, s[a].options = {
                    from: m ? j(c): c,
                    to: m ? j(d): d,
                    color: u
                }, s[a].render(), s[a].isActive=!0)
            }), e._addedPlotLB || (sc((k.plotLines || []).concat(k.plotBands || []), function(a) {
                e.addPlotBandOrLine(a)
            }), e._addedPlotLB=!0)), sc([q, r, s], function(a) {
                var b, c, d = [], e = W ? W.duration || 500: 0, f = function() {
                    for (c = d.length; c--;)
                        a[d[c]]&&!a[d[c]].isActive && (a[d[c]].destroy(), delete a[d[c]])
                };
                for (b in a)
                    a[b].isActive || (a[b].render(b, !1, 0), a[b].isActive=!1, d.push(b));
                a !== s && h.hasRendered && e ? e && setTimeout(f, e) : f()
            }), w && (b = e.getLinePath(w), e.axisLine ? e.axisLine.animate({
                d: b
            }) : e.axisLine = i.path(b).attr({
                stroke: k.lineColor,
                "stroke-width": w,
                zIndex: 7
            }).add(e.axisGroup), e.axisLine[A ? "show": "hide"]()), p && A && (p[p.isNew ? "attr": "animate"](e.getTitlePosition()), p.isNew=!1), t && t.enabled && e.renderStackTotals(), e.isDirty=!1
        },
        redraw: function() {
            var a = this, b = a.chart, c = b.pointer;
            c && c.reset(!0), a.render(), sc(a.plotLinesAndBands, function(a) {
                a.render()
            }), sc(a.series, function(a) {
                a.isDirty=!0
            })
        },
        destroy: function(a) {
            var b, c, d = this, e = d.stacks, f = d.plotLinesAndBands;
            a || xc(d);
            for (b in e)
                D(e[b]), e[b] = null;
            for (sc([d.ticks, d.minorTicks, d.alternateBands], function(a) {
                D(a)
            }), c = f.length; c--;)
                f[c].destroy();
            sc(["stackTotalGroup", "axisLine", "axisTitle", "axisGroup", "cross", "gridGroup", "labelGroup"], function(a) {
                d[a] && (d[a] = d[a].destroy())
            }), this.cross && this.cross.destroy()
        },
        drawCrosshair: function(a, b) {
            if (this.crosshair) {
                if ((l(b) ||!o(this.crosshair.snap, !0))===!1)
                    return void this.hideCrosshair();
                var c, d, e = this.crosshair, f = e.animation;
                if (o(e.snap, !0) ? l(b) && (d = this.chart.inverted != this.horiz ? b.plotX : this.len - b.plotY) : d = this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos, c = this.isRadial ? this.getPlotLinePath(this.isXAxis ? b.x : o(b.stackY, b.y)) : this.getPlotLinePath(null, null, null, null, d), null === c)
                    return void this.hideCrosshair();
                if (this.cross)
                    this.cross.attr({
                        visibility: Vb
                    })[f ? "animate": "attr"]({
                        d: c
                    }, f);
                else {
                    var g = {
                        "stroke-width": e.width || 1,
                        stroke: e.color || "#C0C0C0",
                        zIndex: e.zIndex || 2
                    };
                    e.dashStyle && (g.dashstyle = e.dashStyle), this.cross = this.chart.renderer.path(c).attr(g).add()
                }
            }
        },
        hideCrosshair: function() {
            this.cross && this.cross.hide()
        }
    }, a(N.prototype, Z), N.prototype.getTimeTicks = function(b, c, d, e) {
        var f, g, h = [], i = {}, j = U.global.useUTC, k = new Date(c - _), m = b.unitRange, n = b.count;
        if (l(c)) {
            m >= Y[dc] && (k.setMilliseconds(0), k.setSeconds(m >= Y[ec] ? 0 : n * pb(k.getSeconds() / n))), m >= Y[ec] && k[gb](m >= Y[fc] ? 0 : n * pb(k[ab]() / n)), m >= Y[fc] && k[hb](m >= Y[gc] ? 0 : n * pb(k[bb]() / n)), m >= Y[gc] && k[ib](m >= Y[ic] ? 1 : n * pb(k[db]() / n)), m >= Y[ic] && (k[jb](m >= Y[jc] ? 0 : n * pb(k[eb]() / n)), g = k[fb]()), m >= Y[jc] && (g -= g%n, k[kb](g)), m === Y[hc] && k[ib](k[db]() - k[cb]() + o(e, 1)), f = 1, _ && (k = new Date(k.getTime() + _)), g = k[fb]();
            for (var p = k.getTime(), q = k[eb](), r = k[db](), s = j ? _ : (864e5 + 60 * k.getTimezoneOffset() * 1e3)%864e5; d > p;)
                h.push(p), m === Y[jc] ? p = $(g + f * n, 0) : m === Y[ic] ? p = $(g, q + f * n) : j || m !== Y[gc] && m !== Y[hc] ? p += m * n : p = $(g, q, r + f * n * (m === Y[gc] ? 1 : 7)), f++;
            h.push(p), sc(tc(h, function(a) {
                return m <= Y[fc] && a%Y[gc] === s
            }), function(a) {
                i[a] = gc
            })
        }
        return h.info = a(b, {
            higherRanks: i,
            totalRange: m * n
        }), h
    }, N.prototype.normalizeTimeTickInterval = function(a, b) {
        var c, d, e = b || [[cc, [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [dc, [1, 2, 5, 10, 15, 30]], [ec, [1, 2, 5, 10, 15, 30]], [fc, [1, 2, 3, 4, 6, 8, 12]], [gc, [1, 2]], [hc, [1, 2]], [ic, [1, 2, 3, 4, 6]], [jc, null]], f = e[e.length - 1], g = Y[f[0]], h = f[1];
        for (d = 0; d < e.length; d++)
            if (f = e[d], g = Y[f[0]], h = f[1], e[d + 1]) {
                var i = (g * h[h.length - 1] + Y[e[d + 1][0]]) / 2;
                if (i >= a)
                    break
            }
        return g === Y[jc] && 5 * g > a && (h = [1, 2, 5]), c = y(a / g, h, f[0] === jc ? rb(x(a / g), 1) : 1), {
            unitRange: g,
            count: c,
            unitName: f[0]
        }
    }, N.prototype.getLogTickPositions = function(a, b, c, d) {
        var e = this, f = e.options, g = e.len, h = [];
        if (d || (e._minorAutoInterval = null), a >= .5)
            a = ob(a), h = e.getLinearTickPositions(a, b, c);
        else if (a >= .08) {
            var k, l, m, n, p, q, r, s = pb(b);
            for (k = a > .3 ? [1, 2, 4] : a > .15 ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9], l = s; c + 1 > l&&!r; l++)
                for (n = k.length, m = 0; n > m&&!r; m++)
                    p = i(j(l) * k[m]), p > b && (!d || c >= q) && h.push(q), q > c && (r=!0), q = p
        } else {
            var t = j(b), u = j(c), v = f[d ? "minorTickInterval": "tickInterval"], w = "auto" === v ? null: v, z = f.tickPixelInterval / (d ? 5 : 1), A = d ? g / e.tickPositions.length: g;
            a = o(w, e._minorAutoInterval, (u - t) * z / (A || 1)), a = y(a, null, x(a)), h = vc(e.getLinearTickPositions(a, t, u), i), d || (e._minorAutoInterval = a / 5)
        }
        return d || (e.tickInterval = a), h
    };
    var Pc = mc.Tooltip = function() {
        this.init.apply(this, arguments)
    };
    Pc.prototype = {
        init: function(a, b) {
            var c = b.borderWidth, e = b.style, f = d(e.padding);
            this.chart = a, this.options = b, this.crosshairs = [], this.now = {
                x: 0,
                y: 0
            }, this.isHidden=!0, this.label = a.renderer.label("", 0, 0, b.shape || "callout", null, null, b.useHTML, null, "tooltip").attr({
                padding: f,
                fill: b.backgroundColor,
                "stroke-width": c,
                r: b.borderRadius,
                zIndex: 8
            }).css(e).css({
                padding: 0
            }).add().attr({
                y: - 9999
            }), Ib || this.label.shadow(b.shadow), this.shared = b.shared
        },
        destroy: function() {
            this.label && (this.label = this.label.destroy()), clearTimeout(this.hideTimer), clearTimeout(this.tooltipTimeout)
        },
        move: function(b, c, d, e) {
            var f = this, g = f.now, h = f.options.animation!==!1&&!f.isHidden, i = f.followPointer || f.len > 1;
            a(g, {
                x: h ? (2 * g.x + b) / 3: b,
                y: h ? (g.y + c) / 2: c,
                anchorX: i ? Q: h ? (2 * g.anchorX + d) / 3: d,
                anchorY: i ? Q: h ? (g.anchorY + e) / 2: e
            }), f.label.attr(g), h && (tb(b - g.x) > 1 || tb(c - g.y) > 1) && (clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function() {
                f && f.move(b, c, d, e)
            }, 32))
        },
        hide: function() {
            var a, b = this;
            clearTimeout(this.hideTimer), this.isHidden || (a = this.chart.hoverPoints, this.hideTimer = setTimeout(function() {
                b.label.fadeOut(), b.isHidden=!0
            }, o(this.options.hideDelay, 500)), a && sc(a, function(a) {
                a.setState()
            }), this.chart.hoverPoints = null)
        },
        getAnchor: function(a, b) {
            var c, d, e = this.chart, f = e.inverted, g = e.plotTop, h = 0, i = 0;
            return a = n(a), c = a[0].tooltipPos, this.followPointer && b && (b.chartX === Q && (b = e.pointer.normalize(b)), c = [b.chartX - e.plotLeft, b.chartY - g]), c || (sc(a, function(a) {
                d = a.series.yAxis, h += a.plotX, i += (a.plotLow ? (a.plotLow + a.plotHigh) / 2 : a.plotY) + (!f && d ? d.top - g : 0)
            }), h/=a.length, i/=a.length, c = [f ? e.plotWidth - i: h, this.shared&&!f && a.length > 1 && b ? b.chartY - g: f ? e.plotHeight - h: i]), vc(c, ob)
        },
        getPosition: function(a, b, c) {
            var d, e = this.chart, f = this.distance, g = {}, h = ["y", e.chartHeight, b, c.plotY + e.plotTop], i = ["x", e.chartWidth, a, c.plotX + e.plotLeft], j = c.ttBelow || e.inverted&&!c.negative ||!e.inverted && c.negative, k = function(a, b, c, d) {
                var e = d - f > c, h = b > d + f + c, i = d - f - c, k = d + f;
                if (j && h)
                    g[a] = k;
                else if (!j && e)
                    g[a] = i;
                else if (e)
                    g[a] = i;
                else {
                    if (!h)
                        return !1;
                    g[a] = k
                }
            }, l = function(a, b, c, d) {
                return f > d || d > b - f?!1 : void(g[a] = c / 2 > d ? 1 : d > b - c / 2 ? b - c - 2 : d - c / 2)
            }, m = function(a) {
                var b = h;
                h = i, i = b, d = a
            }, n = function() {
                k.apply(0, h)!==!1 ? l.apply(0, i)!==!1 || d || (m(!0), n()) : d ? g.x = g.y = 0 : (m(!0), n())
            };
            return (e.inverted || this.len > 1) && m(), n(), g
        },
        defaultFormatter: function(a) {
            var b, c = this.points || n(this), d = c[0].series;
            return b = [a.tooltipHeaderFormatter(c[0])], sc(c, function(a) {
                d = a.series, b.push(d.tooltipFormatter && d.tooltipFormatter(a) || a.point.tooltipFormatter(d.tooltipOptions.pointFormat))
            }), b.push(a.options.footerFormat || ""), b.join("")
        },
        refresh: function(a, b) {
            var c, d, e, f, g, h, i = this, j = i.chart, k = i.label, l = i.options, m = {}, p = [], q = l.formatter || i.defaultFormatter, r = j.hoverPoints, s = i.shared;
            clearTimeout(this.hideTimer), i.followPointer = n(a)[0].series.tooltipOptions.followPointer, e = i.getAnchor(a, b), c = e[0], d = e[1], !s || a.series && a.series.noSharedTooltip ? m = a.getLabelConfig() : (j.hoverPoints = a, r && sc(r, function(a) {
                a.setState()
            }), sc(a, function(a) {
                a.setState(ac), p.push(a.getLabelConfig())
            }), m = {
                x: a[0].category,
                y: a[0].y
            }, m.points = p, this.len = p.length, a = a[0]), f = q.call(m, i), h = a.series, this.distance = o(h.tooltipOptions.distance, 16), f===!1 ? this.hide() : (i.isHidden && (Bc(k), k.attr("opacity", 1).show()), k.attr({
                text: f
            }), g = l.borderColor || a.color || h.color || "#606060", k.attr({
                stroke: g
            }), i.updatePosition({
                plotX: c,
                plotY: d,
                negative: a.negative,
                ttBelow: a.ttBelow
            }), this.isHidden=!1), yc(j, "tooltipRefresh", {
                text: f,
                x: c + j.plotLeft,
                y: d + j.plotTop,
                borderColor: g
            })
        },
        updatePosition: function(a) {
            var b = this.chart, c = this.label, d = (this.options.positioner || this.getPosition).call(this, c.width, c.height, a);
            this.move(ob(d.x), ob(d.y), a.plotX + b.plotLeft, a.plotY + b.plotTop)
        },
        tooltipHeaderFormatter: function(a) {
            var b, c = a.series, d = c.tooltipOptions, e = d.dateTimeLabelFormats, f = d.xDateFormat, g = c.xAxis, i = g && "datetime" === g.options.type && h(a.key), j = d.headerFormat, k = g && g.closestPointRange;
            if (i&&!f) {
                if (k) {
                    for (b in Y)
                        if (Y[b] >= k || Y[b] <= Y[gc] && a.key%Y[b] > 0) {
                            f = e[b];
                            break
                        }
                } else 
                    f = e.day;
                f = f || e.year
            }
            return i && f && (j = j.replace("{point.key}", "{point.key:" + f + "}")), w(j, {
                point: a,
                series: c
            })
        }
    };
    var Qc;
    S = lb.documentElement.ontouchstart !== Q;
    var Rc = mc.Pointer = function(a, b) {
        this.init(a, b)
    };
    if (Rc.prototype = {
        init: function(a, b) {
            var c, d, e = b.chart, f = e.events, g = Ib ? "": e.zoomType, h = a.inverted;
            this.options = b, this.chart = a, this.zoomX = c = /x/.test(g), this.zoomY = d = /y/.test(g), this.zoomHor = c&&!h || d && h, this.zoomVert = d&&!h || c && h, this.hasZoom = c || d, this.runChartClick = f&&!!f.click, this.pinchDown = [], this.lastValidTouch = {}, mc.Tooltip && b.tooltip.enabled && (a.tooltip = new Pc(a, b.tooltip), this.followTouchMove = b.tooltip.followTouchMove), this.setDOMEvents()
        },
        normalize: function(b, c) {
            var d, e, f;
            return b = b || window.event, b = zc(b), b.target || (b.target = b.srcElement), f = b.touches ? b.touches.length ? b.touches.item(0) : b.changedTouches[0] : b, c || (this.chartPosition = c = uc(this.chart.container)), f.pageX === Q ? (d = rb(b.x, b.clientX - c.left), e = b.y) : (d = f.pageX - c.left, e = f.pageY - c.top), a(b, {
                chartX: ob(d),
                chartY: ob(e)
            })
        },
        getCoordinates: function(a) {
            var b = {
                xAxis: [],
                yAxis: []
            };
            return sc(this.chart.axes, function(c) {
                b[c.isXAxis ? "xAxis": "yAxis"].push({
                    axis: c,
                    value: c.toValue(a[c.horiz ? "chartX": "chartY"])
                })
            }), b
        },
        getIndex: function(a) {
            var b = this.chart;
            return b.inverted ? b.plotHeight + b.plotTop - a.chartY : a.chartX - b.plotLeft
        },
        runPointActions: function(a) {
            var b, c, d, e, f, g, h = this, i = h.chart, j = i.series, k = i.tooltip, l = i.hoverPoint, m = i.hoverSeries, n = i.chartWidth, p = h.getIndex(a);
            if (k && h.options.tooltip.shared && (!m ||!m.noSharedTooltip)) {
                for (d = [], e = j.length, f = 0; e > f; f++)
                    j[f].visible && j[f].options.enableMouseTracking!==!1&&!j[f].noSharedTooltip && j[f].singularTooltips!==!0 && j[f].tooltipPoints.length && (c = j[f].tooltipPoints[p], c && c.series && (c._dist = tb(p - c.clientX), n = sb(n, c._dist), d.push(c)));
                for (e = d.length; e--;)
                    d[e]._dist > n && d.splice(e, 1);
                d.length && d[0].clientX !== h.hoverX && (k.refresh(d, a), h.hoverX = d[0].clientX)
            }
            b = m && m.tooltipOptions.followPointer, m && m.tracker&&!b ? (c = m.tooltipPoints[p], c && c !== l && c.onMouseOver(a)) : k && b&&!k.isHidden && (g = k.getAnchor([{}
            ], a), k.updatePosition({
                plotX: g[0],
                plotY: g[1]
            })), k&&!h._onDocumentMouseMove && (h._onDocumentMouseMove = function(a) {
                Mb[Qc] && Mb[Qc].pointer.onDocumentMouseMove(a)
            }, wc(lb, "mousemove", h._onDocumentMouseMove)), sc(i.axes, function(b) {
                b.drawCrosshair(a, o(c, l))
            })
        },
        reset: function(a) {
            var b = this, c = b.chart, d = c.hoverSeries, e = c.hoverPoint, f = c.tooltip, g = f && f.shared ? c.hoverPoints: e;
            a = a && f && g, a && n(g)[0].plotX === Q && (a=!1), a ? (f.refresh(g), e && e.setState(e.state, !0)) : (e && e.onMouseOut(), d && d.onMouseOut(), f && f.hide(), b._onDocumentMouseMove && (xc(lb, "mousemove", b._onDocumentMouseMove), b._onDocumentMouseMove = null), sc(c.axes, function(a) {
                a.hideCrosshair()
            }), b.hoverX = null)
        },
        scaleGroups: function(a, b) {
            var c, d = this.chart;
            sc(d.series, function(e) {
                c = a || e.getPlotBox(), e.xAxis && e.xAxis.zoomEnabled && (e.group.attr(c), e.markerGroup && (e.markerGroup.attr(c), e.markerGroup.clip(b ? d.clipRect : null)), e.dataLabelsGroup && e.dataLabelsGroup.attr(c))
            }), d.clipRect.attr(b || d.clipBox)
        },
        dragStart: function(a) {
            var b = this.chart;
            b.mouseIsDown = a.type, b.cancelClick=!1, b.mouseDownX = this.mouseDownX = a.chartX, b.mouseDownY = this.mouseDownY = a.chartY
        },
        drag: function(a) {
            var b, c, d = this.chart, e = d.options.chart, f = a.chartX, g = a.chartY, h = this.zoomHor, i = this.zoomVert, j = d.plotLeft, k = d.plotTop, l = d.plotWidth, m = d.plotHeight, n = this.mouseDownX, o = this.mouseDownY;
            j > f ? f = j : f > j + l && (f = j + l), k > g ? g = k : g > k + m && (g = k + m), this.hasDragged = Math.sqrt(Math.pow(n - f, 2) + Math.pow(o - g, 2)), this.hasDragged > 10 && (b = d.isInsidePlot(n - j, o - k), d.hasCartesianSeries && (this.zoomX || this.zoomY) && b && (this.selectionMarker || (this.selectionMarker = d.renderer.rect(j, k, h ? 1 : l, i ? 1 : m, 0).attr({
                fill: e.selectionMarkerFill || "rgba(69,114,167,0.25)",
                zIndex: 7
            }).add())), this.selectionMarker && h && (c = f - n, this.selectionMarker.attr({
                width: tb(c),
                x: (c > 0 ? 0 : c) + n
            })), this.selectionMarker && i && (c = g - o, this.selectionMarker.attr({
                height: tb(c),
                y: (c > 0 ? 0 : c) + o
            })), b&&!this.selectionMarker && e.panning && d.pan(a, e.panning))
        },
        drop: function(b) {
            var c = this.chart, d = this.hasPinched;
            if (this.selectionMarker) {
                var e, f = {
                    xAxis: [],
                    yAxis: [],
                    originalEvent: b.originalEvent || b
                }, g = this.selectionMarker, h = g.attr ? g.attr("x"): g.x, i = g.attr ? g.attr("y"): g.y, j = g.attr ? g.attr("width"): g.width, k = g.attr ? g.attr("height"): g.height;
                (this.hasDragged || d) && (sc(c.axes, function(a) {
                    if (a.zoomEnabled) {
                        var b = a.horiz, c = a.toValue(b ? h : i), d = a.toValue(b ? h + j : i + k);
                        isNaN(c) || isNaN(d) || (f[a.coll].push({
                            axis: a,
                            min: sb(c, d),
                            max: rb(c, d)
                        }), e=!0)
                    }
                }), e && yc(c, "selection", f, function(b) {
                    c.zoom(a(b, d ? {
                        animation: !1
                    } : null))
                })), this.selectionMarker = this.selectionMarker.destroy(), d && this.scaleGroups()
            }
            c && (p(c.container, {
                cursor: c._cursor
            }), c.cancelClick = this.hasDragged > 10, c.mouseIsDown = this.hasDragged = this.hasPinched=!1, this.pinchDown = [])
        },
        onContainerMouseDown: function(a) {
            a = this.normalize(a), a.preventDefault && a.preventDefault(), this.dragStart(a)
        },
        onDocumentMouseUp: function(a) {
            Mb[Qc] && Mb[Qc].pointer.drop(a)
        },
        onDocumentMouseMove: function(a) {
            var b = this.chart, c = this.chartPosition, d = b.hoverSeries;
            a = this.normalize(a, c), c && d&&!this.inClass(a.target, "highcharts-tracker")&&!b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) && this.reset()
        },
        onContainerMouseLeave: function() {
            var a = Mb[Qc];
            a && (a.pointer.reset(), a.pointer.chartPosition = null)
        },
        onContainerMouseMove: function(a) {
            var b = this.chart;
            Qc = b.index, a = this.normalize(a), "mousedown" === b.mouseIsDown && this.drag(a), !this.inClass(a.target, "highcharts-tracker")&&!b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) || b.openMenu || this.runPointActions(a)
        },
        inClass: function(a, b) {
            for (var c; a;) {
                if (c = m(a, "class")) {
                    if ( - 1 !== c.indexOf(b))
                        return !0;
                    if ( - 1 !== c.indexOf(Ub + "container"))
                        return !1
                }
                a = a.parentNode
            }
        },
        onTrackerMouseOut: function(a) {
            var b = this.chart.hoverSeries, c = a.relatedTarget || a.toElement, d = c && c.point && c.point.series;
            !b || b.options.stickyTracking || this.inClass(c, Ub + "tooltip") || d === b || b.onMouseOut()
        },
        onContainerClick: function(b) {
            var c = this.chart, d = c.hoverPoint, e = c.plotLeft, f = c.plotTop;
            b = this.normalize(b), b.cancelBubble=!0, c.cancelClick || (d && this.inClass(b.target, Ub + "tracker") ? (yc(d.series, "click", a(b, {
                point: d
            })), c.hoverPoint && d.firePointEvent("click", b)) : (a(b, this.getCoordinates(b)), c.isInsidePlot(b.chartX - e, b.chartY - f) && yc(c, "click", b)))
        },
        setDOMEvents: function() {
            var a = this, b = a.chart.container;
            b.onmousedown = function(b) {
                a.onContainerMouseDown(b)
            }, b.onmousemove = function(b) {
                a.onContainerMouseMove(b)
            }, b.onclick = function(b) {
                a.onContainerClick(b)
            }, wc(b, "mouseleave", a.onContainerMouseLeave), 1 === Nb && wc(lb, "mouseup", a.onDocumentMouseUp), S && (b.ontouchstart = function(b) {
                a.onContainerTouchStart(b)
            }, b.ontouchmove = function(b) {
                a.onContainerTouchMove(b)
            }, 1 === Nb && wc(lb, "touchend", a.onDocumentTouchEnd))
        },
        destroy: function() {
            var a;
            xc(this.chart.container, "mouseleave", this.onContainerMouseLeave), Nb || (xc(lb, "mouseup", this.onDocumentMouseUp), xc(lb, "touchend", this.onDocumentTouchEnd)), clearInterval(this.tooltipTimeout);
            for (a in this)
                this[a] = null
        }
    }, a(mc.Pointer.prototype, {
        pinchTranslate: function(a, b, c, d, e, f) {
            (this.zoomHor || this.pinchHor) && this.pinchTranslateDirection(!0, a, b, c, d, e, f), (this.zoomVert || this.pinchVert) && this.pinchTranslateDirection(!1, a, b, c, d, e, f)
        },
        pinchTranslateDirection: function(a, b, c, d, e, f, g, h) {
            var i, j, k, l, m, n, o = this.chart, p = a ? "x": "y", q = a ? "X": "Y", r = "chart" + q, s = a ? "width": "height", t = o["plot" + (a ? "Left" : "Top")], u = h || 1, v = o.inverted, w = o.bounds[a ? "h": "v"], x = 1 === b.length, y = b[0][r], z = c[0][r], A=!x && b[1][r], B=!x && c[1][r], C = function() {
                !x && tb(y - A) > 20 && (u = h || tb(z - B) / tb(y - A)), k = (t - z) / u + y, i = o["plot" + (a ? "Width" : "Height")] / u
            };
            C(), j = k, j < w.min ? (j = w.min, l=!0) : j + i > w.max && (j = w.max - i, l=!0), l ? (z -= .8 * (z - g[p][0]), x || (B -= .8 * (B - g[p][1])), C()) : g[p] = [z, B], v || (f[p] = k - t, f[s] = i), n = v ? a ? "scaleY" : "scaleX" : "scale" + q, m = v ? 1 / u : u, e[s] = i, e[p] = j, d[n] = u, d["translate" + q] = m * t + (z - m * y)
        },
        pinch: function(b) {
            var c = this, d = c.chart, e = c.pinchDown, f = c.followTouchMove, g = b.touches, h = g.length, i = c.lastValidTouch, j = c.hasZoom, k = c.selectionMarker, l = {}, m = 1 === h && (c.inClass(b.target, Ub + "tracker") && d.runTrackerClick || d.runChartClick), n = {};
            !j&&!f || m || b.preventDefault(), vc(g, function(a) {
                return c.normalize(a)
            }), "touchstart" === b.type ? (sc(g, function(a, b) {
                e[b] = {
                    chartX: a.chartX,
                    chartY: a.chartY
                }
            }), i.x = [e[0].chartX, e[1] && e[1].chartX], i.y = [e[0].chartY, e[1] && e[1].chartY], sc(d.axes, function(a) {
                if (a.zoomEnabled) {
                    var b = d.bounds[a.horiz ? "h": "v"], c = a.minPixelPadding, e = a.toPixels(a.dataMin), f = a.toPixels(a.dataMax), g = sb(e, f), h = rb(e, f);
                    b.min = sb(a.pos, g - c), b.max = rb(a.pos + a.len, h + c)
                }
            })) : e.length && (k || (c.selectionMarker = k = a({
                destroy: Lb
            }, d.plotBox)), c.pinchTranslate(e, g, l, k, n, i), c.hasPinched = j, c.scaleGroups(l, n), !j && f && 1 === h && this.runPointActions(c.normalize(b)))
        },
        onContainerTouchStart: function(a) {
            var b = this.chart;
            Qc = b.index, 1 === a.touches.length ? (a = this.normalize(a), b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) ? (this.runPointActions(a), this.pinch(a)) : this.reset()) : 2 === a.touches.length && this.pinch(a)
        },
        onContainerTouchMove: function(a) {
            (1 === a.touches.length || 2 === a.touches.length) && this.pinch(a)
        },
        onDocumentTouchEnd: function(a) {
            Mb[Qc] && Mb[Qc].pointer.drop(a)
        }
    }), mb.PointerEvent || mb.MSPointerEvent) {
        var Sc = {}, Tc=!!mb.PointerEvent, Uc = function() {
            var a, b = [];
            b.item = function(a) {
                return this[a]
            };
            for (a in Sc)
                Sc.hasOwnProperty(a) && b.push({
                    pageX: Sc[a].pageX,
                    pageY: Sc[a].pageY,
                    target: Sc[a].target
                });
            return b
        }, Vc = function(a, b, c, d) {
            var e;
            a = a.originalEvent || a, "touch" !== a.pointerType && a.pointerType !== a.MSPOINTER_TYPE_TOUCH ||!Mb[Qc] || (d(a), e = Mb[Qc].pointer, e[b]({
                type: c,
                target: a.currentTarget,
                preventDefault: Lb,
                touches: Uc()
            }))
        };
        a(Rc.prototype, {
            onContainerPointerDown: function(a) {
                Vc(a, "onContainerTouchStart", "touchstart", function(a) {
                    Sc[a.pointerId] = {
                        pageX: a.pageX,
                        pageY: a.pageY,
                        target: a.currentTarget
                    }
                })
            },
            onContainerPointerMove: function(a) {
                Vc(a, "onContainerTouchMove", "touchmove", function(a) {
                    Sc[a.pointerId] = {
                        pageX: a.pageX,
                        pageY: a.pageY
                    }, Sc[a.pointerId].target || (Sc[a.pointerId].target = a.currentTarget)
                })
            },
            onDocumentPointerUp: function(a) {
                Vc(a, "onContainerTouchEnd", "touchend", function(a) {
                    delete Sc[a.pointerId]
                })
            },
            batchMSEvents: function(a) {
                a(this.chart.container, Tc ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown), a(this.chart.container, Tc ? "pointermove" : "MSPointerMove", this.onContainerPointerMove), a(lb, Tc ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp)
            }
        }), u(Rc.prototype, "init", function(a, b, c) {
            a.call(this, b, c), (this.hasZoom || this.followTouchMove) && p(b.container, {
                "-ms-touch-action": Xb,
                "touch-action": Xb
            })
        }), u(Rc.prototype, "setDOMEvents", function(a) {
            a.apply(this), (this.hasZoom || this.followTouchMove) && this.batchMSEvents(wc)
        }), u(Rc.prototype, "destroy", function(a) {
            this.batchMSEvents(xc), a.call(this)
        })
    }
    var Wc = mc.Legend = function(a, b) {
        this.init(a, b)
    };
    Wc.prototype = {
        init: function(a, c) {
            var e = this, f = c.itemStyle, g = o(c.padding, 8), h = c.itemMarginTop || 0;
            this.options = c, c.enabled && (e.baseline = d(f.fontSize) + 3 + h, e.itemStyle = f, e.itemHiddenStyle = b(f, c.itemHiddenStyle), e.itemMarginTop = h, e.padding = g, e.initialItemX = g, e.initialItemY = g - 5, e.maxItemWidth = 0, e.chart = a, e.itemHeight = 0, e.lastLineHeight = 0, e.symbolWidth = o(c.symbolWidth, 16), e.pages = [], e.render(), wc(e.chart, "endResize", function() {
                e.positionCheckboxes()
            }))
        },
        colorizeItem: function(a, b) {
            var c, d, e = this, f = e.options, g = a.legendItem, h = a.legendLine, i = a.legendSymbol, j = e.itemHiddenStyle.color, k = b ? f.itemStyle.color: j, l = b ? a.legendColor || a.color || "#CCC": j, m = a.options && a.options.marker, n = {
                fill: l
            };
            if (g && g.css({
                fill: k,
                color: k
            }), h && h.attr({
                stroke: l
            }), i) {
                if (m && i.isMarker) {
                    n.stroke = l, m = a.convertAttribs(m);
                    for (c in m)
                        d = m[c], d !== Q && (n[c] = d)
                    }
                i.attr(n)
            }
        },
        positionItem: function(a) {
            var b = this, c = b.options, d = c.symbolPadding, e=!c.rtl, f = a._legendItemPos, g = f[0], h = f[1], i = a.checkbox;
            a.legendGroup && a.legendGroup.translate(e ? g : b.legendWidth - g - 2 * d - 4, h), i && (i.x = g, i.y = h)
        },
        destroyItem: function(a) {
            var b = a.checkbox;
            sc(["legendItem", "legendLine", "legendSymbol", "legendGroup"], function(b) {
                a[b] && (a[b] = a[b].destroy())
            }), b && E(a.checkbox)
        },
        destroy: function() {
            var a = this, b = a.group, c = a.box;
            c && (a.box = c.destroy()), b && (a.group = b.destroy())
        },
        positionCheckboxes: function(a) {
            var b, c = this.group.alignAttr, d = this.clipHeight || this.legendHeight;
            c && (b = c.translateY, sc(this.allItems, function(e) {
                var f, g = e.checkbox;
                g && (f = b + g.y + (a || 0) + 3, p(g, {
                    left: c.translateX + e.checkboxOffset + g.x - 20 + Wb,
                    top: f + Wb,
                    display: f > b - 6 && b + d - 6 > f ? "": Xb
                }))
            }))
        },
        renderTitle: function() {
            var a, b = this.options, c = this.padding, d = b.title, e = 0;
            d.text && (this.title || (this.title = this.chart.renderer.label(d.text, c - 3, c - 4, null, null, null, null, null, "legend-title").attr({
                zIndex: 1
            }).css(d.style).add(this.group)), a = this.title.getBBox(), e = a.height, this.offsetWidth = a.width, this.contentGroup.attr({
                translateY: e
            })), this.titleHeight = e
        },
        renderItem: function(a) {
            var c, d, e, f = this, g = f.chart, h = g.renderer, i = f.options, j = "horizontal" === i.layout, k = f.symbolWidth, l = i.symbolPadding, m = f.itemStyle, n = f.itemHiddenStyle, p = f.padding, q = j ? o(i.itemDistance, 20): 0, r=!i.rtl, s = i.width, t = i.itemMarginBottom || 0, u = f.itemMarginTop, v = f.initialItemX, x = a.legendItem, y = a.series && a.series.drawLegendSymbol ? a.series : a, z = y.options, A = f.createCheckboxForItem && z && z.showCheckbox, B = i.useHTML;
            x || (a.legendGroup = h.g("legend-item").attr({
                zIndex: 1
            }).add(f.scrollGroup), y.drawLegendSymbol(f, a), a.legendItem = x = h.text(i.labelFormat ? w(i.labelFormat, a) : i.labelFormatter.call(a), r ? k + l : - l, f.baseline, B).css(b(a.visible ? m : n)).attr({
                align: r ? "left": "right",
                zIndex: 2
            }).add(a.legendGroup), f.setItemEvents && f.setItemEvents(a, x, B, m, n), f.colorizeItem(a, a.visible), A && f.createCheckboxForItem(a)), d = x.getBBox(), e = a.checkboxOffset = i.itemWidth || a.legendItemWidth || k + l + d.width + q + (A ? 20 : 0), f.itemHeight = c = ob(a.legendItemHeight || d.height), j && f.itemX - v + e > (s || g.chartWidth - 2 * p - v - i.x) && (f.itemX = v, f.itemY += u + f.lastLineHeight + t, f.lastLineHeight = 0), f.maxItemWidth = rb(f.maxItemWidth, e), f.lastItemY = u + f.itemY + t, f.lastLineHeight = rb(c, f.lastLineHeight), a._legendItemPos = [f.itemX, f.itemY], j ? f.itemX += e : (f.itemY += u + c + t, f.lastLineHeight = c), f.offsetWidth = s || rb((j ? f.itemX - v - q : e) + p, f.offsetWidth)
        },
        getAllItems: function() {
            var a = [];
            return sc(this.chart.series, function(b) {
                var c = b.options;
                o(c.showInLegend, l(c.linkedTo)?!1 : Q, !0) && (a = a.concat(b.legendItems || ("point" === c.legendType ? b.data : b)))
            }), a
        },
        render: function() {
            var b, c, d, e, f = this, g = f.chart, h = g.renderer, i = f.group, j = f.box, k = f.options, l = f.padding, m = k.borderWidth, n = k.backgroundColor;
            f.itemX = f.initialItemX, f.itemY = f.initialItemY, f.offsetWidth = 0, f.lastItemY = 0, i || (f.group = i = h.g("legend").attr({
                zIndex: 7
            }).add(), f.contentGroup = h.g().attr({
                zIndex: 1
            }).add(i), f.scrollGroup = h.g().add(f.contentGroup)), f.renderTitle(), b = f.getAllItems(), A(b, function(a, b) {
                return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0)
            }), k.reversed && b.reverse(), f.allItems = b, f.display = c=!!b.length, sc(b, function(a) {
                f.renderItem(a)
            }), d = k.width || f.offsetWidth, e = f.lastItemY + f.lastLineHeight + f.titleHeight, e = f.handleOverflow(e), (m || n) && (d += l, e += l, j ? d > 0 && e > 0 && (j[j.isNew ? "attr": "animate"](j.crisp({
                width: d,
                height: e
            })), j.isNew=!1) : (f.box = j = h.rect(0, 0, d, e, k.borderRadius, m || 0).attr({
                stroke: k.borderColor,
                "stroke-width": m || 0,
                fill: n || Xb
            }).add(i).shadow(k.shadow), j.isNew=!0), j[c ? "show": "hide"]()), f.legendWidth = d, f.legendHeight = e, sc(b, function(a) {
                f.positionItem(a)
            }), c && i.align(a({
                width: d,
                height: e
            }, k), !0, "spacingBox"), g.isResizing || this.positionCheckboxes()
        },
        handleOverflow: function(a) {
            var b, c, d = this, e = this.chart, f = e.renderer, g = this.options, h = g.y, i = "top" === g.verticalAlign, j = e.spacingBox.height + (i?-h : h) - this.padding, k = g.maxHeight, l = this.clipRect, m = g.navigation, n = o(m.animation, !0), p = m.arrowSize || 12, q = this.nav, r = this.pages, s = this.allItems;
            return "horizontal" === g.layout && (j/=2), k && (j = sb(j, k)), r.length = 0, a > j&&!g.useHTML ? (this.clipHeight = b = j - 20 - this.titleHeight - this.padding, this.currentPage = o(this.currentPage, 1), this.fullHeight = a, sc(s, function(a, d) {
                var e = a._legendItemPos[1], f = ob(a.legendItem.getBBox().height), g = r.length;
                (!g || e - r[g - 1] > b && (c || e) !== r[g - 1]) && (r.push(c || e), g++), d === s.length - 1 && e + f - r[g - 1] > b && r.push(e), e !== c && (c = e)
            }), l || (l = d.clipRect = f.clipRect(0, this.padding, 9999, 0), d.contentGroup.clip(l)), l.attr({
                height: b
            }), q || (this.nav = q = f.g().attr({
                zIndex: 1
            }).add(this.group), this.up = f.symbol("triangle", 0, 0, p, p).on("click", function() {
                d.scroll( - 1, n)
            }).add(q), this.pager = f.text("", 15, 10).css(m.style).add(q), this.down = f.symbol("triangle-down", 0, 0, p, p).on("click", function() {
                d.scroll(1, n)
            }).add(q)), d.scroll(0), a = j) : q && (l.attr({
                height: e.chartHeight
            }), q.hide(), this.scrollGroup.attr({
                translateY: 1
            }), this.clipHeight = 0), a
        },
        scroll: function(a, b) {
            var c, d = this.pages, e = d.length, f = this.currentPage + a, g = this.clipHeight, h = this.options.navigation, i = h.activeColor, j = h.inactiveColor, k = this.pager, l = this.padding;
            f > e && (f = e), f > 0 && (b !== Q && H(b, this.chart), this.nav.attr({
                translateX: l,
                translateY: g + this.padding + 7 + this.titleHeight,
                visibility: Vb
            }), this.up.attr({
                fill: 1 === f ? j: i
            }).css({
                cursor: 1 === f ? "default": "pointer"
            }), k.attr({
                text: f + "/" + e
            }), this.down.attr({
                x: 18 + this.pager.getBBox().width,
                fill: f === e ? j: i
            }).css({
                cursor: f === e ? "default": "pointer"
            }), c =- d[f - 1] + this.initialItemY, this.scrollGroup.animate({
                translateY: c
            }), this.currentPage = f, this.positionCheckboxes(c))
        }
    };
    var Xc = mc.LegendSymbolMixin = {
        drawRectangle: function(a, b) {
            var c = a.options.symbolHeight || 12;
            b.legendSymbol = this.chart.renderer.rect(0, a.baseline - 5 - c / 2, a.symbolWidth, c, a.options.symbolRadius || 0).attr({
                zIndex: 3
            }).add(b.legendGroup)
        },
        drawLineMarker: function(a) {
            var b, c, d, e = this.options, f = e.marker, g = a.options, h = a.symbolWidth, i = this.chart.renderer, j = this.legendGroup, k = a.baseline - ob(.3 * i.fontMetrics(g.itemStyle.fontSize).b);
            e.lineWidth && (d = {
                "stroke-width": e.lineWidth
            }, e.dashStyle && (d.dashstyle = e.dashStyle), this.legendLine = i.path([Yb, 0, k, Zb, h, k]).attr(d).add(j)), f && f.enabled!==!1 && (b = f.radius, this.legendSymbol = c = i.symbol(this.symbol, h / 2 - b, k - b, 2 * b, 2 * b).add(j), c.isMarker=!0)
        }
    };
    (/Trident\/7\.0/.test(yb) || Db) && u(Wc.prototype, "positionItem", function(a, b) {
        var c = this, d = function() {
            b._legendItemPos && a.call(c, b)
        };
        d(), setTimeout(d)
    }), O.prototype = {
        init: function(a, c) {
            var d, e = a.series;
            a.series = null, d = b(U, a), d.series = a.series = e, this.userOptions = a;
            var f = d.chart;
            this.margin = this.splashArray("margin", f), this.spacing = this.splashArray("spacing", f);
            var g = f.events;
            this.bounds = {
                h: {},
                v: {}
            }, this.callback = c, this.isResizing = 0, this.options = d, this.axes = [], this.series = [], this.hasCartesianSeries = f.showAxes;
            var h, i = this;
            if (i.index = Mb.length, Mb.push(i), Nb++, f.reflow!==!1 && wc(i, "load", function() {
                i.initReflow()
            }), g)
                for (h in g)
                    wc(i, h, g[h]);
            i.xAxis = [], i.yAxis = [], i.animation = Ib?!1 : o(f.animation, !0), i.pointCount = 0, i.counters = new z, i.firstRender()
        },
        initSeries: function(a) {
            var b, c = this, d = c.options.chart, e = a.type || d.type || d.defaultSeriesType, f = lc[e];
            return f || F(17, !0), b = new f, b.init(this, a), b
        },
        isInsidePlot: function(a, b, c) {
            var d = c ? b: a, e = c ? a: b;
            return d >= 0 && d <= this.plotWidth && e >= 0 && e <= this.plotHeight
        },
        adjustTickAmounts: function() {
            this.options.chart.alignTicks!==!1 && sc(this.axes, function(a) {
                a.adjustTickAmount()
            }), this.maxTicks = null
        },
        redraw: function(b) {
            var c, d, e, f = this, g = f.axes, h = f.series, i = f.pointer, j = f.legend, k = f.isDirtyLegend, l = f.isDirtyBox, m = h.length, n = m, o = f.renderer, p = o.isHidden(), q = [];
            for (H(b, f)
                , p && f.cloneRenderTo(), f.layOutTitles();
            n--;
            )if (e = h[n], e.options.stacking && (c=!0, e.isDirty)) {
                d=!0;
                break
            }
            if (d)
                for (n = m; n--;)
                    e = h[n], e.options.stacking && (e.isDirty=!0);
            sc(h, function(a) {
                a.isDirty && "point" === a.options.legendType && (k=!0)
            }), k && j.options.enabled && (j.render(), f.isDirtyLegend=!1), c && f.getStacks(), f.hasCartesianSeries && (f.isResizing || (f.maxTicks = null, sc(g, function(a) {
                a.setScale()
            })), f.adjustTickAmounts(), f.getMargins(), sc(g, function(a) {
                a.isDirty && (l=!0)
            }), sc(g, function(b) {
                b.isDirtyExtremes && (b.isDirtyExtremes=!1, q.push(function() {
                    yc(b, "afterSetExtremes", a(b.eventArgs, b.getExtremes())), delete b.eventArgs
                })), (l || c) && b.redraw()
            })), l && f.drawChartBox(), sc(h, function(a) {
                a.isDirty && a.visible && (!a.isCartesian || a.xAxis) && a.redraw()
            }), i && i.reset(!0), o.draw(), yc(f, "redraw"), p && f.cloneRenderTo(!0), sc(q, function(a) {
                a.call()
            })
        },
        get: function(a) {
            var b, c, d, e = this, f = e.axes, g = e.series;
            for (b = 0; b < f.length; b++)
                if (f[b].options.id === a)
                    return f[b];
            for (b = 0; b < g.length; b++)
                if (g[b].options.id === a)
                    return g[b];
            for (b = 0; b < g.length; b++)
                for (d = g[b].points || [], c = 0; c < d.length; c++)
                    if (d[c].id === a)
                        return d[c];
            return null
        },
        getAxes: function() {
            var a, b, c = this, d = this.options, e = d.xAxis = n(d.xAxis || {}), f = d.yAxis = n(d.yAxis || {});
            sc(e, function(a, b) {
                a.index = b, a.isX=!0
            }), sc(f, function(a, b) {
                a.index = b
            }), a = e.concat(f), sc(a, function(a) {
                b = new N(c, a)
            }), c.adjustTickAmounts()
        },
        getSelectedPoints: function() {
            var a = [];
            return sc(this.series, function(b) {
                a = a.concat(tc(b.points || [], function(a) {
                    return a.selected
                }))
            }), a
        },
        getSelectedSeries: function() {
            return tc(this.series, function(a) {
                return a.selected
            })
        },
        getStacks: function() {
            var a = this;
            sc(a.yAxis, function(a) {
                a.stacks && a.hasVisibleSeries && (a.oldStacks = a.stacks)
            }), sc(a.series, function(b) {
                !b.options.stacking || b.visible!==!0 && a.options.chart.ignoreHiddenSeries!==!1 || (b.stackKey = b.type + o(b.options.stack, ""))
            })
        },
        setTitle: function(a, c, d) {
            var e, f, g = this, h = g.options;
            e = h.title = b(h.title, a), f = h.subtitle = b(h.subtitle, c), sc([["title", a, e], ["subtitle", c, f]], function(a) {
                var b = a[0], c = g[b], d = a[1], e = a[2];
                c && d && (g[b] = c = c.destroy()), e && e.text&&!c && (g[b] = g.renderer.text(e.text, 0, 0, e.useHTML).attr({
                    align: e.align,
                    "class": Ub + b,
                    zIndex: e.zIndex || 4
                }).css(e.style).add())
            }), g.layOutTitles(d)
        },
        layOutTitles: function(b) {
            var c, d = 0, e = this.title, f = this.subtitle, g = this.options, h = g.title, i = g.subtitle, j = this.spacingBox.width - 44;
            e && (e.css({
                width: (h.width || j) + Wb
            }).align(a({
                y: 15
            }, h), !1, "spacingBox"), h.floating || h.verticalAlign || (d = e.getBBox().height)), f && (f.css({
                width: (i.width || j) + Wb
            }).align(a({
                y: d + h.margin
            }, i), !1, "spacingBox"), i.floating || i.verticalAlign || (d = qb(d + f.getBBox().height))), c = this.titleOffset !== d, this.titleOffset = d, !this.isDirtyBox && c && (this.isDirtyBox = c, this.hasRendered && o(b, !0) && this.isDirtyBox && this.redraw())
        },
        getChartSize: function() {
            var a = this, b = a.options.chart, c = b.width, d = b.height, e = a.renderToClone || a.renderTo;
            l(c) || (a.containerWidth = pc(e, "width")), l(d) || (a.containerHeight = pc(e, "height")), a.chartWidth = rb(0, c || a.containerWidth || 600), a.chartHeight = rb(0, o(d, a.containerHeight > 19 ? a.containerHeight : 400))
        },
        cloneRenderTo: function(a) {
            var b = this.renderToClone, c = this.container;
            a ? b && (this.renderTo.appendChild(c), E(b), delete this.renderToClone) : (c && c.parentNode === this.renderTo && this.renderTo.removeChild(c), this.renderToClone = b = this.renderTo.cloneNode(0), p(b, {
                position: Rb,
                top: "-9999px",
                display: "block"
            }), b.style.setProperty && b.style.setProperty("display", "block", "important"), lb.body.appendChild(b), c && b.appendChild(c))
        },
        getContainer: function() {
            var b, c, f, g, h, i, j = this, k = j.options.chart, l = "data-highcharts-chart";
            j.renderTo = g = k.renderTo, i = Ub + Kb++, e(g) && (j.renderTo = g = lb.getElementById(g)), g || F(13, !0), h = d(m(g, l)), !isNaN(h) && Mb[h] && Mb[h].hasRendered && Mb[h].destroy(), m(g, l, j.index), g.innerHTML = "", k.skipClone || g.offsetWidth || j.cloneRenderTo(), j.getChartSize(), c = j.chartWidth, f = j.chartHeight, j.container = b = q(Qb, {
                className: Ub + "container" + (k.className ? " " + k.className : ""),
                id: i
            }, a({
                position: Sb,
                overflow: Tb,
                width: c + Wb,
                height: f + Wb,
                textAlign: "left",
                lineHeight: "normal",
                zIndex: 0,
                "-webkit-tap-highlight-color": "rgba(0,0,0,0)"
            }, k.style), j.renderToClone || g), j._cursor = b.style.cursor, j.renderer = k.forExport ? new Jc(b, c, f, k.style, !0) : new R(b, c, f, k.style), Ib && j.renderer.create(j, b, c, f)
        },
        getMargins: function() {
            var a, b = this, c = b.spacing, d = b.legend, e = b.margin, f = b.options.legend, g = o(f.margin, 20), h = f.x, i = f.y, j = f.align, k = f.verticalAlign, m = b.titleOffset;
            b.resetMargins(), a = b.axisOffset, m&&!l(e[0]) && (b.plotTop = rb(b.plotTop, m + b.options.title.margin + c[0])), d.display&&!f.floating && ("right" === j ? l(e[1]) || (b.marginRight = rb(b.marginRight, d.legendWidth - h + g + c[1])) : "left" === j ? l(e[3]) || (b.plotLeft = rb(b.plotLeft, d.legendWidth + h + g + c[3])) : "top" === k ? l(e[0]) || (b.plotTop = rb(b.plotTop, d.legendHeight + i + g + c[0])) : "bottom" === k && (l(e[2]) || (b.marginBottom = rb(b.marginBottom, d.legendHeight - i + g + c[2])))), b.extraBottomMargin && (b.marginBottom += b.extraBottomMargin), b.extraTopMargin && (b.plotTop += b.extraTopMargin), b.hasCartesianSeries && sc(b.axes, function(a) {
                a.getOffset()
            }), l(e[3]) || (b.plotLeft += a[3]), l(e[0]) || (b.plotTop += a[0]), l(e[2]) || (b.marginBottom += a[2]), l(e[1]) || (b.marginRight += a[1]), b.setChartSize()
        },
        reflow: function(a) {
            var b = this, c = b.options.chart, d = b.renderTo, e = c.width || pc(d, "width"), f = c.height || pc(d, "height"), g = a ? a.target: mb, h = function() {
                b.container && (b.setSize(e, f, !1), b.hasUserSize = null)
            };
            b.hasUserSize ||!e ||!f || g !== mb && g !== lb || ((e !== b.containerWidth || f !== b.containerHeight) && (clearTimeout(b.reflowTimeout), a ? b.reflowTimeout = setTimeout(h, 100) : h()), b.containerWidth = e, b.containerHeight = f)
        },
        initReflow: function() {
            var a = this, b = function(b) {
                a.reflow(b)
            };
            wc(mb, "resize", b), wc(a, "destroy", function() {
                xc(mb, "resize", b)
            })
        },
        setSize: function(a, b, c) {
            var d, e, f, g = this;
            g.isResizing += 1, f = function() {
                g && yc(g, "endResize", null, function() {
                    g.isResizing -= 1
                })
            }, H(c, g), g.oldChartHeight = g.chartHeight, g.oldChartWidth = g.chartWidth, l(a) && (g.chartWidth = d = rb(0, ob(a)), g.hasUserSize=!!d), l(b) && (g.chartHeight = e = rb(0, ob(b))), (W ? Ac : p)(g.container, {
                width: d + Wb,
                height: e + Wb
            }, W), g.setChartSize(!0), g.renderer.setSize(d, e, c), g.maxTicks = null, sc(g.axes, function(a) {
                a.isDirty=!0, a.setScale()
            }), sc(g.series, function(a) {
                a.isDirty=!0
            }), g.isDirtyLegend=!0, g.isDirtyBox=!0, g.layOutTitles(), g.getMargins(), g.redraw(c), g.oldChartHeight = null, yc(g, "resize"), W===!1 ? f() : setTimeout(f, W && W.duration || 500)
        },
        setChartSize: function(a) {
            var b, c, d, e, f, g, h, i = this, j = i.inverted, k = i.renderer, l = i.chartWidth, m = i.chartHeight, n = i.options.chart, o = i.spacing, p = i.clipOffset;
            i.plotLeft = d = ob(i.plotLeft), i.plotTop = e = ob(i.plotTop), i.plotWidth = f = rb(0, ob(l - d - i.marginRight)), i.plotHeight = g = rb(0, ob(m - e - i.marginBottom)), i.plotSizeX = j ? g : f, i.plotSizeY = j ? f : g, i.plotBorderWidth = n.plotBorderWidth || 0, i.spacingBox = k.spacingBox = {
                x: o[3],
                y: o[0],
                width: l - o[3] - o[1],
                height: m - o[0] - o[2]
            }, i.plotBox = k.plotBox = {
                x: d,
                y: e,
                width: f,
                height: g
            }, h = 2 * pb(i.plotBorderWidth / 2), b = qb(rb(h, p[3]) / 2), c = qb(rb(h, p[0]) / 2), i.clipBox = {
                x: b,
                y: c,
                width: pb(i.plotSizeX - rb(h, p[1]) / 2 - b),
                height: pb(i.plotSizeY - rb(h, p[2]) / 2 - c)
            }, a || sc(i.axes, function(a) {
                a.setAxisSize(), a.setAxisTranslation()
            })
        },
        resetMargins: function() {
            var a = this, b = a.spacing, c = a.margin;
            a.plotTop = o(c[0], b[0]), a.marginRight = o(c[1], b[1]), a.marginBottom = o(c[2], b[2]), a.plotLeft = o(c[3], b[3]), a.axisOffset = [0, 0, 0, 0], a.clipOffset = [0, 0, 0, 0]
        },
        drawChartBox: function() {
            var a, b, c = this, d = c.options.chart, e = c.renderer, f = c.chartWidth, g = c.chartHeight, h = c.chartBackground, i = c.plotBackground, j = c.plotBorder, k = c.plotBGImage, l = d.borderWidth || 0, m = d.backgroundColor, n = d.plotBackgroundColor, o = d.plotBackgroundImage, p = d.plotBorderWidth || 0, q = c.plotLeft, r = c.plotTop, s = c.plotWidth, t = c.plotHeight, u = c.plotBox, v = c.clipRect, w = c.clipBox;
            a = l + (d.shadow ? 8 : 0), (l || m) && (h ? h.animate(h.crisp({
                width: f - a,
                height: g - a
            })) : (b = {
                fill: m || Xb
            }, l && (b.stroke = d.borderColor, b["stroke-width"] = l), c.chartBackground = e.rect(a / 2, a / 2, f - a, g - a, d.borderRadius, l).attr(b).addClass(Ub + "background").add().shadow(d.shadow))), n && (i ? i.animate(u) : c.plotBackground = e.rect(q, r, s, t, 0).attr({
                fill: n
            }).add().shadow(d.plotShadow)), o && (k ? k.animate(u) : c.plotBGImage = e.image(o, q, r, s, t).add()), v ? v.animate({
                width: w.width,
                height: w.height
            }) : c.clipRect = e.clipRect(w), p && (j ? j.animate(j.crisp({
                x: q,
                y: r,
                width: s,
                height: t
            })) : c.plotBorder = e.rect(q, r, s, t, 0, - p).attr({
                stroke: d.plotBorderColor,
                "stroke-width": p,
                fill: Xb,
                zIndex: 1
            }).add()), c.isDirtyBox=!1
        },
        propFromSeries: function() {
            var a, b, c, d = this, e = d.options.chart, f = d.options.series;
            sc(["inverted", "angular", "polar"], function(g) {
                for (a = lc[e.type || e.defaultSeriesType], c = d[g] || e[g] || a && a.prototype[g], b = f && f.length; !c && b--;)
                    a = lc[f[b].type], a && a.prototype[g] && (c=!0);
                d[g] = c
            })
        },
        linkSeries: function() {
            var a = this, b = a.series;
            sc(b, function(a) {
                a.linkedSeries.length = 0
            }), sc(b, function(b) {
                var c = b.options.linkedTo;
                e(c) && (c = ":previous" === c ? a.series[b.index - 1] : a.get(c), c && (c.linkedSeries.push(b), b.linkedParent = c))
            })
        },
        renderSeries: function() {
            sc(this.series, function(a) {
                a.translate(), a.setTooltipPoints && a.setTooltipPoints(), a.render()
            })
        },
        render: function() {
            var b, c = this, e = c.axes, f = c.renderer, g = c.options, h = g.labels, i = g.credits;
            c.setTitle(), c.legend = new Wc(c, g.legend), c.getStacks(), sc(e, function(a) {
                a.setScale()
            }), c.getMargins(), c.maxTicks = null, sc(e, function(a) {
                a.setTickPositions(!0), a.setMaxTicks()
            }), c.adjustTickAmounts(), c.getMargins(), c.drawChartBox(), c.hasCartesianSeries && sc(e, function(a) {
                a.render()
            }), c.seriesGroup || (c.seriesGroup = f.g("series-group").attr({
                zIndex: 3
            }).add()), c.renderSeries(), h.items && sc(h.items, function(b) {
                var e = a(h.style, b.style), g = d(e.left) + c.plotLeft, i = d(e.top) + c.plotTop + 12;
                delete e.left, delete e.top, f.text(b.html, g, i).attr({
                    zIndex: 2
                }).css(e).add()
            }), i.enabled&&!c.credits && (b = i.href, c.credits = f.text(i.text, 0, 0).on("click", function() {
                b && (location.href = b)
            }).attr({
                align: i.position.align,
                zIndex: 8
            }).css(i.style).add().align(i.position)), c.hasRendered=!0
        },
        destroy: function() {
            var a, b = this, c = b.axes, d = b.series, e = b.container, f = e && e.parentNode;
            for (yc(b, "destroy")
                , Mb[b.index] = Q, Nb--, b.renderTo.removeAttribute("data-highcharts-chart"), xc(b), a = c.length;
            a--;
            )c[a] = c[a].destroy();
            for (a = d.length; a--;)
                d[a] = d[a].destroy();
            sc(["title", "subtitle", "chartBackground", "plotBackground", "plotBGImage", "plotBorder", "seriesGroup", "clipRect", "credits", "pointer", "scroller", "rangeSelector", "legend", "resetZoomButton", "tooltip", "renderer"], function(a) {
                var c = b[a];
                c && c.destroy && (b[a] = c.destroy())
            }), e && (e.innerHTML = "", xc(e), f && E(e));
            for (a in b)
                delete b[a]
        },
        isReadyToRender: function() {
            var a = this;
            return !Gb && mb == mb.top && "complete" !== lb.readyState || Ib&&!mb.canvg ? (Ib ? Oc.push(function() {
                a.firstRender()
            }, a.options.global.canvasToolsURL) : lb.attachEvent("onreadystatechange", function() {
                lb.detachEvent("onreadystatechange", a.firstRender), "complete" === lb.readyState && a.firstRender()
            }), !1) : !0
        },
        firstRender: function() {
            var a = this, b = a.options, c = a.callback;
            a.isReadyToRender() && (a.getContainer(), yc(a, "init"), a.resetMargins(), a.setChartSize(), a.propFromSeries(), a.getAxes(), sc(b.series || [], function(b) {
                a.initSeries(b)
            }), a.linkSeries(), yc(a, "beforeRender"), mc.Pointer && (a.pointer = new Rc(a, b)), a.render(), a.renderer.draw(), c && c.apply(a, [a]), sc(a.callbacks, function(b) {
                b.apply(a, [a])
            }), a.cloneRenderTo(!0), yc(a, "load"))
        },
        splashArray: function(a, b) {
            var c = b[a], d = f(c) ? c: [c, c, c, c];
            return [o(b[a + "Top"], d[0]), o(b[a + "Right"], d[1]), o(b[a + "Bottom"], d[2]), o(b[a + "Left"], d[3])]
        }
    }, O.prototype.callbacks = [];
    var Yc = mc.CenteredSeriesMixin = {
        getCenter: function() {
            var a, b, c = this.options, e = this.chart, f = 2 * (c.slicedOffset || 0), g = e.plotWidth - 2 * f, h = e.plotHeight - 2 * f, i = c.center, j = [o(i[0], "50%"), o(i[1], "50%"), c.size || "100%", c.innerSize || 0], k = sb(g, h);
            return vc(j, function(c, e) {
                return b = /%$/.test(c), a = 2 > e || 2 === e && b, (b ? [g, h, k, k][e] * d(c) / 100 : c) + (a ? f : 0)
            })
        }
    }, Zc = function() {};
    Zc.prototype = {
        init: function(a, b, c) {
            var d, e = this;
            return e.series = a, e.applyOptions(b, c), e.pointAttr = {}, a.options.colorByPoint && (d = a.options.colors || a.chart.options.colors, e.color = e.color || d[a.colorCounter++], a.colorCounter === d.length && (a.colorCounter = 0)), a.chart.pointCount++, e
        },
        applyOptions: function(b, c) {
            var d = this, e = d.series, f = e.pointValKey;
            return b = Zc.prototype.optionsToObject.call(this, b), a(d, b), d.options = d.options ? a(d.options, b) : b, f && (d.y = d[f]), d.x === Q && e && (d.x = c === Q ? e.autoIncrement() : c), d
        },
        optionsToObject: function(a) {
            var b, c = {}, d = this.series, e = d.pointArrayMap || ["y"], f = e.length, h = 0, i = 0;
            if ("number" == typeof a || null === a)
                c[e[0]] = a;
            else if (g(a))
                for (a.length > f && (b = typeof a[0], "string" === b ? c.name = a[0] : "number" === b && (c.x = a[0]), h++); f > i;)
                    c[e[i++]] = a[h++];
            else 
                "object" == typeof a && (c = a, a.dataLabels && (d._hasPointLabels=!0), a.marker && (d._hasPointMarkers=!0));
            return c
        },
        destroy: function() {
            var a, b = this, c = b.series, d = c.chart, e = d.hoverPoints;
            d.pointCount--, e && (b.setState(), k(e, b), e.length || (d.hoverPoints = null)), b === d.hoverPoint && b.onMouseOut(), (b.graphic || b.dataLabel) && (xc(b), b.destroyElements()), b.legendItem && d.legend.destroyItem(b);
            for (a in b)
                b[a] = null
        },
        destroyElements: function() {
            for (var a, b = this, c = ["graphic", "dataLabel", "dataLabelUpper", "group", "connector", "shadowGroup"], d = 6; d--;)
                a = c[d], b[a] && (b[a] = b[a].destroy())
        },
        getLabelConfig: function() {
            var a = this;
            return {
                x: a.category,
                y: a.y,
                key: a.name || a.category,
                series: a.series,
                point: a,
                percentage: a.percentage,
                total: a.total || a.stackTotal
            }
        },
        tooltipFormatter: function(a) {
            var b = this.series, c = b.tooltipOptions, d = o(c.valueDecimals, ""), e = c.valuePrefix || "", f = c.valueSuffix || "";
            return sc(b.pointArrayMap || ["y"], function(b) {
                b = "{point." + b, (e || f) && (a = a.replace(b + "}", e + b + "}" + f)), a = a.replace(b + "}", b + ":,." + d + "f}")
            }), w(a, {
                point: this,
                series: this.series
            })
        },
        firePointEvent: function(a, b, c) {
            var d = this, e = this.series, f = e.options;
            (f.point.events[a] || d.options && d.options.events && d.options.events[a]) && this.importEvents(), "click" === a && f.allowPointSelect && (c = function(a) {
                d.select(null, a.ctrlKey || a.metaKey || a.shiftKey)
            }), yc(this, a, b, c)
        }
    };
    var $c = function() {};
    $c.prototype = {
        isCartesian: !0,
        type: "line",
        pointClass: Zc,
        sorted: !0,
        requireSorting: !0,
        pointAttrToOptions: {
            stroke: "lineColor",
            "stroke-width": "lineWidth",
            fill: "fillColor",
            r: "radius"
        },
        axisTypes: ["xAxis", "yAxis"],
        colorCounter: 0,
        parallelArrays: ["x", "y"],
        init: function(b, c) {
            var d, e, f = this, g = b.series, h = function(a, b) {
                return o(a.options.index, a._i) - o(b.options.index, b._i)
            };
            f.chart = b, f.options = c = f.setOptions(c), f.linkedSeries = [], f.bindAxes(), a(f, {
                name: c.name,
                state: _b,
                pointAttr: {},
                visible: c.visible!==!1,
                selected: c.selected===!0
            }), Ib && (c.animation=!1), e = c.events;
            for (d in e)
                wc(f, d, e[d]);
            (e && e.click || c.point && c.point.events && c.point.events.click || c.allowPointSelect) && (b.runTrackerClick=!0), f.getColor(), f.getSymbol(), sc(f.parallelArrays, function(a) {
                f[a + "Data"] = []
            }), f.setData(c.data, !1), f.isCartesian && (b.hasCartesianSeries=!0), g.push(f), f._i = g.length - 1, A(g, h), this.yAxis && A(this.yAxis.series, h), sc(g, function(a, b) {
                a.index = b, a.name = a.name || "Series " + (b + 1)
            })
        },
        bindAxes: function() {
            var a, b = this, c = b.options, d = b.chart;
            sc(b.axisTypes || [], function(e) {
                sc(d[e], function(d) {
                    a = d.options, (c[e] === a.index || c[e] !== Q && c[e] === a.id || c[e] === Q && 0 === a.index) && (d.series.push(b), b[e] = d, d.isDirty=!0)
                }), b[e] || b.optionalAxis === e || F(18, !0)
            })
        },
        updateParallelArrays: function(a, b) {
            var c = a.series, d = arguments, e = "number" == typeof b ? function(d) {
                var e = "y" === d && c.toYData ? c.toYData(a): a[d];
                c[d + "Data"][b] = e
            }
            : function(a) {
                Array.prototype[b].apply(c[a + "Data"], Array.prototype.slice.call(d, 2))
            };
            sc(c.parallelArrays, e)
        },
        autoIncrement: function() {
            var a = this, b = a.options, c = a.xIncrement;
            return c = o(c, b.pointStart, 0), a.pointInterval = o(a.pointInterval, b.pointInterval, 1), a.xIncrement = c + a.pointInterval, c
        },
        getSegments: function() {
            var a, b = this, c =- 1, d = [], e = b.points, f = e.length;
            if (f)
                if (b.options.connectNulls) {
                    for (a = f; a--;)
                        null === e[a].y && e.splice(a, 1);
                        e.length && (d = [e])
                } else 
                    sc(e, function(a, b) {
                        null === a.y ? (b > c + 1 && d.push(e.slice(c + 1, b)), c = b) : b === f - 1 && d.push(e.slice(c + 1, b + 1))
                    });
            b.segments = d
        },
        setOptions: function(a) {
            var c, d = this.chart, e = d.options, f = e.plotOptions, g = d.userOptions || {}, h = g.plotOptions || {}, i = f[this.type];
            return this.userOptions = a, c = b(i, f.series, a), this.tooltipOptions = b(U.tooltip, U.plotOptions[this.type].tooltip, g.tooltip, h.series && h.series.tooltip, h[this.type] && h[this.type].tooltip, a.tooltip), null === i.marker && delete c.marker, c
        },
        getColor: function() {
            var a, b, c = this.options, d = this.userOptions, e = this.chart.options.colors, f = this.chart.counters;
            a = c.color || Dc[this.type].color, a || c.colorByPoint || (l(d._colorIndex) ? b = d._colorIndex : (d._colorIndex = f.color, b = f.color++), a = e[b]), this.color = a, f.wrapColor(e.length)
        },
        getSymbol: function() {
            var a, b = this, c = b.userOptions, d = b.options.marker, e = b.chart, f = e.options.symbols, g = e.counters;
            b.symbol = d.symbol, b.symbol || (l(c._symbolIndex) ? a = c._symbolIndex : (c._symbolIndex = g.symbol, a = g.symbol++), b.symbol = f[a]), /^url/.test(b.symbol) && (d.radius = 0), g.wrapSymbol(f.length)
        },
        drawLegendSymbol: Xc.drawLineMarker,
        setData: function(a, b, c, d) {
            var f, i, j, k = this, l = k.points, m = l && l.length || 0, n = k.options, p = k.chart, q = null, r = k.xAxis, s = r&&!!r.categories, t = k.tooltipPoints, u = n.turboThreshold, v = this.xData, w = this.yData, x = k.pointArrayMap, y = x && x.length;
            if (a = a || [], f = a.length, b = o(b, !0), d===!1 ||!f || m !== f || k.cropped || k.hasGroupedData) {
                if (k.xIncrement = null, k.pointRange = s ? 1 : n.pointRange, k.colorCounter = 0, sc(this.parallelArrays, function(a) {
                    k[a + "Data"].length = 0
                }), u && f > u) {
                    for (i = 0; null === q && f > i;)
                        q = a[i], i++;
                    if (h(q)) {
                        var z = o(n.pointStart, 0), A = o(n.pointInterval, 1);
                        for (i = 0; f > i; i++)
                            v[i] = z, w[i] = a[i], z += A;
                        k.xIncrement = z
                    } else if (g(q))
                        if (y)
                            for (i = 0; f > i; i++)
                                j = a[i], v[i] = j[0], w[i] = j.slice(1, y + 1);
                        else 
                            for (i = 0; f > i; i++)
                                j = a[i], v[i] = j[0], w[i] = j[1];
                    else 
                        F(12)
                    } else 
                        for (i = 0; f > i; i++)
                            a[i] !== Q && (j = {
                                series: k
                            }, k.pointClass.prototype.applyOptions.apply(j, [a[i]]), k.updateParallelArrays(j, i), s && j.name && (r.names[j.x] = j.name));
                for (e(w[0]) 
                    && F(14, !0), k.data = [], k.options.data = a, i = m;
                i--;
                )l[i] && l[i].destroy && l[i].destroy();
                t && (t.length = 0), r && (r.minRange = r.userMinRange), k.isDirty = k.isDirtyData = p.isDirtyBox=!0, c=!1
            } else 
                sc(a, function(a, b) {
                    l[b].update(a, !1)
                });
            b && p.redraw(c)
        },
        processData: function(a) {
            var b, c, d, e, f, g, h, i = this, j = i.xData, k = i.yData, l = j.length, m = 0, n = i.xAxis, o = i.options, p = o.cropThreshold, q = 0, r = i.isCartesian;
            if (r&&!i.isDirty&&!n.isDirty&&!i.yAxis.isDirty&&!a)
                return !1;
            for (r && i.sorted && (!p || l > p || i.forceCrop) && (g = n.min, h = n.max, j[l - 1] < g || j[0] > h ? (j = [], k = []) : (j[0] < g || j[l - 1] > h) && (b = this.cropData(i.xData, i.yData, g, h), j = b.xData, k = b.yData, m = b.start, c=!0, q = j.length)), f = j.length - 1; f >= 0; f--)
                d = j[f] - j[f - 1], !c && j[f] > g && j[f] < h && q++, d > 0 && (e === Q || e > d) ? e = d : 0 > d && i.requireSorting && F(15);
            i.cropped = c, i.cropStart = m, i.processedXData = j, i.processedYData = k, i.activePointCount = q, null === o.pointRange && (i.pointRange = e || 1), i.closestPointRange = e
        },
        cropData: function(a, b, c, d) {
            var e, f = a.length, g = 0, h = f, i = o(this.cropShoulder, 1);
            for (e = 0; f > e; e++)
                if (a[e] >= c) {
                    g = rb(0, e - i);
                    break
                }
            for (; f > e; e++)
                if (a[e] > d) {
                    h = e + i;
                    break
                }
            return {
                xData: a.slice(g, h),
                yData: b.slice(g, h),
                start: g,
                end: h
            }
        },
        generatePoints: function() {
            var a, b, c, d, e = this, f = e.options, g = f.data, h = e.data, i = e.processedXData, j = e.processedYData, k = e.pointClass, l = i.length, m = e.cropStart || 0, o = e.hasGroupedData, p = [];
            if (!h&&!o) {
                var q = [];
                q.length = g.length, h = e.data = q
            }
            for (d = 0; l > d; d++)
                b = m + d, o ? p[d] = (new k).init(e, [i[d]].concat(n(j[d]))) : (h[b] ? c = h[b] : g[b] !== Q && (h[b] = c = (new k).init(e, g[b], i[d])), p[d] = c);
            if (h && (l !== (a = h.length) || o))
                for (d = 0; a > d; d++)
                    d !== m || o || (d += l), h[d] && (h[d].destroyElements(), h[d].plotX = Q);
            e.data = h, e.points = p
        },
        getExtremes: function(a) {
            var b, c, d, e, f, g, h, i, j, k = this.xAxis, l = this.yAxis, m = this.processedXData, n = [], p = 0, q = k.getExtremes(), r = q.min, s = q.max;
            for (a = a || this.stackedYData || this.processedYData, b = a.length, i = 0; b > i; i++)
                if (g = m[i], h = a[i], c = null !== h && h !== Q && (!l.isLog || h.length || h > 0), d = this.getExtremesFromAll || this.cropped || (m[i + 1] || g) >= r && (m[i - 1] || g) <= s, c && d)
                    if (j = h.length)
                        for (; j--;)
                            null !== h[j] && (n[p++] = h[j]);
                    else 
                        n[p++] = h;
            this.dataMin = o(e, B(n)), this.dataMax = o(f, C(n))
        },
        translate: function() {
            this.processedXData || this.processData(), this.generatePoints();
            var a, b = this, c = b.options, d = c.stacking, e = b.xAxis, f = e.categories, g = b.yAxis, i = b.points, j = i.length, k=!!b.modifyValue, m = c.pointPlacement, n = "between" === m || h(m), p = c.threshold;
            for (a = 0; j > a; a++) {
                var q, r, s = i[a], t = s.x, u = s.y, v = s.low, w = d && g.stacks[(b.negStacks && p > u ? "-" : "") + b.stackKey];
                g.isLog && 0 >= u && (s.y = u = null), s.plotX = e.translate(t, 0, 0, 0, 1, m, "flags" === this.type), d && b.visible && w && w[t] && (q = w[t], r = q.points[b.index + "," + a], v = r[0], u = r[1], 0 === v && (v = o(p, g.min)), g.isLog && 0 >= v && (v = null), s.total = s.stackTotal = q.total, s.percentage = q.total && s.y / q.total * 100, s.stackY = u, q.setOffset(b.pointXOffset || 0, b.barW || 0)), s.yBottom = l(v) ? g.translate(v, 0, 1, 0, 1) : null, k && (u = b.modifyValue(u, s)), s.plotY = "number" == typeof u && 1 / 0 !== u ? g.translate(u, 0, 1, 0, 1) : Q, s.clientX = n ? e.translate(t, 0, 0, 0, 1) : s.plotX, s.negative = s.y < (p || 0), s.category = f && f[s.x] !== Q ? f[s.x] : s.x
            }
            b.getSegments()
        },
        animate: function(b) {
            var c, d, e, g = this, h = g.chart, i = h.renderer, j = g.options.animation, k = g.clipBox || h.clipBox, l = h.inverted;
            j&&!f(j) && (j = Dc[g.type].animation), e = ["_sharedClip", j.duration, j.easing, k.height].join(","), b ? (c = h[e], d = h[e + "m"], c || (h[e] = c = i.clipRect(a(k, {
                width: 0
            })), h[e + "m"] = d = i.clipRect( - 99, l?-h.plotLeft : - h.plotTop, 99, l ? h.chartWidth : h.chartHeight)), g.group.clip(c), g.markerGroup.clip(d), g.sharedClipKey = e) : (c = h[e], c && c.animate({
                width: h.plotSizeX
            }, j), h[e + "m"] && h[e + "m"].animate({
                width: h.plotSizeX + 99
            }, j), g.animate = null)
        },
        afterAnimate: function() {
            var a = this.chart, b = this.sharedClipKey, c = this.group, d = this.clipBox;
            c && this.options.clip!==!1 && (b && d || c.clip(d ? a.renderer.clipRect(d) : a.clipRect), this.markerGroup.clip()), yc(this, "afterAnimate"), setTimeout(function() {
                b && a[b] && (d || (a[b] = a[b].destroy()), a[b + "m"] && (a[b + "m"] = a[b + "m"].destroy()))
            }, 100)
        },
        drawPoints: function() {
            var b, c, d, e, f, g, h, i, j, k, l, m, n = this, p = n.points, q = n.chart, r = n.options, s = r.marker, t = n.pointAttr[""], u = n.markerGroup, v = o(s.enabled, n.activePointCount < .5 * n.xAxis.len / s.radius);
            if (s.enabled!==!1 || n._hasPointMarkers)
                for (e = p.length; e--;)
                    f = p[e], c = pb(f.plotX), d = f.plotY, j = f.graphic, k = f.marker || {}, l = v && k.enabled === Q || k.enabled, m = q.isInsidePlot(ob(c), d, q.inverted), l && d !== Q&&!isNaN(d) && null !== f.y ? (b = f.pointAttr[f.selected ? bc: _b] || t, g = b.r, h = o(k.symbol, n.symbol), i = 0 === h.indexOf("url"), j ? j[m ? "show": "hide"](!0).animate(a({
                        x: c - g,
                        y: d - g
                    }, j.symbolName ? {
                        width: 2 * g,
                        height: 2 * g
                    } : {})) : m && (g > 0 || i) && (f.graphic = j = q.renderer.symbol(h, c - g, d - g, 2 * g, 2 * g).attr(b).add(u))) : j && (f.graphic = j.destroy())
        },
        convertAttribs: function(a, b, c, d) {
            var e, f, g = this.pointAttrToOptions, h = {};
            a = a || {}, b = b || {}, c = c || {}, d = d || {};
            for (e in g)
                f = g[e], h[e] = o(a[f], b[e], c[e], d[e]);
            return h
        },
        getAttribs: function() {
            var b, c, d, e, f, g, h = this, i = h.options, j = Dc[h.type].marker ? i.marker: i, k = j.states, m = k[ac], n = h.color, o = {
                stroke: n,
                fill: n
            }, p = h.points || [], q = [], r = h.pointAttrToOptions, s = h.hasPointSpecificOptions, t = i.negativeColor, u = j.lineColor, v = j.fillColor, w = i.turboThreshold;
            if (i.marker ? (m.radius = m.radius || j.radius + 2, m.lineWidth = m.lineWidth || j.lineWidth + 1) : m.color = m.color || Ic(m.color || n).brighten(m.brightness).get(), q[_b] = h.convertAttribs(j, o), sc([ac, bc], function(a) {
                q[a] = h.convertAttribs(k[a], q[_b])
            }), h.pointAttr = q, c = p.length, !w || w > c || s)
                for (; c--;) {
                    if (d = p[c], j = d.options && d.options.marker || d.options, j && j.enabled===!1 && (j.radius = 0), d.negative && t && (d.color = d.fillColor = t), s = i.colorByPoint || d.color, d.options)
                        for (g in r)
                            l(j[r[g]]) && (s=!0);
                            s ? (j = j || {}, e = [], k = j.states || {}, b = k[ac] = k[ac] || {}, i.marker || (b.color = b.color ||!d.options.color && m.color || Ic(d.color).brighten(b.brightness || m.brightness).get()), f = {
                                color: d.color
                            }, v || (f.fillColor = d.color), u || (f.lineColor = d.color), e[_b] = h.convertAttribs(a(f, j), q[_b]), e[ac] = h.convertAttribs(k[ac], q[ac], e[_b]), e[bc] = h.convertAttribs(k[bc], q[bc], e[_b])) : e = q, d.pointAttr = e
                }
        },
        destroy: function() {
            var a, b, c, d, e, f = this, g = f.chart, h = /AppleWebKit\/533/.test(yb), i = f.data || [];
            for (yc(f, "destroy")
                , xc(f), sc(f.axisTypes || [], function(a) {
                e = f[a], e && (k(e.series, f), e.isDirty = e.forceRedraw=!0)
            }), f.legendItem && f.chart.legend.destroyItem(f), b = i.length;
            b--;
            )c = i[b], c && c.destroy && c.destroy();
            f.points = null, clearTimeout(f.animationTimeout), sc(["area", "graph", "dataLabelsGroup", "group", "markerGroup", "tracker", "graphNeg", "areaNeg", "posClip", "negClip"], function(b) {
                f[b] && (a = h && "group" === b ? "hide" : "destroy", f[b][a]())
            }), g.hoverSeries === f && (g.hoverSeries = null), k(g.series, f);
            for (d in f)
                delete f[d]
        },
        getSegmentPath: function(a) {
            var b = this, c = [], d = b.options.step;
            return sc(a, function(e, f) {
                var g, h = e.plotX, i = e.plotY;
                b.getPointSpline ? c.push.apply(c, b.getPointSpline(a, e, f)) : (c.push(f ? Zb : Yb), d && f && (g = a[f - 1], "right" === d ? c.push(g.plotX, i) : "center" === d ? c.push((g.plotX + h) / 2, g.plotY, (g.plotX + h) / 2, i) : c.push(h, g.plotY)), c.push(e.plotX, e.plotY))
            }), c
        },
        getGraphPath: function() {
            var a, b = this, c = [], d = [];
            return sc(b.segments, function(e) {
                a = b.getSegmentPath(e), e.length > 1 ? c = c.concat(a) : d.push(e[0])
            }), b.singlePoints = d, b.graphPath = c, c
        },
        drawGraph: function() {
            var a = this, b = this.options, c = [["graph", b.lineColor || this.color]], d = b.lineWidth, e = b.dashStyle, f = "square" !== b.linecap, g = this.getGraphPath(), h = b.negativeColor;
            h && c.push(["graphNeg", h]), sc(c, function(c, h) {
                var i, j = c[0], k = a[j];
                k ? (Bc(k), k.animate({
                    d: g
                })) : d && g.length && (i = {
                    stroke: c[1],
                    "stroke-width": d,
                    fill: Xb,
                    zIndex: 1
                }, e ? i.dashstyle = e : f && (i["stroke-linecap"] = i["stroke-linejoin"] = "round"), a[j] = a.chart.renderer.path(g).attr(i).add(a.group).shadow(!h && b.shadow))
            })
        },
        clipNeg: function() {
            var a, b, c, d, e, f = this.options, g = this.chart, h = g.renderer, i = f.negativeColor || f.negativeFillColor, j = this.graph, k = this.area, l = this.posClip, m = this.negClip, n = g.chartWidth, o = g.chartHeight, p = rb(n, o), q = this.yAxis;
            i && (j || k) && (a = ob(q.toPixels(f.threshold || 0, !0)), 0 > a && (p -= a), d = {
                x: 0,
                y: 0,
                width: p,
                height: a
            }, e = {
                x: 0,
                y: a,
                width: p,
                height: p
            }, g.inverted && (d.height = e.y = g.plotWidth - a, h.isVML && (d = {
                x: g.plotWidth - a - g.plotLeft,
                y: 0,
                width: n,
                height: o
            }, e = {
                x: a + g.plotLeft - n,
                y: 0,
                width: g.plotLeft + a,
                height: n
            })), q.reversed ? (b = e, c = d) : (b = d, c = e), l ? (l.animate(b), m.animate(c)) : (this.posClip = l = h.clipRect(b), this.negClip = m = h.clipRect(c), j && this.graphNeg && (j.clip(l), this.graphNeg.clip(m)), k && (k.clip(l), this.areaNeg.clip(m))))
        },
        invertGroups: function() {
            function a() {
                var a = {
                    width: b.yAxis.len,
                    height: b.xAxis.len
                };
                sc(["group", "markerGroup"], function(c) {
                    b[c] && b[c].attr(a).invert()
                })
            }
            var b = this, c = b.chart;
            b.xAxis && (wc(c, "resize", a), wc(b, "destroy", function() {
                xc(c, "resize", a)
            }), a(), b.invertGroups = a)
        },
        plotGroup: function(a, b, c, d, e) {
            var f = this[a], g=!f;
            return g && (this[a] = f = this.chart.renderer.g(b).attr({
                visibility: c,
                zIndex: d || .1
            }).add(e)), f[g ? "attr": "animate"](this.getPlotBox()), f
        },
        getPlotBox: function() {
            var a = this.chart, b = this.xAxis, c = this.yAxis;
            return a.inverted && (b = c, c = this.xAxis), {
                translateX: b ? b.left: a.plotLeft,
                translateY: c ? c.top: a.plotTop,
                scaleX: 1,
                scaleY: 1
            }
        },
        render: function() {
            var a, b = this, c = b.chart, d = b.options, e = d.animation, f = e&&!!b.animate && c.renderer.isSVG && o(e.duration, 500) || 0, g = b.visible ? Vb: Tb, h = d.zIndex, i = b.hasRendered, j = c.seriesGroup;
            a = b.plotGroup("group", "series", g, h, j), b.markerGroup = b.plotGroup("markerGroup", "markers", g, h, j), f && b.animate(!0), b.getAttribs(), a.inverted = b.isCartesian ? c.inverted : !1, b.drawGraph && (b.drawGraph(), b.clipNeg()), b.drawDataLabels && b.drawDataLabels(), b.visible && b.drawPoints(), b.drawTracker && b.options.enableMouseTracking!==!1 && b.drawTracker(), c.inverted && b.invertGroups(), d.clip===!1 || b.sharedClipKey || i || a.clip(c.clipRect), f && b.animate(), i || (f ? b.animationTimeout = setTimeout(function() {
                b.afterAnimate()
            }, f) : b.afterAnimate()), b.isDirty = b.isDirtyData=!1, b.hasRendered=!0
        },
        redraw: function() {
            var a = this, b = a.chart, c = a.isDirtyData, d = a.group, e = a.xAxis, f = a.yAxis;
            d && (b.inverted && d.attr({
                width: b.plotWidth,
                height: b.plotHeight
            }), d.animate({
                translateX: o(e && e.left, b.plotLeft),
                translateY: o(f && f.top, b.plotTop)
            })), a.translate(), a.setTooltipPoints && a.setTooltipPoints(!0), a.render(), c && yc(a, "updatedData")
        }
    }, P.prototype = {
        destroy: function() {
            D(this, this.axis)
        },
        render: function(a) {
            var b = this.options, c = b.format, d = c ? w(c, this): b.formatter.call(this);
            this.label ? this.label.attr({
                text: d,
                visibility: Tb
            }) : this.label = this.axis.chart.renderer.text(d, null, null, b.useHTML).css(b.style).attr({
                align: this.textAlign,
                rotation: b.rotation,
                visibility: Tb
            }).add(a)
        },
        setOffset: function(a, b) {
            var c, d = this, e = d.axis, f = e.chart, g = f.inverted, h = this.isNegative, i = e.translate(e.usePercentage ? 100 : this.total, 0, 0, 0, 1), j = e.translate(0), k = tb(i - j), l = f.xAxis[0].translate(this.x) + a, m = f.plotHeight, n = {
                x: g ? h ? i: i - k: l,
                y: g ? m - l - b: h ? m - i - k: m - i,
                width: g ? k: b,
                height: g ? b: k
            }, o = this.label;
            o && (o.align(this.alignOptions, null, n), c = o.alignAttr, o[this.options.crop===!1 || f.isInsidePlot(c.x, c.y) ? "show": "hide"](!0))
        }
    }, N.prototype.buildStacks = function() {
        var a = this.series, b = o(this.options.reversedStacks, !0), c = a.length;
        if (!this.isXAxis) {
            for (this.usePercentage=!1; c--;)
                a[b ? c: a.length - c - 1].setStackedPoints();
            if (this.usePercentage)
                for (c = 0; c < a.length; c++)
                    a[c].setPercentStacks()
        }
    }, N.prototype.renderStackTotals = function() {
        var a, b, c, d = this, e = d.chart, f = e.renderer, g = d.stacks, h = d.stackTotalGroup;
        h || (d.stackTotalGroup = h = f.g("stack-labels").attr({
            visibility: Vb,
            zIndex: 6
        }).add()), h.translate(e.plotLeft, e.plotTop);
        for (a in g) {
            b = g[a];
            for (c in b)
                b[c].render(h)
        }
    }, $c.prototype.setStackedPoints = function() {
        if (this.options.stacking && (this.visible===!0 || this.chart.options.chart.ignoreHiddenSeries===!1)) {
            var a, b, c, d, e, f, g, h, i = this, j = i.processedXData, k = i.processedYData, l = [], m = k.length, n = i.options, o = n.threshold, p = n.stack, q = n.stacking, r = i.stackKey, s = "-" + r, t = i.negStacks, u = i.yAxis, v = u.stacks, w = u.oldStacks;
            for (f = 0; m > f; f++)
                g = j[f], h = k[f], e = i.index + "," + f, a = t && o > h, d = a ? s : r, v[d] || (v[d] = {}), v[d][g] || (w[d] && w[d][g] ? (v[d][g] = w[d][g], v[d][g].total = null) : v[d][g] = new P(u, u.options.stackLabels, a, g, p)), b = v[d][g], b.points[e] = [b.cum || 0], "percent" === q ? (c = a ? r : s, t && v[c] && v[c][g] ? (c = v[c][g], b.total = c.total = rb(c.total, b.total) + tb(h) || 0) : b.total = G(b.total + (tb(h) || 0))) : b.total = G(b.total + (h || 0)), b.cum = (b.cum || 0) + (h || 0), b.points[e].push(b.cum), l[f] = b.cum;
            "percent" === q && (u.usePercentage=!0), this.stackedYData = l, u.oldStacks = {}
        }
    }, $c.prototype.setPercentStacks = function() {
        var a = this, b = a.stackKey, c = a.yAxis.stacks, d = a.processedXData;
        sc([b, "-" + b], function(b) {
            for (var e, f, g, h, i = d.length; i--;)
                e = d[i], f = c[b] && c[b][e], g = f && f.points[a.index + "," + i], g && (h = f.total ? 100 / f.total : 0, g[0] = G(g[0] * h), g[1] = G(g[1] * h), a.stackedYData[i] = g[1])
        })
    }, a(O.prototype, {
        addSeries: function(a, b, c) {
            var d, e = this;
            return a && (b = o(b, !0), yc(e, "addSeries", {
                options: a
            }, function() {
                d = e.initSeries(a), e.isDirtyLegend=!0, e.linkSeries(), b && e.redraw(c)
            })), d
        },
        addAxis: function(a, c, d, e) {
            var f, g = c ? "xAxis": "yAxis", h = this.options;
            f = new N(this, b(a, {
                index: this[g].length,
                isX: c
            })), h[g] = n(h[g] || {}), h[g].push(a), o(d, !0) && this.redraw(e)
        },
        showLoading: function(b) {
            var c = this, d = c.options, e = c.loadingDiv, f = d.loading;
            e || (c.loadingDiv = e = q(Qb, {
                className: Ub + "loading"
            }, a(f.style, {
                zIndex: 10,
                display: Xb
            }), c.container), c.loadingSpan = q("span", null, f.labelStyle, e)), c.loadingSpan.innerHTML = b || d.lang.loading, c.loadingShown || (p(e, {
                opacity: 0,
                display: "",
                left: c.plotLeft + Wb,
                top: c.plotTop + Wb,
                width: c.plotWidth + Wb,
                height: c.plotHeight + Wb
            }), Ac(e, {
                opacity: f.style.opacity
            }, {
                duration: f.showDuration || 0
            }), c.loadingShown=!0)
        },
        hideLoading: function() {
            var a = this.options, b = this.loadingDiv;
            b && Ac(b, {
                opacity: 0
            }, {
                duration: a.loading.hideDuration || 100,
                complete: function() {
                    p(b, {
                        display: Xb
                    })
                }
            }), this.loadingShown=!1
        }
    }), a(Zc.prototype, {
        update: function(a, b, c) {
            var d, e = this, g = e.series, h = e.graphic, i = g.data, j = g.chart, k = g.options;
            b = o(b, !0), e.firePointEvent("update", {
                options: a
            }, function() {
                e.applyOptions(a), f(a) && (g.getAttribs(), h && (a && a.marker && a.marker.symbol ? e.graphic = h.destroy() : h.attr(e.pointAttr[e.state || ""])), a && a.dataLabels && e.dataLabel && (e.dataLabel = e.dataLabel.destroy())), d = rc(e, i), g.updateParallelArrays(e, d), k.data[d] = e.options, g.isDirty = g.isDirtyData=!0, !g.fixedBox && g.hasCartesianSeries && (j.isDirtyBox=!0), "point" === k.legendType && j.legend.destroyItem(e), b && j.redraw(c)
            })
        },
        remove: function(a, b) {
            var c, d = this, e = d.series, f = e.points, g = e.chart, h = e.data;
            H(b, g), a = o(a, !0), d.firePointEvent("remove", null, function() {
                c = rc(d, h), h.length === f.length && f.splice(c, 1), h.splice(c, 1), e.options.data.splice(c, 1), e.updateParallelArrays(d, "splice", c, 1), d.destroy(), e.isDirty=!0, e.isDirtyData=!0, a && g.redraw()
            })
        }
    }), a($c.prototype, {
        addPoint: function(a, b, c, d) {
            var e, f, g, h, i = this, j = i.options, k = i.data, l = i.graph, m = i.area, n = i.chart, p = i.xAxis && i.xAxis.names, q = l && l.shift || 0, r = j.data, s = i.xData;
            if (H(d, n), c && sc([l, m, i.graphNeg, i.areaNeg], function(a) {
                a && (a.shift = q + 1)
            }), m && (m.isArea=!0), b = o(b, !0), e = {
                series: i
            }, i.pointClass.prototype.applyOptions.apply(e, [a]), g = e.x, h = s.length, i.requireSorting && g < s[h - 1])
                for (f=!0; h && s[h - 1] > g;)
                    h--;
            i.updateParallelArrays(e, "splice", h, 0, 0), i.updateParallelArrays(e, h), p && (p[g] = e.name), r.splice(h, 0, a), f && (i.data.splice(h, 0, null), i.processData()), "point" === j.legendType && i.generatePoints(), c && (k[0] && k[0].remove ? k[0].remove(!1) : (k.shift(), i.updateParallelArrays(e, "shift"), r.shift())), i.isDirty=!0, i.isDirtyData=!0, b && (i.getAttribs(), n.redraw())
        },
        remove: function(a, b) {
            var c = this, d = c.chart;
            a = o(a, !0), c.isRemoving || (c.isRemoving=!0, yc(c, "remove", null, function() {
                c.destroy(), d.isDirtyLegend = d.isDirtyBox=!0, d.linkSeries(), a && d.redraw(b)
            })), c.isRemoving=!1
        },
        update: function(c, d) {
            var e, f = this.chart, g = this.userOptions, h = this.type, i = lc[h].prototype;
            c = b(g, {
                animation: !1,
                index: this.index,
                pointStart: this.xData[0]
            }, {
                data: this.options.data
            }, c), this.remove(!1);
            for (e in i)
                i.hasOwnProperty(e) && (this[e] = Q);
            a(this, lc[c.type || h].prototype), this.init(f, c), o(d, !0) && f.redraw(!1)
        }
    }), a(N.prototype, {
        update: function(c, d) {
            var e = this.chart;
            c = e.options[this.coll][this.options.index] = b(this.userOptions, c), this.destroy(!0), this._addedPlotLB = Q, this.init(e, a(c, {
                events: Q
            })), e.isDirtyBox=!0, o(d, !0) && e.redraw()
        },
        remove: function(a) {
            for (var b = this.chart, c = this.coll, d = this.series, e = d.length; e--;)
                d[e] && d[e].remove(!1);
            k(b.axes, this), k(b[c], this), b.options[c].splice(this.options.index, 1), sc(b[c], function(a, b) {
                a.options.index = b
            }), this.destroy(), b.isDirtyBox=!0, o(a, !0) && b.redraw()
        },
        setTitle: function(a, b) {
            this.update({
                title: a
            }, b)
        },
        setCategories: function(a, b) {
            this.update({
                categories: a
            }, b)
        }
    });
    var _c = r($c);
    lc.line = _c, Dc.area = b(Ec, {
        threshold: 0
    });
    var ad = r($c, {
        type: "area",
        getSegments: function() {
            var a, b, c, d, e, f = [], g = [], h = [], i = this.xAxis, j = this.yAxis, k = j.stacks[this.stackKey], l = {}, m = this.points, n = this.options.connectNulls;
            if (this.options.stacking&&!this.cropped) {
                for (d = 0; d < m.length; d++)
                    l[m[d].x] = m[d];
                for (e in k)
                    null !== k[e].total && h.push( + e);
                h.sort(function(a, b) {
                    return a - b
                }), sc(h, function(d) {
                    (!n || l[d] && null !== l[d].y) && (l[d] ? g.push(l[d]) : (a = i.translate(d), c = k[d].percent ? k[d].total ? 100 * k[d].cum / k[d].total : 0 : k[d].cum, b = j.toPixels(c, !0), g.push({
                        y: null,
                        plotX: a,
                        clientX: a,
                        plotY: b,
                        yBottom: b,
                        onMouseOver: Lb
                    })))
                }), g.length && f.push(g)
            } else 
                $c.prototype.getSegments.call(this), f = this.segments;
            this.segments = f
        },
        getSegmentPath: function(a) {
            var b, c, d = $c.prototype.getSegmentPath.call(this, a), e = [].concat(d), f = this.options, g = d.length, h = this.yAxis.getThreshold(f.threshold);
            if (3 === g && e.push(Zb, d[1], d[2]), f.stacking&&!this.closedStacks)
                for (b = a.length - 1; b >= 0; b--)
                    c = o(a[b].yBottom, h), b < a.length - 1 && f.step && e.push(a[b + 1].plotX, c), e.push(a[b].plotX, c);
            else 
                this.closeSegment(e, a, h);
            return this.areaPath = this.areaPath.concat(e), d
        },
        closeSegment: function(a, b, c) {
            a.push(Zb, b[b.length - 1].plotX, c, Zb, b[0].plotX, c)
        },
        drawGraph: function() {
            this.areaPath = [], $c.prototype.drawGraph.apply(this);
            var a = this, b = this.areaPath, c = this.options, d = c.negativeColor, e = c.negativeFillColor, f = [["area", this.color, c.fillColor]];
            (d || e) && f.push(["areaNeg", d, e]), sc(f, function(d) {
                var e = d[0], f = a[e];
                f ? f.animate({
                    d: b
                }) : a[e] = a.chart.renderer.path(b).attr({
                    fill: o(d[2], Ic(d[1]).setOpacity(o(c.fillOpacity, .75)).get()),
                    zIndex: 0
                }).add(a.group)
            })
        },
        drawLegendSymbol: Xc.drawRectangle
    });
    lc.area = ad, Dc.spline = b(Ec);
    var bd = r($c, {
        type: "spline",
        getPointSpline: function(a, b, c) {
            var d, e, f, g, h, i = 1.5, j = i + 1, k = b.plotX, l = b.plotY, m = a[c - 1], n = a[c + 1];
            if (m && n) {
                var o, p = m.plotX, q = m.plotY, r = n.plotX, s = n.plotY;
                d = (i * k + p) / j, e = (i * l + q) / j, f = (i * k + r) / j, g = (i * l + s) / j, o = (g - e) * (f - k) / (f - d) + l - g, e += o, g += o, e > q && e > l ? (e = rb(q, l), g = 2 * l - e) : q > e && l > e && (e = sb(q, l), g = 2 * l - e), g > s && g > l ? (g = rb(s, l), e = 2 * l - g) : s > g && l > g && (g = sb(s, l), e = 2 * l - g), b.rightContX = f, b.rightContY = g
            }
            return c ? (h = ["C", m.rightContX || m.plotX, m.rightContY || m.plotY, d || k, e || l, k, l], m.rightContX = m.rightContY = null) : h = [Yb, k, l], h
        }
    });
    lc.spline = bd, Dc.areaspline = b(Dc.area);
    var cd = ad.prototype, dd = r(bd, {
        type: "areaspline",
        closedStacks: !0,
        getSegmentPath: cd.getSegmentPath,
        closeSegment: cd.closeSegment,
        drawGraph: cd.drawGraph,
        drawLegendSymbol: Xc.drawRectangle
    });
    lc.areaspline = dd, Dc.column = b(Ec, {
        borderColor: "#FFFFFF",
        borderRadius: 0,
        groupPadding: .2,
        marker: null,
        pointPadding: .1,
        minPointLength: 0,
        cropThreshold: 50,
        pointRange: null,
        states: {
            hover: {
                brightness: .1,
                shadow: !1,
                halo: !1
            },
            select: {
                color: "#C0C0C0",
                borderColor: "#000000",
                shadow: !1
            }
        },
        dataLabels: {
            align: null,
            verticalAlign: null,
            y: null
        },
        stickyTracking: !1,
        tooltip: {
            distance: 6
        },
        threshold: 0
    });
    var ed = r($c, {
        type: "column",
        pointAttrToOptions: {
            stroke: "borderColor",
            fill: "color",
            r: "borderRadius"
        },
        cropShoulder: 0,
        trackerGroups: ["group", "dataLabelsGroup"],
        negStacks: !0,
        init: function() {
            $c.prototype.init.apply(this, arguments);
            var a = this, b = a.chart;
            b.hasRendered && sc(b.series, function(b) {
                b.type === a.type && (b.isDirty=!0)
            })
        },
        getColumnMetrics: function() {
            var a, b, c = this, d = c.options, e = c.xAxis, f = c.yAxis, g = e.reversed, h = {}, i = 0;
            d.grouping===!1 ? i = 1 : sc(c.chart.series, function(d) {
                var e = d.options, g = d.yAxis;
                d.type === c.type && d.visible && f.len === g.len && f.pos === g.pos && (e.stacking ? (a = d.stackKey, h[a] === Q && (h[a] = i++), b = h[a]) : e.grouping!==!1 && (b = i++), d.columnIndex = b)
            });
            var j = sb(tb(e.transA) * (e.ordinalSlope || d.pointRange || e.closestPointRange || e.tickInterval || 1), e.len), k = j * d.groupPadding, m = j - 2 * k, n = m / i, p = d.pointWidth, q = l(p) ? (n - p) / 2: n * d.pointPadding, r = o(p, n - 2 * q), s = (g ? i - (c.columnIndex || 0) : c.columnIndex) || 0, t = q + (k + s * n - j / 2) * (g?-1 : 1);
            return c.columnMetrics = {
                width: r,
                offset: t
            }
        },
        translate: function() {
            var a = this, b = a.chart, c = a.options, d = a.borderWidth = o(c.borderWidth, a.activePointCount > .5 * a.xAxis.len ? 0 : 1), e = a.yAxis, f = c.threshold, g = a.translatedThreshold = e.getThreshold(f), h = o(c.minPointLength, 5), i = a.getColumnMetrics(), j = i.width, k = a.barW = qb(rb(j, 1 + 2 * d)), l = a.pointXOffset = i.offset, m =- (d%2 ? .5 : 0), n = d%2 ? .5 : 1;
            b.renderer.isVML && b.inverted && (n += 1), $c.prototype.translate.apply(a), sc(a.points, function(c) {
                var d, f, i, p, q = o(c.yBottom, g), r = sb(rb( - 999 - q, c.plotY), e.len + 999 + q), s = c.plotX + l, t = k, u = sb(r, q), v = rb(r, q) - u;
                tb(v) < h && h && (v = h, u = ob(tb(u - g) > h ? q - h : g - (e.translate(c.y, 0, 1, 0, 1) <= g ? h : 0))), c.barX = s, c.pointWidth = j, c.tooltipPos = b.inverted ? [e.len - r, a.xAxis.len - s - t / 2] : [s + t / 2, r], p = tb(s) < .5, d = ob(s + t) + m, s = ob(s) + m, t = d - s, i = tb(u) < .5, f = ob(u + v) + n, u = ob(u) + n, v = f - u, p && (s += 1, t -= 1), i && (u -= 1, v += 1), c.shapeType = "rect", c.shapeArgs = {
                    x: s,
                    y: u,
                    width: t,
                    height: v
                }
            })
        },
        getSymbol: Lb,
        drawLegendSymbol: Xc.drawRectangle,
        drawGraph: Lb,
        drawPoints: function() {
            var a, c, d, e = this, f = this.chart, g = e.options, h = f.renderer, i = g.animationLimit || 250;
            sc(e.points, function(j) {
                var k = j.plotY, m = j.graphic;
                k === Q || isNaN(k) || null === j.y ? m && (j.graphic = m.destroy()) : (a = j.shapeArgs, d = l(e.borderWidth) ? {
                    "stroke-width": e.borderWidth
                } : {}, c = j.pointAttr[j.selected ? bc: _b] || e.pointAttr[_b], m ? (Bc(m), m.attr(d)[f.pointCount < i ? "animate": "attr"](b(a))) : j.graphic = m = h[j.shapeType](a).attr(c).attr(d).add(e.group).shadow(g.shadow, null, g.stacking&&!g.borderRadius))
            })
        },
        animate: function(a) {
            var b, c = this, d = this.yAxis, e = c.options, f = this.chart.inverted, g = {};
            Gb && (a ? (g.scaleY = .001, b = sb(d.pos + d.len, rb(d.pos, d.toPixels(e.threshold))), f ? g.translateX = b - d.len : g.translateY = b, c.group.attr(g)) : (g.scaleY = 1, g[f ? "translateX": "translateY"] = d.pos, c.group.animate(g, c.options.animation), c.animate = null))
        },
        remove: function() {
            var a = this, b = a.chart;
            b.hasRendered && sc(b.series, function(b) {
                b.type === a.type && (b.isDirty=!0)
            }), $c.prototype.remove.apply(a, arguments)
        }
    });
    lc.column = ed, Dc.bar = b(Dc.column);
    var fd = r(ed, {
        type: "bar",
        inverted: !0
    });
    lc.bar = fd, Dc.scatter = b(Ec, {
        lineWidth: 0,
        tooltip: {
            headerFormat: '<span style="color:{series.color}">●</span> <span style="font-size: 10px;"> {series.name}</span><br/>',
            pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
        },
        stickyTracking: !1
    });
    var gd = r($c, {
        type: "scatter",
        sorted: !1,
        requireSorting: !1,
        noSharedTooltip: !0,
        trackerGroups: ["markerGroup"],
        takeOrdinalPosition: !1,
        singularTooltips: !0,
        drawGraph: function() {
            this.options.lineWidth && $c.prototype.drawGraph.call(this)
        }
    });
    lc.scatter = gd, Dc.pie = b(Ec, {
        borderColor: "#FFFFFF",
        borderWidth: 1,
        center: [null, null],
        clip: !1,
        colorByPoint: !0,
        dataLabels: {
            distance: 30,
            enabled: !0,
            formatter: function() {
                return this.point.name
            }
        },
        ignoreHiddenPoint: !0,
        legendType: "point",
        marker: null,
        size: null,
        showInLegend: !1,
        slicedOffset: 10,
        states: {
            hover: {
                brightness: .1,
                shadow: !1
            }
        },
        stickyTracking: !1,
        tooltip: {
            followPointer: !0
        }
    });
    var hd = r(Zc, {
        init: function() {
            Zc.prototype.init.apply(this, arguments);
            var b, c = this;
            return c.y < 0 && (c.y = null), a(c, {
                visible: c.visible!==!1,
                name: o(c.name, "Slice")
            }), b = function(a) {
                c.slice("select" === a.type)
            }, wc(c, "select", b), wc(c, "unselect", b), c
        },
        setVisible: function(a) {
            var b = this, c = b.series, d = c.chart;
            b.visible = b.options.visible = a = a === Q?!b.visible : a, c.options.data[rc(b, c.data)] = b.options, sc(["graphic", "dataLabel", "connector", "shadowGroup"], function(c) {
                b[c] && b[c][a ? "show": "hide"](!0)
            }), b.legendItem && d.legend.colorizeItem(b, a), !c.isDirty && c.options.ignoreHiddenPoint && (c.isDirty=!0, d.redraw())
        },
        slice: function(a, b, c) {
            var d, e = this, f = e.series, g = f.chart;
            H(c, g), b = o(b, !0), e.sliced = e.options.sliced = a = l(a) ? a : !e.sliced, f.options.data[rc(e, f.data)] = e.options, d = a ? e.slicedTranslation : {
                translateX: 0,
                translateY: 0
            }, e.graphic.animate(d), e.shadowGroup && e.shadowGroup.animate(d)
        },
        haloPath: function(a) {
            var b = this.shapeArgs, c = this.series.chart;
            return this.series.chart.renderer.symbols.arc(c.plotLeft + b.x, c.plotTop + b.y, b.r + a, b.r + a, {
                innerR: this.shapeArgs.r,
                start: b.start,
                end: b.end
            })
        }
    }), id = {
        type: "pie",
        isCartesian: !1,
        pointClass: hd,
        requireSorting: !1,
        noSharedTooltip: !0,
        trackerGroups: ["group", "dataLabelsGroup"],
        axisTypes: [],
        pointAttrToOptions: {
            stroke: "borderColor",
            "stroke-width": "borderWidth",
            fill: "color"
        },
        singularTooltips: !0,
        getColor: Lb,
        animate: function(a) {
            var b = this, c = b.points, d = b.startAngleRad;
            a || (sc(c, function(a) {
                var c = a.graphic, e = a.shapeArgs;
                c && (c.attr({
                    r: b.center[3] / 2,
                    start: d,
                    end: d
                }), c.animate({
                    r: e.r,
                    start: e.start,
                    end: e.end
                }, b.options.animation))
            }), b.animate = null)
        },
        setData: function(a, b, c, d) {
            $c.prototype.setData.call(this, a, !1, c, d), this.processData(), this.generatePoints(), o(b, !0) && this.chart.redraw(c)
        },
        generatePoints: function() {
            var a, b, c, d, e = 0, f = this.options.ignoreHiddenPoint;
            for ($c.prototype.generatePoints.call(this), b = this.points, c = b.length, a = 0; c > a; a++)
                d = b[a], e += f&&!d.visible ? 0 : d.y;
            for (this.total = e, a = 0; c > a; a++)
                d = b[a], d.percentage = e > 0 ? d.y / e * 100 : 0, d.total = e
        },
        translate: function(a) {
            this.generatePoints();
            var b, c, d, e, f, g, h, i = this, j = 0, k = 1e3, l = i.options, m = l.slicedOffset, n = m + l.borderWidth, p = l.startAngle || 0, q = i.startAngleRad = wb / 180 * (p - 90), r = i.endAngleRad = wb / 180 * (o(l.endAngle, p + 360) - 90), s = r - q, t = i.points, u = l.dataLabels.distance, v = l.ignoreHiddenPoint, w = t.length;
            for (a || (i.center = a = i.getCenter()), i.getX = function(b, c) {
                return d = nb.asin(sb((b - a[1]) / (a[2] / 2 + u), 1)), a[0] + (c?-1 : 1) * ub(d) * (a[2] / 2 + u)
            }, g = 0; w > g; g++)
                h = t[g], b = q + j * s, (!v || h.visible) && (j += h.percentage / 100), c = q + j * s, h.shapeType = "arc", h.shapeArgs = {
                    x: a[0],
                    y: a[1],
                    r: a[2] / 2,
                    innerR: a[3] / 2,
                    start: ob(b * k) / k,
                    end: ob(c * k) / k
                }, d = (c + b) / 2, d > 1.5 * wb ? d -= 2 * wb : - wb / 2 > d && (d += 2 * wb), h.slicedTranslation = {
                    translateX: ob(ub(d) * m),
                    translateY: ob(vb(d) * m)
                }, e = ub(d) * a[2] / 2, f = vb(d) * a[2] / 2, h.tooltipPos = [a[0] + .7 * e, a[1] + .7 * f], h.half =- wb / 2 > d || d > wb / 2 ? 1 : 0, h.angle = d, n = sb(n, u / 2), h.labelPos = [a[0] + e + ub(d) * u, a[1] + f + vb(d) * u, a[0] + e + ub(d) * n, a[1] + f + vb(d) * n, a[0] + e, a[1] + f, 0 > u ? "center": h.half ? "right": "left", d]
        },
        drawGraph: null,
        drawPoints: function() {
            var b, c, d, e, f = this, g = f.chart, h = g.renderer, i = f.options.shadow;
            i&&!f.shadowGroup && (f.shadowGroup = h.g("shadow").add(f.group)), sc(f.points, function(g) {
                c = g.graphic, e = g.shapeArgs, d = g.shadowGroup, i&&!d && (d = g.shadowGroup = h.g("shadow").add(f.shadowGroup)), b = g.sliced ? g.slicedTranslation : {
                    translateX: 0,
                    translateY: 0
                }, d && d.attr(b), c ? c.animate(a(e, b)) : g.graphic = c = h[g.shapeType](e).setRadialReference(f.center).attr(g.pointAttr[g.selected ? bc: _b]).attr({
                    "stroke-linejoin": "round"
                }).attr(b).add(f.group).shadow(i, d), void 0 !== g.visible && g.setVisible(g.visible)
            })
        },
        sortByAngle: function(a, b) {
            a.sort(function(a, c) {
                return void 0 !== a.angle && (c.angle - a.angle) * b
            })
        },
        drawLegendSymbol: Xc.drawRectangle,
        getCenter: Yc.getCenter,
        getSymbol: Lb
    };
    id = r($c, id), lc.pie = id, $c.prototype.drawDataLabels = function() {
        var c, d, e, f, g = this, h = g.options, i = h.cursor, j = h.dataLabels, k = g.points;
        (j.enabled || g._hasPointLabels) && (g.dlProcessOptions && g.dlProcessOptions(j), f = g.plotGroup("dataLabelsGroup", "data-labels", Tb, j.zIndex || 6), !g.hasRendered && o(j.defer, !0) && (f.attr({
            opacity: 0
        }), wc(g, "afterAnimate", function() {
            g.dataLabelsGroup.show()[h.animation ? "animate": "attr"]({
                opacity: 1
            }, {
                duration: 200
            })
        })), d = j, sc(k, function(h) {
            var k, m, n, p, q, r = h.dataLabel, s = h.connector, t=!0;
            if (c = h.options && h.options.dataLabels, k = o(c && c.enabled, d.enabled), r&&!k)
                h.dataLabel = r.destroy();
            else if (k) {
                if (j = b(d, c), q = j.rotation, m = h.getLabelConfig(), e = j.format ? w(j.format, m) : j.formatter.call(m, j), j.style.color = o(j.color, j.style.color, g.color, "black"), r)
                    l(e) ? (r.attr({
                        text: e
                    }), t=!1) : (h.dataLabel = r = r.destroy(), s && (h.connector = s.destroy()));
                else if (l(e)) {
                    n = {
                        fill: j.backgroundColor,
                        stroke: j.borderColor,
                        "stroke-width": j.borderWidth,
                        r: j.borderRadius || 0,
                        rotation: q,
                        padding: j.padding,
                        zIndex: 1
                    };
                    for (p in n)
                        n[p] === Q && delete n[p];
                    r = h.dataLabel = g.chart.renderer[q ? "text": "label"](e, 0, - 999, null, null, null, j.useHTML).attr(n).css(a(j.style, i && {
                        cursor: i
                    })).add(f).shadow(j.shadow)
                }
                r && g.alignDataLabel(h, r, j, null, t)
            }
        }))
    }, $c.prototype.alignDataLabel = function(b, c, d, e, f) {
        var g, h = this.chart, i = h.inverted, j = o(b.plotX, - 999), k = o(b.plotY, - 999), l = c.getBBox(), m = this.visible && (b.series.forceDL || h.isInsidePlot(j, ob(k), i) || e && h.isInsidePlot(j, i ? e.x + 1 : e.y + e.height - 1, i));
        m && (e = a({
            x: i ? h.plotWidth - k: j,
            y: ob(i ? h.plotHeight - j : k),
            width: 0,
            height: 0
        }, e), a(d, {
            width: l.width,
            height: l.height
        }), d.rotation ? (g = {
            align: d.align,
            x: e.x + d.x + e.width / 2,
            y: e.y + d.y + e.height / 2
        }, c[f ? "attr": "animate"](g)) : (c.align(d, null, e), g = c.alignAttr, "justify" === o(d.overflow, "justify") ? this.justifyDataLabel(c, d, g, l, e, f) : o(d.crop, !0) && (m = h.isInsidePlot(g.x, g.y) && h.isInsidePlot(g.x + l.width, g.y + l.height)))), m || (c.attr({
            y: - 999
        }), c.placed=!1)
    }, $c.prototype.justifyDataLabel = function(a, b, c, d, e, f) {
        var g, h, i = this.chart, j = b.align, k = b.verticalAlign;
        g = c.x, 0 > g && ("right" === j ? b.align = "left" : b.x =- g, h=!0), g = c.x + d.width, g > i.plotWidth && ("left" === j ? b.align = "right" : b.x = i.plotWidth - g, h=!0), g = c.y, 0 > g && ("bottom" === k ? b.verticalAlign = "top" : b.y =- g, h=!0), g = c.y + d.height, g > i.plotHeight && ("top" === k ? b.verticalAlign = "bottom" : b.y = i.plotHeight - g, h=!0), h && (a.placed=!f, a.align(b, null, e))
    }, lc.pie && (lc.pie.prototype.drawDataLabels = function() {
        var a, b, c, d, e, f, g, h, i, j, k, l, m, n = this, p = n.data, q = n.chart, r = n.options.dataLabels, s = o(r.connectorPadding, 10), t = o(r.connectorWidth, 1), u = q.plotWidth, v = q.plotHeight, w = o(r.softConnector, !0), x = r.distance, y = n.center, z = y[2] / 2, A = y[1], B = x > 0, D = [[], []], E = [0, 0, 0, 0], F = function(a, b) {
            return b.y - a.y
        };
        if (n.visible && (r.enabled || n._hasPointLabels)) {
            for ($c.prototype.drawDataLabels.apply(n), sc(p, function(a) {
                a.dataLabel && a.visible && D[a.half].push(a)
            }), l = 0; !g && p[l];)
                g = p[l] && p[l].dataLabel && (p[l].dataLabel.getBBox().height || 21), l++;
            for (l = 2; l--;) {
                var G, H, I, J = [], K = [], L = D[l], M = L.length;
                if (n.sortByAngle(L, l - .5), x > 0) {
                    for (H = A - z - x; A + z + x >= H; H += g)
                        J.push(H);
                    if (G = J.length, M > G) {
                        for (k = [].concat(L), k.sort(F), m = M; m--;)
                            k[m].rank = m;
                        for (m = M; m--;)
                            L[m].rank >= G && L.splice(m, 1);
                        M = L.length
                    }
                    for (m = 0; M > m; m++) {
                        a = L[m], f = a.labelPos;
                        var N, O, P = 9999;
                        for (O = 0; G > O; O++)
                            N = tb(J[O] - f[1]), P > N && (P = N, I = O);
                        if (m > I && null !== J[m])
                            I = m;
                        else if (M - m + I > G && null !== J[m])
                            for (I = G - M + m; null === J[I];)
                                I++;
                        else 
                            for (; null === J[I];)
                                I++;
                        K.push({
                            i: I,
                            y: J[I]
                        }), J[I] = null
                    }
                    K.sort(F)
                }
                for (m = 0; M > m; m++) {
                    var Q, R;
                    a = L[m], f = a.labelPos, d = a.dataLabel, j = a.visible===!1 ? Tb : Vb, R = f[1], x > 0 ? (Q = K.pop(), I = Q.i, i = Q.y, (R > i && null !== J[I + 1] || i > R && null !== J[I - 1]) && (i = R)) : i = R, h = r.justify ? y[0] + (l?-1 : 1) * (z + x) : n.getX(0 === I || I === J.length - 1 ? R : i, l), d._attr = {
                        visibility: j,
                        align: f[6]
                    }, d._pos = {
                        x: h + r.x + ({
                            left: s,
                            right: - s
                        }
                        [f[6]] || 0),
                        y: i + r.y - 10
                    }, d.connX = h, d.connY = i, null === this.options.size && (e = d.width, s > h - e ? E[3] = rb(ob(e - h + s), E[3]) : h + e > u - s && (E[1] = rb(ob(h + e - u + s), E[1])), 0 > i - g / 2 ? E[0] = rb(ob( - i + g / 2), E[0]) : i + g / 2 > v && (E[2] = rb(ob(i + g / 2 - v), E[2])))
                }
            }(0 === C(E) || this.verifyDataLabelOverflow(E)) && (this.placeDataLabels(), B && t && sc(this.points, function(a) {
                b = a.connector, f = a.labelPos, d = a.dataLabel, d && d._pos ? (j = d._attr.visibility, h = d.connX, i = d.connY, c = w ? [Yb, h + ("left" === f[6] ? 5 : - 5), i, "C", h, i, 2 * f[2] - f[4], 2 * f[3] - f[5], f[2], f[3], Zb, f[4], f[5]] : [Yb, h + ("left" === f[6] ? 5 : - 5), i, Zb, f[2], f[3], Zb, f[4], f[5]], b ? (b.animate({
                    d: c
                }), b.attr("visibility", j)) : a.connector = b = n.chart.renderer.path(c).attr({
                    "stroke-width": t,
                    stroke: r.connectorColor || a.color || "#606060",
                    visibility: j
                }).add(n.dataLabelsGroup)) : b && (a.connector = b.destroy())
            }))
        }
    }, lc.pie.prototype.placeDataLabels = function() {
        sc(this.points, function(a) {
            var b, c = a.dataLabel;
            c && (b = c._pos, b ? (c.attr(c._attr), c[c.moved ? "animate": "attr"](b), c.moved=!0) : c && c.attr({
                y: - 999
            }))
        })
    }, lc.pie.prototype.alignDataLabel = Lb, lc.pie.prototype.verifyDataLabelOverflow = function(a) {
        var b, c = this.center, d = this.options, e = d.center, f = d.minSize || 80, g = f;
        return null !== e[0] ? g = rb(c[2] - rb(a[1], a[3]), f) : (g = rb(c[2] - a[1] - a[3], f), c[0] += (a[3] - a[1]) / 2), null !== e[1] ? g = rb(sb(g, c[2] - rb(a[0], a[2])), f) : (g = rb(sb(g, c[2] - a[0] - a[2]), f), c[1] += (a[0] - a[2]) / 2), g < c[2] ? (c[2] = g, this.translate(c), sc(this.points, function(a) {
            a.dataLabel && (a.dataLabel._pos = null)
        }), this.drawDataLabels && this.drawDataLabels()) : b=!0, b
    }), lc.column && (lc.column.prototype.alignDataLabel = function(a, c, d, e, f) {
        var g = this.chart, h = g.inverted, i = a.dlBox || a.shapeArgs, j = a.below || a.plotY > o(this.translatedThreshold, g.plotSizeY), k = o(d.inside, !!this.options.stacking);
        i && (e = b(i), h && (e = {
            x: g.plotWidth - e.y - e.height,
            y: g.plotHeight - e.x - e.width,
            width: e.height,
            height: e.width
        }), k || (h ? (e.x += j ? 0 : e.width, e.width = 0) : (e.y += j ? e.height : 0, e.height = 0))), d.align = o(d.align, !h || k ? "center" : j ? "right" : "left"), d.verticalAlign = o(d.verticalAlign, h || k ? "middle" : j ? "top" : "bottom"), $c.prototype.alignDataLabel.call(this, a, c, d, e, f)
    });
    var jd = mc.TrackerMixin = {
        drawTrackerPoint: function() {
            var a = this, b = a.chart, c = b.pointer, d = a.options.cursor, e = d && {
                cursor: d
            }, f = function(c) {
                var d, e = c.target;
                for (b.hoverSeries !== a && a.onMouseOver(); e&&!d;)
                    d = e.point, e = e.parentNode;
                d !== Q && d !== b.hoverPoint && d.onMouseOver(c)
            };
            sc(a.points, function(a) {
                a.graphic && (a.graphic.element.point = a), a.dataLabel && (a.dataLabel.element.point = a)
            }), a._hasTracking || (sc(a.trackerGroups, function(b) {
                a[b] && (a[b].addClass(Ub + "tracker").on("mouseover", f).on("mouseout", function(a) {
                    c.onTrackerMouseOut(a)
                }).css(e), S && a[b].on("touchstart", f))
            }), a._hasTracking=!0)
        },
        drawTrackerGraph: function() {
            var a, b, c = this, d = c.options, e = d.trackByArea, f = [].concat(e ? c.areaPath : c.graphPath), g = f.length, h = c.chart, i = h.pointer, j = h.renderer, k = h.options.tooltip.snap, l = c.tracker, m = d.cursor, n = m && {
                cursor: m
            }, o = c.singlePoints, p = function() {
                h.hoverSeries !== c && c.onMouseOver()
            }, q = "rgba(192,192,192," + (Gb ? 1e-4 : .002) + ")";
            if (g&&!e)
                for (b = g + 1; b--;)
                    f[b] === Yb && f.splice(b + 1, 0, f[b + 1] - k, f[b + 2], Zb), (b && f[b] === Yb || b === g) && f.splice(b, 0, Zb, f[b - 2] + k, f[b - 1]);
            for (b = 0; b < o.length; b++)
                a = o[b], f.push(Yb, a.plotX - k, a.plotY, Zb, a.plotX + k, a.plotY);
            l ? l.attr({
                d: f
            }) : (c.tracker = j.path(f).attr({
                "stroke-linejoin": "round",
                visibility: c.visible ? Vb: Tb,
                stroke: q,
                fill: e ? q: Xb,
                "stroke-width": d.lineWidth + (e ? 0 : 2 * k),
                zIndex: 2
            }).add(c.group), sc([c.tracker, c.markerGroup], function(a) {
                a.addClass(Ub + "tracker").on("mouseover", p).on("mouseout", function(a) {
                    i.onTrackerMouseOut(a)
                }).css(n), S && a.on("touchstart", p)
            }))
        }
    };
    lc.column && (ed.prototype.drawTracker = jd.drawTrackerPoint), lc.pie && (lc.pie.prototype.drawTracker = jd.drawTrackerPoint), lc.scatter && (gd.prototype.drawTracker = jd.drawTrackerPoint), a(Wc.prototype, {
        setItemEvents: function(a, b, c, d, e) {
            var f = this;
            (c ? b : a.legendGroup).on("mouseover", function() {
                a.setState(ac), b.css(f.options.itemHoverStyle)
            }).on("mouseout", function() {
                b.css(a.visible ? d : e), a.setState()
            }).on("click", function(b) {
                var c = "legendItemClick", d = function() {
                    a.setVisible()
                };
                b = {
                    browserEvent: b
                }, a.firePointEvent ? a.firePointEvent(c, b, d) : yc(a, c, b, d)
            })
        },
        createCheckboxForItem: function(a) {
            var b = this;
            a.checkbox = q("input", {
                type: "checkbox",
                checked: a.selected,
                defaultChecked: a.selected
            }, b.options.itemCheckboxStyle, b.chart.container), wc(a.checkbox, "click", function(b) {
                var c = b.target;
                yc(a, "checkboxClick", {
                    checked: c.checked
                }, function() {
                    a.select()
                })
            })
        }
    }), U.legend.itemStyle.cursor = "pointer", a(O.prototype, {
        showResetZoom: function() {
            var a = this, b = U.lang, c = a.options.chart.resetZoomButton, d = c.theme, e = d.states, f = "chart" === c.relativeTo ? null: "plotBox";
            this.resetZoomButton = a.renderer.button(b.resetZoom, null, null, function() {
                a.zoomOut()
            }, d, e && e.hover).attr({
                align: c.position.align,
                title: b.resetZoomTitle
            }).add().align(c.position, !1, f)
        },
        zoomOut: function() {
            var a = this;
            yc(a, "selection", {
                resetSelection: !0
            }, function() {
                a.zoom()
            })
        },
        zoom: function(a) {
            var b, c, d = this, e = d.pointer, g=!1;
            !a || a.resetSelection ? sc(d.axes, function(a) {
                b = a.zoom()
            }) : sc(a.xAxis.concat(a.yAxis), function(a) {
                var c = a.axis, d = c.isXAxis;
                (e[d ? "zoomX": "zoomY"] || e[d ? "pinchX": "pinchY"]) && (b = c.zoom(a.min, a.max), c.displayBtn && (g=!0))
            }), c = d.resetZoomButton, g&&!c ? d.showResetZoom() : !g && f(c) && (d.resetZoomButton = c.destroy()), b && d.redraw(o(d.options.chart.animation, a && a.animation, d.pointCount < 100))
        },
        pan: function(a, b) {
            var c, d = this, e = d.hoverPoints;
            e && sc(e, function(a) {
                a.setState()
            }), sc("xy" === b ? [1, 0] : [1], function(b) {
                var e = a[b ? "chartX": "chartY"], f = d[b ? "xAxis": "yAxis"][0], g = d[b ? "mouseDownX": "mouseDownY"], h = (f.pointRange || 0) / 2, i = f.getExtremes(), j = f.toValue(g - e, !0) + h, k = f.toValue(g + d[b ? "plotWidth": "plotHeight"] - e, !0) - h;
                f.series.length && j > sb(i.dataMin, i.min) && k < rb(i.dataMax, i.max) && (f.setExtremes(j, k, !1, !1, {
                    trigger: "pan"
                }), c=!0), d[b ? "mouseDownX": "mouseDownY"] = e
            }), c && d.redraw(!1), p(d.container, {
                cursor: "move"
            })
        }
    }), a(Zc.prototype, {
        select: function(a, b) {
            var c = this, d = c.series, e = d.chart;
            a = o(a, !c.selected), c.firePointEvent(a ? "select" : "unselect", {
                accumulate: b
            }, function() {
                c.selected = c.options.selected = a, d.options.data[rc(c, d.data)] = c.options, c.setState(a && bc), b || sc(e.getSelectedPoints(), function(a) {
                    a.selected && a !== c && (a.selected = a.options.selected=!1, d.options.data[rc(a, d.data)] = a.options, a.setState(_b), a.firePointEvent("unselect"))
                })
            })
        },
        onMouseOver: function(a) {
            var b = this, c = b.series, d = c.chart, e = d.tooltip, f = d.hoverPoint;
            f && f !== b && f.onMouseOut(), b.firePointEvent("mouseOver"), !e || e.shared&&!c.noSharedTooltip || e.refresh(b, a), b.setState(ac), d.hoverPoint = b
        },
        onMouseOut: function() {
            var a = this.series.chart, b = a.hoverPoints;
            b&&-1 !== rc(this, b) || (this.firePointEvent("mouseOut"), this.setState(), a.hoverPoint = null)
        },
        importEvents: function() {
            if (!this.hasImportedEvents) {
                var a, c = this, d = b(c.series.options.point, c.options), e = d.events;
                c.events = e;
                for (a in e)
                    wc(c, a, e[a]);
                this.hasImportedEvents=!0
            }
        },
        setState: function(c, d) {
            var e, f, g, h, i = this, j = i.plotX, k = i.plotY, l = i.series, m = l.options.states, n = Dc[l.type].marker && l.options.marker, o = n&&!n.enabled, p = n && n.states[c], q = p && p.enabled===!1, r = l.stateMarkerGraphic, s = i.marker || {}, t = l.chart, u = l.halo;
            c = c || _b, h = i.pointAttr[c] || l.pointAttr[c], c === i.state&&!d || i.selected && c !== bc || m[c] && m[c].enabled===!1 || c && (q || o && p.enabled===!1) || c && s.states && s.states[c] && s.states[c].enabled===!1 || (i.graphic ? (e = n && i.graphic.symbolName && h.r, i.graphic.attr(b(h, e ? {
                x: j - e,
                y: k - e,
                width: 2 * e,
                height: 2 * e
            } : {})), r && r.hide()) : (c && p && (e = p.radius, g = s.symbol || l.symbol, r && r.currentSymbol !== g && (r = r.destroy()), r ? r[d ? "animate": "attr"]({
                x: j - e,
                y: k - e
            }) : g && (l.stateMarkerGraphic = r = t.renderer.symbol(g, j - e, k - e, 2 * e, 2 * e).attr(h).add(l.markerGroup), r.currentSymbol = g)), r && r[c && t.isInsidePlot(j, k, t.inverted) ? "show": "hide"]()), f = m[c] && m[c].halo, f && f.size ? (u || (l.halo = u = t.renderer.path().add(l.seriesGroup)), u.attr(a({
                fill: Ic(i.color || l.color).setOpacity(f.opacity).get()
            }, f.attributes))[d ? "animate": "attr"]({
                d: i.haloPath(f.size)
            })) : u && u.attr({
                d: []
            }), i.state = c)
        },
        haloPath: function(a) {
            var b = this.series, c = b.chart, d = b.getPlotBox(), e = c.inverted;
            return c.renderer.symbols.circle(d.translateX + (e ? b.yAxis.len - this.plotY : this.plotX) - a, d.translateY + (e ? b.xAxis.len - this.plotX : this.plotY) - a, 2 * a, 2 * a)
        }
    }), a($c.prototype, {
        onMouseOver: function() {
            var a = this, b = a.chart, c = b.hoverSeries;
            c && c !== a && c.onMouseOut(), a.options.events.mouseOver && yc(a, "mouseOver"), a.setState(ac), b.hoverSeries = a
        },
        onMouseOut: function() {
            var a = this, b = a.options, c = a.chart, d = c.tooltip, e = c.hoverPoint;
            e && e.onMouseOut(), a && b.events.mouseOut && yc(a, "mouseOut"), !d || b.stickyTracking || d.shared&&!a.noSharedTooltip || d.hide(), a.setState(), c.hoverSeries = null
        },
        setState: function(a) {
            var b, c = this, d = c.options, e = c.graph, f = c.graphNeg, g = d.states, h = d.lineWidth;
            if (a = a || _b, c.state !== a) {
                if (c.state = a, g[a] && g[a].enabled===!1)
                    return;
                a && (h = g[a].lineWidth || h + 1), e&&!e.dashstyle && (b = {
                    "stroke-width": h
                }, e.attr(b), f && f.attr(b))
            }
        },
        setVisible: function(a, b) {
            var c, d = this, e = d.chart, f = d.legendItem, g = e.options.chart.ignoreHiddenSeries, h = d.visible;
            d.visible = a = d.userOptions.visible = a === Q?!h : a, c = a ? "show" : "hide", sc(["group", "dataLabelsGroup", "markerGroup", "tracker"], function(a) {
                d[a] && d[a][c]()
            }), e.hoverSeries === d && d.onMouseOut(), f && e.legend.colorizeItem(d, a), d.isDirty=!0, d.options.stacking && sc(e.series, function(a) {
                a.options.stacking && a.visible && (a.isDirty=!0)
            }), sc(d.linkedSeries, function(b) {
                b.setVisible(a, !1)
            }), g && (e.isDirtyBox=!0), b!==!1 && e.redraw(), yc(d, c)
        },
        setTooltipPoints: function(a) {
            var b, c, d, e, f, g, h, i = this, j = [], k = i.xAxis, l = k && k.getExtremes(), m = k ? k.tooltipLen || k.len: i.chart.plotSizeX, n = [];
            if (i.options.enableMouseTracking!==!1&&!i.singularTooltips) {
                for (a && (i.tooltipPoints = null), sc(i.segments || i.points, function(a) {
                    j = j.concat(a)
                }), k && k.reversed && (j = j.reverse()), i.orderTooltipPoints && i.orderTooltipPoints(j), b = j.length, h = 0; b > h; h++)
                    if (e = j[h], f = e.x, f >= l.min && f <= l.max)
                        for (g = j[h + 1], c = d === Q ? 0 : d + 1, d = j[h + 1] ? sb(rb(0, pb((e.clientX + (g ? g.wrappedClientX || g.clientX : m)) / 2)), m) : m; c >= 0 && d >= c;)
                            n[c++] = e;
                i.tooltipPoints = n
            }
        },
        show: function() {
            this.setVisible(!0)
        },
        hide: function() {
            this.setVisible(!1)
        },
        select: function(a) {
            var b = this;
            b.selected = a = a === Q?!b.selected : a, b.checkbox && (b.checkbox.checked = a), yc(b, a ? "select" : "unselect")
        },
        drawTracker: jd.drawTrackerGraph
    }), a(mc, {
        Axis: N,
        Chart: O,
        Color: Ic,
        Point: Zc,
        Tick: M,
        Renderer: R,
        Series: $c,
        SVGElement: L,
        SVGRenderer: Jc,
        arrayMin: B,
        arrayMax: C,
        charts: Mb,
        dateFormat: V,
        format: w,
        pathAnim: X,
        getOptions: K,
        hasBidiBug: Hb,
        isTouchDevice: Eb,
        numberFormat: s,
        seriesTypes: lc,
        setOptions: J,
        addEvent: wc,
        removeEvent: xc,
        createElement: q,
        discardElement: E,
        css: p,
        each: sc,
        extend: a,
        map: vc,
        merge: b,
        pick: o,
        splat: n,
        extendClass: r,
        pInt: d,
        wrap: u,
        svg: Gb,
        canvas: Ib,
        vml: !Gb&&!Ib,
        product: Ob,
        version: Pb
    })
}();
var Undertaker = new Class({
    Implements: [Events, Options],
    options: {
        url: location.href,
        action_name: "delete_item",
        enable_promoter: !1,
        promoter_action: "approve_item",
        itemSelector: "li",
        itemsIgnore: "data-undertaker-ignore",
        do_fx: !0,
        btn_class: "undertaker_thumbnails",
        btn_html: "&times;",
        promoter_btn_class: "undertaker_thumbnails undertaker_green",
        promoter_btn_html: "+",
        require_reason: !1,
        prompt_view_url: location.href,
        trans_property: "opacity",
        trans_value: "0",
        btn_hover: !1,
        duration: 300,
        transition: Fx.Transitions.Expo.easeIn,
        onRemove: function() {},
        onComplete: function() {}
    },
    initialize: function(a, b) {
        if (a) {
            if (a = $(a), a.hasClass("kane"))
                return;
            if (this.container_selector = a.get("id"), this.container_selector)
                this.container_selector_type = "id";
            else {
                this.container_selector_type = "class";
                var c = a.get("class");
                c = c.split(" ").join(", ." + a.get("tagName")), this.container_selector = "." + c
            }
            this.setOptions(b), this.createRequest(), this.attachBtns(), Signal.browse.attachEvents.add(this.onBrowseEventsReady.bind(this))
        }
    },
    createRequest: function() {
        this.request = new Request.HTML({
            url: this.options.url,
            method: "post",
            onComplete: function() {
                this.fireEvent("onComplete")
            }.bind(this)
        })
    },
    attachBtns: function() {
        var a, b, c, d, e;
        a = "id" === this.container_selector_type ? $(this.container_selector) : $$(this.container_selector)[0], a.hasClass("kane") || (c = a.get(this.options.itemsIgnore), a.getElements(this.options.itemSelector).each(function(a) {
            a.get("id") ? (b = a.get("id").split("_"), d = b[1]) : d = a.get("data-undertaker-id"), d && (c && c.indexOf(d) >= 0 || (e = new Element("a", {
                href: "javascript:void(0);",
                html: this.options.btn_html,
                "class": this.options.btn_class,
                title: "Delete this item",
                "data-action-type": "delete"
            }), this.options.btn_hover && (a.addEvent("mouseenter", function() {
                e.show()
            }), a.addEvent("mouseleave", function() {
                e.hide()
            })), a.adopt([e]), e.removeEvents("click"), this.options.require_reason ? e.addEvent("click", this.promptReason.bind(this)) : e.addEvent("click", this.bury.bind(this))))
        }, this), a.hasClass("promoter_list") && a.getElements(this.options.itemSelector).each(function(a) {
            var b = new Element("a", {
                href: "javascript:void(0);",
                html: this.options.promoter_btn_html,
                "class": this.options.promoter_btn_class,
                title: "Approve this item",
                "data-action-type": "promote"
            });
            this.options.btn_hover && (a.addEvent("mouseenter", function() {
                b.show()
            }), a.addEvent("mouseleave", function() {
                b.hide()
            })), a.adopt([b]), b.addEvent("click", this.bury.bind(this))
        }, this))
    },
    promptReason: function(a) {
        var b = a, c = a.target.getParent(), d = String.from(c.get("id")), e = d.split("_");
        Singletonbox.open({
            url: this.options.prompt_view_url + "/" + e[1],
            width: 500,
            position: "fixed",
            top: "auto",
            onLoad: function() {
                var a = $("lightbox_content").getElements("input#submit")[0];
                a.addEvent("click", function() {
                    b.reason = $("reason").value, this.bury(b), Singletonbox.close()
                }.bind(this))
            }.bind(this)
        })
    },
    bury: function(a) {
        var b, c, d, e, f;
        a.stop(), b = a.target.getParent(), c = b.get("data-undertaker-id"), c || (d = String.from(b.get("id")), e = d.split("_"), c = e[1] ? e[1] : d), f = "promote" === a.target.get("data-action-type") ? this.options.promoter_action : this.options.action_name, this.options.do_fx ? (b.set("tween", {
            duration: this.options.duration,
            onComplete: function() {
                b.destroy(), this.fireEvent("onRemove")
            }.bind(this)
        }), b.tween(this.options.trans_property, this.options.trans_value)) : (b.destroy(), this.fireEvent("onRemove")), this.request.send("undefined" != typeof a.reason ? {
            data: {
                action: f,
                id: c,
                reason: a.reason,
                token: vimeo.xsrft
            }
        } : {
            data: {
                action: f,
                id: c,
                token: vimeo.xsrft
            }
        })
    },
    onBrowseEventsReady: function() {
        this.attachBtns()
    }
});
!function() {
    "use strict";
    var a = {
        emails: function() {
            var a = ["ar", "au", "be", "br", "ca", "cz", "cl", "co.uk", "co.jp", "com", "dk", "de", "ee", "es", "fr", "hr", "in", "id", "ie", "it", "lv", "lt", "hu", "mx", "nl", "nz", "no", "at", "pe", "ph", "pl", "xp", "qc", "ro", "sg", "si", "sk", "za", "fi", "se", "tr", "uk", "ve", "vn", "gr", "bg", "ru", "rs", "ua", "il", "th", "hk", "tw"], b = ["hotmail", "yahoo"], c = ["aim.com", "aol.com", "bellsouth.net", "comcast.net", "gmail.com", "icloud.com", "live.com", "mac.com", "me.com", "msn.com", "outlook.com", "verizon.net", "ymail.com"];
            return b.each(function(b) {
                a.each(function(a) {
                    c.push(b + "." + a)
                })
            }), c
        },
        check: function(a) {
            var b = this, c = "", d = "", e = 100;
            return "string" != typeof a||-1 === a.indexOf("@")?!1 : (a = a.split("@"), "vimeo.com" !== a[1] ? (b.emails().each(function(b) {
                (d = b.levenshtein(a[1])) < e && (e = d, c = b)
            }), e > 0 && 3 > e ? [a[0], c].join("@") : !1) : void 0)
        }
    };
    window.EmailSuggestion = a
}();
var StatsSnippet = new Class({
    Implements: [Options, Events],
    options: {
        type: "clip",
        static_footers: !0,
        onSuccess: function() {}
    },
    initialize: function(a) {
        if (null === $("stats_snippet"))
            throw new Error("Invalid element supplied to StatsSnippet");
        var b = this;
        b.container = $("stats_snippet"), b.sparklines = $("summary_sparklines"), b.pagination = b.container.getElement(".stats_pagination"), b.prev_btn = b.pagination.getElement(".prev"), b.next_btn = b.pagination.getElement(".next"), b.toggle_table = $("stats_toggle_table"), b.toggle_graph = $("stats_toggle_graph"), b.table = $("stats_snippet_table"), b.table_parent = b.table.getParent(), b.graph = $("stats_snippet_graph"), b.end_date = new Date, b.start_date = (new Date).decrement("day", 4), b.request = new Request.JSON({
            method: "get",
            url: "/stats",
            link: "cancel",
            onSuccess: b.onRequestSuccess.bind(b)
        }), b.sparklines && (b.plays_display = b.sparklines.getElement(".plays var"), b.likes_display = b.sparklines.getElement(".likes var"), b.comments_display = b.sparklines.getElement(".comments var")), b.setOptions(a), b.attachEvents(), b.load()
    },
    attachEvents: function() {
        var a = this;
        a.prev_btn.addEvent("click", a.onPrevClick.bind(a)), a.next_btn.addEvent("click", a.onNextClick.bind(a)), a.toggle_table && a.toggle_table.addEvent("click", a.onToggleViews.bind(a)), a.toggle_graph && a.toggle_graph.addEvent("click", a.onToggleViews.bind(a))
    },
    load: function() {
        var a = this, b = {
            action: "snippet",
            stats_type: a.options.type,
            start_date: a.start_date.format("%Y/%m/%d"),
            end_date: a.end_date.format("%Y/%m/%d")
        };
        "clip" === a.options.type && (b.clip_id = vimeo.config.clip.id), a.request.send({
            data: b
        })
    },
    renderTable: function(a) {
        var b, c, d, e, f, g, h, i = this, j = a.stat_totals.formatted, k = a.first_page && a.last_page, l = $("vod_stats_snippet_table"), m = [], n = 0, o = 0, p = 0;
        i.stats_table = i.stats_table || new HtmlTable("stats_snippet_table"), i.stats_table.empty(), i.vod_stats_table = i.vod_stats_table || new HtmlTable("vod_stats_snippet_table"), i.vod_stats_table.empty(), a.data.each(function(a, i) {
            var j;
            h = [], b = a.date_label, c = (a.total_plays || 0).toInt(), d = (a.likes || 0).toInt(), e = (a.total_finishes || 0).toInt(), f = (a.total_embed_plays || 0).toInt(), g = (a.comments || 0).toInt(), n += c, o += d, p += g, h.push({
                content: b,
                properties: {
                    "class": "left"
                }
            }), j = vimeo.cur_user && vimeo.cur_user.opted_out ? [c, e, f] : [c, d, g], j.each(function(a, b) {
                h.push({
                    content: a.formatBigNumber(),
                    properties: {
                        "class": 0 === a ? "zero": "",
                        "data-index": b + 1
                    }
                })
            }), m[i] = h
        }), i.stats_table.pushMany(m), (!i.options.static_footers || k) && (vimeo.cur_user && vimeo.cur_user.opted_out ? i.stats_table.set("footers", [{
            content: Copy.dict.totals || "Totals",
            properties: {
                "class": "left"
            }
        }, j.plays, j.finishes, j.embeds]) : i.stats_table.set("footers", [{
            content: Copy.dict.totals || "Totals",
            properties: {
                "class": "left"
            }
        }, j.plays, j.likes, j.comments])), l && (h = [], ["vod_purchases", "vod_gross_revenue", "vod_ondemand_total_plays"].each(function(b, c) {
            h.push({
                content: a.stat_totals.formatted[b],
                properties: {
                    "class": 0 === a.stat_totals.unformatted[b] ? "zero": "",
                    "data-index": c + 1
                }
            })
        }), i.vod_stats_table.pushMany([h]))
    },
    renderSparklines: function(a) {
        var b, c, d, e = this, f = a.data, g = a.stat_totals.formatted, h = [], i = [], j = [], k = 0, l = 0, m = 0, n = 0, o = 0, p = 0;
        f.each(function(a) {
            a.total_plays && (n = (a.total_plays || 0).toInt()), k += n, h.push(n), o = (a.likes || 0).toInt(), l += o, i.push(o), p = (a.comments || 0).toInt(), m += p, j.push(p)
        }), e.graph.show(), b = new Highcharts.Chart(e.getChartOptions("plays_graph", h, "#d9f2e5", "#66cc99")), c = new Highcharts.Chart(e.getChartOptions("likes_graph", i, "#fed5d7", "#fc575e")), d = new Highcharts.Chart(e.getChartOptions("comments_graph", j, "#d3eeff", "#44bbff")), e.toggle_graph&&!e.toggle_graph.hasClass("selected") && e.graph.hide(), e.plays_display.set("html", g.plays), e.likes_display.set("html", g.likes), e.comments_display.set("html", g.comments), $("sparklines_range") && $("sparklines_range").set("html", f[0].date_label + " &ndash; " + f[f.length - 1].date_label)
    },
    getChartOptions: function(a, b, c, d) {
        var e = {
            chart: {
                renderTo: a,
                borderColor: "#ffffff",
                type: "area",
                margin: 0
            },
            credits: !1,
            legend: {
                enabled: !1
            },
            plotOptions: {
                area: {
                    fillColor: c,
                    fillOpacity: 1,
                    lineColor: d,
                    animation: !1,
                    marker: {
                        enabled: !1,
                        states: {
                            hover: {
                                enabled: !1
                            }
                        }
                    },
                    shadow: !1
                }
            },
            tooltip: {
                enabled: !1
            },
            title: null,
            series: [{
                data: b
            }
            ],
            yAxis: {
                gridLineWidth: 0,
                min: 0,
                minRange: .1
            }
        };
        return e
    },
    onPrevClick: function(a) {
        a.preventDefault();
        var b = this;
        b.end_date = b.end_date.decrement("day", 5), b.start_date = b.start_date.decrement("day", 5), b.load()
    },
    onNextClick: function(a) {
        a.preventDefault();
        var b = this;
        b.end_date = b.end_date.increment("day", 5), b.start_date = b.start_date.increment("day", 5), b.load()
    },
    onToggleViews: function(a) {
        a.preventDefault();
        var b = this, c = b.toggle_table, d = b.toggle_graph, e = b.table_parent, f = b.graph;
        c.hasClass("selected") ? (c.removeClass("selected"), d.addClass("selected"), e.hide(), f.show()) : (c.addClass("selected"), d.removeClass("selected"), e.show(), f.hide())
    },
    onRequestSuccess: function(a) {
        var b = this, c = a.stat_totals.formatted;
        a.first_page ? b.prev_btn.hide() : b.prev_btn.show(), a.last_page ? b.next_btn.hide() : b.next_btn.show(), b.renderTable(a), b.sparklines && b.renderSparklines(a), a.first_page && a.last_page && (b.plays_display.set("html", c.plays), b.likes_display.set("html", c.likes), b.comments_display.set("html", c.comments)), this.fireEvent("onSuccess")
    }
}), Inbox = {
    initialize: function() {
        Signal.browse.attachEvents.add(Inbox.onBrowseEventsReady), Signal.tip.close.add(Inbox.onTipClose), $("stats_snippet_table") && Inbox.setupStats()
    },
    setupStats: function() {
        new StatsSnippet({
            type: "user",
            static_footers: !1
        })
    },
    onBrowseEventsReady: function() {
        if ("undefined" != typeof Undertaker) {
            new Undertaker($("browse"), {
                btn_hover: !0,
                btn_class: "undertaker_details",
                onComplete: Inbox.onRemoveMessageComplete
            })
        }
    },
    onTipClose: function() {
        "undefined" != typeof Browse && Browse.killAllCache()
    },
    onRemoveMessageComplete: function() {
        Browse.cache.empty()
    }
};
window.addEvent("domready", function() {
    Inbox.initialize()
});
var Browse = {
    container: null,
    cache: new Hash,
    paging: !1,
    append_content: !1,
    use_infinite_scroll: !1,
    auto_scroll_urls: [],
    infinite_scroll_spy: null,
    scroll_spy_agents: [],
    scroll_spy_agent_urls: [],
    urlToSet: "",
    search_term: "",
    initialize: function() {
        History.addEvent && History.addEvent("change", Browse.onHistoryChange);
        var a;
        if (History.addEvent("change", Browse.onHistoryChange), Browse.createElements(), Browse.attachEvents(), Browse.createRequest(), Browse.setupAutoScroll(), Browse.setupKeyboardShortcuts(), Browse.updateCouchmodeUrl(window.location.href), a = Browse.container.getElement(".js-defer")) {
            var b=!0;
            Browse.loadFromAjax(window.location.pathname, b)
        }
        null !== Browse.searchForm && (Browse.search_term = Browse.searchForm.getElement("input").get("value")), History.pageLoad(), document.querySelector(".pagination") && new NextTooltip
    },
    createElements: function() {
        Browse.container = $("browser"), Browse.content = $("browse_content"), Browse.searchForm = null !== Browse.container.getElement(".js-search_within") ? Browse.container.getElement(".js-search_within").getElement("form") : null, Browse.couchmodeLink = Browse.container.getElement(".couchmode"), Browse.content && (Browse.load_indicator = Browse.content.getElement(".js-browse-load-indicator"))
    },
    createRequest: function() {
        Browse.request = new Request.HTML({
            method: "get",
            link: "cancel",
            onSuccess: Browse.onRequestSuccess,
            onFailure: Browse.onRequestFailure,
            evalScripts: !1
        }), Browse.groupPendingVideo = new Request.JSON({
            url: location.href,
            method: "post",
            onSuccess: Browse.onGroupPendingVideoSuccess
        })
    },
    setupAutoScroll: function(a) {
        var b = Browse.container.getElement(".js-show_more"), c = 200;
        if (a && Browse.killAllAgents(), b) {
            if (History.hashFallback=!0, a && (Browse.auto_scroll_urls = [], Browse.use_infinite_scroll=!1), Browse.setupInfiniteScrollPages(a), !Browse.use_infinite_scroll)
                return b.addEvent("click", Browse.onShowMoreClick), void(Browse.use_infinite_scroll=!0);
            Browse.infinite_scroll_spy && (Browse.infinite_scroll_spy.stop(), Browse.infinite_scroll_spy = null), Browse.infinite_scroll_spy = new ThrottledScrollSpy({
                min: b.getPosition().y - window.getSize().y - c,
                onEnter: function() {
                    Browse.showMore(b)
                }
            }), b.hide()
        }
    },
    setupInfiniteScrollPages: function(a) {
        var b = $$("[data-start-page]").pop(), c = $$("[data-end-page]").pop();
        if (a && Browse.killAllAgents(), void 0 === b ||!Browse.scroll_spy_agent_urls.contains(b.get("data-start-page")
            )) {
            {
                var d = $$(".col_small")[0];
                new ThrottledScrollSpy({
                    min: d.getSize().y + d.getPosition().y + 100,
                    onEnter: function() {
                        Browse.addToTopLink()
                    },
                    onLeave: function() {
                        Browse.removeToTopLink()
                    }
                })
            }
            b && c && (Browse.scroll_spy_agents.push(new ThrottledScrollSpy({
                min: b.getCoordinates().top,
                max: c.getCoordinates().bottom,
                onEnter: function() {
                    History.getPath() !== b.get("data-start-page") && (Browse.append_content=!0, History.push(b.get("data-start-page")))
                }
            })), Browse.scroll_spy_agent_urls.push(b.get("data-start-page")))
        }
    },
    killAllAgents: function() {
        Browse.scroll_spy_agents.each(function(a) {
            a.stop()
        }), Browse.scroll_spy_agents = [], Browse.scroll_spy_agent_urls = []
    },
    onShowMoreClick: function(a) {
        a.preventDefault(), Browse.showMore(a.target)
    },
    showMore: function(a) {
        var b = a.get("href");
        Browse.auto_scroll_urls.contains(b) || (a.destroy(), $$(".hide_on_scroll").hide(), Browse.container.getElement(".js-while_loading").show(), Browse.addContentFromUrl(b), Browse.auto_scroll_urls.push(b)), Browse.infinite_scroll_spy && Browse.infinite_scroll_spy.stop()
    },
    addToTopLink: function() {
        if ($("top_link"))
            return $("top_link").show(), !1;
        var a = new Element("a", {
            id: "top_link",
            "class": "btn iconify_up_b",
            html: Copy.translate("top"),
            events: {
                click: function() {
                    Global.scroll.toTop(), Browse.removeToTopLink()
                }
            }
        });
        $$(".col_small").adopt(a)
    },
    removeToTopLink: function() {
        $("top_link") && $("top_link").hide()
    },
    addContentFromUrl: function(a) {
        Browse.setWatchLaterUrl(a), Browse.append_content=!0, Browse.request.send({
            url: a
        })
    },
    setupKeyboardShortcuts: function() {
        Global.keyManager.register("left", Browse.goPrev), Global.keyManager.register("right", Browse.goNext), Global.keyManager.register("j", Browse.selectNextVideo), Global.keyManager.register("k", Browse.selectPreviousVideo), Global.keyManager.register("enter", Browse.goToVideo)
    },
    attachEvents: function(a) {
        var b, c = $("follow_btn"), d = Browse.container.getElement(".js-browse_list");
        a!==!0 && Browse.container && (Browse.container.addEvent("click:relay(a)", Browse.onBrowseLinkClick), Browse.container.addEvent("click:relay(button)", Browse.onBrowseButtonClick), Browse.container.addEvent("click:relay(.js-title)", Browse.onFeedTitleClick), Signal.browse.cache.success.add(Browse.reBindLightboxes), Signal.browse.ajax.success.add(Browse.reBindLightboxes), Signal.browse.infiniteLoad.add(Browse.reBindLightboxes), null !== c && (c.addEvent("click", Browse.onFollowLinkClick), c.addEvents({
            mouseover: function(a) {
                Browse.onFollowLinkHover(a)
            },
            mouseout: function(a) {
                Browse.onFollowLinkHover(a)
            }
        })), d && d.getElements("form.pending_video").length && Browse.container.addEvents({
            "click:relay(form.pending_video .accept, form.pending_video .reject)": Browse.updatePendingVideo
        })), null !== Browse.searchForm && null === Browse.searchForm.retrieve("validator") && (b = new Form.Validator(Browse.searchForm, {
            onFormValidate: function(a, b, c) {
                if (a===!1)
                    return void b.getElement("input").focus();
                c.stop();
                var d = null, e = encodeURIComponent(b.getElement("input").get("value")), f = b.get("action").split("/sort:"), g = b.get("action").split("/filter:"), h = b.get("action").split("/format:"), i = b.get("action").split("/year:");
                f.length > 1 ? d = f[0] + "/search:" + e + "/sort:" + f[1] : g.length > 1 ? d = g[0] + "/search:" + e + "/filter:" + g[1] : h.length > 1 ? d = h[0] + "/search:" + e + "/format:" + h[1] : i.length > 1 && (d = i[0] + "/search:" + e + "/year:" + i[1]), null !== d && (Browse.search_term = e, History.push(d))
            }
        })), Browse.searchForm && Browse.searchForm.getElements(".cancel").addEvent("click", Browse.onCancelSearch), Signal.browse.attachEvents.dispatch(a)
    },
    loadFromCache: function(a) {
        var b;
        Browse.paging!==!1 && (b = null === $("tutorials") ? "content" : "browser", Global.smoothScroll(b), Browse.paging=!1), Browse.container.set("html", Browse.cache.get(a)), Browse.createElements(), Browse.attachEvents(!0), Browse.updateCouchmodeUrl(window.location.href), Browse.setupAutoScroll(!0), "undefined" != typeof FauxPlayer && FauxPlayer.initialize(), Browse.focus_first_video && (Browse.selectNextVideo(), Browse.focus_first_video=!1), Browse.setupAutoScroll(!0), Signal.browse.cache.success.dispatch()
    },
    setWatchLaterUrl: function(a) {
        a.contains("/watchlater") && "object" == typeof WatchLater && (WatchLater.last_url = a)
    },
    loadFromAjax: function(a, b) {
        var c;
        Browse.urlToSet = a, Browse.content&&!b && Browse.content.addClass("loading"), Browse.paging!==!1 && (c = null === $("tutorials") ? "content" : "browser", Global.smoothScroll(c), Browse.paging=!1), Browse.request.send({
            url: a
        })
    },
    goPrev: function() {
        try {
            Browse.paging=!0, History.push($("pagination").getElement('a[rel="prev"]').get("href"))
        } catch (a) {}
    },
    goNext: function() {
        try {
            Browse.paging=!0, History.push($("pagination").getElement('a[rel="next"]').get("href"))
        } catch (a) {}
    },
    focusElement: function(a, b) {
        a.addClass(b || "selected");
        var c = $(window).getSize(), d = $(window).getScroll(), e = a.getSize(), f = a.getPosition(), g = d.y, h = d.y + c.y, i = f.y, j = f.y + e.y;
        if (!(i >= g && h >= j))
            return j > h ? $(window).scrollTo(d.x, d.y + j - h + 10) : void $(window).scrollTo(d.x, d.y - (g - i))
    },
    selectNextVideo: function() {
        var a = Browse.container.getElement(".js-browse_list"), b = a.getElement("li.selected"), c = $("pagination"), d = c ? c.getElement('a[rel="next"]'): null;
        if (b ||!d ||!d.hasClass("hover")) {
            if (!b) {
                var e = a.getFirst();
                return Browse.focusElement(e)
            }
            var f = b.getNext();
            return !f && Browse.container.getElement(".js-show_more") ? (Signal.browse.infiniteLoad.addOnce(Browse.selectNextVideo), void Browse.container.getElement(".js-show_more").click()) : !f && c ? (b.removeClass("selected"), void d.click()) : void(f && (b.removeClass("selected"), Browse.focusElement(f)))
        }
    },
    selectPreviousVideo: function() {
        var a = Browse.container.getElement(".js-browse_list"), b = a.getElement("li.selected"), c = $("pagination"), d = c ? c.getElement('a[rel="next"]'): null;
        if (!b && d && d.hasClass("hover"))
            return d.removeClass("hover"), Browse.focusElement(a.getLast());
        if (!b)
            return Browse.selectNextVideo();
        var e = b.getPrevious();
        e && (b.removeClass("selected"), Browse.focusElement(e))
    },
    goToVideo: function() {
        var a = Browse.container.getElement(".js-browse_list"), b = a.getElement("li.selected");
        b && (window.location = b.getFirst("a").get("href"));
        var c = $("pagination").getElement('a[rel="next"]');
        c && c.hasClass("hover") && (Browse.focus_first_video=!0, Browse.goNext())
    },
    setUrlToCache: function(a) {
        Browse.urlToSet && Browse.cache.set(Browse.urlToSet, a || Browse.container.get("html"))
    },
    killAllCache: function() {
        Browse.cache.each(function(a, b) {
            Browse.cache.erase(b)
        })
    },
    removeItem: function(a) {
        var b = Browse.container.getElement("#" + a), c = Browse.container.getElement(".js-browse_list"), d = $("pagination");
        b && (b.set("tween", {
            duration: 300,
            onComplete: function() {
                b.destroy(), Browse.container.getElements("li").removeClass("last"), Browse.container.getElements("li:even").addClass("last"), Browse.clearTabCache(), c.getChildren().length || (d ? d.getElement("a[rel=next]") ? Browse.loadFromAjax(d.getElement("a.selected").get("href")) : d.getElement("a[rel=prev]") && d.getElement("a[rel=prev]").click() : Browse.content.set("html", '<h3 class="empty">' + Copy.dict.browse_error_no_videos + "</h3>"))
            }
        }), b.tween("opacity", 0))
    },
    clearTabCache: function(a) {
        var b;
        (null === a || "undefined" == typeof a) && (a = History.getPathName()), b =- 1 !== a.indexOf("/page:") ? a.substring(0, a.indexOf("/page:")) : - 1 !== a.indexOf("/search:") ? a.substring(0, a.indexOf("/search:")) : - 1 !== a.indexOf("/sort:") ? a.substring(0, a.indexOf("/sort:")) : - 1 !== a.indexOf("/format:") ? a.substring(0, a.indexOf("/format:")) : a, Browse.cache.each(function(a, c) {
            - 1 !== c.indexOf(b) && Browse.cache.erase(c)
        })
    },
    onHistoryChange: function(a) {
        if (Browse.append_content)
            return void(Browse.append_content=!1);
        if (Browse.scroll_spy_agent_urls.contains(a)) {
            var b, c = $$('[data-start-page="' + a + '"]');
            return void(c.length && (b = c[0], Global.scroll.toElement(b)))
        }
        History.hasPushState() || a || (a = History.getPathName()), null !== Browse.cache.get(a) ? Browse.loadFromCache(a) : Browse.loadFromAjax(a)
    },
    onBrowseLinkClick: function(a) {
        var b = null, c = null, d = Browse.container.getElement(".js-search_within");
        if ("link" !== this.get("data-browse-type")) {
            if (this.getParent("#pagination"))
                return a.stop(), void("#" !== this.get("href") && (Browse.paging=!0, History.push(this.get("href"))));
            if (this.hasClass("search_within"))
                return d.toggleClass("open"), void(d.isDisplayed() && (Browse.searchForm.getElementById("search_field") ? Browse.searchForm.getElementById("search_field").focus() : Browse.searchForm.getElement("input") && Browse.searchForm.getElement("input").focus()));
            if (this.hasClass("more")) {
                var e = this.getSiblings(".collections");
                return a.stop(), void new Request.HTML({
                    url: this.get("href"),
                    data: {
                        action: "more_details"
                    },
                    method: "get",
                    onSuccess: function(a, b, c) {
                        this.destroy(), e.set("html", c).show(), Browse.cache.set(History.getPathName(), Browse.container.get("html"))
                    }.bind(this)
                }).send()
            }
            if (!this.getParent(".js-tabs")&&!this.getParent(".js-sortbar"))
                return null !== this.getParent("ol") && (b = this.getParent("ol").get("data-stream")), b && Cookie.write("stream_id", b, {
                    domain: vimeo.domain,
                    path: "/"
                }), null !== this.getParent("li") && (c = this.getParent("li").get("data-position")), void(c && Cookie.write("stream_pos", c, {
                    domain: vimeo.domain,
                    path: "/"
                }));
            a.stop(), this.getParent().getChildren().removeClass("selected"), this.addClass("selected"), this.getParent(".js-tabs") && (Browse.search_term = "", Signal.browse.tabs.click.dispatch({
                from: this
            })), this.getParent("#format") && Browse.killAllCache(), History.push(this.get("href"))
        }
    },
    onBrowseButtonClick: function(a) {
        if (this.hasClass("js-watchlater")) {
            a.preventDefault();
            {
                var b, c = this;
                new Request.JSONP({
                    url: c.get("data-player_url") + "/watch_later/" + c.get("data-clip_id"),
                    data: {
                        status: c.hasClass("selected") ? 0: 1,
                        token: c.get("data-token"),
                        time: c.get("data-time")
                    },
                    onRequest: function() {
                        return (b = c.get("data-alt_text")) && (c.set("data-alt_text", c.get("text")), c.set("text", b)), c.hasClass("selected") ? c.removeClass("selected") : void c.addClass("selected")
                    }
                }).send()
            }
        } else ;
    },
    onFeedTitleClick: function() {
        var a = this.href, b = PlayerManager.getPlayer(this);
        b && b.currentTime > 0 && b.currentTime < b.duration - 30&&!b.paused && (a += "#at=" + Math.floor(b.currentTime), this.href = a)
    },
    onFollowLinkHover: function(a) {
        {
            var b = $$("a#follow_btn");
            b.get("html")
        }
        "mouseover" === a.type ? b.set("html", b.get("data-hover-text")) : b.set("html", b.get("data-btn-text"))
    },
    onFollowLinkClick: function(a) {
        a.preventDefault(), Browse.followBtn = this, Browse.followRequest = new Request.HTML({
            method: "post",
            append: Browse.followBtn.getParent().getParent(),
            url: Browse.followBtn.get("data-subject-url"),
            data: {
                action: "follow",
                is_sidebar: !0,
                token: vimeo.xsrft,
                subject_id: Browse.followBtn.get("data-subject-id")
            },
            onRequest: Browse.onFollowRequest,
            onSuccess: Browse.onFollowRequestSuccess
        }).send()
    },
    onCancelSearch: function(a) {
        a.stop(), Browse.container.getElement(".js-search_within").toggleClass("open"), ("" !== Browse.search_term || Browser.ie) && History.push(Browse.searchForm.get("action")), Browse.search_term = ""
    },
    onRequestSuccess: function(a, b, c, d) {
        if (Browse.append_content)
            return Browse.onShowMoreRequestSuccess(c, d);
        Browse.container.set("html", c);
        var e = Browse.container.getElement(".js-search_within");
        null !== Browse.content && Browse.content.removeClass("loading"), Browse.createElements(), Browse.attachEvents(!0), Browse.updateCouchmodeUrl(window.location.href), null !== e && e.isDisplayed() && e.getElement("input").focus(), Browse.setUrlToCache(c), Browse.urlToSet = null, Signal.browse.ajax.success.dispatch(), Browse.focus_first_video && (Browse.selectNextVideo(), Browse.focus_first_video=!1), Browse.setupAutoScroll(!0), Browser.exec(d), "undefined" != typeof FauxPlayer && FauxPlayer.initialize(), Browse.container.getElement(".js-browse_list") && Browse.container.getElement(".js-browse_list").getFirst("li").getElement("a").focus(), Browse.load_indicator && Browse.load_indicator.hide(), Global.setupContentFilterSelector(), setTimeout(function() {
            $(document.body).addEvent("mousemove:once", function() {
                $(document.activeElement) && $(document.activeElement).blur()
            })
        }, 300)
    },
    reBindLightboxes: function() {
        Global.lightbox.attachToLinks("[data-lightbox]")
    },
    onShowMoreRequestSuccess: function(a, b) {
        Browse.container.getElement(".js-while_loading").destroy();
        for (var c, d, e, f = Elements.from(a, !0), g = null, h = 0, i = f.length; i > h; ++h)
            if ("browse_content" === f[h].get("id")) {
                g = f[h];
                break
            }
        for (e = g.getFirst(); e;) {
            if (e.hasClass("js-browse_list")) {
                c = e.getChildren();
                break
            }
            e = e.getNext()
        }
        d = g.getElement(".pagination"), $$(".pagination").set("html", d.get("html")), Browse.container.getElement(".js-browse_list").adopt(c), f.destroy(), Signal.browse.infiniteLoad.dispatch(), Browse.append_content=!1, Browse.setupInfiniteScrollPages(), Browse.setupAutoScroll(), Browser.exec(b)
    },
    onRequestFailure: function() {
        var a = $("pagination");
        null !== a && a.destroy(), Browse.load_indicator.hide(), Browse.content.empty().adopt(new Element("h3", {
            "class": "empty flush",
            html: Copy.dict.browse_error_generic
        })).removeClass("loading"), Signal.browse.ajax.error.dispatch()
    },
    onFollowRequest: function() {
        var a = parseInt(Browse.followBtn.get("data-subscribed"), 10);
        Browse.followBtn.set("data-subscribed", 1 - a), a ? Browse.followBtn.removeClass("following").addClass("unfollowing").addClass("btn_gray") : Browse.followBtn.addClass("btn_disabled"), Signal.browse.ajax.request.dispatch()
    },
    onFollowRequestSuccess: function() {
        var a = Browse.followBtn.get("data-hover-text"), b = Browse.followBtn.get("data-btn-text"), c = parseInt(Browse.followBtn.get("data-subscribed"), 10);
        Browse.followBtn.set("data-btn-text", Browse.followBtn.get("data-alternate-text")).set("html", Browse.followBtn.get("data-alternate-text")).set("data-hover-text", Browse.followBtn.get("data-alternate-hover")).set("data-alternate-text", b).set("data-alternate-hover", a), c ? Browse.followBtn.removeClass("follow").removeClass("btn_disabled").addClass("following") : (Browse.followBtn.removeClass("unfollowing").removeClass("btn_gray").addClass("follow"), $$("div.follow_box").destroy())
    },
    updatePendingVideo: function(a, b) {
        a.stop();
        var c = b.getSiblings("input[name=clip_id]")[0].get("value");
        Browse.groupPendingVideo.send({
            data: {
                action: "pending_video",
                mode: b.get("name"),
                clip_id: c,
                token: vimeo.xsrft
            }
        })
    },
    onGroupPendingVideoSuccess: function(a) {
        a.success===!0 && (Browse.removeItem("clip_" + a.clip_id), "accept" === a.mode&&-1 !== History.getPathName().indexOf("/pending") && Browse.clearTabCache(History.getPathName().substring(0, History.getPathName().indexOf("/pending"))))
    },
    updateCouchmodeUrl: function(a) {
        var b, c, d = /\/sort:.*\//;
        b = a.match(d), b && b.length && Browse.couchmodeLink && (c = Browse.couchmodeLink.get("href"), c.indexOf("sort")>-1 ? c.replace(d, b.shift()) : c += b.shift(), Browse.couchmodeLink.set("href", c))
    }
};
window.addEvent("domready", function() {
    $("browser") && Browse.initialize()
});
var Share = {
    storage: null,
    initialize: function() {
        var a, b = $("share_popup");
        Share.loadDependencies(), Share.columns = b.getElements(".col"), Share.columns.length >= 2 && (Share.columnPadding = Share.columns[0].getStyle("padding-top").toInt() + Share.columns[0].getStyle("padding-bottom").toInt()), Cookie.read("embed_preferences") && (Share.storage = JSON.decode(Cookie.read("embed_preferences"))), b.getElements(".toggle_box").each(function(b) {
            a = new ToggleBox(b, {
                onToggle: function() {
                    Share.equalize()
                }
            })
        }), Share.equalize(), $("message_input") && $("message_input").addEvent("keyup", this.onMessageUpdate), "undefined" != typeof FB && (FB.Event.subscribe("edge.create", function() {
            _gaq.push(["_trackSocial", "facebook", "like"])
        }), FB.Event.subscribe("edge.remove", function() {
            _gaq.push(["_trackSocial", "facebook", "unlike"])
        })), $$('#social_share img[src*="btn_fb_share"]').addEvent("click", function() {
            _gaq.push(["_trackSocial", "facebook", "post"])
        })
    },
    loadDependencies: function() {
        Share.onForageLoaded()
    },
    equalize: function() {
        var a, b;
        return Share.columns.length < 2?!1 : (Share.columns.each(function(a) {
            a.erase("style")
        }), Share.columns.each(function(c, d) {
            a = c.measure(function() {
                return this.getSize().y
            }), (0 === d || a > b) && (b = a - Share.columnPadding)
        }), Share.columns.each(function(a) {
            a.setStyle("height", b + "px")
        }), !0)
    },
    onForageLoaded: function() {
        Share.forage = new Forage.Share("fg", {
            addEmails: !$("fg").hasClass("no_email"),
            form: "mailer",
            onUserAdded: function() {
                setTimeout(function() {
                    Share.equalize()
                }, 50)
            },
            onUserRemoved: function() {
                setTimeout(function() {
                    Share.equalize()
                }, 50)
            }
        }), Global.lightbox.centerWindow(), Global.shareLightbox && Global.shareLightbox.centerWindow(), Global.xsrfProtect()
    },
    onColorPickerLoaded: function() {
        var a;
        $("share_embed") && (Share.storage && (a = Share.storage.color), $("color_picker_toggle") && (Embed.colorPicker = new ColorPicker("color_picker_toggle", {
            initial_color: a || $("embed_color").get("value"),
            onUpdate: function(a) {
                var b = a.hex.toLowerCase();
                Embed.customizations.colorInput.set("value", b), Embed.setColor(b)
            },
            onSelect: function(a) {
                var b = a.hex.toLowerCase();
                Embed.customizations.colorInput.set("value", b), Embed.setColor(b), Embed.refreshEmbedCode()
            }
        })))
    },
    onMessageUpdate: function() {
        $("message").set("text", this.value)
    }
}, Embed = {
    customizations: {},
    warnings: {},
    originalValues: {},
    codeRequest: null,
    initialize: function() {
        if (!$("share_embed"))
            return !1;
        Embed.clipId = $("embed_clip_id").get("value"), Embed.textArea = $("embed_code"), Embed.customizeView = $("embed_customize"), Embed.customizeToggle = $("embed_customize_toggle"), Embed.codeToggles = $("embed_generator").getElements("a.embed_code_toggle"), Embed.previewPlayer = $("embed_preview").getElement(['*[id*="player', Embed.clipId, '"]'].join("")), Embed.customizations = {
            widthInput: $("embed_width"),
            heightInput: $("embed_height"),
            titleCheckbox: $("embed_title"),
            bylineCheckbox: $("embed_byline"),
            portraitCheckbox: $("embed_portrait"),
            badgeCheckbox: $("embed_badge"),
            autoplayCheckbox: $("embed_autoplay"),
            loopCheckbox: $("embed_loop"),
            linkCheckbox: $("embed_link"),
            descriptionCheckbox: $("embed_description"),
            staticColors: $("embed_customize").getElements(".color_block"),
            colorInput: $("embed_color")
        }, Embed.warnings = {
            size: $("size_alert"),
            autoplay: $("autoplay_alert"),
            loop: $("loop_alert"),
            caption: $("text_alert"),
            link: $("link_alert"),
            description: $("description_alert"),
            link_description: $("link_description_alert")
        }, Embed.originalValues = {
            width: $("embed_orig_width").get("value"),
            height: $("embed_orig_height").get("value")
        }, Embed.codeRequest = new Request({
            url: "/embed",
            method: "get",
            link: "cancel",
            onSuccess: Embed.onEmbedCodeSuccess
        }), $("embed_customize").getElements(".toggle_box").each(function(a) {
            var b = new ToggleBox(a);
            b.addEvent("onToggle", function() {
                Share.equalize()
            })
        }), Share.onColorPickerLoaded(), Embed.attachEvents(), Embed.refreshEmbedCode();
        try {
            Singletonbox.centerWindow()
        } catch (a) {}
    },
    attachEvents: function() {
        Object.each(Embed.customizations, function(a) {
            $(a) && $(a).addEvent("change", Embed.onOptionChange)
        }), [Embed.customizations.widthInput, Embed.customizations.heightInput].each(function(a) {
            a.addEvent("keydown", Embed.onDimensionKeyDown), a.addEvent("blur", Embed.onDimensionBlur)
        }), Embed.customizations.staticColors.addEvent("click", Embed.onStaticColorSelected), Embed.customizations.colorInput.addEvent("keydown", Embed.onColorKeyDown), Embed.textArea.addEvent("click", Embed.onTextAreaClick), $("old_code").addEvent("click", function() {
            Embed.refreshEmbedCode(!0)
        })
    },
    resetSize: function() {
        Embed.customizations.widthInput.set("value", Embed.originalValues.width), Embed.customizations.heightInput.set("value", Embed.originalValues.height)
    },
    calculateSize: function(a) {
        var b, c, d;
        switch (a) {
        case"x":
        case"width":
            b = Embed.customizations.heightInput.get("value"), c = Embed.originalValues.width / Embed.originalValues.height;
            break;
        case"y":
        case"height":
            b = Embed.customizations.widthInput.get("value"), c = Embed.originalValues.height / Embed.originalValues.width;
            break;
        default:
            throw new Error("Invalid direction")
        }
        return d = Math.round(b * c)
    },
    resetWarnings: function() {
        Object.each(Embed.warnings, function(a) {
            $(a).hide()
        })
    },
    checkWarnings: function() {
        var a = Embed.customizations, b = Embed.warnings;
        Embed.resetWarnings(), a.autoplayCheckbox.get("checked") && b.autoplay.show(), a.loopCheckbox.get("checked") && b.loop.show(), (a.linkCheckbox.get("checked") || a.descriptionCheckbox.get("checked")) && (b.caption.show(), a.descriptionCheckbox.get("checked") && a.linkCheckbox.get("checked") ? b.link_description.show("inline") : a.descriptionCheckbox.get("checked") ? b.description.show("inline") : a.linkCheckbox.get("checked") && b.link.show("inline")), Share.equalize()
    },
    refreshEmbedCode: function(a) {
        var b = Embed.customizations;
        Embed.checkWarnings(), Embed.savePreferences(), Embed.codeRequest.send({
            data: {
                clip_id: Embed.clipId,
                width: b.widthInput.get("value"),
                height: b.heightInput.get("value"),
                title: b.titleCheckbox.get("checked") ? 1: 0,
                byline: b.bylineCheckbox.get("checked") ? 1: 0,
                portrait: b.portraitCheckbox.get("checked") ? 1: 0,
                badge: b.badgeCheckbox && b.badgeCheckbox.get("checked") ? 1: 0,
                autoplay: b.autoplayCheckbox.get("checked") ? 1: 0,
                loop: b.loopCheckbox.get("checked") ? 1: 0,
                color: b.colorInput.get("value"),
                link: b.linkCheckbox.get("checked") ? 1: 0,
                caption: b.descriptionCheckbox.get("checked") ? 1: 0,
                iframe: a===!0?!1: !0
            }
        }), a===!0 ? $("code_notice").setStyle("visibility", "hidden") : $("code_notice").setStyle("visibility", "visible")
    },
    savePreferences: function() {
        var a = Embed.customizations, b = JSON.encode({
            width: a.widthInput.get("value").toInt(),
            title: a.titleCheckbox.get("checked") ? 1: 0,
            byline: a.bylineCheckbox.get("checked") ? 1: 0,
            badge: a.badgeCheckbox && a.badgeCheckbox.get("checked") ? 1: 0,
            portrait: a.portraitCheckbox.get("checked") ? 1: 0,
            autoplay: a.autoplayCheckbox.get("checked") ? 1: 0,
            loop: a.loopCheckbox.get("checked") ? 1: 0,
            color: a.colorInput.get("value"),
            link: a.linkCheckbox.get("checked") ? 1: 0,
            caption: a.descriptionCheckbox.get("checked") ? 1: 0
        });
        Cookie.write("embed_preferences", b, {
            domain: vimeo.domain,
            path: "/",
            duration: 365
        })
    },
    refreshPreview: function(a) {
        var b = Embed.customizations, c = a.get("checked");
        switch (a) {
        case b.titleCheckbox:
            Embed.toggleElement("title", c);
            break;
        case b.bylineCheckbox:
            Embed.toggleElement("byline", c);
            break;
        case b.portraitCheckbox:
            Embed.toggleElement("portrait", c);
            break;
        case b.badgeCheckbox:
            Embed.toggleElement("badge", c);
            break;
        default:
            throw new Error("Invalid option supplied.")
        }
    },
    onTextAreaClick: function(a) {
        this.get("data-ios") || (a.stop(), this.focus(), this.select())
    },
    onDimensionKeyDown: function(a) {
        var b = this, c = a.code, d = a.key, e = c > 47 && 58 > c || c > 95 && 106 > c, f = "delete" === d || "backspace" === d || "tab" === d || "left" === d || "right" === d || "up" === d || "down" === d, g = e&&!a.shift || f, h = Embed.customizations.widthInput, i = Embed.customizations.heightInput;
        return g ? void setTimeout(function() {
            b === h ? i.set("value", Embed.calculateSize("height")) : h.set("value", Embed.calculateSize("width"))
        },
        50): void a.preventDefault()
    }, onDimensionBlur : function() {
        ("" === Embed.customizations.widthInput.get("value") || "" === Embed.customizations.heightInput.get("value")) && Embed.resetSize()
    }, onOptionChange: function() {
        var a = Embed.customizations;
        (this === a.titleCheckbox || this === a.bylineCheckbox || this === a.portraitCheckbox || this === a.badgeCheckbox) && Embed.refreshPreview(this), Embed.refreshEmbedCode()
    }, onStaticColorSelected: function(a) {
        var b = ["#", this.get("data-hex")].join("");
        a.stop(), Embed.customizations.colorInput.set("value", b), Embed.onOptionChange(null), Embed.colorPicker.setColor(b)
    }, onColorKeyDown: function(a) {
        var b = a.key, c = a.shift, d = "delete" === b || "backspace" === b || "tab" === b || "left" === b || "right" === b || "up" === b || "down" === b, e=!c && /[a-fA-F0-9]/.test(b), f = c && "3" === b, g = e || f || d;
        g || a.preventDefault()
    }, onEmbedCodeSuccess: function(a) {
        Embed.textArea.set("value", a.clean()), Share.equalize()
    }, onPlayerLoaded: function() {}, toggleElement: function(a, b) {
        Embed.previewPlayer = Embed.previewPlayer || $("embed_preview").getElement(['*[id*="player', Embed.clipId, '"]'].join("")), Embed.previewPlayer.api_toggleElement(a, b)
    }, setColor: function(a) {
        Embed.previewPlayer = Embed.previewPlayer || $("embed_preview").getElement(['*[id*="player', Embed.clipId, '"]'].join("")), "#" === a.substr(0, 1) && (a = a.substr(1));
        try {
            Embed.previewPlayer.api_changeColor(a)
        } catch (b) {}
    }
};
!function() {
    var a = new Class({
        players: [],
        initialize: function() {
            var a = this;
            a.createElements(), a.attachEvents()
        },
        createElements: function() {
            var a = this;
            a.browse_list = $$(".js-browse_list"), a.body = $$("body")
        },
        attachEvents: function() {
            var a = this;
            a.bound_events = {
                body_mouse_up: a.clearButtonHover.bind(a),
                like_click: a.onLikeClick.bind(a),
                on_demand_click: a.onOnDemandClick.bind(a),
                watchlater_click: a.onWatchlaterClick.bind(a),
                faux_player_click: a.onFauxPlayerClick.bind(a),
                share_click: a.onShareClick.bind(a),
                button_mousedown: a.onMouseDown.bind(a),
                button_mouseup: a.onMouseUp.bind(a),
                player_ready: a.onPlayerReady.bind(a),
                player_play: a.onPlayerPlay.bind(a)
            }, a.browse_list && (a.browse_list.addEvent("click:relay(.faux_player)", a.bound_events.faux_player_click), a.browse_list.addEvent("click:relay(.on_demand)", a.bound_events.on_demand_click), a.browse_list.addEvent("click:relay(.like)", a.bound_events.like_click), a.browse_list.addEvent("click:relay(.watchlater)", a.bound_events.watchlater_click), a.browse_list.addEvent("click:relay(.share)", a.bound_events.share_click), a.browse_list.addEvent("mousedown:relay(button)", a.bound_events.button_mousedown), a.browse_list.addEvent("mouseup:relay(button)", a.bound_events.button_mouseup), Signal.player.ready.add(a.bound_events.player_ready), Signal.player.ready.add(a.bound_events.player_play))
        },
        clearButtonHover: function() {
            var a = this, b = $$("button");
            a.body.removeEvent("mouseup", a.bound_events.body_mouse_up), b.each(function(a) {
                a.blur()
            })
        },
        sendPlayerRequest: function(a) {
            var b = this, c = a.getParent();
            new Request.HTML({
                url: "/" + a.get("data-clip_id") + "/lightbox",
                data: {
                    api: 1,
                    width: a.getWidth(),
                    autoplay: 1,
                    title: 0,
                    portrait: 0,
                    byline: 0,
                    badge: 0,
                    from_watch_later: a.get("data-watch_later"),
                    on_ready: "FauxPlayer.init"
                },
                method: "GET",
                update: c,
                onSuccess: b.onPlayerRequestSuccess.bind(b, c)
            }).send()
        },
        sendPlayerActionRequst: function(a, b) {
            {
                var c = this, d = a.getParent(".faux_player");
                a.getNext(".tip_question .body")
            }
            new Request.JSONP({
                url: d.get("data-player_url") + "/video/" + d.get("data-clip_id") + "/" + b,
                data: {
                    status: a.hasClass("selected") ? 0: 1,
                    signature: a.get("data-token"),
                    time: d.get("data-time")
                },
                onRequest: c.onPlayerActionRequest.bind(c, a, b)
            }).send()
        },
        onPlayerReady: function(a) {
            this.players.push(a)
        },
        onPlayerPlay: function(a) {
            var b, c = this, d = c.players.length;
            for (b = 0; d > b; ++b)
                c.players[b] !== a && c.players[b].pause()
        },
        onMouseDown: function() {
            var a = this;
            a.body.addEvent("mouseup", a.bound_events.body_mouse_up)
        },
        onMouseUp: function() {
            var a = this;
            a.clearButtonHover(), a.body.removeEvent("mouseup", a.bound_events.body_mouse_up)
        },
        onPlayerRequestSuccess: function(a) {
            var b, c = a.getElement(".private");
            c && (b = new Fx.Elements(c, {
                duration: 500,
                transition: "quad:in:out"
            }), b.start({
                0: {
                    "margin-left": "-120px",
                    "margin-top": "-120px",
                    opacity: 0
                }
            }))
        },
        onPlayerActionRequest: function(a, b) {
            var c = a.get("data-alt_text"), d = a.getNext(".tip_question .body");
            return c && (a.set("data-alt_text", d.get("text")), d.set("text", c)), "watch_later" === b && "object" == typeof Browse && Browse.cache.empty(), a.hasClass("selected") ? a.removeClass("selected") : void a.addClass("selected")
        },
        onFauxPlayerClick: function(a, b) {
            var c = this, d = a.target;
            (d.hasClass("faux_player") || d.hasClass("play")) && (PlayerManager.pauseAllPlayers(), c.sendPlayerRequest(b))
        },
        onOnDemandClick: function(a, b) {
            var c = b.getParent(".faux_player").get("data-clip_id");
            return window.location.href = "/" + c, !1
        },
        onShareClick: function(a, b) {
            window.shareWindowPopup(b.getParent(".faux_player").get("data-clip_id"))
        },
        onLikeClick: function(a, b) {
            this.sendPlayerActionRequst(b, "like")
        },
        onWatchlaterClick: function(a, b) {
            this.sendPlayerActionRequst(b, "watch-later")
        },
        destroy: function() {
            var a = this;
            a.browse_list && (a.browse_list.removeEvent("click:relay(.faux_player)", a.bound_events.faux_player_click), a.browse_list.removeEvent("click:relay(.like)", a.bound_events.like_click), a.browse_list.removeEvent("click:relay(.watchlater)", a.bound_events.watchlater_click), a.browse_list.removeEvent("click:relay(.share)", a.bound_events.share_click), a.browse_list.removeEvent("mousedown:relay(button)", a.bound_events.button_mousedown), a.browse_list.removeEvent("mouseup:relay(button)", a.bound_events.button_mouseup), Signal.player.ready.remove(a.bound_events.player_ready), Signal.player.ready.remove(a.bound_events.player_play))
        },
        refresh: function() {
            var a = this;
            a.destroy(), a.initialize()
        }
    });
    window.FauxPlayer = new a
}(), window.addEvent("domready", function() {
    FauxPlayer.refresh()
});
var WatchLater = {
    clock_hands_processed: [],
    last_url: null,
    initialize: function() {
        WatchLater.onBrowseEventsReady(null), Signal.browse.attachEvents.add(WatchLater.onBrowseEventsReady), Signal.browse.infiniteLoad.add(WatchLater.onBrowseEventsReady)
    },
    clearVideos: function() {
        if (confirm(Copy.dict.clear_all_confirm)) {
            new Request({
                url: location.href,
                method: "post",
                data: {
                    action: "clearall_watchlater",
                    token: vimeo.xsrft
                },
                onComplete: function() {
                    window.location = "/home/watchlater"
                }
            }).send()
        }
    },
    onBrowseEventsReady: function() {
        var a, b = $$(".js-clear_button"), c = 850, d = 12;
        if (b && b.addEvent("click", WatchLater.clearVideos), WatchLater.browseList = $$(".js-browse_list")[0], WatchLater.browseList && WatchLater.browseList.hasClass("allow_removal")) {
            new Undertaker(WatchLater.browseList, {
                url: location.href,
                onRemove: WatchLater.onRemoveClip,
                onComplete: WatchLater.onRemoveClipComplete
            })
        }
        setTimeout(function() {
            a = WatchLater.last_url || window.location.pathname, $$(".hour_hand").each(function(a, b) {
                setTimeout(function() {
                    a.removeClass("current_hours")
                }, c * (b%d))
            }), $$(".minute_hand").each(function(a, b) {
                setTimeout(function() {
                    a.removeClass("current_minutes")
                }, c * (b%d))
            }), Browse.cache.set(a, $("browser").get("html"))
        }, c)
    },
    onRemoveClip: function() {
        WatchLater.browseList.getElements("li").removeClass("last"), WatchLater.browseList.getElements("li:even").addClass("last")
    },
    onRemoveClipComplete: function() {
        Browse.cache.empty()
    }
};
window.addEvent("domready", function() {
    WatchLater.initialize()
});

